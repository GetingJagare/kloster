(()=>{var __webpack_modules__={"./node_modules/axios/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");\n\n//# sourceURL=webpack://kloster/./node_modules/axios/index.js?')},"./node_modules/axios/lib/adapters/xhr.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nvar settle = __webpack_require__(/*! ./../core/settle */ \"./node_modules/axios/lib/core/settle.js\");\n\nvar cookies = __webpack_require__(/*! ./../helpers/cookies */ \"./node_modules/axios/lib/helpers/cookies.js\");\n\nvar buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\n\nvar buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ \"./node_modules/axios/lib/core/buildFullPath.js\");\n\nvar parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ \"./node_modules/axios/lib/helpers/parseHeaders.js\");\n\nvar isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ \"./node_modules/axios/lib/helpers/isURLSameOrigin.js\");\n\nvar transitionalDefaults = __webpack_require__(/*! ../defaults/transitional */ \"./node_modules/axios/lib/defaults/transitional.js\");\n\nvar AxiosError = __webpack_require__(/*! ../core/AxiosError */ \"./node_modules/axios/lib/core/AxiosError.js\");\n\nvar CanceledError = __webpack_require__(/*! ../cancel/CanceledError */ \"./node_modules/axios/lib/cancel/CanceledError.js\");\n\nvar parseProtocol = __webpack_require__(/*! ../helpers/parseProtocol */ \"./node_modules/axios/lib/helpers/parseProtocol.js\");\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n    var responseType = config.responseType;\n    var onCanceled;\n\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest(); // HTTP basic authentication\n\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS\n\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      } // Prepare the response\n\n\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response); // Clean up request\n\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        } // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n\n\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        } // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n\n\n        setTimeout(onloadend);\n      };\n    } // Handle browser request cancellation (as opposed to a manual cancellation)\n\n\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request)); // Clean up request\n\n      request = null;\n    }; // Handle low level network errors\n\n\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request)); // Clean up request\n\n      request = null;\n    }; // Handle timeout\n\n\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n      var transitional = config.transitional || transitionalDefaults;\n\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n\n      reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, request)); // Clean up request\n\n      request = null;\n    }; // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n\n\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    } // Add headers to the request\n\n\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    } // Add withCredentials to request if needed\n\n\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    } // Add responseType to request if needed\n\n\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    } // Handle progress if needed\n\n\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    } // Not all browsers support upload events\n\n\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function (cancel) {\n        if (!request) {\n          return;\n        }\n\n        reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);\n        request.abort();\n        request = null;\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    var protocol = parseProtocol(fullPath);\n\n    if (protocol && ['http', 'https', 'file'].indexOf(protocol) === -1) {\n      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    } // Send the request\n\n\n    request.send(requestData);\n  });\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/adapters/xhr.js?")},"./node_modules/axios/lib/axios.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");\n\nvar bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");\n\nvar Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");\n\nvar mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");\n\nvar defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults/index.js");\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\n\n\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance\n\n  utils.extend(instance, Axios.prototype, context); // Copy context to instance\n\n  utils.extend(instance, context); // Factory for creating new instances\n\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n} // Create the default instance to be exported\n\n\nvar axios = createInstance(defaults); // Expose Axios class to allow class inheritance\n\naxios.Axios = Axios; // Expose Cancel & CancelToken\n\naxios.CanceledError = __webpack_require__(/*! ./cancel/CanceledError */ "./node_modules/axios/lib/cancel/CanceledError.js");\naxios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");\naxios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");\naxios.VERSION = (__webpack_require__(/*! ./env/data */ "./node_modules/axios/lib/env/data.js").version);\naxios.toFormData = __webpack_require__(/*! ./helpers/toFormData */ "./node_modules/axios/lib/helpers/toFormData.js"); // Expose AxiosError class\n\naxios.AxiosError = __webpack_require__(/*! ../lib/core/AxiosError */ "./node_modules/axios/lib/core/AxiosError.js"); // alias for CanceledError for backward compatibility\n\naxios.Cancel = axios.CanceledError; // Expose all/spread\n\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js"); // Expose isAxiosError\n\naxios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");\nmodule.exports = axios; // Allow use of default import syntax in TypeScript\n\nmodule.exports["default"] = axios;\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/axios.js?')},"./node_modules/axios/lib/cancel/CancelToken.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar CanceledError = __webpack_require__(/*! ./CanceledError */ \"./node_modules/axios/lib/cancel/CanceledError.js\");\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\n\n\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n  var token = this; // eslint-disable-next-line func-names\n\n  this.promise.then(function (cancel) {\n    if (!token._listeners) return;\n    var i;\n    var l = token._listeners.length;\n\n    for (i = 0; i < l; i++) {\n      token._listeners[i](cancel);\n    }\n\n    token._listeners = null;\n  }); // eslint-disable-next-line func-names\n\n  this.promise.then = function (onfulfilled) {\n    var _resolve; // eslint-disable-next-line func-names\n\n\n    var promise = new Promise(function (resolve) {\n      token.subscribe(resolve);\n      _resolve = resolve;\n    }).then(onfulfilled);\n\n    promise.cancel = function reject() {\n      token.unsubscribe(_resolve);\n    };\n\n    return promise;\n  };\n\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new CanceledError(message);\n    resolvePromise(token.reason);\n  });\n}\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n */\n\n\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n/**\n * Subscribe to the cancel signal\n */\n\n\nCancelToken.prototype.subscribe = function subscribe(listener) {\n  if (this.reason) {\n    listener(this.reason);\n    return;\n  }\n\n  if (this._listeners) {\n    this._listeners.push(listener);\n  } else {\n    this._listeners = [listener];\n  }\n};\n/**\n * Unsubscribe from the cancel signal\n */\n\n\nCancelToken.prototype.unsubscribe = function unsubscribe(listener) {\n  if (!this._listeners) {\n    return;\n  }\n\n  var index = this._listeners.indexOf(listener);\n\n  if (index !== -1) {\n    this._listeners.splice(index, 1);\n  }\n};\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\n\n\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/cancel/CancelToken.js?")},"./node_modules/axios/lib/cancel/CanceledError.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar AxiosError = __webpack_require__(/*! ../core/AxiosError */ \"./node_modules/axios/lib/core/AxiosError.js\");\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\n\n\nfunction CanceledError(message) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED);\n  this.name = 'CanceledError';\n}\n\nutils.inherits(CanceledError, AxiosError, {\n  __CANCEL__: true\n});\nmodule.exports = CanceledError;\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/cancel/CanceledError.js?")},"./node_modules/axios/lib/cancel/isCancel.js":module=>{"use strict";eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/cancel/isCancel.js?")},"./node_modules/axios/lib/core/Axios.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nvar buildURL = __webpack_require__(/*! ../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\n\nvar InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ \"./node_modules/axios/lib/core/InterceptorManager.js\");\n\nvar dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ \"./node_modules/axios/lib/core/dispatchRequest.js\");\n\nvar mergeConfig = __webpack_require__(/*! ./mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\n\nvar buildFullPath = __webpack_require__(/*! ./buildFullPath */ \"./node_modules/axios/lib/core/buildFullPath.js\");\n\nvar validator = __webpack_require__(/*! ../helpers/validator */ \"./node_modules/axios/lib/helpers/validator.js\");\n\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\n\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\n\n\nAxios.prototype.request = function request(configOrUrl, config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof configOrUrl === 'string') {\n    config = config || {};\n    config.url = configOrUrl;\n  } else {\n    config = configOrUrl || {};\n  }\n\n  config = mergeConfig(this.defaults, config); // Set config.method\n\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  var transitional = config.transitional;\n\n  if (transitional !== undefined) {\n    validator.assertOptions(transitional, {\n      silentJSONParsing: validators.transitional(validators.boolean),\n      forcedJSONParsing: validators.transitional(validators.boolean),\n      clarifyTimeoutError: validators.transitional(validators.boolean)\n    }, false);\n  } // filter out skipped interceptors\n\n\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n    promise = Promise.resolve(config);\n\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n  var newConfig = config;\n\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  var fullPath = buildFullPath(config.baseURL, config.url);\n  return buildURL(fullPath, config.params, config.paramsSerializer);\n}; // Provide aliases for supported request methods\n\n\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function (url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method: method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url: url,\n        data: data\n      }));\n    };\n  }\n\n  Axios.prototype[method] = generateHTTPMethod();\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\nmodule.exports = Axios;\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/core/Axios.js?")},"./node_modules/axios/lib/core/AxiosError.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\n\n\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n  this.message = message;\n  this.name = 'AxiosError';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  response && (this.response = response);\n}\n\nutils.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  }\n});\nvar prototype = AxiosError.prototype;\nvar descriptors = {};\n['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED' // eslint-disable-next-line func-names\n].forEach(function (code) {\n  descriptors[code] = {\n    value: code\n  };\n});\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(prototype, 'isAxiosError', {\n  value: true\n}); // eslint-disable-next-line func-names\n\nAxiosError.from = function (error, code, config, request, response, customProps) {\n  var axiosError = Object.create(prototype);\n  utils.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  });\n  AxiosError.call(axiosError, error.message, code, config, request, response);\n  axiosError.name = error.name;\n  customProps && Object.assign(axiosError, customProps);\n  return axiosError;\n};\n\nmodule.exports = AxiosError;\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/core/AxiosError.js?")},"./node_modules/axios/lib/core/InterceptorManager.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\n\n\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected,\n    synchronous: options ? options.synchronous : false,\n    runWhen: options ? options.runWhen : null\n  });\n  return this.handlers.length - 1;\n};\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\n\n\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\n\n\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/core/InterceptorManager.js?')},"./node_modules/axios/lib/core/buildFullPath.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");\n\nvar combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\n\n\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n\n  return requestedURL;\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/core/buildFullPath.js?')},"./node_modules/axios/lib/core/dispatchRequest.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nvar transformData = __webpack_require__(/*! ./transformData */ \"./node_modules/axios/lib/core/transformData.js\");\n\nvar isCancel = __webpack_require__(/*! ../cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\n\nvar defaults = __webpack_require__(/*! ../defaults */ \"./node_modules/axios/lib/defaults/index.js\");\n\nvar CanceledError = __webpack_require__(/*! ../cancel/CanceledError */ \"./node_modules/axios/lib/cancel/CanceledError.js\");\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n */\n\n\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new CanceledError();\n  }\n}\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\n\n\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config); // Ensure headers exist\n\n  config.headers = config.headers || {}; // Transform request data\n\n  config.data = transformData.call(config, config.data, config.headers, config.transformRequest); // Flatten headers\n\n  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);\n  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {\n    delete config.headers[method];\n  });\n  var adapter = config.adapter || defaults.adapter;\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config); // Transform response data\n\n    response.data = transformData.call(config, response.data, response.headers, config.transformResponse);\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config); // Transform response data\n\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/core/dispatchRequest.js?")},"./node_modules/axios/lib/core/mergeConfig.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\n\n\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n\n    return source;\n  } // eslint-disable-next-line consistent-return\n\n\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  } // eslint-disable-next-line consistent-return\n\n\n  function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    }\n  } // eslint-disable-next-line consistent-return\n\n\n  function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  } // eslint-disable-next-line consistent-return\n\n\n  function mergeDirectKeys(prop) {\n    if (prop in config2) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  var mergeMap = {\n    'url': valueFromConfig2,\n    'method': valueFromConfig2,\n    'data': valueFromConfig2,\n    'baseURL': defaultToConfig2,\n    'transformRequest': defaultToConfig2,\n    'transformResponse': defaultToConfig2,\n    'paramsSerializer': defaultToConfig2,\n    'timeout': defaultToConfig2,\n    'timeoutMessage': defaultToConfig2,\n    'withCredentials': defaultToConfig2,\n    'adapter': defaultToConfig2,\n    'responseType': defaultToConfig2,\n    'xsrfCookieName': defaultToConfig2,\n    'xsrfHeaderName': defaultToConfig2,\n    'onUploadProgress': defaultToConfig2,\n    'onDownloadProgress': defaultToConfig2,\n    'decompress': defaultToConfig2,\n    'maxContentLength': defaultToConfig2,\n    'maxBodyLength': defaultToConfig2,\n    'beforeRedirect': defaultToConfig2,\n    'transport': defaultToConfig2,\n    'httpAgent': defaultToConfig2,\n    'httpsAgent': defaultToConfig2,\n    'cancelToken': defaultToConfig2,\n    'socketPath': defaultToConfig2,\n    'responseEncoding': defaultToConfig2,\n    'validateStatus': mergeDirectKeys\n  };\n  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {\n    var merge = mergeMap[prop] || mergeDeepProperties;\n    var configValue = merge(prop);\n    utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);\n  });\n  return config;\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/core/mergeConfig.js?")},"./node_modules/axios/lib/core/settle.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar AxiosError = __webpack_require__(/*! ./AxiosError */ \"./node_modules/axios/lib/core/AxiosError.js\");\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\n\n\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new AxiosError('Request failed with status code ' + response.status, [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));\n  }\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/core/settle.js?")},"./node_modules/axios/lib/core/transformData.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");\n\nvar defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults/index.js");\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\n\n\nmodule.exports = function transformData(data, headers, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers);\n  });\n  return data;\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/core/transformData.js?')},"./node_modules/axios/lib/defaults/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\nvar normalizeHeaderName = __webpack_require__(/*! ../helpers/normalizeHeaderName */ \"./node_modules/axios/lib/helpers/normalizeHeaderName.js\");\n\nvar AxiosError = __webpack_require__(/*! ../core/AxiosError */ \"./node_modules/axios/lib/core/AxiosError.js\");\n\nvar transitionalDefaults = __webpack_require__(/*! ./transitional */ \"./node_modules/axios/lib/defaults/transitional.js\");\n\nvar toFormData = __webpack_require__(/*! ../helpers/toFormData */ \"./node_modules/axios/lib/helpers/toFormData.js\");\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(/*! ../adapters/xhr */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(/*! ../adapters/http */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  }\n\n  return adapter;\n}\n\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nvar defaults = {\n  transitional: transitionalDefaults,\n  adapter: getDefaultAdapter(),\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {\n      return data;\n    }\n\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n\n    var isObjectPayload = utils.isObject(data);\n    var contentType = headers && headers['Content-Type'];\n    var isFileList;\n\n    if ((isFileList = utils.isFileList(data)) || isObjectPayload && contentType === 'multipart/form-data') {\n      var _FormData = this.env && this.env.FormData;\n\n      return toFormData(isFileList ? {\n        'files[]': data\n      } : data, _FormData && new _FormData());\n    } else if (isObjectPayload || contentType === 'application/json') {\n      setContentTypeIfUnset(headers, 'application/json');\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional || defaults.transitional;\n    var silentJSONParsing = transitional && transitional.silentJSONParsing;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';\n\n    if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n  maxContentLength: -1,\n  maxBodyLength: -1,\n  env: {\n    FormData: __webpack_require__(/*! ./env/FormData */ \"./node_modules/axios/lib/helpers/null.js\")\n  },\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*'\n    }\n  }\n};\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\nmodule.exports = defaults;\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/defaults/index.js?")},"./node_modules/axios/lib/defaults/transitional.js":module=>{"use strict";eval("\n\nmodule.exports = {\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/defaults/transitional.js?")},"./node_modules/axios/lib/env/data.js":module=>{eval('module.exports = {\n  "version": "0.27.2"\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/env/data.js?')},"./node_modules/axios/lib/helpers/bind.js":module=>{"use strict";eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    return fn.apply(thisArg, args);\n  };\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/helpers/bind.js?")},"./node_modules/axios/lib/helpers/buildURL.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction encode(val) {\n  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');\n}\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\n\n\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/helpers/buildURL.js?")},"./node_modules/axios/lib/helpers/combineURLs.js":module=>{"use strict";eval("\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\n\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '') : baseURL;\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/helpers/combineURLs.js?")},"./node_modules/axios/lib/helpers/cookies.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie\nfunction standardBrowserEnv() {\n  return {\n    write: function write(name, value, expires, path, domain, secure) {\n      var cookie = [];\n      cookie.push(name + '=' + encodeURIComponent(value));\n\n      if (utils.isNumber(expires)) {\n        cookie.push('expires=' + new Date(expires).toGMTString());\n      }\n\n      if (utils.isString(path)) {\n        cookie.push('path=' + path);\n      }\n\n      if (utils.isString(domain)) {\n        cookie.push('domain=' + domain);\n      }\n\n      if (secure === true) {\n        cookie.push('secure');\n      }\n\n      document.cookie = cookie.join('; ');\n    },\n    read: function read(name) {\n      var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n      return match ? decodeURIComponent(match[3]) : null;\n    },\n    remove: function remove(name) {\n      this.write(name, '', Date.now() - 86400000);\n    }\n  };\n}() : // Non standard browser env (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n  return {\n    write: function write() {},\n    read: function read() {\n      return null;\n    },\n    remove: function remove() {}\n  };\n}();\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/helpers/cookies.js?")},"./node_modules/axios/lib/helpers/isAbsoluteURL.js":module=>{"use strict";eval('\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\n\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/helpers/isAbsoluteURL.js?')},"./node_modules/axios/lib/helpers/isAxiosError.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\n\n\nmodule.exports = function isAxiosError(payload) {\n  return utils.isObject(payload) && payload.isAxiosError === true;\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/helpers/isAxiosError.js?')},"./node_modules/axios/lib/helpers/isURLSameOrigin.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test\n// whether the request URL is of the same origin as current location.\nfunction standardBrowserEnv() {\n  var msie = /(msie|trident)/i.test(navigator.userAgent);\n  var urlParsingNode = document.createElement('a');\n  var originURL;\n  /**\n  * Parse a URL to discover it's components\n  *\n  * @param {String} url The URL to be parsed\n  * @returns {Object}\n  */\n\n  function resolveURL(url) {\n    var href = url;\n\n    if (msie) {\n      // IE needs attribute set twice to normalize properties\n      urlParsingNode.setAttribute('href', href);\n      href = urlParsingNode.href;\n    }\n\n    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n\n    return {\n      href: urlParsingNode.href,\n      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n      host: urlParsingNode.host,\n      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n      hostname: urlParsingNode.hostname,\n      port: urlParsingNode.port,\n      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname\n    };\n  }\n\n  originURL = resolveURL(window.location.href);\n  /**\n  * Determine if a URL shares the same origin as the current location\n  *\n  * @param {String} requestURL The URL to test\n  * @returns {boolean} True if URL shares the same origin, otherwise false\n  */\n\n  return function isURLSameOrigin(requestURL) {\n    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;\n    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;\n  };\n}() : // Non standard browser envs (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n  return function isURLSameOrigin() {\n    return true;\n  };\n}();\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/helpers/isURLSameOrigin.js?")},"./node_modules/axios/lib/helpers/normalizeHeaderName.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/helpers/normalizeHeaderName.js?')},"./node_modules/axios/lib/helpers/null.js":module=>{eval("// eslint-disable-next-line strict\nmodule.exports = null;\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/helpers/null.js?")},"./node_modules/axios/lib/helpers/parseHeaders.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\"); // Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\n\n\nvar ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\n\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) {\n    return parsed;\n  }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n  return parsed;\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/helpers/parseHeaders.js?")},"./node_modules/axios/lib/helpers/parseProtocol.js":module=>{"use strict";eval("\n\nmodule.exports = function parseProtocol(url) {\n  var match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || '';\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/helpers/parseProtocol.js?")},"./node_modules/axios/lib/helpers/spread.js":module=>{"use strict";eval("\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\n\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/helpers/spread.js?")},"./node_modules/axios/lib/helpers/toFormData.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n/**\n * Convert a data object to FormData\n * @param {Object} obj\n * @param {?Object} [formData]\n * @returns {Object}\n **/\n\n\nfunction toFormData(obj, formData) {\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new FormData();\n  var stack = [];\n\n  function convertValue(value) {\n    if (value === null) return '';\n\n    if (utils.isDate(value)) {\n      return value.toISOString();\n    }\n\n    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {\n      return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  function build(data, parentKey) {\n    if (utils.isPlainObject(data) || utils.isArray(data)) {\n      if (stack.indexOf(data) !== -1) {\n        throw Error('Circular reference detected in ' + parentKey);\n      }\n\n      stack.push(data);\n      utils.forEach(data, function each(value, key) {\n        if (utils.isUndefined(value)) return;\n        var fullKey = parentKey ? parentKey + '.' + key : key;\n        var arr;\n\n        if (value && !parentKey && typeof value === 'object') {\n          if (utils.endsWith(key, '{}')) {\n            // eslint-disable-next-line no-param-reassign\n            value = JSON.stringify(value);\n          } else if (utils.endsWith(key, '[]') && (arr = utils.toArray(value))) {\n            // eslint-disable-next-line func-names\n            arr.forEach(function (el) {\n              !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));\n            });\n            return;\n          }\n        }\n\n        build(value, fullKey);\n      });\n      stack.pop();\n    } else {\n      formData.append(parentKey, convertValue(data));\n    }\n  }\n\n  build(obj);\n  return formData;\n}\n\nmodule.exports = toFormData;\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/helpers/toFormData.js?")},"./node_modules/axios/lib/helpers/validator.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar VERSION = (__webpack_require__(/*! ../env/data */ \"./node_modules/axios/lib/env/data.js\").version);\n\nvar AxiosError = __webpack_require__(/*! ../core/AxiosError */ \"./node_modules/axios/lib/core/AxiosError.js\");\n\nvar validators = {}; // eslint-disable-next-line func-names\n\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function (type, i) {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\nvar deprecatedWarnings = {};\n/**\n * Transitional option validator\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n * @returns {function}\n */\n\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  } // eslint-disable-next-line func-names\n\n\n  return function (value, opt, opts) {\n    if (validator === false) {\n      throw new AxiosError(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), AxiosError.ERR_DEPRECATED);\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true; // eslint-disable-next-line no-console\n\n      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */\n\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n\n  var keys = Object.keys(options);\n  var i = keys.length;\n\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n\n      if (result !== true) {\n        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n\n      continue;\n    }\n\n    if (allowUnknown !== true) {\n      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n\nmodule.exports = {\n  assertOptions: assertOptions,\n  validators: validators\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/helpers/validator.js?")},"./node_modules/axios/lib/utils.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\"); // utils is a library of generic helper functions non-specific to axios\n\n\nvar toString = Object.prototype.toString; // eslint-disable-next-line func-names\n\nvar kindOf = function (cache) {\n  // eslint-disable-next-line func-names\n  return function (thing) {\n    var str = toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n  };\n}(Object.create(null));\n\nfunction kindOfTest(type) {\n  type = type.toLowerCase();\n  return function isKindOf(thing) {\n    return kindOf(thing) === type;\n  };\n}\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\n\n\nfunction isArray(val) {\n  return Array.isArray(val);\n}\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\n\n\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\n\n\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\n\n\nvar isArrayBuffer = kindOfTest('ArrayBuffer');\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\n\nfunction isArrayBufferView(val) {\n  var result;\n\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = val && val.buffer && isArrayBuffer(val.buffer);\n  }\n\n  return result;\n}\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\n\n\nfunction isString(val) {\n  return typeof val === 'string';\n}\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\n\n\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\n\n\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\n\n\nfunction isPlainObject(val) {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n/**\n * Determine if a value is a Date\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\n\n\nvar isDate = kindOfTest('Date');\n/**\n * Determine if a value is a File\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\n\nvar isFile = kindOfTest('File');\n/**\n * Determine if a value is a Blob\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\n\nvar isBlob = kindOfTest('Blob');\n/**\n * Determine if a value is a FileList\n *\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\n\nvar isFileList = kindOfTest('FileList');\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\n\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\n\n\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} thing The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\n\n\nfunction isFormData(thing) {\n  var pattern = '[object FormData]';\n  return thing && (typeof FormData === 'function' && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);\n}\n/**\n * Determine if a value is a URLSearchParams object\n * @function\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\n\n\nvar isURLSearchParams = kindOfTest('URLSearchParams');\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\n\nfunction trim(str) {\n  return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n}\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\n\n\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {\n    return false;\n  }\n\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\n\n\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  } // Force an array if not already something iterable\n\n\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\n\n\nfunction\n  /* obj1, obj2, obj3, ... */\nmerge() {\n  var result = {};\n\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n\n  return result;\n}\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\n\n\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\n\n\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n\n  return content;\n}\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n */\n\n\nfunction inherits(constructor, superConstructor, props, descriptors) {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  props && Object.assign(constructor.prototype, props);\n}\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function} [filter]\n * @returns {Object}\n */\n\n\nfunction toFlatObject(sourceObj, destObj, filter) {\n  var props;\n  var i;\n  var prop;\n  var merged = {};\n  destObj = destObj || {};\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n\n    while (i-- > 0) {\n      prop = props[i];\n\n      if (!merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n\n    sourceObj = Object.getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n}\n/*\n * determines whether a string ends with the characters of a specified string\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n * @returns {boolean}\n */\n\n\nfunction endsWith(str, searchString, position) {\n  str = String(str);\n\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n\n  position -= searchString.length;\n  var lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n}\n/**\n * Returns new array from array like object\n * @param {*} [thing]\n * @returns {Array}\n */\n\n\nfunction toArray(thing) {\n  if (!thing) return null;\n  var i = thing.length;\n  if (isUndefined(i)) return null;\n  var arr = new Array(i);\n\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n\n  return arr;\n} // eslint-disable-next-line func-names\n\n\nvar isTypedArray = function (TypedArray) {\n  // eslint-disable-next-line func-names\n  return function (thing) {\n    return TypedArray && thing instanceof TypedArray;\n  };\n}(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM,\n  inherits: inherits,\n  toFlatObject: toFlatObject,\n  kindOf: kindOf,\n  kindOfTest: kindOfTest,\n  endsWith: endsWith,\n  toArray: toArray,\n  isTypedArray: isTypedArray,\n  isFileList: isFileList\n};\n\n//# sourceURL=webpack://kloster/./node_modules/axios/lib/utils.js?")},"./node_modules/blueimp-gallery/js/blueimp-gallery-fullscreen.js":(module,exports,__webpack_require__)=>{eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * blueimp Gallery Fullscreen JS\n * https://github.com/blueimp/Gallery\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./blueimp-helper */ \"./node_modules/blueimp-gallery/js/blueimp-helper.js\"), __webpack_require__(/*! ./blueimp-gallery */ \"./node_modules/blueimp-gallery/js/blueimp-gallery.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(function ($, Gallery) {\n  'use strict';\n\n  var galleryPrototype = Gallery.prototype;\n  $.extend(galleryPrototype.options, {\n    // Defines if the gallery should open in fullscreen mode:\n    fullScreen: false\n  });\n  var initialize = galleryPrototype.initialize;\n  var close = galleryPrototype.close;\n  $.extend(galleryPrototype, {\n    getFullScreenElement: function () {\n      return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;\n    },\n    requestFullScreen: function (element) {\n      if (element.requestFullscreen) {\n        element.requestFullscreen();\n      } else if (element.webkitRequestFullscreen) {\n        element.webkitRequestFullscreen();\n      } else if (element.mozRequestFullScreen) {\n        element.mozRequestFullScreen();\n      } else if (element.msRequestFullscreen) {\n        element.msRequestFullscreen();\n      }\n    },\n    exitFullScreen: function () {\n      if (document.exitFullscreen) {\n        document.exitFullscreen();\n      } else if (document.webkitCancelFullScreen) {\n        document.webkitCancelFullScreen();\n      } else if (document.mozCancelFullScreen) {\n        document.mozCancelFullScreen();\n      } else if (document.msExitFullscreen) {\n        document.msExitFullscreen();\n      }\n    },\n    initialize: function () {\n      initialize.call(this);\n\n      if (this.options.fullScreen && !this.getFullScreenElement()) {\n        this.requestFullScreen(this.container[0]);\n      }\n    },\n    close: function () {\n      if (this.getFullScreenElement() === this.container[0]) {\n        this.exitFullScreen();\n      }\n\n      close.call(this);\n    }\n  });\n  return Gallery;\n});\n\n//# sourceURL=webpack://kloster/./node_modules/blueimp-gallery/js/blueimp-gallery-fullscreen.js?")},"./node_modules/blueimp-gallery/js/blueimp-gallery-video.js":(module,exports,__webpack_require__)=>{eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * blueimp Gallery Video Factory JS\n * https://github.com/blueimp/Gallery\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./blueimp-helper */ \"./node_modules/blueimp-gallery/js/blueimp-helper.js\"), __webpack_require__(/*! ./blueimp-gallery */ \"./node_modules/blueimp-gallery/js/blueimp-gallery.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(function ($, Gallery) {\n  'use strict';\n\n  var galleryPrototype = Gallery.prototype;\n  $.extend(galleryPrototype.options, {\n    // The class for video content elements:\n    videoContentClass: 'video-content',\n    // The class for video when it is loading:\n    videoLoadingClass: 'video-loading',\n    // The class for video when it is playing:\n    videoPlayingClass: 'video-playing',\n    // The list object property (or data attribute) for the video poster URL:\n    videoPosterProperty: 'poster',\n    // The list object property (or data attribute) for the video sources array:\n    videoSourcesProperty: 'sources'\n  });\n  var handleSlide = galleryPrototype.handleSlide;\n  $.extend(galleryPrototype, {\n    handleSlide: function (index) {\n      handleSlide.call(this, index);\n\n      if (this.playingVideo) {\n        this.playingVideo.pause();\n      }\n    },\n    videoFactory: function (obj, callback, videoInterface) {\n      var that = this;\n      var options = this.options;\n      var videoContainerNode = this.elementPrototype.cloneNode(false);\n      var videoContainer = $(videoContainerNode);\n      var errorArgs = [{\n        type: 'error',\n        target: videoContainerNode\n      }];\n      var video = videoInterface || document.createElement('video');\n      var url = this.getItemProperty(obj, options.urlProperty);\n      var type = this.getItemProperty(obj, options.typeProperty);\n      var title = this.getItemProperty(obj, options.titleProperty);\n      var altText = this.getItemProperty(obj, this.options.altTextProperty) || title;\n      var posterUrl = this.getItemProperty(obj, options.videoPosterProperty);\n      var posterImage;\n      var sources = this.getItemProperty(obj, options.videoSourcesProperty);\n      var source;\n      var playMediaControl;\n      var isLoading;\n      var hasControls;\n      videoContainer.addClass(options.videoContentClass);\n\n      if (title) {\n        videoContainerNode.title = title;\n      }\n\n      if (video.canPlayType) {\n        if (url && type && video.canPlayType(type)) {\n          video.src = url;\n        } else if (sources) {\n          while (sources.length) {\n            source = sources.shift();\n            url = this.getItemProperty(source, options.urlProperty);\n            type = this.getItemProperty(source, options.typeProperty);\n\n            if (url && type && video.canPlayType(type)) {\n              video.src = url;\n              break;\n            }\n          }\n        }\n      }\n\n      if (posterUrl) {\n        video.poster = posterUrl;\n        posterImage = this.imagePrototype.cloneNode(false);\n        $(posterImage).addClass(options.toggleClass);\n        posterImage.src = posterUrl;\n        posterImage.draggable = false;\n        posterImage.alt = altText;\n        videoContainerNode.appendChild(posterImage);\n      }\n\n      playMediaControl = document.createElement('a');\n      playMediaControl.setAttribute('target', '_blank');\n\n      if (!videoInterface) {\n        playMediaControl.setAttribute('download', title);\n      }\n\n      playMediaControl.href = url;\n\n      if (video.src) {\n        video.controls = true;\n        (videoInterface || $(video)).on('error', function () {\n          that.setTimeout(callback, errorArgs);\n        }).on('pause', function () {\n          if (video.seeking) return;\n          isLoading = false;\n          videoContainer.removeClass(that.options.videoLoadingClass).removeClass(that.options.videoPlayingClass);\n\n          if (hasControls) {\n            that.container.addClass(that.options.controlsClass);\n          }\n\n          delete that.playingVideo;\n\n          if (that.interval) {\n            that.play();\n          }\n        }).on('playing', function () {\n          isLoading = false;\n          videoContainer.removeClass(that.options.videoLoadingClass).addClass(that.options.videoPlayingClass);\n\n          if (that.container.hasClass(that.options.controlsClass)) {\n            hasControls = true;\n            that.container.removeClass(that.options.controlsClass);\n          } else {\n            hasControls = false;\n          }\n        }).on('play', function () {\n          window.clearTimeout(that.timeout);\n          isLoading = true;\n          videoContainer.addClass(that.options.videoLoadingClass);\n          that.playingVideo = video;\n        });\n        $(playMediaControl).on('click', function (event) {\n          that.preventDefault(event);\n\n          if (isLoading) {\n            video.pause();\n          } else {\n            video.play();\n          }\n        });\n        videoContainerNode.appendChild(videoInterface && videoInterface.element || video);\n      }\n\n      videoContainerNode.appendChild(playMediaControl);\n      this.setTimeout(callback, [{\n        type: 'load',\n        target: videoContainerNode\n      }]);\n      return videoContainerNode;\n    }\n  });\n  return Gallery;\n});\n\n//# sourceURL=webpack://kloster/./node_modules/blueimp-gallery/js/blueimp-gallery-video.js?")},"./node_modules/blueimp-gallery/js/blueimp-gallery-youtube.js":(module,exports,__webpack_require__)=>{eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * blueimp Gallery YouTube Video Factory JS\n * https://github.com/blueimp/Gallery\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, YT */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./blueimp-helper */ \"./node_modules/blueimp-gallery/js/blueimp-helper.js\"), __webpack_require__(/*! ./blueimp-gallery-video */ \"./node_modules/blueimp-gallery/js/blueimp-gallery-video.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(function ($, Gallery) {\n  'use strict';\n\n  if (!window.postMessage) {\n    return Gallery;\n  }\n\n  var galleryPrototype = Gallery.prototype;\n  $.extend(galleryPrototype.options, {\n    // The list object property (or data attribute) with the YouTube video id:\n    youTubeVideoIdProperty: 'youtube',\n    // Optional object with parameters passed to the YouTube video player:\n    // https://developers.google.com/youtube/player_parameters\n    youTubePlayerVars: {\n      wmode: 'transparent'\n    },\n    // Require a click on the native YouTube player for the initial playback:\n    youTubeClickToPlay: true\n  });\n  var textFactory = galleryPrototype.textFactory || galleryPrototype.imageFactory;\n\n  var YouTubePlayer = function (videoId, playerVars, clickToPlay) {\n    this.videoId = videoId;\n    this.playerVars = playerVars;\n    this.clickToPlay = clickToPlay;\n    this.element = document.createElement('div');\n    this.listeners = {};\n  };\n\n  $.extend(YouTubePlayer.prototype, {\n    canPlayType: function () {\n      return true;\n    },\n    on: function (type, func) {\n      this.listeners[type] = func;\n      return this;\n    },\n    loadAPI: function () {\n      var that = this;\n      var onYouTubeIframeAPIReady = window.onYouTubeIframeAPIReady;\n      var apiUrl = '//www.youtube.com/iframe_api';\n      var scriptTags = document.getElementsByTagName('script');\n      var i = scriptTags.length;\n      var scriptTag;\n\n      window.onYouTubeIframeAPIReady = function () {\n        if (onYouTubeIframeAPIReady) {\n          onYouTubeIframeAPIReady.apply(this);\n        }\n\n        if (that.playOnReady) {\n          that.play();\n        }\n      };\n\n      while (i) {\n        i -= 1;\n\n        if (scriptTags[i].src === apiUrl) {\n          return;\n        }\n      }\n\n      scriptTag = document.createElement('script');\n      scriptTag.src = apiUrl;\n      scriptTags[0].parentNode.insertBefore(scriptTag, scriptTags[0]);\n    },\n    onReady: function () {\n      this.ready = true;\n\n      if (this.playOnReady) {\n        this.play();\n      }\n    },\n    onPlaying: function () {\n      if (this.playStatus < 2) {\n        this.listeners.playing();\n        this.playStatus = 2;\n      }\n    },\n    onPause: function () {\n      galleryPrototype.setTimeout.call(this, this.checkSeek, null, 2000);\n    },\n    checkSeek: function () {\n      if (this.stateChange === YT.PlayerState.PAUSED || this.stateChange === YT.PlayerState.ENDED) {\n        // check if current state change is actually paused\n        this.listeners.pause();\n        delete this.playStatus;\n      }\n    },\n    onStateChange: function (event) {\n      switch (event.data) {\n        case YT.PlayerState.PLAYING:\n          this.hasPlayed = true;\n          this.onPlaying();\n          break;\n\n        case YT.PlayerState.PAUSED:\n        case YT.PlayerState.ENDED:\n          this.onPause();\n          break;\n      } // Save most recent state change to this.stateChange\n\n\n      this.stateChange = event.data;\n    },\n    onError: function (event) {\n      this.listeners.error(event);\n    },\n    play: function () {\n      var that = this;\n\n      if (!this.playStatus) {\n        this.listeners.play();\n        this.playStatus = 1;\n      }\n\n      if (this.ready) {\n        if (!this.hasPlayed && (this.clickToPlay || window.navigator && /iP(hone|od|ad)/.test(window.navigator.platform))) {\n          // Manually trigger the playing callback if clickToPlay\n          // is enabled and to workaround a limitation in iOS,\n          // which requires synchronous user interaction to start\n          // the video playback:\n          this.onPlaying();\n        } else {\n          this.player.playVideo();\n        }\n      } else {\n        this.playOnReady = true;\n\n        if (!(window.YT && YT.Player)) {\n          this.loadAPI();\n        } else if (!this.player) {\n          this.player = new YT.Player(this.element, {\n            videoId: this.videoId,\n            playerVars: this.playerVars,\n            events: {\n              onReady: function () {\n                that.onReady();\n              },\n              onStateChange: function (event) {\n                that.onStateChange(event);\n              },\n              onError: function (event) {\n                that.onError(event);\n              }\n            }\n          });\n        }\n      }\n    },\n    pause: function () {\n      if (this.ready) {\n        this.player.pauseVideo();\n      } else if (this.playStatus) {\n        delete this.playOnReady;\n        this.listeners.pause();\n        delete this.playStatus;\n      }\n    }\n  });\n  $.extend(galleryPrototype, {\n    YouTubePlayer: YouTubePlayer,\n    textFactory: function (obj, callback) {\n      var options = this.options;\n      var videoId = this.getItemProperty(obj, options.youTubeVideoIdProperty);\n\n      if (videoId) {\n        if (this.getItemProperty(obj, options.urlProperty) === undefined) {\n          obj[options.urlProperty] = '//www.youtube.com/watch?v=' + videoId;\n        }\n\n        if (this.getItemProperty(obj, options.videoPosterProperty) === undefined) {\n          obj[options.videoPosterProperty] = '//img.youtube.com/vi/' + videoId + '/maxresdefault.jpg';\n        }\n\n        return this.videoFactory(obj, callback, new YouTubePlayer(videoId, options.youTubePlayerVars, options.youTubeClickToPlay));\n      }\n\n      return textFactory.call(this, obj, callback);\n    }\n  });\n  return Gallery;\n});\n\n//# sourceURL=webpack://kloster/./node_modules/blueimp-gallery/js/blueimp-gallery-youtube.js?")},"./node_modules/blueimp-gallery/js/blueimp-gallery.js":(module,exports,__webpack_require__)=>{eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * blueimp Gallery JS\n * https://github.com/blueimp/Gallery\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Swipe implementation based on\n * https://github.com/bradbirdsall/Swipe\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, DocumentTouch */\n\n/* eslint-disable no-param-reassign */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (true) {\n    // Register as an anonymous AMD module:\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./blueimp-helper */ \"./node_modules/blueimp-gallery/js/blueimp-helper.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(function ($) {\n  'use strict';\n  /**\n   * Gallery constructor\n   *\n   * @class\n   * @param {Array|NodeList} list Gallery content\n   * @param {object} [options] Gallery options\n   * @returns {object} Gallery object\n   */\n\n  function Gallery(list, options) {\n    if (document.body.style.maxHeight === undefined) {\n      // document.body.style.maxHeight is undefined on IE6 and lower\n      return null;\n    }\n\n    if (!this || this.options !== Gallery.prototype.options) {\n      // Called as function instead of as constructor,\n      // so we simply return a new instance:\n      return new Gallery(list, options);\n    }\n\n    if (!list || !list.length) {\n      this.console.log('blueimp Gallery: No or empty list provided as first argument.', list);\n      return;\n    }\n\n    this.list = list;\n    this.num = list.length;\n    this.initOptions(options);\n    this.initialize();\n  }\n\n  $.extend(Gallery.prototype, {\n    options: {\n      // The Id, element or querySelector of the gallery widget:\n      container: '#blueimp-gallery',\n      // The tag name, Id, element or querySelector of the slides container:\n      slidesContainer: 'div',\n      // The tag name, Id, element or querySelector of the title element:\n      titleElement: 'h3',\n      // The class to add when the gallery is visible:\n      displayClass: 'blueimp-gallery-display',\n      // The class to add when the gallery controls are visible:\n      controlsClass: 'blueimp-gallery-controls',\n      // The class to add when the gallery only displays one element:\n      singleClass: 'blueimp-gallery-single',\n      // The class to add when the left edge has been reached:\n      leftEdgeClass: 'blueimp-gallery-left',\n      // The class to add when the right edge has been reached:\n      rightEdgeClass: 'blueimp-gallery-right',\n      // The class to add when the automatic slideshow is active:\n      playingClass: 'blueimp-gallery-playing',\n      // The class for all slides:\n      slideClass: 'slide',\n      // The slide class for loading elements:\n      slideLoadingClass: 'slide-loading',\n      // The slide class for elements that failed to load:\n      slideErrorClass: 'slide-error',\n      // The class for the content element loaded into each slide:\n      slideContentClass: 'slide-content',\n      // The class for the \"toggle\" control:\n      toggleClass: 'toggle',\n      // The class for the \"prev\" control:\n      prevClass: 'prev',\n      // The class for the \"next\" control:\n      nextClass: 'next',\n      // The class for the \"close\" control:\n      closeClass: 'close',\n      // The class for the \"play-pause\" toggle control:\n      playPauseClass: 'play-pause',\n      // The list object property (or data attribute) with the object type:\n      typeProperty: 'type',\n      // The list object property (or data attribute) with the object title:\n      titleProperty: 'title',\n      // The list object property (or data attribute) with the object alt text:\n      altTextProperty: 'alt',\n      // The list object property (or data attribute) with the object URL:\n      urlProperty: 'href',\n      // The list object property (or data attribute) with the object srcset URL(s):\n      srcsetProperty: 'urlset',\n      // The gallery listens for transitionend events before triggering the\n      // opened and closed events, unless the following option is set to false:\n      displayTransition: true,\n      // Defines if the gallery slides are cleared from the gallery modal,\n      // or reused for the next gallery initialization:\n      clearSlides: true,\n      // Defines if images should be stretched to fill the available space,\n      // while maintaining their aspect ratio (will only be enabled for browsers\n      // supporting background-size=\"contain\", which excludes IE < 9).\n      // Set to \"cover\", to make images cover all available space (requires\n      // support for background-size=\"cover\", which excludes IE < 9):\n      stretchImages: false,\n      // Toggle the controls on pressing the Return key:\n      toggleControlsOnReturn: true,\n      // Toggle the controls on slide click:\n      toggleControlsOnSlideClick: true,\n      // Toggle the automatic slideshow interval on pressing the Space key:\n      toggleSlideshowOnSpace: true,\n      // Navigate the gallery by pressing left and right on the keyboard:\n      enableKeyboardNavigation: true,\n      // Close the gallery on pressing the Esc key:\n      closeOnEscape: true,\n      // Close the gallery when clicking on an empty slide area:\n      closeOnSlideClick: true,\n      // Close the gallery by swiping up or down:\n      closeOnSwipeUpOrDown: true,\n      // Close the gallery when URL changes:\n      closeOnHashChange: true,\n      // Emulate touch events on mouse-pointer devices such as desktop browsers:\n      emulateTouchEvents: true,\n      // Stop touch events from bubbling up to ancestor elements of the Gallery:\n      stopTouchEventsPropagation: false,\n      // Hide the page scrollbars:\n      hidePageScrollbars: true,\n      // Stops any touches on the container from scrolling the page:\n      disableScroll: true,\n      // Carousel mode (shortcut for carousel specific options):\n      carousel: false,\n      // Allow continuous navigation, moving from last to first\n      // and from first to last slide:\n      continuous: true,\n      // Remove elements outside of the preload range from the DOM:\n      unloadElements: true,\n      // Start with the automatic slideshow:\n      startSlideshow: false,\n      // Delay in milliseconds between slides for the automatic slideshow:\n      slideshowInterval: 5000,\n      // The direction the slides are moving: ltr=LeftToRight or rtl=RightToLeft\n      slideshowDirection: 'ltr',\n      // The starting index as integer.\n      // Can also be an object of the given list,\n      // or an equal object with the same url property:\n      index: 0,\n      // The number of elements to load around the current index:\n      preloadRange: 2,\n      // The transition duration between slide changes in milliseconds:\n      transitionDuration: 300,\n      // The transition duration for automatic slide changes, set to an integer\n      // greater 0 to override the default transition duration:\n      slideshowTransitionDuration: 500,\n      // The event object for which the default action will be canceled\n      // on Gallery initialization (e.g. the click event to open the Gallery):\n      event: undefined,\n      // Callback function executed when the Gallery is initialized.\n      // Is called with the gallery instance as \"this\" object:\n      onopen: undefined,\n      // Callback function executed when the Gallery has been initialized\n      // and the initialization transition has been completed.\n      // Is called with the gallery instance as \"this\" object:\n      onopened: undefined,\n      // Callback function executed on slide change.\n      // Is called with the gallery instance as \"this\" object and the\n      // current index and slide as arguments:\n      onslide: undefined,\n      // Callback function executed after the slide change transition.\n      // Is called with the gallery instance as \"this\" object and the\n      // current index and slide as arguments:\n      onslideend: undefined,\n      // Callback function executed on slide content load.\n      // Is called with the gallery instance as \"this\" object and the\n      // slide index and slide element as arguments:\n      onslidecomplete: undefined,\n      // Callback function executed when the Gallery is about to be closed.\n      // Is called with the gallery instance as \"this\" object:\n      onclose: undefined,\n      // Callback function executed when the Gallery has been closed\n      // and the closing transition has been completed.\n      // Is called with the gallery instance as \"this\" object:\n      onclosed: undefined\n    },\n    carouselOptions: {\n      hidePageScrollbars: false,\n      toggleControlsOnReturn: false,\n      toggleSlideshowOnSpace: false,\n      enableKeyboardNavigation: false,\n      closeOnEscape: false,\n      closeOnSlideClick: false,\n      closeOnSwipeUpOrDown: false,\n      disableScroll: false,\n      startSlideshow: true\n    },\n    console: window.console && typeof window.console.log === 'function' ? window.console : {\n      log: function () {}\n    },\n    // Detect touch, transition, transform and background-size support:\n    support: function (element) {\n      var support = {\n        touch: window.ontouchstart !== undefined || window.DocumentTouch && document instanceof DocumentTouch\n      };\n      var transitions = {\n        webkitTransition: {\n          end: 'webkitTransitionEnd',\n          prefix: '-webkit-'\n        },\n        MozTransition: {\n          end: 'transitionend',\n          prefix: '-moz-'\n        },\n        OTransition: {\n          end: 'otransitionend',\n          prefix: '-o-'\n        },\n        transition: {\n          end: 'transitionend',\n          prefix: ''\n        }\n      };\n      var prop;\n\n      for (prop in transitions) {\n        if (Object.prototype.hasOwnProperty.call(transitions, prop) && element.style[prop] !== undefined) {\n          support.transition = transitions[prop];\n          support.transition.name = prop;\n          break;\n        }\n      }\n      /**\n       * Tests browser support\n       */\n\n\n      function elementTests() {\n        var transition = support.transition;\n        var prop;\n        var translateZ;\n        document.body.appendChild(element);\n\n        if (transition) {\n          prop = transition.name.slice(0, -9) + 'ransform';\n\n          if (element.style[prop] !== undefined) {\n            element.style[prop] = 'translateZ(0)';\n            translateZ = window.getComputedStyle(element).getPropertyValue(transition.prefix + 'transform');\n            support.transform = {\n              prefix: transition.prefix,\n              name: prop,\n              translate: true,\n              translateZ: !!translateZ && translateZ !== 'none'\n            };\n          }\n        }\n\n        if (element.style.backgroundSize !== undefined) {\n          support.backgroundSize = {};\n          element.style.backgroundSize = 'contain';\n          support.backgroundSize.contain = window.getComputedStyle(element).getPropertyValue('background-size') === 'contain';\n          element.style.backgroundSize = 'cover';\n          support.backgroundSize.cover = window.getComputedStyle(element).getPropertyValue('background-size') === 'cover';\n        }\n\n        document.body.removeChild(element);\n      }\n\n      if (document.body) {\n        elementTests();\n      } else {\n        $(document).on('DOMContentLoaded', elementTests);\n      }\n\n      return support; // Test element, has to be standard HTML and must not be hidden\n      // for the CSS3 tests using window.getComputedStyle to be applicable:\n    }(document.createElement('div')),\n    requestAnimationFrame: window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame,\n    cancelAnimationFrame: window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame,\n    initialize: function () {\n      this.initStartIndex();\n\n      if (this.initWidget() === false) {\n        return false;\n      }\n\n      this.initEventListeners(); // Load the slide at the given index:\n\n      this.onslide(this.index); // Manually trigger the slideend event for the initial slide:\n\n      this.ontransitionend(); // Start the automatic slideshow if applicable:\n\n      if (this.options.startSlideshow) {\n        this.play();\n      }\n    },\n    slide: function (to, duration) {\n      window.clearTimeout(this.timeout);\n      var index = this.index;\n      var direction;\n      var naturalDirection;\n      var diff;\n\n      if (index === to || this.num === 1) {\n        return;\n      }\n\n      if (!duration) {\n        duration = this.options.transitionDuration;\n      }\n\n      if (this.support.transform) {\n        if (!this.options.continuous) {\n          to = this.circle(to);\n        } // 1: backward, -1: forward:\n\n\n        direction = Math.abs(index - to) / (index - to); // Get the actual position of the slide:\n\n        if (this.options.continuous) {\n          naturalDirection = direction;\n          direction = -this.positions[this.circle(to)] / this.slideWidth; // If going forward but to < index, use to = slides.length + to\n          // If going backward but to > index, use to = -slides.length + to\n\n          if (direction !== naturalDirection) {\n            to = -direction * this.num + to;\n          }\n        }\n\n        diff = Math.abs(index - to) - 1; // Move all the slides between index and to in the right direction:\n\n        while (diff) {\n          diff -= 1;\n          this.move(this.circle((to > index ? to : index) - diff - 1), this.slideWidth * direction, 0);\n        }\n\n        to = this.circle(to);\n        this.move(index, this.slideWidth * direction, duration);\n        this.move(to, 0, duration);\n\n        if (this.options.continuous) {\n          this.move(this.circle(to - direction), -(this.slideWidth * direction), 0);\n        }\n      } else {\n        to = this.circle(to);\n        this.animate(index * -this.slideWidth, to * -this.slideWidth, duration);\n      }\n\n      this.onslide(to);\n    },\n    getIndex: function () {\n      return this.index;\n    },\n    getNumber: function () {\n      return this.num;\n    },\n    prev: function () {\n      if (this.options.continuous || this.index) {\n        this.slide(this.index - 1);\n      }\n    },\n    next: function () {\n      if (this.options.continuous || this.index < this.num - 1) {\n        this.slide(this.index + 1);\n      }\n    },\n    play: function (time) {\n      var that = this;\n      var nextIndex = this.index + (this.options.slideshowDirection === 'rtl' ? -1 : 1);\n      window.clearTimeout(this.timeout);\n      this.interval = time || this.options.slideshowInterval;\n\n      if (this.elements[this.index] > 1) {\n        this.timeout = this.setTimeout(!this.requestAnimationFrame && this.slide || function (to, duration) {\n          that.animationFrameId = that.requestAnimationFrame.call(window, function () {\n            that.slide(to, duration);\n          });\n        }, [nextIndex, this.options.slideshowTransitionDuration], this.interval);\n      }\n\n      this.container.addClass(this.options.playingClass);\n    },\n    pause: function () {\n      window.clearTimeout(this.timeout);\n      this.interval = null;\n\n      if (this.cancelAnimationFrame) {\n        this.cancelAnimationFrame.call(window, this.animationFrameId);\n        this.animationFrameId = null;\n      }\n\n      this.container.removeClass(this.options.playingClass);\n    },\n    add: function (list) {\n      var i;\n\n      if (!list.concat) {\n        // Make a real array out of the list to add:\n        list = Array.prototype.slice.call(list);\n      }\n\n      if (!this.list.concat) {\n        // Make a real array out of the Gallery list:\n        this.list = Array.prototype.slice.call(this.list);\n      }\n\n      this.list = this.list.concat(list);\n      this.num = this.list.length;\n\n      if (this.num > 2 && this.options.continuous === null) {\n        this.options.continuous = true;\n        this.container.removeClass(this.options.leftEdgeClass);\n      }\n\n      this.container.removeClass(this.options.rightEdgeClass).removeClass(this.options.singleClass);\n\n      for (i = this.num - list.length; i < this.num; i += 1) {\n        this.addSlide(i);\n        this.positionSlide(i);\n      }\n\n      this.positions.length = this.num;\n      this.initSlides(true);\n    },\n    resetSlides: function () {\n      this.slidesContainer.empty();\n      this.unloadAllSlides();\n      this.slides = [];\n    },\n    handleClose: function () {\n      var options = this.options;\n      this.destroyEventListeners(); // Cancel the slideshow:\n\n      this.pause();\n      this.container[0].style.display = 'none';\n      this.container.removeClass(options.displayClass).removeClass(options.singleClass).removeClass(options.leftEdgeClass).removeClass(options.rightEdgeClass);\n\n      if (options.hidePageScrollbars) {\n        document.body.style.overflow = this.bodyOverflowStyle;\n      }\n\n      if (this.options.clearSlides) {\n        this.resetSlides();\n      }\n\n      if (this.options.onclosed) {\n        this.options.onclosed.call(this);\n      }\n    },\n    close: function () {\n      var that = this;\n      /**\n       * Close handler\n       *\n       * @param {event} event Close event\n       */\n\n      function closeHandler(event) {\n        if (event.target === that.container[0]) {\n          that.container.off(that.support.transition.end, closeHandler);\n          that.handleClose();\n        }\n      }\n\n      if (this.options.onclose) {\n        this.options.onclose.call(this);\n      }\n\n      if (this.support.transition && this.options.displayTransition) {\n        this.container.on(this.support.transition.end, closeHandler);\n        this.container.removeClass(this.options.displayClass);\n      } else {\n        this.handleClose();\n      }\n    },\n    circle: function (index) {\n      // Always return a number inside of the slides index range:\n      return (this.num + index % this.num) % this.num;\n    },\n    move: function (index, dist, duration) {\n      this.translateX(index, dist, duration);\n      this.positions[index] = dist;\n    },\n    translate: function (index, x, y, duration) {\n      if (!this.slides[index]) return;\n      var style = this.slides[index].style;\n      var transition = this.support.transition;\n      var transform = this.support.transform;\n      style[transition.name + 'Duration'] = duration + 'ms';\n      style[transform.name] = 'translate(' + x + 'px, ' + y + 'px)' + (transform.translateZ ? ' translateZ(0)' : '');\n    },\n    translateX: function (index, x, duration) {\n      this.translate(index, x, 0, duration);\n    },\n    translateY: function (index, y, duration) {\n      this.translate(index, 0, y, duration);\n    },\n    animate: function (from, to, duration) {\n      if (!duration) {\n        this.slidesContainer[0].style.left = to + 'px';\n        return;\n      }\n\n      var that = this;\n      var start = new Date().getTime();\n      var timer = window.setInterval(function () {\n        var timeElap = new Date().getTime() - start;\n\n        if (timeElap > duration) {\n          that.slidesContainer[0].style.left = to + 'px';\n          that.ontransitionend();\n          window.clearInterval(timer);\n          return;\n        }\n\n        that.slidesContainer[0].style.left = (to - from) * (Math.floor(timeElap / duration * 100) / 100) + from + 'px';\n      }, 4);\n    },\n    preventDefault: function (event) {\n      if (event.preventDefault) {\n        event.preventDefault();\n      } else {\n        event.returnValue = false;\n      }\n    },\n    stopPropagation: function (event) {\n      if (event.stopPropagation) {\n        event.stopPropagation();\n      } else {\n        event.cancelBubble = true;\n      }\n    },\n    onresize: function () {\n      this.initSlides(true);\n    },\n    onhashchange: function () {\n      if (this.options.closeOnHashChange) {\n        this.close();\n      }\n    },\n    onmousedown: function (event) {\n      // Trigger on clicks of the left mouse button only\n      // and exclude video & audio elements:\n      if (event.which && event.which === 1 && event.target.nodeName !== 'VIDEO' && event.target.nodeName !== 'AUDIO') {\n        // Preventing the default mousedown action is required\n        // to make touch emulation work with Firefox:\n        event.preventDefault();\n        (event.originalEvent || event).touches = [{\n          pageX: event.pageX,\n          pageY: event.pageY\n        }];\n        this.ontouchstart(event);\n      }\n    },\n    onmousemove: function (event) {\n      if (this.touchStart) {\n        ;\n        (event.originalEvent || event).touches = [{\n          pageX: event.pageX,\n          pageY: event.pageY\n        }];\n        this.ontouchmove(event);\n      }\n    },\n    onmouseup: function (event) {\n      if (this.touchStart) {\n        this.ontouchend(event);\n        delete this.touchStart;\n      }\n    },\n    onmouseout: function (event) {\n      if (this.touchStart) {\n        var target = event.target;\n        var related = event.relatedTarget;\n\n        if (!related || related !== target && !$.contains(target, related)) {\n          this.onmouseup(event);\n        }\n      }\n    },\n    ontouchstart: function (event) {\n      if (this.options.stopTouchEventsPropagation) {\n        this.stopPropagation(event);\n      } // jQuery doesn't copy touch event properties by default,\n      // so we have to access the originalEvent object:\n\n\n      var touch = (event.originalEvent || event).touches[0];\n      this.touchStart = {\n        // Remember the initial touch coordinates:\n        x: touch.pageX,\n        y: touch.pageY,\n        // Store the time to determine touch duration:\n        time: Date.now()\n      }; // Helper variable to detect scroll movement:\n\n      this.isScrolling = undefined; // Reset delta values:\n\n      this.touchDelta = {};\n    },\n    ontouchmove: function (event) {\n      if (this.options.stopTouchEventsPropagation) {\n        this.stopPropagation(event);\n      } // jQuery doesn't copy touch event properties by default,\n      // so we have to access the originalEvent object:\n\n\n      var touches = (event.originalEvent || event).touches;\n      var touch = touches[0];\n      var scale = (event.originalEvent || event).scale;\n      var index = this.index;\n      var touchDeltaX;\n      var indices; // Ensure this is a one touch swipe and not, e.g. a pinch:\n\n      if (touches.length > 1 || scale && scale !== 1) {\n        return;\n      }\n\n      if (this.options.disableScroll) {\n        event.preventDefault();\n      } // Measure change in x and y coordinates:\n\n\n      this.touchDelta = {\n        x: touch.pageX - this.touchStart.x,\n        y: touch.pageY - this.touchStart.y\n      };\n      touchDeltaX = this.touchDelta.x; // Detect if this is a vertical scroll movement (run only once per touch):\n\n      if (this.isScrolling === undefined) {\n        this.isScrolling = this.isScrolling || Math.abs(touchDeltaX) < Math.abs(this.touchDelta.y);\n      }\n\n      if (!this.isScrolling) {\n        // Always prevent horizontal scroll:\n        event.preventDefault(); // Stop the slideshow:\n\n        window.clearTimeout(this.timeout);\n\n        if (this.options.continuous) {\n          indices = [this.circle(index + 1), index, this.circle(index - 1)];\n        } else {\n          // Increase resistance if first slide and sliding left\n          // or last slide and sliding right:\n          this.touchDelta.x = touchDeltaX = touchDeltaX / (!index && touchDeltaX > 0 || index === this.num - 1 && touchDeltaX < 0 ? Math.abs(touchDeltaX) / this.slideWidth + 1 : 1);\n          indices = [index];\n\n          if (index) {\n            indices.push(index - 1);\n          }\n\n          if (index < this.num - 1) {\n            indices.unshift(index + 1);\n          }\n        }\n\n        while (indices.length) {\n          index = indices.pop();\n          this.translateX(index, touchDeltaX + this.positions[index], 0);\n        }\n      } else if (!this.options.carousel) {\n        this.translateY(index, this.touchDelta.y + this.positions[index], 0);\n      }\n    },\n    ontouchend: function (event) {\n      if (this.options.stopTouchEventsPropagation) {\n        this.stopPropagation(event);\n      }\n\n      var index = this.index;\n      var absTouchDeltaX = Math.abs(this.touchDelta.x);\n      var slideWidth = this.slideWidth;\n      var duration = Math.ceil(this.options.transitionDuration * (1 - absTouchDeltaX / slideWidth) / 2); // Determine if slide attempt triggers next/prev slide:\n\n      var isValidSlide = absTouchDeltaX > 20; // Determine if slide attempt is past start or end:\n\n      var isPastBounds = !index && this.touchDelta.x > 0 || index === this.num - 1 && this.touchDelta.x < 0;\n      var isValidClose = !isValidSlide && this.options.closeOnSwipeUpOrDown && Math.abs(this.touchDelta.y) > 20;\n      var direction;\n      var indexForward;\n      var indexBackward;\n      var distanceForward;\n      var distanceBackward;\n\n      if (this.options.continuous) {\n        isPastBounds = false;\n      } // Determine direction of swipe (true: right, false: left):\n\n\n      direction = this.touchDelta.x < 0 ? -1 : 1;\n\n      if (!this.isScrolling) {\n        if (isValidSlide && !isPastBounds) {\n          indexForward = index + direction;\n          indexBackward = index - direction;\n          distanceForward = slideWidth * direction;\n          distanceBackward = -slideWidth * direction;\n\n          if (this.options.continuous) {\n            this.move(this.circle(indexForward), distanceForward, 0);\n            this.move(this.circle(index - 2 * direction), distanceBackward, 0);\n          } else if (indexForward >= 0 && indexForward < this.num) {\n            this.move(indexForward, distanceForward, 0);\n          }\n\n          this.move(index, this.positions[index] + distanceForward, duration);\n          this.move(this.circle(indexBackward), this.positions[this.circle(indexBackward)] + distanceForward, duration);\n          index = this.circle(indexBackward);\n          this.onslide(index);\n        } else {\n          // Move back into position\n          if (this.options.continuous) {\n            this.move(this.circle(index - 1), -slideWidth, duration);\n            this.move(index, 0, duration);\n            this.move(this.circle(index + 1), slideWidth, duration);\n          } else {\n            if (index) {\n              this.move(index - 1, -slideWidth, duration);\n            }\n\n            this.move(index, 0, duration);\n\n            if (index < this.num - 1) {\n              this.move(index + 1, slideWidth, duration);\n            }\n          }\n        }\n      } else {\n        if (isValidClose) {\n          this.close();\n        } else {\n          // Move back into position\n          this.translateY(index, 0, duration);\n        }\n      }\n    },\n    ontouchcancel: function (event) {\n      if (this.touchStart) {\n        this.ontouchend(event);\n        delete this.touchStart;\n      }\n    },\n    ontransitionend: function (event) {\n      var slide = this.slides[this.index];\n\n      if (!event || slide === event.target) {\n        if (this.interval) {\n          this.play();\n        }\n\n        this.setTimeout(this.options.onslideend, [this.index, slide]);\n      }\n    },\n    oncomplete: function (event) {\n      var target = event.target || event.srcElement;\n      var parent = target && target.parentNode;\n      var index;\n\n      if (!target || !parent) {\n        return;\n      }\n\n      index = this.getNodeIndex(parent);\n      $(parent).removeClass(this.options.slideLoadingClass);\n\n      if (event.type === 'error') {\n        $(parent).addClass(this.options.slideErrorClass);\n        this.elements[index] = 3; // Fail\n      } else {\n        this.elements[index] = 2; // Done\n      } // Fix for IE7's lack of support for percentage max-height:\n\n\n      if (target.clientHeight > this.container[0].clientHeight) {\n        target.style.maxHeight = this.container[0].clientHeight;\n      }\n\n      if (this.interval && this.slides[this.index] === parent) {\n        this.play();\n      }\n\n      this.setTimeout(this.options.onslidecomplete, [index, parent]);\n    },\n    onload: function (event) {\n      this.oncomplete(event);\n    },\n    onerror: function (event) {\n      this.oncomplete(event);\n    },\n    onkeydown: function (event) {\n      switch (event.which || event.keyCode) {\n        case 13:\n          // Return\n          if (this.options.toggleControlsOnReturn) {\n            this.preventDefault(event);\n            this.toggleControls();\n          }\n\n          break;\n\n        case 27:\n          // Esc\n          if (this.options.closeOnEscape) {\n            this.close(); // prevent Esc from closing other things\n\n            event.stopImmediatePropagation();\n          }\n\n          break;\n\n        case 32:\n          // Space\n          if (this.options.toggleSlideshowOnSpace) {\n            this.preventDefault(event);\n            this.toggleSlideshow();\n          }\n\n          break;\n\n        case 37:\n          // Left\n          if (this.options.enableKeyboardNavigation) {\n            this.preventDefault(event);\n            this.prev();\n          }\n\n          break;\n\n        case 39:\n          // Right\n          if (this.options.enableKeyboardNavigation) {\n            this.preventDefault(event);\n            this.next();\n          }\n\n          break;\n      }\n    },\n    handleClick: function (event) {\n      var options = this.options;\n      var target = event.target || event.srcElement;\n      var parent = target.parentNode;\n      /**\n       * Checks if the target from the close has the given class\n       *\n       * @param {string} className Class name\n       * @returns {boolean} Returns true if the target has the class name\n       */\n\n      function isTarget(className) {\n        return $(target).hasClass(className) || $(parent).hasClass(className);\n      }\n\n      if (isTarget(options.toggleClass)) {\n        // Click on \"toggle\" control\n        this.preventDefault(event);\n        this.toggleControls();\n      } else if (isTarget(options.prevClass)) {\n        // Click on \"prev\" control\n        this.preventDefault(event);\n        this.prev();\n      } else if (isTarget(options.nextClass)) {\n        // Click on \"next\" control\n        this.preventDefault(event);\n        this.next();\n      } else if (isTarget(options.closeClass)) {\n        // Click on \"close\" control\n        this.preventDefault(event);\n        this.close();\n      } else if (isTarget(options.playPauseClass)) {\n        // Click on \"play-pause\" control\n        this.preventDefault(event);\n        this.toggleSlideshow();\n      } else if (parent === this.slidesContainer[0]) {\n        // Click on slide background\n        if (options.closeOnSlideClick) {\n          this.preventDefault(event);\n          this.close();\n        } else if (options.toggleControlsOnSlideClick) {\n          this.preventDefault(event);\n          this.toggleControls();\n        }\n      } else if (parent.parentNode && parent.parentNode === this.slidesContainer[0]) {\n        // Click on displayed element\n        if (options.toggleControlsOnSlideClick) {\n          this.preventDefault(event);\n          this.toggleControls();\n        }\n      }\n    },\n    onclick: function (event) {\n      if (this.options.emulateTouchEvents && this.touchDelta && (Math.abs(this.touchDelta.x) > 20 || Math.abs(this.touchDelta.y) > 20)) {\n        delete this.touchDelta;\n        return;\n      }\n\n      return this.handleClick(event);\n    },\n    updateEdgeClasses: function (index) {\n      if (!index) {\n        this.container.addClass(this.options.leftEdgeClass);\n      } else {\n        this.container.removeClass(this.options.leftEdgeClass);\n      }\n\n      if (index === this.num - 1) {\n        this.container.addClass(this.options.rightEdgeClass);\n      } else {\n        this.container.removeClass(this.options.rightEdgeClass);\n      }\n    },\n    handleSlide: function (index) {\n      if (!this.options.continuous) {\n        this.updateEdgeClasses(index);\n      }\n\n      this.loadElements(index);\n\n      if (this.options.unloadElements) {\n        this.unloadElements(index);\n      }\n\n      this.setTitle(index);\n    },\n    onslide: function (index) {\n      this.index = index;\n      this.handleSlide(index);\n      this.setTimeout(this.options.onslide, [index, this.slides[index]]);\n    },\n    setTitle: function (index) {\n      var firstChild = this.slides[index].firstChild;\n      var text = firstChild.title || firstChild.alt;\n      var titleElement = this.titleElement;\n\n      if (titleElement.length) {\n        this.titleElement.empty();\n\n        if (text) {\n          titleElement[0].appendChild(document.createTextNode(text));\n        }\n      }\n    },\n    setTimeout: function (func, args, wait) {\n      var that = this;\n      return func && window.setTimeout(function () {\n        func.apply(that, args || []);\n      }, wait || 0);\n    },\n    imageFactory: function (obj, callback) {\n      var that = this;\n      var img = this.imagePrototype.cloneNode(false);\n      var url = obj;\n      var backgroundSize = this.options.stretchImages;\n      var called;\n      var element;\n      var title;\n      var altText;\n      /**\n       * Wraps the callback function for the load/error event\n       *\n       * @param {event} event load/error event\n       * @returns {number} timeout ID\n       */\n\n      function callbackWrapper(event) {\n        if (!called) {\n          event = {\n            type: event.type,\n            target: element\n          };\n\n          if (!element.parentNode) {\n            // Fix for IE7 firing the load event for\n            // cached images before the element could\n            // be added to the DOM:\n            return that.setTimeout(callbackWrapper, [event]);\n          }\n\n          called = true;\n          $(img).off('load error', callbackWrapper);\n\n          if (backgroundSize) {\n            if (event.type === 'load') {\n              element.style.background = 'url(\"' + url + '\") center no-repeat';\n              element.style.backgroundSize = backgroundSize;\n            }\n          }\n\n          callback(event);\n        }\n      }\n\n      if (typeof url !== 'string') {\n        url = this.getItemProperty(obj, this.options.urlProperty);\n        title = this.getItemProperty(obj, this.options.titleProperty);\n        altText = this.getItemProperty(obj, this.options.altTextProperty) || title;\n      }\n\n      if (backgroundSize === true) {\n        backgroundSize = 'contain';\n      }\n\n      backgroundSize = this.support.backgroundSize && this.support.backgroundSize[backgroundSize] && backgroundSize;\n\n      if (backgroundSize) {\n        element = this.elementPrototype.cloneNode(false);\n      } else {\n        element = img;\n        img.draggable = false;\n      }\n\n      if (title) {\n        element.title = title;\n      }\n\n      if (altText) {\n        element.alt = altText;\n      }\n\n      $(img).on('load error', callbackWrapper);\n      img.src = url;\n      return element;\n    },\n    createElement: function (obj, callback) {\n      var type = obj && this.getItemProperty(obj, this.options.typeProperty);\n      var factory = type && this[type.split('/')[0] + 'Factory'] || this.imageFactory;\n      var element = obj && factory.call(this, obj, callback);\n      var srcset = this.getItemProperty(obj, this.options.srcsetProperty);\n\n      if (!element) {\n        element = this.elementPrototype.cloneNode(false);\n        this.setTimeout(callback, [{\n          type: 'error',\n          target: element\n        }]);\n      }\n\n      if (srcset) {\n        element.setAttribute('srcset', srcset);\n      }\n\n      $(element).addClass(this.options.slideContentClass);\n      return element;\n    },\n    loadElement: function (index) {\n      if (!this.elements[index]) {\n        if (this.slides[index].firstChild) {\n          this.elements[index] = $(this.slides[index]).hasClass(this.options.slideErrorClass) ? 3 : 2;\n        } else {\n          this.elements[index] = 1; // Loading\n\n          $(this.slides[index]).addClass(this.options.slideLoadingClass);\n          this.slides[index].appendChild(this.createElement(this.list[index], this.proxyListener));\n        }\n      }\n    },\n    loadElements: function (index) {\n      var limit = Math.min(this.num, this.options.preloadRange * 2 + 1);\n      var j = index;\n      var i;\n\n      for (i = 0; i < limit; i += 1) {\n        // First load the current slide element (0),\n        // then the next one (+1),\n        // then the previous one (-2),\n        // then the next after next (+2), etc.:\n        j += i * (i % 2 === 0 ? -1 : 1); // Connect the ends of the list to load slide elements for\n        // continuous navigation:\n\n        j = this.circle(j);\n        this.loadElement(j);\n      }\n    },\n    unloadElements: function (index) {\n      var i, diff;\n\n      for (i in this.elements) {\n        if (Object.prototype.hasOwnProperty.call(this.elements, i)) {\n          diff = Math.abs(index - i);\n\n          if (diff > this.options.preloadRange && diff + this.options.preloadRange < this.num) {\n            this.unloadSlide(i);\n            delete this.elements[i];\n          }\n        }\n      }\n    },\n    addSlide: function (index) {\n      var slide = this.slidePrototype.cloneNode(false);\n      slide.setAttribute('data-index', index);\n      this.slidesContainer[0].appendChild(slide);\n      this.slides.push(slide);\n    },\n    positionSlide: function (index) {\n      var slide = this.slides[index];\n      slide.style.width = this.slideWidth + 'px';\n\n      if (this.support.transform) {\n        slide.style.left = index * -this.slideWidth + 'px';\n        this.move(index, this.index > index ? -this.slideWidth : this.index < index ? this.slideWidth : 0, 0);\n      }\n    },\n    initSlides: function (reload) {\n      var clearSlides, i;\n\n      if (!reload) {\n        this.positions = [];\n        this.positions.length = this.num;\n        this.elements = {};\n        this.imagePrototype = document.createElement('img');\n        this.elementPrototype = document.createElement('div');\n        this.slidePrototype = document.createElement('div');\n        $(this.slidePrototype).addClass(this.options.slideClass);\n        this.slides = this.slidesContainer[0].children;\n        clearSlides = this.options.clearSlides || this.slides.length !== this.num;\n      }\n\n      this.slideWidth = this.container[0].clientWidth;\n      this.slideHeight = this.container[0].clientHeight;\n      this.slidesContainer[0].style.width = this.num * this.slideWidth + 'px';\n\n      if (clearSlides) {\n        this.resetSlides();\n      }\n\n      for (i = 0; i < this.num; i += 1) {\n        if (clearSlides) {\n          this.addSlide(i);\n        }\n\n        this.positionSlide(i);\n      } // Reposition the slides before and after the given index:\n\n\n      if (this.options.continuous && this.support.transform) {\n        this.move(this.circle(this.index - 1), -this.slideWidth, 0);\n        this.move(this.circle(this.index + 1), this.slideWidth, 0);\n      }\n\n      if (!this.support.transform) {\n        this.slidesContainer[0].style.left = this.index * -this.slideWidth + 'px';\n      }\n    },\n    unloadSlide: function (index) {\n      var slide, firstChild;\n      slide = this.slides[index];\n      firstChild = slide.firstChild;\n\n      if (firstChild !== null) {\n        slide.removeChild(firstChild);\n      }\n    },\n    unloadAllSlides: function () {\n      var i, len;\n\n      for (i = 0, len = this.slides.length; i < len; i++) {\n        this.unloadSlide(i);\n      }\n    },\n    toggleControls: function () {\n      var controlsClass = this.options.controlsClass;\n\n      if (this.container.hasClass(controlsClass)) {\n        this.container.removeClass(controlsClass);\n      } else {\n        this.container.addClass(controlsClass);\n      }\n    },\n    toggleSlideshow: function () {\n      if (!this.interval) {\n        this.play();\n      } else {\n        this.pause();\n      }\n    },\n    getNodeIndex: function (element) {\n      return parseInt(element.getAttribute('data-index'), 10);\n    },\n    getNestedProperty: function (obj, property) {\n      property.replace( // Matches native JavaScript notation in a String,\n      // e.g. '[\"doubleQuoteProp\"].dotProp[2]'\n      // eslint-disable-next-line no-useless-escape\n      /\\[(?:'([^']+)'|\"([^\"]+)\"|(\\d+))\\]|(?:(?:^|\\.)([^\\.\\[]+))/g, function (str, singleQuoteProp, doubleQuoteProp, arrayIndex, dotProp) {\n        var prop = dotProp || singleQuoteProp || doubleQuoteProp || arrayIndex && parseInt(arrayIndex, 10);\n\n        if (str && obj) {\n          obj = obj[prop];\n        }\n      });\n      return obj;\n    },\n    getDataProperty: function (obj, property) {\n      var key;\n      var prop;\n\n      if (obj.dataset) {\n        key = property.replace(/-([a-z])/g, function (_, b) {\n          return b.toUpperCase();\n        });\n        prop = obj.dataset[key];\n      } else if (obj.getAttribute) {\n        prop = obj.getAttribute('data-' + property.replace(/([A-Z])/g, '-$1').toLowerCase());\n      }\n\n      if (typeof prop === 'string') {\n        // eslint-disable-next-line no-useless-escape\n        if (/^(true|false|null|-?\\d+(\\.\\d+)?|\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/.test(prop)) {\n          try {\n            return $.parseJSON(prop);\n          } catch (ignore) {// ignore JSON parsing errors\n          }\n        }\n\n        return prop;\n      }\n    },\n    getItemProperty: function (obj, property) {\n      var prop = this.getDataProperty(obj, property);\n\n      if (prop === undefined) {\n        prop = obj[property];\n      }\n\n      if (prop === undefined) {\n        prop = this.getNestedProperty(obj, property);\n      }\n\n      return prop;\n    },\n    initStartIndex: function () {\n      var index = this.options.index;\n      var urlProperty = this.options.urlProperty;\n      var i; // Check if the index is given as a list object:\n\n      if (index && typeof index !== 'number') {\n        for (i = 0; i < this.num; i += 1) {\n          if (this.list[i] === index || this.getItemProperty(this.list[i], urlProperty) === this.getItemProperty(index, urlProperty)) {\n            index = i;\n            break;\n          }\n        }\n      } // Make sure the index is in the list range:\n\n\n      this.index = this.circle(parseInt(index, 10) || 0);\n    },\n    initEventListeners: function () {\n      var that = this;\n      var slidesContainer = this.slidesContainer;\n      /**\n       * Proxy listener\n       *\n       * @param {event} event original event\n       */\n\n      function proxyListener(event) {\n        var type = that.support.transition && that.support.transition.end === event.type ? 'transitionend' : event.type;\n        that['on' + type](event);\n      }\n\n      $(window).on('resize', proxyListener);\n      $(window).on('hashchange', proxyListener);\n      $(document.body).on('keydown', proxyListener);\n      this.container.on('click', proxyListener);\n\n      if (this.support.touch) {\n        slidesContainer.on('touchstart touchmove touchend touchcancel', proxyListener);\n      } else if (this.options.emulateTouchEvents && this.support.transition) {\n        slidesContainer.on('mousedown mousemove mouseup mouseout', proxyListener);\n      }\n\n      if (this.support.transition) {\n        slidesContainer.on(this.support.transition.end, proxyListener);\n      }\n\n      this.proxyListener = proxyListener;\n    },\n    destroyEventListeners: function () {\n      var slidesContainer = this.slidesContainer;\n      var proxyListener = this.proxyListener;\n      $(window).off('resize', proxyListener);\n      $(document.body).off('keydown', proxyListener);\n      this.container.off('click', proxyListener);\n\n      if (this.support.touch) {\n        slidesContainer.off('touchstart touchmove touchend touchcancel', proxyListener);\n      } else if (this.options.emulateTouchEvents && this.support.transition) {\n        slidesContainer.off('mousedown mousemove mouseup mouseout', proxyListener);\n      }\n\n      if (this.support.transition) {\n        slidesContainer.off(this.support.transition.end, proxyListener);\n      }\n    },\n    handleOpen: function () {\n      if (this.options.onopened) {\n        this.options.onopened.call(this);\n      }\n    },\n    initWidget: function () {\n      var that = this;\n      /**\n       * Open handler\n       *\n       * @param {event} event Gallery open event\n       */\n\n      function openHandler(event) {\n        if (event.target === that.container[0]) {\n          that.container.off(that.support.transition.end, openHandler);\n          that.handleOpen();\n        }\n      }\n\n      this.container = $(this.options.container);\n\n      if (!this.container.length) {\n        this.console.log('blueimp Gallery: Widget container not found.', this.options.container);\n        return false;\n      }\n\n      this.slidesContainer = this.container.find(this.options.slidesContainer).first();\n\n      if (!this.slidesContainer.length) {\n        this.console.log('blueimp Gallery: Slides container not found.', this.options.slidesContainer);\n        return false;\n      }\n\n      this.titleElement = this.container.find(this.options.titleElement).first();\n\n      if (this.num === 1) {\n        this.container.addClass(this.options.singleClass);\n      }\n\n      if (this.options.onopen) {\n        this.options.onopen.call(this);\n      }\n\n      if (this.support.transition && this.options.displayTransition) {\n        this.container.on(this.support.transition.end, openHandler);\n      } else {\n        this.handleOpen();\n      }\n\n      if (this.options.hidePageScrollbars) {\n        // Hide the page scrollbars:\n        this.bodyOverflowStyle = document.body.style.overflow;\n        document.body.style.overflow = 'hidden';\n      }\n\n      this.container[0].style.display = 'block';\n      this.initSlides();\n      this.container.addClass(this.options.displayClass);\n    },\n    initOptions: function (options) {\n      // Create a copy of the prototype options:\n      this.options = $.extend({}, this.options); // Check if carousel mode is enabled:\n\n      if (options && options.carousel || this.options.carousel && (!options || options.carousel !== false)) {\n        $.extend(this.options, this.carouselOptions);\n      } // Override any given options:\n\n\n      $.extend(this.options, options);\n\n      if (this.num < 3) {\n        // 1 or 2 slides cannot be displayed continuous,\n        // remember the original option by setting to null instead of false:\n        this.options.continuous = this.options.continuous ? null : false;\n      }\n\n      if (!this.support.transition) {\n        this.options.emulateTouchEvents = false;\n      }\n\n      if (this.options.event) {\n        this.preventDefault(this.options.event);\n      }\n    }\n  });\n  return Gallery;\n});\n\n//# sourceURL=webpack://kloster/./node_modules/blueimp-gallery/js/blueimp-gallery.js?")},"./node_modules/blueimp-gallery/js/blueimp-helper.js":(module,exports,__webpack_require__)=>{eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*\n * blueimp helper JS\n * https://github.com/blueimp/Gallery\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define */\n\n/* eslint-disable no-param-reassign */\n;\n\n(function () {\n  'use strict';\n  /**\n   * Object.assign polyfill\n   *\n   * @param {object} obj1 First object\n   * @param {object} obj2 Second object\n   * @returns {object} Merged object\n   */\n\n  function extend(obj1, obj2) {\n    var prop;\n\n    for (prop in obj2) {\n      if (Object.prototype.hasOwnProperty.call(obj2, prop)) {\n        obj1[prop] = obj2[prop];\n      }\n    }\n\n    return obj1;\n  }\n  /**\n   * Helper constructor\n   *\n   * @class\n   * @param {*} query jQuery type query argument\n   */\n\n\n  function Helper(query) {\n    if (!this || this.find !== Helper.prototype.find) {\n      // Called as function instead of as constructor,\n      // so we simply return a new instance:\n      return new Helper(query);\n    }\n\n    this.length = 0;\n\n    if (query) {\n      if (typeof query === 'string') {\n        query = this.find(query);\n      }\n\n      if (query.nodeType || query === query.window) {\n        // Single HTML element\n        this.length = 1;\n        this[0] = query;\n      } else {\n        // HTML element collection\n        var i = query.length;\n        this.length = i;\n\n        while (i) {\n          i -= 1;\n          this[i] = query[i];\n        }\n      }\n    }\n  }\n\n  Helper.extend = extend;\n\n  Helper.contains = function (container, element) {\n    do {\n      element = element.parentNode;\n\n      if (element === container) {\n        return true;\n      }\n    } while (element);\n\n    return false;\n  };\n\n  Helper.parseJSON = function (string) {\n    return window.JSON && JSON.parse(string);\n  };\n\n  extend(Helper.prototype, {\n    find: function (query) {\n      var container = this[0] || document;\n\n      if (typeof query === 'string') {\n        if (container.querySelectorAll) {\n          query = container.querySelectorAll(query);\n        } else if (query.charAt(0) === '#') {\n          query = container.getElementById(query.slice(1));\n        } else {\n          query = container.getElementsByTagName(query);\n        }\n      }\n\n      return new Helper(query);\n    },\n    hasClass: function (className) {\n      if (!this[0]) {\n        return false;\n      }\n\n      return new RegExp('(^|\\\\s+)' + className + '(\\\\s+|$)').test(this[0].className);\n    },\n    addClass: function (className) {\n      var i = this.length;\n      var element;\n\n      while (i) {\n        i -= 1;\n        element = this[i];\n\n        if (!element.className) {\n          element.className = className;\n          return this;\n        }\n\n        if (this.hasClass(className)) {\n          return this;\n        }\n\n        element.className += ' ' + className;\n      }\n\n      return this;\n    },\n    removeClass: function (className) {\n      var regexp = new RegExp('(^|\\\\s+)' + className + '(\\\\s+|$)');\n      var i = this.length;\n      var element;\n\n      while (i) {\n        i -= 1;\n        element = this[i];\n        element.className = element.className.replace(regexp, ' ');\n      }\n\n      return this;\n    },\n    on: function (eventName, handler) {\n      var eventNames = eventName.split(/\\s+/);\n      var i;\n      var element;\n\n      while (eventNames.length) {\n        eventName = eventNames.shift();\n        i = this.length;\n\n        while (i) {\n          i -= 1;\n          element = this[i];\n\n          if (element.addEventListener) {\n            element.addEventListener(eventName, handler, false);\n          } else if (element.attachEvent) {\n            element.attachEvent('on' + eventName, handler);\n          }\n        }\n      }\n\n      return this;\n    },\n    off: function (eventName, handler) {\n      var eventNames = eventName.split(/\\s+/);\n      var i;\n      var element;\n\n      while (eventNames.length) {\n        eventName = eventNames.shift();\n        i = this.length;\n\n        while (i) {\n          i -= 1;\n          element = this[i];\n\n          if (element.removeEventListener) {\n            element.removeEventListener(eventName, handler, false);\n          } else if (element.detachEvent) {\n            element.detachEvent('on' + eventName, handler);\n          }\n        }\n      }\n\n      return this;\n    },\n    empty: function () {\n      var i = this.length;\n      var element;\n\n      while (i) {\n        i -= 1;\n        element = this[i];\n\n        while (element.hasChildNodes()) {\n          element.removeChild(element.lastChild);\n        }\n      }\n\n      return this;\n    },\n    first: function () {\n      return new Helper(this[0]);\n    }\n  });\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return Helper;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})();\n\n//# sourceURL=webpack://kloster/./node_modules/blueimp-gallery/js/blueimp-helper.js?")},"./node_modules/bootstrap-vue/dist/bootstrap-vue.js":function(module,__unused_webpack_exports,__webpack_require__){eval("/*!\n * BootstrapVue 2.22.0\n *\n * @link https://bootstrap-vue.org\n * @source https://github.com/bootstrap-vue/bootstrap-vue\n * @copyright (c) 2016-2022 BootstrapVue\n * @license MIT\n * https://github.com/bootstrap-vue/bootstrap-vue/blob/master/LICENSE\n */(function(global,factory){ true?module.exports=factory(__webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm.js\")):0;})(this,function(Vue){'use strict';function _interopDefaultLegacy(e){return e&&typeof e==='object'&&'default'in e?e:{'default':e};}var Vue__default=/*#__PURE__*/_interopDefaultLegacy(Vue);function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread2$3(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}function _typeof$1(obj){\"@babel/helpers - typeof\";return _typeof$1=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(obj){return typeof obj;}:function(obj){return obj&&\"function\"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;},_typeof$1(obj);}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);Object.defineProperty(Constructor,\"prototype\",{writable:false});return Constructor;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function\");}Object.defineProperty(subClass,\"prototype\",{value:Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:true,configurable:true}}),writable:false});if(superClass)_setPrototypeOf(subClass,superClass);}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _setPrototypeOf(o,p){_setPrototypeOf=Object.setPrototypeOf||function _setPrototypeOf(o,p){o.__proto__=p;return o;};return _setPrototypeOf(o,p);}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}function _construct(Parent,args,Class){if(_isNativeReflectConstruct()){_construct=Reflect.construct;}else{_construct=function _construct(Parent,args,Class){var a=[null];a.push.apply(a,args);var Constructor=Function.bind.apply(Parent,a);var instance=new Constructor();if(Class)_setPrototypeOf(instance,Class.prototype);return instance;};}return _construct.apply(null,arguments);}function _isNativeFunction(fn){return Function.toString.call(fn).indexOf(\"[native code]\")!==-1;}function _wrapNativeSuper(Class){var _cache=typeof Map===\"function\"?new Map():undefined;_wrapNativeSuper=function _wrapNativeSuper(Class){if(Class===null||!_isNativeFunction(Class))return Class;if(typeof Class!==\"function\"){throw new TypeError(\"Super expression must either be null or a function\");}if(typeof _cache!==\"undefined\"){if(_cache.has(Class))return _cache.get(Class);_cache.set(Class,Wrapper);}function Wrapper(){return _construct(Class,arguments,_getPrototypeOf(this).constructor);}Wrapper.prototype=Object.create(Class.prototype,{constructor:{value:Wrapper,enumerable:false,writable:true,configurable:true}});return _setPrototypeOf(Wrapper,Class);};return _wrapNativeSuper(Class);}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return self;}function _possibleConstructorReturn(self,call){if(call&&(typeof call===\"object\"||typeof call===\"function\")){return call;}else if(call!==void 0){throw new TypeError(\"Derived constructors may only return object or undefined\");}return _assertThisInitialized(self);}function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _superPropBase(object,property){while(!Object.prototype.hasOwnProperty.call(object,property)){object=_getPrototypeOf(object);if(object===null)break;}return object;}function _get(){if(typeof Reflect!==\"undefined\"&&Reflect.get){_get=Reflect.get;}else{_get=function _get(target,property,receiver){var base=_superPropBase(target,property);if(!base)return;var desc=Object.getOwnPropertyDescriptor(base,property);if(desc.get){return desc.get.call(arguments.length<3?target:receiver);}return desc.value;};}return _get.apply(this,arguments);}function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_unsupportedIterableToArray(arr,i)||_nonIterableRest();}function _toConsumableArray$1(arr){return _arrayWithoutHoles$1(arr)||_iterableToArray$1(arr)||_unsupportedIterableToArray(arr)||_nonIterableSpread$1();}function _arrayWithoutHoles$1(arr){if(Array.isArray(arr))return _arrayLikeToArray(arr);}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr;}function _iterableToArray$1(iter){if(typeof Symbol!==\"undefined\"&&iter[Symbol.iterator]!=null||iter[\"@@iterator\"]!=null)return Array.from(iter);}function _iterableToArrayLimit(arr,i){var _i=arr==null?null:typeof Symbol!==\"undefined\"&&arr[Symbol.iterator]||arr[\"@@iterator\"];if(_i==null)return;var _arr=[];var _n=true;var _d=false;var _s,_e;try{for(_i=_i.call(arr);!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i[\"return\"]!=null)_i[\"return\"]();}finally{if(_d)throw _e;}}return _arr;}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2;}function _nonIterableSpread$1(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _nonIterableRest(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var e=function(){return(e=Object.assign||function(e){for(var t,r=1,s=arguments.length;r<s;r++)for(var a in t=arguments[r])Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]);return e;}).apply(this,arguments);},t={kebab:/-(\\w)/g,styleProp:/:(.*)/,styleList:/;(?![^(]*\\))/g};function r(e,t){return t?t.toUpperCase():\"\";}function s(e){for(var s,a={},c=0,o=e.split(t.styleList);c<o.length;c++){var n=o[c].split(t.styleProp),i=n[0],l=n[1];(i=i.trim())&&(\"string\"==typeof l&&(l=l.trim()),a[(s=i,s.replace(t.kebab,r))]=l);}return a;}function a(){for(var t,r,a={},c=arguments.length;c--;)for(var o=0,n=Object.keys(arguments[c]);o<n.length;o++)switch(t=n[o]){case\"class\":case\"style\":case\"directives\":if(Array.isArray(a[t])||(a[t]=[]),\"style\"===t){var i=void 0;i=Array.isArray(arguments[c].style)?arguments[c].style:[arguments[c].style];for(var l=0;l<i.length;l++){var y=i[l];\"string\"==typeof y&&(i[l]=s(y));}arguments[c].style=i;}a[t]=a[t].concat(arguments[c][t]);break;case\"staticClass\":if(!arguments[c][t])break;void 0===a[t]&&(a[t]=\"\"),a[t]&&(a[t]+=\" \"),a[t]+=arguments[c][t].trim();break;case\"on\":case\"nativeOn\":a[t]||(a[t]={});for(var p=0,f=Object.keys(arguments[c][t]||{});p<f.length;p++)r=f[p],a[t][r]?a[t][r]=[].concat(a[t][r],arguments[c][t][r]):a[t][r]=arguments[c][t][r];break;case\"attrs\":case\"props\":case\"domProps\":case\"scopedSlots\":case\"staticStyle\":case\"hook\":case\"transition\":a[t]||(a[t]={}),a[t]=e({},arguments[c][t],a[t]);break;case\"slot\":case\"key\":case\"ref\":case\"tag\":case\"show\":case\"keepAlive\":default:a[t]||(a[t]=arguments[c][t]);}return a;}var COMPONENT_UID_KEY='_uid';var HAS_WINDOW_SUPPORT=typeof window!=='undefined';var HAS_DOCUMENT_SUPPORT=typeof document!=='undefined';var HAS_NAVIGATOR_SUPPORT=typeof navigator!=='undefined';var HAS_PROMISE_SUPPORT=typeof Promise!=='undefined';/* istanbul ignore next: JSDOM always returns false */var HAS_MUTATION_OBSERVER_SUPPORT=typeof MutationObserver!=='undefined'||typeof WebKitMutationObserver!=='undefined'||typeof MozMutationObserver!=='undefined';var IS_BROWSER=HAS_WINDOW_SUPPORT&&HAS_DOCUMENT_SUPPORT&&HAS_NAVIGATOR_SUPPORT;var WINDOW=HAS_WINDOW_SUPPORT?window:{};var DOCUMENT=HAS_DOCUMENT_SUPPORT?document:{};var NAVIGATOR=HAS_NAVIGATOR_SUPPORT?navigator:{};var USER_AGENT=(NAVIGATOR.userAgent||'').toLowerCase();var IS_JSDOM=USER_AGENT.indexOf('jsdom')>0;/msie|trident/.test(USER_AGENT);// Determine if the browser supports the option passive for events\nvar HAS_PASSIVE_EVENT_SUPPORT=function(){var passiveEventSupported=false;if(IS_BROWSER){try{var options={// This function will be called when the browser\n// attempts to access the passive property\nget passive(){/* istanbul ignore next: will never be called in JSDOM */passiveEventSupported=true;}};WINDOW.addEventListener('test',options,options);WINDOW.removeEventListener('test',options,options);}catch(_unused){/* istanbul ignore next: will never be called in JSDOM */passiveEventSupported=false;}}return passiveEventSupported;}();var HAS_TOUCH_SUPPORT=IS_BROWSER&&('ontouchstart'in DOCUMENT.documentElement||NAVIGATOR.maxTouchPoints>0);var HAS_POINTER_EVENT_SUPPORT=IS_BROWSER&&Boolean(WINDOW.PointerEvent||WINDOW.MSPointerEvent);/* istanbul ignore next: JSDOM only checks for 'IntersectionObserver' */var HAS_INTERACTION_OBSERVER_SUPPORT=IS_BROWSER&&'IntersectionObserver'in WINDOW&&'IntersectionObserverEntry'in WINDOW&&// Edge 15 and UC Browser lack support for `isIntersecting`\n// but we an use `intersectionRatio > 0` instead\n// 'isIntersecting' in window.IntersectionObserverEntry.prototype &&\n'intersectionRatio'in WINDOW.IntersectionObserverEntry.prototype;var NAME$2='BvConfig';var PROP_NAME$2='$bvConfig';var DEFAULT_BREAKPOINT=['xs','sm','md','lg','xl'];// --- General ---\nvar RX_ARRAY_NOTATION=/\\[(\\d+)]/g;var RX_BV_PREFIX=/^(BV?)/;var RX_DIGITS=/^\\d+$/;var RX_EXTENSION=/^\\..+/;var RX_HASH=/^#/;var RX_HASH_ID=/^#[A-Za-z]+[\\w\\-:.]*$/;var RX_HTML_TAGS=/(<([^>]+)>)/gi;var RX_HYPHENATE=/\\B([A-Z])/g;var RX_LOWER_UPPER=/([a-z])([A-Z])/g;var RX_NUMBER=/^[0-9]*\\.?[0-9]+$/;var RX_PLUS=/\\+/g;var RX_REGEXP_REPLACE=/[-/\\\\^$*+?.()|[\\]{}]/g;var RX_SPACES=/[\\s\\uFEFF\\xA0]+/g;var RX_SPACE_SPLIT=/\\s+/;var RX_STAR=/\\/\\*$/;var RX_START_SPACE_WORD=/(\\s|^)(\\w)/g;var RX_TRIM_LEFT=/^\\s+/;var RX_UNDERSCORE=/_/g;var RX_UN_KEBAB=/-(\\w)/g;// --- Date ---\n// Loose YYYY-MM-DD matching, ignores any appended time inforation\n// Matches '1999-12-20', '1999-1-1', '1999-01-20T22:51:49.118Z', '1999-01-02 13:00:00'\nvar RX_DATE=/^\\d+-\\d\\d?-\\d\\d?(?:\\s|T|$)/;// Used to split off the date parts of the YYYY-MM-DD string\nvar RX_DATE_SPLIT=/-|\\s|T/;// Time string RegEx (optional seconds)\nvar RX_TIME=/^([0-1]?[0-9]|2[0-3]):[0-5]?[0-9](:[0-5]?[0-9])?$/;// --- URL ---\n// HREFs must end with a hash followed by at least one non-hash character\nvar RX_HREF=/^.*(#[^#]+)$/;var RX_ENCODED_COMMA=/%2C/g;var RX_ENCODE_REVERSE=/[!'()*]/g;var RX_QUERY_START=/^(\\?|#|&)/;// --- Aspect ---\nvar RX_ASPECT=/^\\d+(\\.\\d*)?[/:]\\d+(\\.\\d*)?$/;var RX_ASPECT_SEPARATOR=/[/:]/;// --- Grid ---\nvar RX_COL_CLASS=/^col-/;// --- Icon ---\nvar RX_ICON_PREFIX=/^BIcon/;// --- Locale ---\nvar RX_STRIP_LOCALE_MODS=/-u-.+/;/* istanbul ignore next */var Element=HAS_WINDOW_SUPPORT?WINDOW.Element:/*#__PURE__*/function(_Object){_inherits(Element,_Object);var _super=_createSuper(Element);function Element(){_classCallCheck(this,Element);return _super.apply(this,arguments);}return Element;}(/*#__PURE__*/_wrapNativeSuper(Object));/* istanbul ignore next */var HTMLElement=HAS_WINDOW_SUPPORT?WINDOW.HTMLElement:/*#__PURE__*/function(_Element){_inherits(HTMLElement,_Element);var _super2=_createSuper(HTMLElement);function HTMLElement(){_classCallCheck(this,HTMLElement);return _super2.apply(this,arguments);}return HTMLElement;}(Element);/* istanbul ignore next */var SVGElement=HAS_WINDOW_SUPPORT?WINDOW.SVGElement:/*#__PURE__*/function(_Element2){_inherits(SVGElement,_Element2);var _super3=_createSuper(SVGElement);function SVGElement(){_classCallCheck(this,SVGElement);return _super3.apply(this,arguments);}return SVGElement;}(Element);/* istanbul ignore next */var File=HAS_WINDOW_SUPPORT?WINDOW.File:/*#__PURE__*/function(_Object2){_inherits(File,_Object2);var _super4=_createSuper(File);function File(){_classCallCheck(this,File);return _super4.apply(this,arguments);}return File;}(/*#__PURE__*/_wrapNativeSuper(Object));var toType$1=function toType(value){return _typeof$1(value);};var toRawType=function toRawType(value){return Object.prototype.toString.call(value).slice(8,-1);};var isUndefined=function isUndefined(value){return value===undefined;};var isNull=function isNull(value){return value===null;};var isUndefinedOrNull=function isUndefinedOrNull(value){return isUndefined(value)||isNull(value);};var isFunction$1=function isFunction(value){return toType$1(value)==='function';};var isBoolean=function isBoolean(value){return toType$1(value)==='boolean';};var isString=function isString(value){return toType$1(value)==='string';};var isNumber=function isNumber(value){return toType$1(value)==='number';};var isNumeric$1=function isNumeric(value){return RX_NUMBER.test(String(value));};var isArray=function isArray(value){return Array.isArray(value);};// Quick object check\n// This is primarily used to tell Objects from primitive values\n// when we know the value is a JSON-compliant type\n// Note object could be a complex type like array, Date, etc.\nvar isObject=function isObject(obj){return obj!==null&&_typeof$1(obj)==='object';};// Strict object type check\n// Only returns true for plain JavaScript objects\nvar isPlainObject=function isPlainObject(obj){return Object.prototype.toString.call(obj)==='[object Object]';};var isDate=function isDate(value){return value instanceof Date;};var isEvent=function isEvent(value){return value instanceof Event;};var isFile=function isFile(value){return value instanceof File;};var isRegExp=function isRegExp(value){return toRawType(value)==='RegExp';};var isPromise=function isPromise(value){return!isUndefinedOrNull(value)&&isFunction$1(value.then)&&isFunction$1(value.catch);};var assign=function assign(){return Object.assign.apply(Object,arguments);};var create=function create(proto,optionalProps){return Object.create(proto,optionalProps);};var defineProperties=function defineProperties(obj,props){return Object.defineProperties(obj,props);};var defineProperty$1=function defineProperty(obj,prop,descriptor){return Object.defineProperty(obj,prop,descriptor);};var getOwnPropertyNames=function getOwnPropertyNames(obj){return Object.getOwnPropertyNames(obj);};var keys=function keys(obj){return Object.keys(obj);};// --- \"Instance\" ---\nvar hasOwnProperty=function hasOwnProperty(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop);};var toString$1=function toString(obj){return Object.prototype.toString.call(obj);};// --- Utilities ---\n// Shallow copy an object\nvar clone=function clone(obj){return _objectSpread2$3({},obj);};// Return a shallow copy of object with the specified properties only\n// See: https://gist.github.com/bisubus/2da8af7e801ffd813fab7ac221aa7afc\nvar pick$1=function pick(obj,props){return keys(obj).filter(function(key){return props.indexOf(key)!==-1;}).reduce(function(result,key){return _objectSpread2$3(_objectSpread2$3({},result),{},_defineProperty({},key,obj[key]));},{});};// Return a shallow copy of object with the specified properties omitted\n// See: https://gist.github.com/bisubus/2da8af7e801ffd813fab7ac221aa7afc\nvar omit=function omit(obj,props){return keys(obj).filter(function(key){return props.indexOf(key)===-1;}).reduce(function(result,key){return _objectSpread2$3(_objectSpread2$3({},result),{},_defineProperty({},key,obj[key]));},{});};// Merges two object deeply together\n// See: https://gist.github.com/Salakar/1d7137de9cb8b704e48a\nvar mergeDeep=function mergeDeep(target,source){if(isObject(target)&&isObject(source)){keys(source).forEach(function(key){if(isObject(source[key])){if(!target[key]||!isObject(target[key])){target[key]=source[key];}mergeDeep(target[key],source[key]);}else{assign(target,_defineProperty({},key,source[key]));}});}return target;};// Returns a shallow copy of the object with keys in sorted order\nvar sortKeys=function sortKeys(obj){return keys(obj).sort().reduce(function(result,key){return _objectSpread2$3(_objectSpread2$3({},result),{},_defineProperty({},key,obj[key]));},{});};// Convenience method to create a read-only descriptor\nvar readonlyDescriptor=function readonlyDescriptor(){return{enumerable:true,configurable:false,writable:false};};var cloneDeep=function cloneDeep(obj){var defaultValue=arguments.length>1&&arguments[1]!==undefined?arguments[1]:obj;if(isArray(obj)){return obj.reduce(function(result,val){return[].concat(_toConsumableArray$1(result),[cloneDeep(val,val)]);},[]);}if(isPlainObject(obj)){return keys(obj).reduce(function(result,key){return _objectSpread2$3(_objectSpread2$3({},result),{},_defineProperty({},key,cloneDeep(obj[key],obj[key])));},{});}return defaultValue;};var identity=function identity(x){return x;};/**\n   * Get property defined by dot/array notation in string, returns undefined if not found\n   *\n   * @link https://gist.github.com/jeneg/9767afdcca45601ea44930ea03e0febf#gistcomment-1935901\n   *\n   * @param {Object} obj\n   * @param {string|Array} path\n   * @return {*}\n   */var getRaw=function getRaw(obj,path){var defaultValue=arguments.length>2&&arguments[2]!==undefined?arguments[2]:undefined;// Handle array of path values\npath=isArray(path)?path.join('.'):path;// If no path or no object passed\nif(!path||!isObject(obj)){return defaultValue;}// Handle edge case where user has dot(s) in top-level item field key\n// See https://github.com/bootstrap-vue/bootstrap-vue/issues/2762\n// Switched to `in` operator vs `hasOwnProperty` to handle obj.prototype getters\n// https://github.com/bootstrap-vue/bootstrap-vue/issues/3463\nif(path in obj){return obj[path];}// Handle string array notation (numeric indices only)\npath=String(path).replace(RX_ARRAY_NOTATION,'.$1');var steps=path.split('.').filter(identity);// Handle case where someone passes a string of only dots\nif(steps.length===0){return defaultValue;}// Traverse path in object to find result\n// Switched to `in` operator vs `hasOwnProperty` to handle obj.prototype getters\n// https://github.com/bootstrap-vue/bootstrap-vue/issues/3463\nreturn steps.every(function(step){return isObject(obj)&&step in obj&&!isUndefinedOrNull(obj=obj[step]);})?obj:isNull(obj)?null:defaultValue;};/**\n   * Get property defined by dot/array notation in string.\n   *\n   * @link https://gist.github.com/jeneg/9767afdcca45601ea44930ea03e0febf#gistcomment-1935901\n   *\n   * @param {Object} obj\n   * @param {string|Array} path\n   * @param {*} defaultValue (optional)\n   * @return {*}\n   */var get=function get(obj,path){var defaultValue=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;var value=getRaw(obj,path);return isUndefinedOrNull(value)?defaultValue:value;};/**\n   * Utilities to get information about the current environment\n   */var getEnv=function getEnv(key){var fallback=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;var env=typeof process!=='undefined'&&process?process.env||{}:{};if(!key){/* istanbul ignore next */return env;}return env[key]||fallback;};var getNoWarn=function getNoWarn(){return getEnv('BOOTSTRAP_VUE_NO_WARN')||getEnv('NODE_ENV')==='production';};/**\n   * Log a warning message to the console with BootstrapVue formatting\n   * @param {string} message\n   */var warn=function warn(message)/* istanbul ignore next */{var source=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;if(!getNoWarn()){console.warn(\"[BootstrapVue warn]: \".concat(source?\"\".concat(source,\" - \"):'').concat(message));}};/**\n   * Warn when no Promise support is given\n   * @param {string} source\n   * @returns {boolean} warned\n   */var warnNotClient=function warnNotClient(source){/* istanbul ignore else */if(IS_BROWSER){return false;}else{warn(\"\".concat(source,\": Can not be called during SSR.\"));return true;}};/**\n   * Warn when no Promise support is given\n   * @param {string} source\n   * @returns {boolean} warned\n   */var warnNoPromiseSupport=function warnNoPromiseSupport(source){/* istanbul ignore else */if(HAS_PROMISE_SUPPORT){return false;}else{warn(\"\".concat(source,\": Requires Promise support.\"));return true;}};/**\n   * Warn when no MutationObserver support is given\n   * @param {string} source\n   * @returns {boolean} warned\n   */var warnNoMutationObserverSupport=function warnNoMutationObserverSupport(source){/* istanbul ignore else */if(HAS_MUTATION_OBSERVER_SUPPORT){return false;}else{warn(\"\".concat(source,\": Requires MutationObserver support.\"));return true;}};var BvConfig=/*#__PURE__*/function(){function BvConfig(){_classCallCheck(this,BvConfig);this.$_config={};}// Method to merge in user config parameters\n_createClass(BvConfig,[{key:\"setConfig\",value:function setConfig(){var _this=this;var config=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};/* istanbul ignore next */if(!isPlainObject(config)){return;}var configKeys=getOwnPropertyNames(config);configKeys.forEach(function(key){/* istanbul ignore next */var subConfig=config[key];if(key==='breakpoints'){/* istanbul ignore if */if(!isArray(subConfig)||subConfig.length<2||subConfig.some(function(b){return!isString(b)||b.length===0;})){warn('\"breakpoints\" must be an array of at least 2 breakpoint names',NAME$2);}else{_this.$_config[key]=cloneDeep(subConfig);}}else if(isPlainObject(subConfig)){// Component prop defaults\n_this.$_config[key]=getOwnPropertyNames(subConfig).reduce(function(config,prop){if(!isUndefined(subConfig[prop])){config[prop]=cloneDeep(subConfig[prop]);}return config;},_this.$_config[key]||{});}});}// Clear the config\n},{key:\"resetConfig\",value:function resetConfig(){this.$_config={};}// Returns a deep copy of the user config\n},{key:\"getConfig\",value:function getConfig(){return cloneDeep(this.$_config);}// Returns a deep copy of the config value\n},{key:\"getConfigValue\",value:function getConfigValue(key){var defaultValue=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined;return cloneDeep(getRaw(this.$_config,key,defaultValue));}}]);return BvConfig;}();// Method for applying a global config\nvar setConfig=function setConfig(){var config=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var Vue=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Vue__default['default'];// Ensure we have a `$bvConfig` Object on the Vue prototype\n// We set on Vue and OurVue just in case consumer has not set an alias of `vue`\nVue.prototype[PROP_NAME$2]=Vue__default['default'].prototype[PROP_NAME$2]=Vue.prototype[PROP_NAME$2]||Vue__default['default'].prototype[PROP_NAME$2]||new BvConfig();// Apply the config values\nVue.prototype[PROP_NAME$2].setConfig(config);};// Method for resetting the user config\n/**\n   * Checks if there are multiple instances of Vue, and warns (once) about possible issues.\n   * @param {object} Vue\n   */var checkMultipleVue=function(){var checkMultipleVueWarned=false;var MULTIPLE_VUE_WARNING=['Multiple instances of Vue detected!','You may need to set up an alias for Vue in your bundler config.','See: https://bootstrap-vue.org/docs#using-module-bundlers'].join('\\n');return function(Vue){/* istanbul ignore next */if(!checkMultipleVueWarned&&Vue__default['default']!==Vue&&!IS_JSDOM){warn(MULTIPLE_VUE_WARNING);}checkMultipleVueWarned=true;};}();/**\n   * Plugin install factory function.\n   * @param {object} { components, directives }\n   * @returns {function} plugin install function\n   */var installFactory=function installFactory(){var _ref=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},components=_ref.components,directives=_ref.directives,plugins=_ref.plugins;var install=function install(Vue){var config=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(install.installed){/* istanbul ignore next */return;}install.installed=true;checkMultipleVue(Vue);setConfig(config,Vue);registerComponents(Vue,components);registerDirectives(Vue,directives);registerPlugins(Vue,plugins);};install.installed=false;return install;};/**\n   * Plugin object factory function.\n   * @param {object} { components, directives, plugins }\n   * @returns {object} plugin install object\n   */var pluginFactory=function pluginFactory(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var extend=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return _objectSpread2$3(_objectSpread2$3({},extend),{},{install:installFactory(options)});};/**\n   * Load a group of plugins.\n   * @param {object} Vue\n   * @param {object} Plugin definitions\n   */var registerPlugins=function registerPlugins(Vue){var plugins=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};for(var plugin in plugins){if(plugin&&plugins[plugin]){Vue.use(plugins[plugin]);}}};/**\n   * Load a component.\n   * @param {object} Vue\n   * @param {string} Component name\n   * @param {object} Component definition\n   */var registerComponent=function registerComponent(Vue,name,def){if(Vue&&name&&def){Vue.component(name,def);}};/**\n   * Load a group of components.\n   * @param {object} Vue\n   * @param {object} Object of component definitions\n   */var registerComponents=function registerComponents(Vue){var components=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};for(var component in components){registerComponent(Vue,component,components[component]);}};/**\n   * Load a directive.\n   * @param {object} Vue\n   * @param {string} Directive name\n   * @param {object} Directive definition\n   */var registerDirective=function registerDirective(Vue,name,def){if(Vue&&name&&def){// Ensure that any leading V is removed from the\n// name, as Vue adds it automatically\nVue.directive(name.replace(/^VB/,'B'),def);}};/**\n   * Load a group of directives.\n   * @param {object} Vue\n   * @param {object} Object of directive definitions\n   */var registerDirectives=function registerDirectives(Vue){var directives=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};for(var directive in directives){registerDirective(Vue,directive,directives[directive]);}};/**\n   * Install plugin if window.Vue available\n   * @param {object} Plugin definition\n   */var vueUse=function vueUse(VuePlugin){/* istanbul ignore next */if(HAS_WINDOW_SUPPORT&&window.Vue){window.Vue.use(VuePlugin);}/* istanbul ignore next */if(HAS_WINDOW_SUPPORT&&VuePlugin.NAME){window[VuePlugin.NAME]=VuePlugin;}};// Component names\nvar NAME_ALERT='BAlert';var NAME_ASPECT='BAspect';var NAME_AVATAR='BAvatar';var NAME_AVATAR_GROUP='BAvatarGroup';var NAME_BADGE='BBadge';var NAME_BREADCRUMB='BBreadcrumb';var NAME_BREADCRUMB_ITEM='BBreadcrumbItem';var NAME_BREADCRUMB_LINK='BBreadcrumbLink';var NAME_BUTTON='BButton';var NAME_BUTTON_CLOSE='BButtonClose';var NAME_BUTTON_GROUP='BButtonGroup';var NAME_BUTTON_TOOLBAR='BButtonToolbar';var NAME_CALENDAR='BCalendar';var NAME_CARD='BCard';var NAME_CARD_BODY='BCardBody';var NAME_CARD_FOOTER='BCardFooter';var NAME_CARD_GROUP='BCardGroup';var NAME_CARD_HEADER='BCardHeader';var NAME_CARD_IMG='BCardImg';var NAME_CARD_IMG_LAZY='BCardImgLazy';var NAME_CARD_SUB_TITLE='BCardSubTitle';var NAME_CARD_TEXT='BCardText';var NAME_CARD_TITLE='BCardTitle';var NAME_CAROUSEL='BCarousel';var NAME_CAROUSEL_SLIDE='BCarouselSlide';var NAME_COL='BCol';var NAME_COLLAPSE='BCollapse';var NAME_CONTAINER='BContainer';var NAME_DROPDOWN='BDropdown';var NAME_DROPDOWN_DIVIDER='BDropdownDivider';var NAME_DROPDOWN_FORM='BDropdownForm';var NAME_DROPDOWN_GROUP='BDropdownGroup';var NAME_DROPDOWN_HEADER='BDropdownHeader';var NAME_DROPDOWN_ITEM='BDropdownItem';var NAME_DROPDOWN_ITEM_BUTTON='BDropdownItemButton';var NAME_DROPDOWN_TEXT='BDropdownText';var NAME_EMBED='BEmbed';var NAME_FORM='BForm';var NAME_FORM_CHECKBOX='BFormCheckbox';var NAME_FORM_CHECKBOX_GROUP='BFormCheckboxGroup';var NAME_FORM_DATALIST='BFormDatalist';var NAME_FORM_DATEPICKER='BFormDatepicker';var NAME_FORM_FILE='BFormFile';var NAME_FORM_GROUP='BFormGroup';var NAME_FORM_INPUT='BFormInput';var NAME_FORM_INVALID_FEEDBACK='BFormInvalidFeedback';var NAME_FORM_RADIO='BFormRadio';var NAME_FORM_RADIO_GROUP='BFormRadioGroup';var NAME_FORM_RATING='BFormRating';var NAME_FORM_ROW='BFormRow';var NAME_FORM_SELECT='BFormSelect';var NAME_FORM_SELECT_OPTION='BFormSelectOption';var NAME_FORM_SELECT_OPTION_GROUP='BFormSelectOptionGroup';var NAME_FORM_SPINBUTTON='BFormSpinbutton';var NAME_FORM_TAG='BFormTag';var NAME_FORM_TAGS='BFormTags';var NAME_FORM_TEXT='BFormText';var NAME_FORM_TEXTAREA='BFormTextarea';var NAME_FORM_TIMEPICKER='BFormTimepicker';var NAME_FORM_VALID_FEEDBACK='BFormValidFeedback';var NAME_ICON='BIcon';var NAME_ICONSTACK='BIconstack';var NAME_ICON_BASE='BIconBase';var NAME_IMG='BImg';var NAME_IMG_LAZY='BImgLazy';var NAME_INPUT_GROUP='BInputGroup';var NAME_INPUT_GROUP_ADDON='BInputGroupAddon';var NAME_INPUT_GROUP_APPEND='BInputGroupAppend';var NAME_INPUT_GROUP_PREPEND='BInputGroupPrepend';var NAME_INPUT_GROUP_TEXT='BInputGroupText';var NAME_JUMBOTRON='BJumbotron';var NAME_LINK='BLink';var NAME_LIST_GROUP='BListGroup';var NAME_LIST_GROUP_ITEM='BListGroupItem';var NAME_MEDIA='BMedia';var NAME_MEDIA_ASIDE='BMediaAside';var NAME_MEDIA_BODY='BMediaBody';var NAME_MODAL='BModal';var NAME_MSG_BOX='BMsgBox';var NAME_NAV='BNav';var NAME_NAVBAR='BNavbar';var NAME_NAVBAR_BRAND='BNavbarBrand';var NAME_NAVBAR_NAV='BNavbarNav';var NAME_NAVBAR_TOGGLE='BNavbarToggle';var NAME_NAV_FORM='BNavForm';var NAME_NAV_ITEM='BNavItem';var NAME_NAV_ITEM_DROPDOWN='BNavItemDropdown';var NAME_NAV_TEXT='BNavText';var NAME_OVERLAY='BOverlay';var NAME_PAGINATION='BPagination';var NAME_PAGINATION_NAV='BPaginationNav';var NAME_POPOVER='BPopover';var NAME_PROGRESS='BProgress';var NAME_PROGRESS_BAR='BProgressBar';var NAME_ROW='BRow';var NAME_SIDEBAR='BSidebar';var NAME_SKELETON='BSkeleton';var NAME_SKELETON_ICON='BSkeletonIcon';var NAME_SKELETON_IMG='BSkeletonImg';var NAME_SKELETON_TABLE='BSkeletonTable';var NAME_SKELETON_WRAPPER='BSkeletonWrapper';var NAME_SPINNER='BSpinner';var NAME_TAB='BTab';var NAME_TABLE='BTable';var NAME_TABLE_CELL='BTableCell';var NAME_TABLE_LITE='BTableLite';var NAME_TABLE_SIMPLE='BTableSimple';var NAME_TABS='BTabs';var NAME_TBODY='BTbody';var NAME_TFOOT='BTfoot';var NAME_TH='BTh';var NAME_THEAD='BThead';var NAME_TIME='BTime';var NAME_TOAST='BToast';var NAME_TOASTER='BToaster';var NAME_TOOLTIP='BTooltip';var NAME_TR='BTr';// Helper component names\nvar NAME_COLLAPSE_HELPER='BVCollapse';var NAME_FORM_BUTTON_LABEL_CONTROL='BVFormBtnLabelControl';var NAME_FORM_RATING_STAR='BVFormRatingStar';var NAME_POPOVER_HELPER='BVPopover';var NAME_POPOVER_TEMPLATE='BVPopoverTemplate';var NAME_POPPER='BVPopper';var NAME_TAB_BUTTON_HELPER='BVTabButton';var NAME_TOAST_POP='BVToastPop';var NAME_TOOLTIP_HELPER='BVTooltip';var NAME_TOOLTIP_TEMPLATE='BVTooltipTemplate';var NAME_TRANSITION='BVTransition';var NAME_TRANSPORTER='BVTransporter';var NAME_TRANSPORTER_TARGET='BVTransporterTarget';var EVENT_NAME_ACTIVATE_TAB='activate-tab';var EVENT_NAME_BLUR='blur';var EVENT_NAME_CANCEL='cancel';var EVENT_NAME_CHANGE='change';var EVENT_NAME_CHANGED='changed';var EVENT_NAME_CLICK='click';var EVENT_NAME_CLOSE='close';var EVENT_NAME_CONTEXT='context';var EVENT_NAME_CONTEXT_CHANGED='context-changed';var EVENT_NAME_DESTROYED='destroyed';var EVENT_NAME_DISABLE='disable';var EVENT_NAME_DISABLED='disabled';var EVENT_NAME_DISMISSED='dismissed';var EVENT_NAME_DISMISS_COUNT_DOWN='dismiss-count-down';var EVENT_NAME_ENABLE='enable';var EVENT_NAME_ENABLED='enabled';var EVENT_NAME_FILTERED='filtered';var EVENT_NAME_FIRST='first';var EVENT_NAME_FOCUS='focus';var EVENT_NAME_FOCUSIN='focusin';var EVENT_NAME_FOCUSOUT='focusout';var EVENT_NAME_HEAD_CLICKED='head-clicked';var EVENT_NAME_HIDDEN='hidden';var EVENT_NAME_HIDE='hide';var EVENT_NAME_IMG_ERROR='img-error';var EVENT_NAME_INPUT='input';var EVENT_NAME_LAST='last';var EVENT_NAME_MOUSEENTER='mouseenter';var EVENT_NAME_MOUSELEAVE='mouseleave';var EVENT_NAME_NEXT='next';var EVENT_NAME_OK='ok';var EVENT_NAME_OPEN='open';var EVENT_NAME_PAGE_CLICK='page-click';var EVENT_NAME_PAUSED='paused';var EVENT_NAME_PREV='prev';var EVENT_NAME_REFRESH='refresh';var EVENT_NAME_REFRESHED='refreshed';var EVENT_NAME_REMOVE='remove';var EVENT_NAME_ROW_CLICKED='row-clicked';var EVENT_NAME_ROW_CONTEXTMENU='row-contextmenu';var EVENT_NAME_ROW_DBLCLICKED='row-dblclicked';var EVENT_NAME_ROW_HOVERED='row-hovered';var EVENT_NAME_ROW_MIDDLE_CLICKED='row-middle-clicked';var EVENT_NAME_ROW_SELECTED='row-selected';var EVENT_NAME_ROW_UNHOVERED='row-unhovered';var EVENT_NAME_SELECTED='selected';var EVENT_NAME_SHOW='show';var EVENT_NAME_SHOWN='shown';var EVENT_NAME_SLIDING_END='sliding-end';var EVENT_NAME_SLIDING_START='sliding-start';var EVENT_NAME_SORT_CHANGED='sort-changed';var EVENT_NAME_TAG_STATE='tag-state';var EVENT_NAME_TOGGLE='toggle';var EVENT_NAME_UNPAUSED='unpaused';var EVENT_NAME_UPDATE='update';var HOOK_EVENT_NAME_BEFORE_DESTROY='hook:beforeDestroy';var HOOK_EVENT_NAME_DESTROYED='hook:destroyed';var MODEL_EVENT_NAME_PREFIX='update:';var ROOT_EVENT_NAME_PREFIX='bv';var ROOT_EVENT_NAME_SEPARATOR='::';var EVENT_OPTIONS_PASSIVE={passive:true};var EVENT_OPTIONS_NO_CAPTURE={passive:true,capture:false};// General types\nvar PROP_TYPE_ANY=undefined;var PROP_TYPE_ARRAY=Array;var PROP_TYPE_BOOLEAN=Boolean;var PROP_TYPE_DATE=Date;var PROP_TYPE_FUNCTION=Function;var PROP_TYPE_NUMBER=Number;var PROP_TYPE_OBJECT=Object;var PROP_TYPE_REG_EXP=RegExp;var PROP_TYPE_STRING=String;// Multiple types\nvar PROP_TYPE_ARRAY_FUNCTION=[PROP_TYPE_ARRAY,PROP_TYPE_FUNCTION];var PROP_TYPE_ARRAY_OBJECT=[PROP_TYPE_ARRAY,PROP_TYPE_OBJECT];var PROP_TYPE_ARRAY_OBJECT_STRING=[PROP_TYPE_ARRAY,PROP_TYPE_OBJECT,PROP_TYPE_STRING];var PROP_TYPE_ARRAY_STRING=[PROP_TYPE_ARRAY,PROP_TYPE_STRING];var PROP_TYPE_BOOLEAN_NUMBER=[PROP_TYPE_BOOLEAN,PROP_TYPE_NUMBER];var PROP_TYPE_BOOLEAN_NUMBER_STRING=[PROP_TYPE_BOOLEAN,PROP_TYPE_NUMBER,PROP_TYPE_STRING];var PROP_TYPE_BOOLEAN_STRING=[PROP_TYPE_BOOLEAN,PROP_TYPE_STRING];var PROP_TYPE_DATE_STRING=[PROP_TYPE_DATE,PROP_TYPE_STRING];var PROP_TYPE_FUNCTION_STRING=[PROP_TYPE_FUNCTION,PROP_TYPE_STRING];var PROP_TYPE_NUMBER_STRING=[PROP_TYPE_NUMBER,PROP_TYPE_STRING];var PROP_TYPE_NUMBER_OBJECT_STRING=[PROP_TYPE_NUMBER,PROP_TYPE_OBJECT,PROP_TYPE_STRING];var PROP_TYPE_OBJECT_FUNCTION=[PROP_TYPE_OBJECT,PROP_TYPE_FUNCTION];var PROP_TYPE_OBJECT_STRING=[PROP_TYPE_OBJECT,PROP_TYPE_STRING];var SLOT_NAME_ADD_BUTTON_TEXT='add-button-text';var SLOT_NAME_APPEND='append';var SLOT_NAME_ASIDE='aside';var SLOT_NAME_BADGE='badge';var SLOT_NAME_BOTTOM_ROW='bottom-row';var SLOT_NAME_BUTTON_CONTENT='button-content';var SLOT_NAME_CUSTOM_FOOT='custom-foot';var SLOT_NAME_DECREMENT='decrement';var SLOT_NAME_DEFAULT='default';var SLOT_NAME_DESCRIPTION='description';var SLOT_NAME_DISMISS='dismiss';var SLOT_NAME_DROP_PLACEHOLDER='drop-placeholder';var SLOT_NAME_ELLIPSIS_TEXT='ellipsis-text';var SLOT_NAME_EMPTY='empty';var SLOT_NAME_EMPTYFILTERED='emptyfiltered';var SLOT_NAME_FILE_NAME='file-name';var SLOT_NAME_FIRST='first';var SLOT_NAME_FIRST_TEXT='first-text';var SLOT_NAME_FOOTER='footer';var SLOT_NAME_HEADER='header';var SLOT_NAME_HEADER_CLOSE='header-close';var SLOT_NAME_ICON_CLEAR='icon-clear';var SLOT_NAME_ICON_EMPTY='icon-empty';var SLOT_NAME_ICON_FULL='icon-full';var SLOT_NAME_ICON_HALF='icon-half';var SLOT_NAME_IMG='img';var SLOT_NAME_INCREMENT='increment';var SLOT_NAME_INVALID_FEEDBACK='invalid-feedback';var SLOT_NAME_LABEL='label';var SLOT_NAME_LAST_TEXT='last-text';var SLOT_NAME_LEAD='lead';var SLOT_NAME_LOADING='loading';var SLOT_NAME_MODAL_BACKDROP='modal-backdrop';var SLOT_NAME_MODAL_CANCEL='modal-cancel';var SLOT_NAME_MODAL_FOOTER='modal-footer';var SLOT_NAME_MODAL_HEADER='modal-header';var SLOT_NAME_MODAL_HEADER_CLOSE='modal-header-close';var SLOT_NAME_MODAL_OK='modal-ok';var SLOT_NAME_MODAL_TITLE='modal-title';var SLOT_NAME_NAV_NEXT_DECADE='nav-next-decade';var SLOT_NAME_NAV_NEXT_MONTH='nav-next-month';var SLOT_NAME_NAV_NEXT_YEAR='nav-next-year';var SLOT_NAME_NAV_PEV_DECADE='nav-prev-decade';var SLOT_NAME_NAV_PEV_MONTH='nav-prev-month';var SLOT_NAME_NAV_PEV_YEAR='nav-prev-year';var SLOT_NAME_NAV_THIS_MONTH='nav-this-month';var SLOT_NAME_NEXT_TEXT='next-text';var SLOT_NAME_OVERLAY='overlay';var SLOT_NAME_PAGE='page';var SLOT_NAME_PLACEHOLDER='placeholder';var SLOT_NAME_PREPEND='prepend';var SLOT_NAME_PREV_TEXT='prev-text';var SLOT_NAME_ROW_DETAILS='row-details';var SLOT_NAME_TABLE_BUSY='table-busy';var SLOT_NAME_TABLE_CAPTION='table-caption';var SLOT_NAME_TABLE_COLGROUP='table-colgroup';var SLOT_NAME_TABS_END='tabs-end';var SLOT_NAME_TABS_START='tabs-start';var SLOT_NAME_TEXT='text';var SLOT_NAME_THEAD_TOP='thead-top';var SLOT_NAME_TITLE='title';var SLOT_NAME_TOAST_TITLE='toast-title';var SLOT_NAME_TOP_ROW='top-row';var SLOT_NAME_VALID_FEEDBACK='valid-feedback';var from=function from(){return Array.from.apply(Array,arguments);};// --- Instance ---\nvar arrayIncludes=function arrayIncludes(array,value){return array.indexOf(value)!==-1;};var concat=function concat(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return Array.prototype.concat.apply([],args);};// --- Utilities ---\nvar createArray=function createArray(length,fillFn){var mapFn=isFunction$1(fillFn)?fillFn:function(){return fillFn;};return Array.apply(null,{length:length}).map(mapFn);};var flatten=function flatten(array){return array.reduce(function(result,item){return concat(result,item);},[]);};var flattenDeep=function flattenDeep(array){return array.reduce(function(result,item){return concat(result,Array.isArray(item)?flattenDeep(item):item);},[]);};// Number utilities\n// Converts a value (string, number, etc.) to an integer number\n// Assumes radix base 10\nvar toInteger=function toInteger(value){var defaultValue=arguments.length>1&&arguments[1]!==undefined?arguments[1]:NaN;var integer=parseInt(value,10);return isNaN(integer)?defaultValue:integer;};// Converts a value (string, number, etc.) to a number\nvar toFloat=function toFloat(value){var defaultValue=arguments.length>1&&arguments[1]!==undefined?arguments[1]:NaN;var float=parseFloat(value);return isNaN(float)?defaultValue:float;};// Converts a value (string, number, etc.) to a string\n// representation with `precision` digits after the decimal\n// Returns the string 'NaN' if the value cannot be converted\nvar toFixed=function toFixed(val,precision){return toFloat(val).toFixed(toInteger(precision,0));};// String utilities\n// Converts PascalCase or camelCase to kebab-case\nvar kebabCase=function kebabCase(str){return str.replace(RX_HYPHENATE,'-$1').toLowerCase();};// Converts a kebab-case or camelCase string to PascalCase\nvar pascalCase=function pascalCase(str){str=kebabCase(str).replace(RX_UN_KEBAB,function(_,c){return c?c.toUpperCase():'';});return str.charAt(0).toUpperCase()+str.slice(1);};// Converts a string, including strings in camelCase or snake_case, into Start Case\n// It keeps original single quote and hyphen in the word\n// https://github.com/UrbanCompass/to-start-case\nvar startCase=function startCase(str){return str.replace(RX_UNDERSCORE,' ').replace(RX_LOWER_UPPER,function(str,$1,$2){return $1+' '+$2;}).replace(RX_START_SPACE_WORD,function(str,$1,$2){return $1+$2.toUpperCase();});};// Lowercases the first letter of a string and returns a new string\nvar lowerFirst=function lowerFirst(str){str=isString(str)?str.trim():String(str);return str.charAt(0).toLowerCase()+str.slice(1);};// Uppercases the first letter of a string and returns a new string\nvar upperFirst=function upperFirst(str){str=isString(str)?str.trim():String(str);return str.charAt(0).toUpperCase()+str.slice(1);};// Escape characters to be used in building a regular expression\nvar escapeRegExp=function escapeRegExp(str){return str.replace(RX_REGEXP_REPLACE,'\\\\$&');};// Convert a value to a string that can be rendered\n// `undefined`/`null` will be converted to `''`\n// Plain objects and arrays will be JSON stringified\nvar toString=function toString(val){var spaces=arguments.length>1&&arguments[1]!==undefined?arguments[1]:2;return isUndefinedOrNull(val)?'':isArray(val)||isPlainObject(val)&&val.toString===Object.prototype.toString?JSON.stringify(val,null,spaces):String(val);};// Remove leading white space from a string\nvar trimLeft=function trimLeft(str){return toString(str).replace(RX_TRIM_LEFT,'');};// Remove Trailing white space from a string\nvar trim=function trim(str){return toString(str).trim();};// Lower case a string\nvar lowerCase=function lowerCase(str){return toString(str).toLowerCase();};// Upper case a string\nvar ELEMENT_PROTO=Element.prototype;var TABABLE_SELECTOR=['button','[href]:not(.disabled)','input','select','textarea','[tabindex]','[contenteditable]'].map(function(s){return\"\".concat(s,\":not(:disabled):not([disabled])\");}).join(', ');// --- Normalization utils ---\n// See: https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\n/* istanbul ignore next */var matchesEl=ELEMENT_PROTO.matches||ELEMENT_PROTO.msMatchesSelector||ELEMENT_PROTO.webkitMatchesSelector;// See: https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n/* istanbul ignore next */var closestEl=ELEMENT_PROTO.closest||function(sel){var el=this;do{// Use our \"patched\" matches function\nif(matches(el,sel)){return el;}el=el.parentElement||el.parentNode;}while(!isNull(el)&&el.nodeType===Node.ELEMENT_NODE);return null;};// `requestAnimationFrame()` convenience method\n/* istanbul ignore next: JSDOM always returns the first option */var requestAF=(WINDOW.requestAnimationFrame||WINDOW.webkitRequestAnimationFrame||WINDOW.mozRequestAnimationFrame||WINDOW.msRequestAnimationFrame||WINDOW.oRequestAnimationFrame||// Fallback, but not a true polyfill\n// Only needed for Opera Mini\n/* istanbul ignore next */function(cb){return setTimeout(cb,16);}).bind(WINDOW);var MutationObs=WINDOW.MutationObserver||WINDOW.WebKitMutationObserver||WINDOW.MozMutationObserver||null;// --- Utils ---\n// Remove a node from DOM\nvar removeNode=function removeNode(el){return el&&el.parentNode&&el.parentNode.removeChild(el);};// Determine if an element is an HTML element\nvar isElement=function isElement(el){return!!(el&&el.nodeType===Node.ELEMENT_NODE);};// Get the currently active HTML element\nvar getActiveElement=function getActiveElement(){var excludes=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var activeElement=DOCUMENT.activeElement;return activeElement&&!excludes.some(function(el){return el===activeElement;})?activeElement:null;};// Returns `true` if a tag's name equals `name`\nvar isTag=function isTag(tag,name){return toString(tag).toLowerCase()===toString(name).toLowerCase();};// Determine if an HTML element is the currently active element\nvar isActiveElement=function isActiveElement(el){return isElement(el)&&el===getActiveElement();};// Determine if an HTML element is visible - Faster than CSS check\nvar isVisible=function isVisible(el){if(!isElement(el)||!el.parentNode||!contains(DOCUMENT.body,el)){// Note this can fail for shadow dom elements since they\n// are not a direct descendant of document.body\nreturn false;}if(getStyle(el,'display')==='none'){// We do this check to help with vue-test-utils when using v-show\n/* istanbul ignore next */return false;}// All browsers support getBoundingClientRect(), except JSDOM as it returns all 0's for values :(\n// So any tests that need isVisible will fail in JSDOM\n// Except when we override the getBCR prototype in some tests\nvar bcr=getBCR(el);return!!(bcr&&bcr.height>0&&bcr.width>0);};// Determine if an element is disabled\nvar isDisabled=function isDisabled(el){return!isElement(el)||el.disabled||hasAttr(el,'disabled')||hasClass(el,'disabled');};// Cause/wait-for an element to reflow its content (adjusting its height/width)\nvar reflow=function reflow(el){// Requesting an elements offsetHight will trigger a reflow of the element content\n/* istanbul ignore next: reflow doesn't happen in JSDOM */return isElement(el)&&el.offsetHeight;};// Select all elements matching selector. Returns `[]` if none found\nvar selectAll=function selectAll(selector,root){return from((isElement(root)?root:DOCUMENT).querySelectorAll(selector));};// Select a single element, returns `null` if not found\nvar select=function select(selector,root){return(isElement(root)?root:DOCUMENT).querySelector(selector)||null;};// Determine if an element matches a selector\nvar matches=function matches(el,selector){return isElement(el)?matchesEl.call(el,selector):false;};// Finds closest element matching selector. Returns `null` if not found\nvar closest=function closest(selector,root){var includeRoot=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(!isElement(root)){return null;}var el=closestEl.call(root,selector);// Native closest behaviour when `includeRoot` is truthy,\n// else emulate jQuery closest and return `null` if match is\n// the passed in root element when `includeRoot` is falsey\nreturn includeRoot?el:el===root?null:el;};// Returns true if the parent element contains the child element\nvar contains=function contains(parent,child){return parent&&isFunction$1(parent.contains)?parent.contains(child):false;};// Get an element given an ID\nvar getById=function getById(id){return DOCUMENT.getElementById(/^#/.test(id)?id.slice(1):id)||null;};// Add a class to an element\nvar addClass=function addClass(el,className){// We are checking for `el.classList` existence here since IE 11\n// returns `undefined` for some elements (e.g. SVG elements)\n// See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713\nif(className&&isElement(el)&&el.classList){el.classList.add(className);}};// Remove a class from an element\nvar removeClass=function removeClass(el,className){// We are checking for `el.classList` existence here since IE 11\n// returns `undefined` for some elements (e.g. SVG elements)\n// See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713\nif(className&&isElement(el)&&el.classList){el.classList.remove(className);}};// Test if an element has a class\nvar hasClass=function hasClass(el,className){// We are checking for `el.classList` existence here since IE 11\n// returns `undefined` for some elements (e.g. SVG elements)\n// See https://github.com/bootstrap-vue/bootstrap-vue/issues/2713\nif(className&&isElement(el)&&el.classList){return el.classList.contains(className);}return false;};// Set an attribute on an element\nvar setAttr=function setAttr(el,attr,value){if(attr&&isElement(el)){el.setAttribute(attr,value);}};// Remove an attribute from an element\nvar removeAttr=function removeAttr(el,attr){if(attr&&isElement(el)){el.removeAttribute(attr);}};// Get an attribute value from an element\n// Returns `null` if not found\nvar getAttr=function getAttr(el,attr){return attr&&isElement(el)?el.getAttribute(attr):null;};// Determine if an attribute exists on an element\n// Returns `true` or `false`, or `null` if element not found\nvar hasAttr=function hasAttr(el,attr){return attr&&isElement(el)?el.hasAttribute(attr):null;};// Set an style property on an element\nvar setStyle=function setStyle(el,prop,value){if(prop&&isElement(el)){el.style[prop]=value;}};// Remove an style property from an element\nvar removeStyle=function removeStyle(el,prop){if(prop&&isElement(el)){el.style[prop]='';}};// Get an style property value from an element\n// Returns `null` if not found\nvar getStyle=function getStyle(el,prop){return prop&&isElement(el)?el.style[prop]||null:null;};// Return the Bounding Client Rect of an element\n// Returns `null` if not an element\n/* istanbul ignore next: getBoundingClientRect() doesn't work in JSDOM */var getBCR=function getBCR(el){return isElement(el)?el.getBoundingClientRect():null;};// Get computed style object for an element\n/* istanbul ignore next: getComputedStyle() doesn't work in JSDOM */var getCS=function getCS(el){var getComputedStyle=WINDOW.getComputedStyle;return getComputedStyle&&isElement(el)?getComputedStyle(el):{};};// Returns a `Selection` object representing the range of text selected\n// Returns `null` if no window support is given\n/* istanbul ignore next: getSelection() doesn't work in JSDOM */var getSel=function getSel(){var getSelection=WINDOW.getSelection;return getSelection?WINDOW.getSelection():null;};// Return an element's offset with respect to document element\n// https://j11y.io/jquery/#v=git&fn=jQuery.fn.offset\nvar offset$1=function offset(el)/* istanbul ignore next: getBoundingClientRect(), getClientRects() doesn't work in JSDOM */{var _offset={top:0,left:0};if(!isElement(el)||el.getClientRects().length===0){return _offset;}var bcr=getBCR(el);if(bcr){var win=el.ownerDocument.defaultView;_offset.top=bcr.top+win.pageYOffset;_offset.left=bcr.left+win.pageXOffset;}return _offset;};// Return an element's offset with respect to to its offsetParent\n// https://j11y.io/jquery/#v=git&fn=jQuery.fn.position\nvar position=function position(el)/* istanbul ignore next: getBoundingClientRect() doesn't work in JSDOM */{var _offset={top:0,left:0};if(!isElement(el)){return _offset;}var parentOffset={top:0,left:0};var elStyles=getCS(el);if(elStyles.position==='fixed'){_offset=getBCR(el)||_offset;}else{_offset=offset$1(el);var doc=el.ownerDocument;var offsetParent=el.offsetParent||doc.documentElement;while(offsetParent&&(offsetParent===doc.body||offsetParent===doc.documentElement)&&getCS(offsetParent).position==='static'){offsetParent=offsetParent.parentNode;}if(offsetParent&&offsetParent!==el&&offsetParent.nodeType===Node.ELEMENT_NODE){parentOffset=offset$1(offsetParent);var offsetParentStyles=getCS(offsetParent);parentOffset.top+=toFloat(offsetParentStyles.borderTopWidth,0);parentOffset.left+=toFloat(offsetParentStyles.borderLeftWidth,0);}}return{top:_offset.top-parentOffset.top-toFloat(elStyles.marginTop,0),left:_offset.left-parentOffset.left-toFloat(elStyles.marginLeft,0)};};// Find all tabable elements in the given element\n// Assumes users have not used `tabindex` > `0` on elements\nvar getTabables=function getTabables(){var rootEl=arguments.length>0&&arguments[0]!==undefined?arguments[0]:document;return selectAll(TABABLE_SELECTOR,rootEl).filter(isVisible).filter(function(el){return el.tabIndex>-1&&!el.disabled;});};// Attempt to focus an element, and return `true` if successful\nvar attemptFocus=function attemptFocus(el){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};try{el.focus(options);}catch(_unused){}return isActiveElement(el);};// Attempt to blur an element, and return `true` if successful\nvar attemptBlur=function attemptBlur(el){try{el.blur();}catch(_unused2){}return!isActiveElement(el);};var memoize=function memoize(fn){var cache=create(null);return function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}var argsKey=JSON.stringify(args);return cache[argsKey]=cache[argsKey]||fn.apply(null,args);};};var VueProto=Vue__default['default'].prototype;// --- Getter methods ---\nvar getConfigValue=function getConfigValue(key){var defaultValue=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined;var bvConfig=VueProto[PROP_NAME$2];return bvConfig?bvConfig.getConfigValue(key,defaultValue):cloneDeep(defaultValue);};// Method to grab a config value for a particular component\nvar getComponentConfig=function getComponentConfig(key){var propKey=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;var defaultValue=arguments.length>2&&arguments[2]!==undefined?arguments[2]:undefined;// Return the particular config value for key if specified,\n// otherwise we return the full config (or an empty object if not found)\nreturn propKey?getConfigValue(\"\".concat(key,\".\").concat(propKey),defaultValue):getConfigValue(key,{});};// Get all breakpoint names\nvar getBreakpoints=function getBreakpoints(){return getConfigValue('breakpoints',DEFAULT_BREAKPOINT);};// Private method for caching breakpoint names\nvar _getBreakpointsCached=memoize(function(){return getBreakpoints();});// Get all breakpoint names (cached)\nvar getBreakpointsCached=function getBreakpointsCached(){return cloneDeep(_getBreakpointsCached());};// Get breakpoints with the smallest breakpoint set as ''\n// Useful for components that create breakpoint specific props\nvar getBreakpointsUpCached=memoize(function(){var breakpoints=getBreakpointsCached();breakpoints[0]='';return breakpoints;});// Get breakpoints with the largest breakpoint set as ''\nvar prefixPropName=function prefixPropName(prefix,value){return prefix+upperFirst(value);};// Remove a prefix from a property\nvar unprefixPropName=function unprefixPropName(prefix,value){return lowerFirst(value.replace(prefix,''));};// Suffix can be a falsey value so nothing is appended to string\n// (helps when looping over props & some shouldn't change)\n// Use data last parameters to allow for currying\nvar suffixPropName=function suffixPropName(suffix,value){return value+(suffix?upperFirst(suffix):'');};// Generates a prop object\nvar makeProp=function makeProp(){var type=arguments.length>0&&arguments[0]!==undefined?arguments[0]:PROP_TYPE_ANY;var value=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined;var requiredOrValidator=arguments.length>2&&arguments[2]!==undefined?arguments[2]:undefined;var validator=arguments.length>3&&arguments[3]!==undefined?arguments[3]:undefined;var required=requiredOrValidator===true;validator=required?validator:requiredOrValidator;return _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},type?{type:type}:{}),required?{required:required}:isUndefined(value)?{}:{default:isObject(value)?function(){return value;}:value}),isUndefined(validator)?{}:{validator:validator});};// Copies props from one array/object to a new array/object\n// Prop values are also cloned as new references to prevent possible\n// mutation of original prop object values\n// Optionally accepts a function to transform the prop name\nvar copyProps=function copyProps(props){var transformFn=arguments.length>1&&arguments[1]!==undefined?arguments[1]:identity;if(isArray(props)){return props.map(transformFn);}var copied={};for(var prop in props){/* istanbul ignore else */if(hasOwnProperty(props,prop)){// If the prop value is an object, do a shallow clone\n// to prevent potential mutations to the original object\ncopied[transformFn(prop)]=isObject(props[prop])?clone(props[prop]):props[prop];}}return copied;};// Given an array of properties or an object of property keys,\n// plucks all the values off the target object, returning a new object\n// that has props that reference the original prop values\nvar pluckProps=function pluckProps(keysToPluck,objToPluck){var transformFn=arguments.length>2&&arguments[2]!==undefined?arguments[2]:identity;return(isArray(keysToPluck)?keysToPluck.slice():keys(keysToPluck)).reduce(function(memo,prop){memo[transformFn(prop)]=objToPluck[prop];return memo;},{});};// Make a prop object configurable by global configuration\n// Replaces the current `default` key of each prop with a `getComponentConfig()`\n// call that falls back to the current default value of the prop\nvar makePropConfigurable=function makePropConfigurable(prop,key,componentKey){return _objectSpread2$3(_objectSpread2$3({},cloneDeep(prop)),{},{default:function bvConfigurablePropDefault(){var value=getComponentConfig(componentKey,key,prop.default);return isFunction$1(value)?value():value;}});};// Make a props object configurable by global configuration\n// Replaces the current `default` key of each prop with a `getComponentConfig()`\n// call that falls back to the current default value of the prop\nvar makePropsConfigurable=function makePropsConfigurable(props,componentKey){return keys(props).reduce(function(result,key){return _objectSpread2$3(_objectSpread2$3({},result),{},_defineProperty({},key,makePropConfigurable(props[key],key,componentKey)));},{});};// Get function name we use in `makePropConfigurable()`\n// for the prop default value override to compare\n// against in `hasPropFunction()`\nvar configurablePropDefaultFnName=makePropConfigurable({},'','').default.name;// Detect wether the given value is currently a function\n// and isn't the props default function\nvar hasPropFunction=function hasPropFunction(fn){return isFunction$1(fn)&&fn.name&&fn.name!==configurablePropDefaultFnName;};var makeModelMixin=function makeModelMixin(prop){var _ref=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},_ref$type=_ref.type,type=_ref$type===void 0?PROP_TYPE_ANY:_ref$type,_ref$defaultValue=_ref.defaultValue,defaultValue=_ref$defaultValue===void 0?undefined:_ref$defaultValue,_ref$validator=_ref.validator,validator=_ref$validator===void 0?undefined:_ref$validator,_ref$event=_ref.event,event=_ref$event===void 0?EVENT_NAME_INPUT:_ref$event;var props=_defineProperty({},prop,makeProp(type,defaultValue,validator));// @vue/component\nvar mixin=Vue__default['default'].extend({model:{prop:prop,event:event},props:props});return{mixin:mixin,props:props,prop:prop,event:event};};// In functional components, `slots` is a function so it must be called\n// first before passing to the below methods. `scopedSlots` is always an\n// object and may be undefined (for Vue < 2.6.x)\n/**\n   * Returns true if either scoped or unscoped named slot exists\n   *\n   * @param {String, Array} name or name[]\n   * @param {Object} scopedSlots\n   * @param {Object} slots\n   * @returns {Array|undefined} VNodes\n   */var hasNormalizedSlot=function hasNormalizedSlot(names){var $scopedSlots=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var $slots=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};// Ensure names is an array\nnames=concat(names).filter(identity);// Returns true if the either a $scopedSlot or $slot exists with the specified name\nreturn names.some(function(name){return $scopedSlots[name]||$slots[name];});};/**\n   * Returns VNodes for named slot either scoped or unscoped\n   *\n   * @param {String, Array} name or name[]\n   * @param {String} scope\n   * @param {Object} scopedSlots\n   * @param {Object} slots\n   * @returns {Array|undefined} VNodes\n   */var normalizeSlot=function normalizeSlot(names){var scope=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var $scopedSlots=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var $slots=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};// Ensure names is an array\nnames=concat(names).filter(identity);var slot;for(var i=0;i<names.length&&!slot;i++){var name=names[i];slot=$scopedSlots[name]||$slots[name];}// Note: in Vue 2.6.x, all named slots are also scoped slots\nreturn isFunction$1(slot)?slot(scope):slot;};var normalizeSlotMixin=Vue__default['default'].extend({methods:{// Returns `true` if the either a `$scopedSlot` or `$slot` exists with the specified name\n// `name` can be a string name or an array of names\nhasNormalizedSlot:function hasNormalizedSlot$1(){var name=arguments.length>0&&arguments[0]!==undefined?arguments[0]:SLOT_NAME_DEFAULT;var scopedSlots=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.$scopedSlots;var slots=arguments.length>2&&arguments[2]!==undefined?arguments[2]:this.$slots;return hasNormalizedSlot(name,scopedSlots,slots);},// Returns an array of rendered VNodes if slot found, otherwise `undefined`\n// `name` can be a string name or an array of names\nnormalizeSlot:function normalizeSlot$1(){var name=arguments.length>0&&arguments[0]!==undefined?arguments[0]:SLOT_NAME_DEFAULT;var scope=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var scopedSlots=arguments.length>2&&arguments[2]!==undefined?arguments[2]:this.$scopedSlots;var slots=arguments.length>3&&arguments[3]!==undefined?arguments[3]:this.$slots;var vNodes=normalizeSlot(name,scope,scopedSlots,slots);return vNodes?concat(vNodes):vNodes;}}});// Normalize event options based on support of passive option\n// Exported only for testing purposes\nvar parseEventOptions=function parseEventOptions(options){/* istanbul ignore else: can't test in JSDOM, as it supports passive */if(HAS_PASSIVE_EVENT_SUPPORT){return isObject(options)?options:{capture:!!options||false};}else{// Need to translate to actual Boolean value\nreturn!!(isObject(options)?options.capture:options);}};// Attach an event listener to an element\nvar eventOn=function eventOn(el,eventName,handler,options){if(el&&el.addEventListener){el.addEventListener(eventName,handler,parseEventOptions(options));}};// Remove an event listener from an element\nvar eventOff=function eventOff(el,eventName,handler,options){if(el&&el.removeEventListener){el.removeEventListener(eventName,handler,parseEventOptions(options));}};// Utility method to add/remove a event listener based on first argument (boolean)\n// It passes all other arguments to the `eventOn()` or `eventOff` method\nvar eventOnOff=function eventOnOff(on){var method=on?eventOn:eventOff;for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}method.apply(void 0,args);};// Utility method to prevent the default event handling and propagation\nvar stopEvent=function stopEvent(event){var _ref=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{},_ref$preventDefault=_ref.preventDefault,preventDefault=_ref$preventDefault===void 0?true:_ref$preventDefault,_ref$propagation=_ref.propagation,propagation=_ref$propagation===void 0?true:_ref$propagation,_ref$immediatePropaga=_ref.immediatePropagation,immediatePropagation=_ref$immediatePropaga===void 0?false:_ref$immediatePropaga;if(preventDefault){event.preventDefault();}if(propagation){event.stopPropagation();}if(immediatePropagation){event.stopImmediatePropagation();}};// Helper method to convert a component/directive name to a base event name\n// `getBaseEventName('BNavigationItem')` => 'navigation-item'\n// `getBaseEventName('BVToggle')` => 'toggle'\nvar getBaseEventName=function getBaseEventName(value){return kebabCase(value.replace(RX_BV_PREFIX,''));};// Get a root event name by component/directive and event name\n// `getBaseEventName('BModal', 'show')` => 'bv::modal::show'\nvar getRootEventName=function getRootEventName(name,eventName){return[ROOT_EVENT_NAME_PREFIX,getBaseEventName(name),eventName].join(ROOT_EVENT_NAME_SEPARATOR);};// Get a root action event name by component/directive and action name\n// `getRootActionEventName('BModal', 'show')` => 'bv::show::modal'\nvar getRootActionEventName=function getRootActionEventName(name,actionName){return[ROOT_EVENT_NAME_PREFIX,actionName,getBaseEventName(name)].join(ROOT_EVENT_NAME_SEPARATOR);};var props$2l=makePropsConfigurable({ariaLabel:makeProp(PROP_TYPE_STRING,'Close'),content:makeProp(PROP_TYPE_STRING,'&times;'),disabled:makeProp(PROP_TYPE_BOOLEAN,false),textVariant:makeProp(PROP_TYPE_STRING)},NAME_BUTTON_CLOSE);// --- Main component ---\n// @vue/component\nvar BButtonClose=/*#__PURE__*/Vue__default['default'].extend({name:NAME_BUTTON_CLOSE,functional:true,props:props$2l,render:function render(h,_ref){var props=_ref.props,data=_ref.data,slots=_ref.slots,scopedSlots=_ref.scopedSlots;var $slots=slots();var $scopedSlots=scopedSlots||{};var componentData={staticClass:'close',class:_defineProperty({},\"text-\".concat(props.textVariant),props.textVariant),attrs:{type:'button',disabled:props.disabled,'aria-label':props.ariaLabel?String(props.ariaLabel):null},on:{click:function click(event){// Ensure click on button HTML content is also disabled\n/* istanbul ignore if: bug in JSDOM still emits click on inner element */if(props.disabled&&isEvent(event)){stopEvent(event);}}}};// Careful not to override the default slot with innerHTML\nif(!hasNormalizedSlot(SLOT_NAME_DEFAULT,$scopedSlots,$slots)){componentData.domProps={innerHTML:props.content};}return h('button',a(data,componentData),normalizeSlot(SLOT_NAME_DEFAULT,{},$scopedSlots,$slots));}});var NO_FADE_PROPS={name:'',enterClass:'',enterActiveClass:'',enterToClass:'show',leaveClass:'show',leaveActiveClass:'',leaveToClass:''};var FADE_PROPS=_objectSpread2$3(_objectSpread2$3({},NO_FADE_PROPS),{},{enterActiveClass:'fade',leaveActiveClass:'fade'});// --- Props ---\nvar props$2k={// Has no effect if `trans-props` provided\nappear:makeProp(PROP_TYPE_BOOLEAN,false),// Can be overridden by user supplied `trans-props`\nmode:makeProp(PROP_TYPE_STRING),// Only applicable to the built in transition\n// Has no effect if `trans-props` provided\nnoFade:makeProp(PROP_TYPE_BOOLEAN,false),// For user supplied transitions (if needed)\ntransProps:makeProp(PROP_TYPE_OBJECT)};// --- Main component ---\n// @vue/component\nvar BVTransition=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TRANSITION,functional:true,props:props$2k,render:function render(h,_ref){var children=_ref.children,data=_ref.data,props=_ref.props;var transProps=props.transProps;if(!isPlainObject(transProps)){transProps=props.noFade?NO_FADE_PROPS:FADE_PROPS;if(props.appear){// Default the appear classes to equal the enter classes\ntransProps=_objectSpread2$3(_objectSpread2$3({},transProps),{},{appear:true,appearClass:transProps.enterClass,appearActiveClass:transProps.enterActiveClass,appearToClass:transProps.enterToClass});}}transProps=_objectSpread2$3(_objectSpread2$3({mode:props.mode},transProps),{},{// We always need `css` true\ncss:true});return h('transition',// Any transition event listeners will get merged here\na(data,{props:transProps}),children);}});var _watch$k;var _makeModelMixin$k=makeModelMixin('show',{type:PROP_TYPE_BOOLEAN_NUMBER_STRING,defaultValue:false}),modelMixin$j=_makeModelMixin$k.mixin,modelProps$j=_makeModelMixin$k.props,MODEL_PROP_NAME$j=_makeModelMixin$k.prop,MODEL_EVENT_NAME$j=_makeModelMixin$k.event;// --- Helper methods ---\n// Convert `show` value to a number\nvar parseCountDown=function parseCountDown(show){if(show===''||isBoolean(show)){return 0;}show=toInteger(show,0);return show>0?show:0;};// Convert `show` value to a boolean\nvar parseShow=function parseShow(show){if(show===''||show===true){return true;}if(toInteger(show,0)<1){// Boolean will always return false for the above comparison\nreturn false;}return!!show;};// --- Props ---\nvar props$2j=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},modelProps$j),{},{dismissLabel:makeProp(PROP_TYPE_STRING,'Close'),dismissible:makeProp(PROP_TYPE_BOOLEAN,false),fade:makeProp(PROP_TYPE_BOOLEAN,false),variant:makeProp(PROP_TYPE_STRING,'info')})),NAME_ALERT);// --- Main component ---\n// @vue/component\nvar BAlert=/*#__PURE__*/Vue__default['default'].extend({name:NAME_ALERT,mixins:[modelMixin$j,normalizeSlotMixin],props:props$2j,data:function data(){return{countDown:0,// If initially shown, we need to set these for SSR\nlocalShow:parseShow(this[MODEL_PROP_NAME$j])};},watch:(_watch$k={},_defineProperty(_watch$k,MODEL_PROP_NAME$j,function(newValue){this.countDown=parseCountDown(newValue);this.localShow=parseShow(newValue);}),_defineProperty(_watch$k,\"countDown\",function countDown(newValue){var _this=this;this.clearCountDownInterval();var show=this[MODEL_PROP_NAME$j];// Ignore if `show` transitions to a boolean value\nif(isNumeric$1(show)){this.$emit(EVENT_NAME_DISMISS_COUNT_DOWN,newValue);// Update the v-model if needed\nif(show!==newValue){this.$emit(MODEL_EVENT_NAME$j,newValue);}if(newValue>0){this.localShow=true;this.$_countDownTimeout=setTimeout(function(){_this.countDown--;},1000);}else{// Slightly delay the hide to allow any UI updates\nthis.$nextTick(function(){requestAF(function(){_this.localShow=false;});});}}}),_defineProperty(_watch$k,\"localShow\",function localShow(newValue){var show=this[MODEL_PROP_NAME$j];// Only emit dismissed events for dismissible or auto-dismissing alerts\nif(!newValue&&(this.dismissible||isNumeric$1(show))){this.$emit(EVENT_NAME_DISMISSED);}// Only emit booleans if we weren't passed a number via v-model\nif(!isNumeric$1(show)&&show!==newValue){this.$emit(MODEL_EVENT_NAME$j,newValue);}}),_watch$k),created:function created(){// Create private non-reactive props\nthis.$_filterTimer=null;var show=this[MODEL_PROP_NAME$j];this.countDown=parseCountDown(show);this.localShow=parseShow(show);},beforeDestroy:function beforeDestroy(){this.clearCountDownInterval();},methods:{dismiss:function dismiss(){this.clearCountDownInterval();this.countDown=0;this.localShow=false;},clearCountDownInterval:function clearCountDownInterval(){clearTimeout(this.$_countDownTimeout);this.$_countDownTimeout=null;}},render:function render(h){var $alert=h();if(this.localShow){var dismissible=this.dismissible,variant=this.variant;var $dismissButton=h();if(dismissible){// Add dismiss button\n$dismissButton=h(BButtonClose,{attrs:{'aria-label':this.dismissLabel},on:{click:this.dismiss}},[this.normalizeSlot(SLOT_NAME_DISMISS)]);}$alert=h('div',{staticClass:'alert',class:_defineProperty({'alert-dismissible':dismissible},\"alert-\".concat(variant),variant),attrs:{role:'alert','aria-live':'polite','aria-atomic':true},key:this[COMPONENT_UID_KEY]},[$dismissButton,this.normalizeSlot()]);}return h(BVTransition,{props:{noFade:!this.fade}},[$alert]);}});var AlertPlugin=/*#__PURE__*/pluginFactory({components:{BAlert:BAlert}});// Math utilty functions\nvar mathMin=Math.min;var mathMax=Math.max;var mathAbs=Math.abs;var mathCeil=Math.ceil;var mathFloor=Math.floor;var mathPow=Math.pow;var mathRound=Math.round;var CLASS_NAME$3='b-aspect';// --- Props ---\nvar props$2i=makePropsConfigurable({// Accepts a number (i.e. `16 / 9`, `1`, `4 / 3`)\n// Or a string (i.e. '16/9', '16:9', '4:3' '1:1')\naspect:makeProp(PROP_TYPE_NUMBER_STRING,'1:1'),tag:makeProp(PROP_TYPE_STRING,'div')},NAME_ASPECT);// --- Main component ---\n// @vue/component\nvar BAspect=/*#__PURE__*/Vue__default['default'].extend({name:NAME_ASPECT,mixins:[normalizeSlotMixin],props:props$2i,computed:{padding:function padding(){var aspect=this.aspect;var ratio=1;if(RX_ASPECT.test(aspect)){// Width and/or Height can be a decimal value below `1`, so\n// we only fallback to `1` if the value is `0` or `NaN`\nvar _aspect$split$map=aspect.split(RX_ASPECT_SEPARATOR).map(function(v){return toFloat(v)||1;}),_aspect$split$map2=_slicedToArray(_aspect$split$map,2),width=_aspect$split$map2[0],height=_aspect$split$map2[1];ratio=width/height;}else{ratio=toFloat(aspect)||1;}return\"\".concat(100/mathAbs(ratio),\"%\");}},render:function render(h){var $sizer=h('div',{staticClass:\"\".concat(CLASS_NAME$3,\"-sizer flex-grow-1\"),style:{paddingBottom:this.padding,height:0}});var $content=h('div',{staticClass:\"\".concat(CLASS_NAME$3,\"-content flex-grow-1 w-100 mw-100\"),style:{marginLeft:'-100%'}},this.normalizeSlot());return h(this.tag,{staticClass:\"\".concat(CLASS_NAME$3,\" d-flex\")},[$sizer,$content]);}});var AspectPlugin=/*#__PURE__*/pluginFactory({components:{BAspect:BAspect}});var ANCHOR_TAG='a';// Method to replace reserved chars\nvar encodeReserveReplacer=function encodeReserveReplacer(c){return'%'+c.charCodeAt(0).toString(16);};// Fixed encodeURIComponent which is more conformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\nvar encode=function encode(str){return encodeURIComponent(toString(str)).replace(RX_ENCODE_REVERSE,encodeReserveReplacer).replace(RX_ENCODED_COMMA,',');};var decode=decodeURIComponent;// Stringifies an object of query parameters\n// See: https://github.com/vuejs/vue-router/blob/dev/src/util/query.js\nvar stringifyQueryObj=function stringifyQueryObj(obj){if(!isPlainObject(obj)){return'';}var query=keys(obj).map(function(key){var value=obj[key];if(isUndefined(value)){return'';}else if(isNull(value)){return encode(key);}else if(isArray(value)){return value.reduce(function(results,value2){if(isNull(value2)){results.push(encode(key));}else if(!isUndefined(value2)){// Faster than string interpolation\nresults.push(encode(key)+'='+encode(value2));}return results;},[]).join('&');}// Faster than string interpolation\nreturn encode(key)+'='+encode(value);})/* must check for length, as we only want to filter empty strings, not things that look falsey! */.filter(function(x){return x.length>0;}).join('&');return query?\"?\".concat(query):'';};var parseQuery=function parseQuery(query){var parsed={};query=toString(query).trim().replace(RX_QUERY_START,'');if(!query){return parsed;}query.split('&').forEach(function(param){var parts=param.replace(RX_PLUS,' ').split('=');var key=decode(parts.shift());var value=parts.length>0?decode(parts.join('=')):null;if(isUndefined(parsed[key])){parsed[key]=value;}else if(isArray(parsed[key])){parsed[key].push(value);}else{parsed[key]=[parsed[key],value];}});return parsed;};var isLink$1=function isLink(props){return!!(props.href||props.to);};var isRouterLink=function isRouterLink(tag){return!!(tag&&!isTag(tag,'a'));};var computeTag=function computeTag(_ref,thisOrParent){var to=_ref.to,disabled=_ref.disabled,routerComponentName=_ref.routerComponentName;var hasRouter=!!thisOrParent.$router;if(!hasRouter||hasRouter&&(disabled||!to)){return ANCHOR_TAG;}// TODO:\n//   Check registered components for existence of user supplied router link component name\n//   We would need to check PascalCase, kebab-case, and camelCase versions of name:\n//   const name = routerComponentName\n//   const names = [name, PascalCase(name), KebabCase(name), CamelCase(name)]\n//   exists = names.some(name => !!thisOrParent.$options.components[name])\n//   And may want to cache the result for performance or we just let the render fail\n//   if the component is not registered\nreturn routerComponentName||(thisOrParent.$nuxt?'nuxt-link':'router-link');};var computeRel=function computeRel(){var _ref2=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},target=_ref2.target,rel=_ref2.rel;return target==='_blank'&&isNull(rel)?'noopener':rel||null;};var computeHref=function computeHref(){var _ref3=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},href=_ref3.href,to=_ref3.to;var tag=arguments.length>1&&arguments[1]!==undefined?arguments[1]:ANCHOR_TAG;var fallback=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'#';var toFallback=arguments.length>3&&arguments[3]!==undefined?arguments[3]:'/';// Return `href` when explicitly provided\nif(href){return href;}// We've checked for `$router` in `computeTag()`, so `isRouterLink()` indicates a live router\n// When deferring to Vue Router's `<router-link>`, don't use the `href` attribute at all\n// We return `null`, and then remove `href` from the attributes passed to `<router-link>`\nif(isRouterLink(tag)){return null;}// Fallback to `to` prop (if `to` is a string)\nif(isString(to)){return to||toFallback;}// Fallback to `to.path' + `to.query` + `to.hash` prop (if `to` is an object)\nif(isPlainObject(to)&&(to.path||to.query||to.hash)){var path=toString(to.path);var query=stringifyQueryObj(to.query);var hash=toString(to.hash);hash=!hash||hash.charAt(0)==='#'?hash:\"#\".concat(hash);return\"\".concat(path).concat(query).concat(hash)||toFallback;}// If nothing is provided return the fallback\nreturn fallback;};// Base attributes needed on all icons\nvar BASE_ATTRS={viewBox:'0 0 16 16',width:'1em',height:'1em',focusable:'false',role:'img','aria-label':'icon'};// Attributes that are nulled out when stacked\nvar STACKED_ATTRS={width:null,height:null,focusable:null,role:null,'aria-label':null};// --- Props ---\nvar props$2h={animation:makeProp(PROP_TYPE_STRING),content:makeProp(PROP_TYPE_STRING),flipH:makeProp(PROP_TYPE_BOOLEAN,false),flipV:makeProp(PROP_TYPE_BOOLEAN,false),fontScale:makeProp(PROP_TYPE_NUMBER_STRING,1),rotate:makeProp(PROP_TYPE_NUMBER_STRING,0),scale:makeProp(PROP_TYPE_NUMBER_STRING,1),shiftH:makeProp(PROP_TYPE_NUMBER_STRING,0),shiftV:makeProp(PROP_TYPE_NUMBER_STRING,0),stacked:makeProp(PROP_TYPE_BOOLEAN,false),title:makeProp(PROP_TYPE_STRING),variant:makeProp(PROP_TYPE_STRING)};// --- Main component ---\n// Shared private base component to reduce bundle/runtime size\n// @vue/component\nvar BVIconBase=/*#__PURE__*/Vue__default['default'].extend({name:NAME_ICON_BASE,functional:true,props:props$2h,render:function render(h,_ref){var _class;var data=_ref.data,props=_ref.props,children=_ref.children;var animation=props.animation,content=props.content,flipH=props.flipH,flipV=props.flipV,stacked=props.stacked,title=props.title,variant=props.variant;var fontScale=mathMax(toFloat(props.fontScale,1),0)||1;var scale=mathMax(toFloat(props.scale,1),0)||1;var rotate=toFloat(props.rotate,0);var shiftH=toFloat(props.shiftH,0);var shiftV=toFloat(props.shiftV,0);// Compute the transforms\n// Note that order is important as SVG transforms are applied in order from\n// left to right and we want flipping/scale to occur before rotation\n// Note shifting is applied separately\n// Assumes that the viewbox is `0 0 16 16` (`8 8` is the center)\nvar hasScale=flipH||flipV||scale!==1;var hasTransforms=hasScale||rotate;var hasShift=shiftH||shiftV;var hasContent=!isUndefinedOrNull(content);var transforms=[hasTransforms?'translate(8 8)':null,hasScale?\"scale(\".concat((flipH?-1:1)*scale,\" \").concat((flipV?-1:1)*scale,\")\"):null,rotate?\"rotate(\".concat(rotate,\")\"):null,hasTransforms?'translate(-8 -8)':null].filter(identity);// We wrap the content in a `<g>` for handling the transforms (except shift)\nvar $inner=h('g',{attrs:{transform:transforms.join(' ')||null},domProps:hasContent?{innerHTML:content||''}:{}},children);// If needed, we wrap in an additional `<g>` in order to handle the shifting\nif(hasShift){$inner=h('g',{attrs:{transform:\"translate(\".concat(16*shiftH/16,\" \").concat(-16*shiftV/16,\")\")}},[$inner]);}// Wrap in an additional `<g>` for proper animation handling if stacked\nif(stacked){$inner=h('g',[$inner]);}var $title=title?h('title',title):null;var $content=[$title,$inner].filter(identity);return h('svg',a({staticClass:'b-icon bi',class:(_class={},_defineProperty(_class,\"text-\".concat(variant),variant),_defineProperty(_class,\"b-icon-animation-\".concat(animation),animation),_class),attrs:BASE_ATTRS,style:stacked?{}:{fontSize:fontScale===1?null:\"\".concat(fontScale*100,\"%\")}},// Merge in user supplied data\ndata,// If icon is stacked, null-out some attrs\nstacked?{attrs:STACKED_ATTRS}:{},// These cannot be overridden by users\n{attrs:{xmlns:stacked?null:'http://www.w3.org/2000/svg',fill:'currentColor'}}),$content);}});var iconProps$1=omit(props$2h,['content']);/**\n   * Icon component generator function\n   *\n   * @param {string} icon name (minus the leading `BIcon`)\n   * @param {string} raw `innerHTML` for SVG\n   * @return {VueComponent}\n   */var makeIcon=function makeIcon(name,content){// For performance reason we pre-compute some values, so that\n// they are not computed on each render of the icon component\nvar kebabName=kebabCase(name);var iconName=\"BIcon\".concat(pascalCase(name));var iconNameClass=\"bi-\".concat(kebabName);var iconTitle=kebabName.replace(/-/g,' ');var svgContent=trim(content||'');return/*#__PURE__*/Vue__default['default'].extend({name:iconName,functional:true,props:iconProps$1,render:function render(h,_ref){var data=_ref.data,props=_ref.props;return h(BVIconBase,a(// Defaults\n{props:{title:iconTitle},attrs:{'aria-label':iconTitle}},// User data\ndata,// Required data\n{staticClass:iconNameClass,props:_objectSpread2$3(_objectSpread2$3({},props),{},{content:svgContent})}));}});};// --- BEGIN AUTO-GENERATED FILE ---\nvar BIconBlank=/*#__PURE__*/makeIcon('Blank','');// --- Bootstrap Icons ---\nvar BIconCalendar=/*#__PURE__*/makeIcon('Calendar','<path d=\"M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5zM1 4v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V4H1z\"/>');// eslint-disable-next-line\nvar BIconCalendarFill=/*#__PURE__*/makeIcon('CalendarFill','<path d=\"M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V5h16V4H0V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5z\"/>');// eslint-disable-next-line\nvar BIconChevronBarLeft=/*#__PURE__*/makeIcon('ChevronBarLeft','<path fill-rule=\"evenodd\" d=\"M11.854 3.646a.5.5 0 0 1 0 .708L8.207 8l3.647 3.646a.5.5 0 0 1-.708.708l-4-4a.5.5 0 0 1 0-.708l4-4a.5.5 0 0 1 .708 0zM4.5 1a.5.5 0 0 0-.5.5v13a.5.5 0 0 0 1 0v-13a.5.5 0 0 0-.5-.5z\"/>');// eslint-disable-next-line\nvar BIconChevronDoubleLeft=/*#__PURE__*/makeIcon('ChevronDoubleLeft','<path fill-rule=\"evenodd\" d=\"M8.354 1.646a.5.5 0 0 1 0 .708L2.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z\"/><path fill-rule=\"evenodd\" d=\"M12.354 1.646a.5.5 0 0 1 0 .708L6.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z\"/>');// eslint-disable-next-line\nvar BIconChevronDown=/*#__PURE__*/makeIcon('ChevronDown','<path fill-rule=\"evenodd\" d=\"M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z\"/>');// eslint-disable-next-line\nvar BIconChevronLeft=/*#__PURE__*/makeIcon('ChevronLeft','<path fill-rule=\"evenodd\" d=\"M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z\"/>');// eslint-disable-next-line\nvar BIconChevronUp=/*#__PURE__*/makeIcon('ChevronUp','<path fill-rule=\"evenodd\" d=\"M7.646 4.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1-.708.708L8 5.707l-5.646 5.647a.5.5 0 0 1-.708-.708l6-6z\"/>');// eslint-disable-next-line\nvar BIconCircleFill=/*#__PURE__*/makeIcon('CircleFill','<circle cx=\"8\" cy=\"8\" r=\"8\"/>');// eslint-disable-next-line\nvar BIconClock=/*#__PURE__*/makeIcon('Clock','<path d=\"M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z\"/><path d=\"M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z\"/>');// eslint-disable-next-line\nvar BIconClockFill=/*#__PURE__*/makeIcon('ClockFill','<path d=\"M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z\"/>');// eslint-disable-next-line\nvar BIconDash=/*#__PURE__*/makeIcon('Dash','<path d=\"M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z\"/>');// eslint-disable-next-line\nvar BIconPersonFill=/*#__PURE__*/makeIcon('PersonFill','<path d=\"M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z\"/>');// eslint-disable-next-line\nvar BIconPlus=/*#__PURE__*/makeIcon('Plus','<path d=\"M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z\"/>');// eslint-disable-next-line\nvar BIconStar=/*#__PURE__*/makeIcon('Star','<path d=\"M2.866 14.85c-.078.444.36.791.746.593l4.39-2.256 4.389 2.256c.386.198.824-.149.746-.592l-.83-4.73 3.522-3.356c.33-.314.16-.888-.282-.95l-4.898-.696L8.465.792a.513.513 0 0 0-.927 0L5.354 5.12l-4.898.696c-.441.062-.612.636-.283.95l3.523 3.356-.83 4.73zm4.905-2.767-3.686 1.894.694-3.957a.565.565 0 0 0-.163-.505L1.71 6.745l4.052-.576a.525.525 0 0 0 .393-.288L8 2.223l1.847 3.658a.525.525 0 0 0 .393.288l4.052.575-2.906 2.77a.565.565 0 0 0-.163.506l.694 3.957-3.686-1.894a.503.503 0 0 0-.461 0z\"/>');// eslint-disable-next-line\nvar BIconStarFill=/*#__PURE__*/makeIcon('StarFill','<path d=\"M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z\"/>');// eslint-disable-next-line\nvar BIconStarHalf=/*#__PURE__*/makeIcon('StarHalf','<path d=\"M5.354 5.119 7.538.792A.516.516 0 0 1 8 .5c.183 0 .366.097.465.292l2.184 4.327 4.898.696A.537.537 0 0 1 16 6.32a.548.548 0 0 1-.17.445l-3.523 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256a.52.52 0 0 1-.146.05c-.342.06-.668-.254-.6-.642l.83-4.73L.173 6.765a.55.55 0 0 1-.172-.403.58.58 0 0 1 .085-.302.513.513 0 0 1 .37-.245l4.898-.696zM8 12.027a.5.5 0 0 1 .232.056l3.686 1.894-.694-3.957a.565.565 0 0 1 .162-.505l2.907-2.77-4.052-.576a.525.525 0 0 1-.393-.288L8.001 2.223 8 2.226v9.8z\"/>');// eslint-disable-next-line\nvar BIconX=/*#__PURE__*/makeIcon('X','<path d=\"M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z\"/>');// eslint-disable-next-line\n// --- END AUTO-GENERATED FILE ---\nvar findIconComponent=function findIconComponent(ctx,iconName){if(!ctx){return Vue__default['default'].component(iconName);}var components=(ctx.$options||{}).components;var iconComponent=components&&components[iconName];return iconComponent||findIconComponent(ctx.$parent,iconName);};// --- Props ---\nvar iconProps=omit(props$2h,['content']);var props$2g=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},iconProps),{},{icon:makeProp(PROP_TYPE_STRING)})),NAME_ICON);// --- Main component ---\n// Helper BIcon component\n// Requires the requested icon component to be installed\n// @vue/component\nvar BIcon=/*#__PURE__*/Vue__default['default'].extend({name:NAME_ICON,functional:true,props:props$2g,render:function render(h,_ref){var data=_ref.data,props=_ref.props,parent=_ref.parent;var icon=pascalCase(trim(props.icon||'')).replace(RX_ICON_PREFIX,'');// If parent context exists, we check to see if the icon has been registered\n// either locally in the parent component, or globally at the `$root` level\n// If not registered, we render a blank icon\nreturn h(icon?findIconComponent(parent,\"BIcon\".concat(icon))||BIconBlank:BIconBlank,a(data,{props:pluckProps(iconProps,props)}));}});var CODE_BACKSPACE=8;var CODE_DELETE=46;var CODE_DOWN=40;var CODE_END=35;var CODE_ENTER=13;var CODE_ESC=27;var CODE_HOME=36;var CODE_LEFT=37;var CODE_PAGEDOWN=34;var CODE_PAGEUP=33;var CODE_RIGHT=39;var CODE_SPACE=32;var CODE_UP=38;// Handles when arrays are \"sparse\" (array.every(...) doesn't handle sparse)\nvar compareArrays=function compareArrays(a,b){if(a.length!==b.length){return false;}var equal=true;for(var i=0;equal&&i<a.length;i++){equal=looseEqual(a[i],b[i]);}return equal;};/**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   * Returns boolean true or false\n   */var looseEqual=function looseEqual(a,b){if(a===b){return true;}var aValidType=isDate(a);var bValidType=isDate(b);if(aValidType||bValidType){return aValidType&&bValidType?a.getTime()===b.getTime():false;}aValidType=isArray(a);bValidType=isArray(b);if(aValidType||bValidType){return aValidType&&bValidType?compareArrays(a,b):false;}aValidType=isObject(a);bValidType=isObject(b);if(aValidType||bValidType){/* istanbul ignore if: this if will probably never be called */if(!aValidType||!bValidType){return false;}var aKeysCount=keys(a).length;var bKeysCount=keys(b).length;if(aKeysCount!==bKeysCount){return false;}for(var key in a){var aHasKey=hasOwnProperty(a,key);var bHasKey=hasOwnProperty(b,key);if(aHasKey&&!bHasKey||!aHasKey&&bHasKey||!looseEqual(a[key],b[key])){return false;}}}return String(a)===String(b);};var isEmpty=function isEmpty(value){return!value||keys(value).length===0;};var makePropWatcher=function makePropWatcher(propName){return{handler:function handler(newValue,oldValue){if(looseEqual(newValue,oldValue)){return;}if(isEmpty(newValue)||isEmpty(oldValue)){this[propName]=cloneDeep(newValue);return;}for(var key in oldValue){if(!hasOwnProperty(newValue,key)){this.$delete(this.$data[propName],key);}}for(var _key in newValue){this.$set(this.$data[propName],_key,newValue[_key]);}}};};var makePropCacheMixin=function makePropCacheMixin(propName,proxyPropName){return Vue__default['default'].extend({data:function data(){return _defineProperty({},proxyPropName,cloneDeep(this[propName]));},watch:_defineProperty({},propName,makePropWatcher(proxyPropName))});};var attrsMixin=makePropCacheMixin('$attrs','bvAttrs');var PROP$3='$_rootListeners';// --- Mixin ---\n// @vue/component\nvar listenOnRootMixin=Vue__default['default'].extend({created:function created(){// Define non-reactive property\n// Object of arrays, keyed by event name,\n// where value is an array of callbacks\nthis[PROP$3]={};},beforeDestroy:function beforeDestroy(){var _this=this;// Unregister all registered listeners\nkeys(this[PROP$3]||{}).forEach(function(event){_this[PROP$3][event].forEach(function(callback){_this.listenOffRoot(event,callback);});});this[PROP$3]=null;},methods:{registerRootListener:function registerRootListener(event,callback){if(this[PROP$3]){this[PROP$3][event]=this[PROP$3][event]||[];if(!arrayIncludes(this[PROP$3][event],callback)){this[PROP$3][event].push(callback);}}},unregisterRootListener:function unregisterRootListener(event,callback){if(this[PROP$3]&&this[PROP$3][event]){this[PROP$3][event]=this[PROP$3][event].filter(function(cb){return cb!==callback;});}},/**\n       * Safely register event listeners on the root Vue node\n       * While Vue automatically removes listeners for individual components,\n       * when a component registers a listener on `$root` and is destroyed,\n       * this orphans a callback because the node is gone, but the `$root`\n       * does not clear the callback\n       *\n       * When registering a `$root` listener, it also registers the listener\n       * to be removed in the component's `beforeDestroy()` hook\n       *\n       * @param {string} event\n       * @param {function} callback\n       */listenOnRoot:function listenOnRoot(event,callback){if(this.$root){this.$root.$on(event,callback);this.registerRootListener(event,callback);}},/**\n       * Safely register a `$once()` event listener on the root Vue node\n       * While Vue automatically removes listeners for individual components,\n       * when a component registers a listener on `$root` and is destroyed,\n       * this orphans a callback because the node is gone, but the `$root`\n       * does not clear the callback\n       *\n       * When registering a `$root` listener, it also registers the listener\n       * to be removed in the component's `beforeDestroy()` hook\n       *\n       * @param {string} event\n       * @param {function} callback\n       */listenOnRootOnce:function listenOnRootOnce(event,callback){var _this2=this;if(this.$root){var _callback=function _callback(){_this2.unregisterRootListener(_callback);// eslint-disable-next-line node/no-callback-literal\ncallback.apply(void 0,arguments);};this.$root.$once(event,_callback);this.registerRootListener(event,_callback);}},/**\n       * Safely unregister event listeners from the root Vue node\n       *\n       * @param {string} event\n       * @param {function} callback\n       */listenOffRoot:function listenOffRoot(event,callback){this.unregisterRootListener(event,callback);if(this.$root){this.$root.$off(event,callback);}},/**\n       * Convenience method for calling `vm.$emit()` on `$root`\n       *\n       * @param {string} event\n       * @param {*} args\n       */emitOnRoot:function emitOnRoot(event){if(this.$root){var _this$$root;for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}(_this$$root=this.$root).$emit.apply(_this$$root,[event].concat(args));}}}});var listenersMixin=makePropCacheMixin('$listeners','bvListeners');var ROOT_EVENT_NAME_CLICKED=getRootEventName(NAME_LINK,'clicked');// --- Props ---\n// `<router-link>` specific props\nvar routerLinkProps={activeClass:makeProp(PROP_TYPE_STRING),append:makeProp(PROP_TYPE_BOOLEAN,false),event:makeProp(PROP_TYPE_ARRAY_STRING),exact:makeProp(PROP_TYPE_BOOLEAN,false),exactActiveClass:makeProp(PROP_TYPE_STRING),exactPath:makeProp(PROP_TYPE_BOOLEAN,false),exactPathActiveClass:makeProp(PROP_TYPE_STRING),replace:makeProp(PROP_TYPE_BOOLEAN,false),routerTag:makeProp(PROP_TYPE_STRING),to:makeProp(PROP_TYPE_OBJECT_STRING)};// `<nuxt-link>` specific props\nvar nuxtLinkProps={noPrefetch:makeProp(PROP_TYPE_BOOLEAN,false),// Must be `null` to fall back to the value defined in the\n// `nuxt.config.js` configuration file for `router.prefetchLinks`\n// We convert `null` to `undefined`, so that Nuxt.js will use the\n// compiled default\n// Vue treats `undefined` as default of `false` for Boolean props,\n// so we must set it as `null` here to be a true tri-state prop\nprefetch:makeProp(PROP_TYPE_BOOLEAN,null)};// All `<b-link>` props\nvar props$2f=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},nuxtLinkProps),routerLinkProps),{},{active:makeProp(PROP_TYPE_BOOLEAN,false),disabled:makeProp(PROP_TYPE_BOOLEAN,false),href:makeProp(PROP_TYPE_STRING),// Must be `null` if no value provided\nrel:makeProp(PROP_TYPE_STRING,null),// To support 3rd party router links based on `<router-link>` (i.e. `g-link` for Gridsome)\n// Default is to auto choose between `<router-link>` and `<nuxt-link>`\n// Gridsome doesn't provide a mechanism to auto detect and has caveats\n// such as not supporting FQDN URLs or hash only URLs\nrouterComponentName:makeProp(PROP_TYPE_STRING),target:makeProp(PROP_TYPE_STRING,'_self')})),NAME_LINK);// --- Main component ---\n// @vue/component\nvar BLink=/*#__PURE__*/Vue__default['default'].extend({name:NAME_LINK,// Mixin order is important!\nmixins:[attrsMixin,listenersMixin,listenOnRootMixin,normalizeSlotMixin],inheritAttrs:false,props:props$2f,computed:{computedTag:function computedTag(){// We don't pass `this` as the first arg as we need reactivity of the props\nvar to=this.to,disabled=this.disabled,routerComponentName=this.routerComponentName;return computeTag({to:to,disabled:disabled,routerComponentName:routerComponentName},this);},isRouterLink:function isRouterLink$1(){return isRouterLink(this.computedTag);},computedRel:function computedRel(){// We don't pass `this` as the first arg as we need reactivity of the props\nvar target=this.target,rel=this.rel;return computeRel({target:target,rel:rel});},computedHref:function computedHref(){// We don't pass `this` as the first arg as we need reactivity of the props\nvar to=this.to,href=this.href;return computeHref({to:to,href:href},this.computedTag);},computedProps:function computedProps(){var event=this.event,prefetch=this.prefetch,routerTag=this.routerTag;return this.isRouterLink?_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},pluckProps(omit(_objectSpread2$3(_objectSpread2$3({},routerLinkProps),nuxtLinkProps),['event','prefetch','routerTag']),this)),event?{event:event}:{}),isBoolean(prefetch)?{prefetch:prefetch}:{}),routerTag?{tag:routerTag}:{}):{};},computedAttrs:function computedAttrs(){var bvAttrs=this.bvAttrs,href=this.computedHref,rel=this.computedRel,disabled=this.disabled,target=this.target,routerTag=this.routerTag,isRouterLink=this.isRouterLink;return _objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},bvAttrs),href?{href:href}:{}),isRouterLink&&routerTag&&!isTag(routerTag,'a')?{}:{rel:rel,target:target}),{},{tabindex:disabled?'-1':isUndefined(bvAttrs.tabindex)?null:bvAttrs.tabindex,'aria-disabled':disabled?'true':null});},computedListeners:function computedListeners(){return _objectSpread2$3(_objectSpread2$3({},this.bvListeners),{},{// We want to overwrite any click handler since our callback\n// will invoke the user supplied handler(s) if `!this.disabled`\nclick:this.onClick});}},methods:{onClick:function onClick(event){var _arguments=arguments;var eventIsEvent=isEvent(event);var isRouterLink=this.isRouterLink;var suppliedHandler=this.bvListeners.click;if(eventIsEvent&&this.disabled){// Stop event from bubbling up\n// Kill the event loop attached to this specific `EventTarget`\n// Needed to prevent `vue-router` for doing its thing\nstopEvent(event,{immediatePropagation:true});}else{// Router links do not emit instance `click` events, so we\n// add in an `$emit('click', event)` on its Vue instance\n/* istanbul ignore next: difficult to test, but we know it works */if(isRouterLink&&event.currentTarget.__vue__){event.currentTarget.__vue__.$emit(EVENT_NAME_CLICK,event);}// Call the suppliedHandler(s), if any provided\nconcat(suppliedHandler).filter(function(h){return isFunction$1(h);}).forEach(function(handler){handler.apply(void 0,_toConsumableArray$1(_arguments));});// Emit the global `$root` click event\nthis.emitOnRoot(ROOT_EVENT_NAME_CLICKED,event);// TODO: Remove deprecated 'clicked::link' event with next major release\nthis.emitOnRoot('clicked::link',event);}// Stop scroll-to-top behavior or navigation on\n// regular links when href is just '#'\nif(eventIsEvent&&!isRouterLink&&this.computedHref==='#'){stopEvent(event,{propagation:false});}},focus:function focus(){attemptFocus(this.$el);},blur:function blur(){attemptBlur(this.$el);}},render:function render(h){var active=this.active,disabled=this.disabled;return h(this.computedTag,_defineProperty({class:{active:active,disabled:disabled},attrs:this.computedAttrs,props:this.computedProps},this.isRouterLink?'nativeOn':'on',this.computedListeners),this.normalizeSlot());}});var linkProps$7=omit(props$2f,['event','routerTag']);delete linkProps$7.href.default;delete linkProps$7.to.default;var props$2e=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},linkProps$7),{},{block:makeProp(PROP_TYPE_BOOLEAN,false),disabled:makeProp(PROP_TYPE_BOOLEAN,false),pill:makeProp(PROP_TYPE_BOOLEAN,false),// Tri-state: `true`, `false` or `null`\n// => On, off, not a toggle\npressed:makeProp(PROP_TYPE_BOOLEAN,null),size:makeProp(PROP_TYPE_STRING),squared:makeProp(PROP_TYPE_BOOLEAN,false),tag:makeProp(PROP_TYPE_STRING,'button'),type:makeProp(PROP_TYPE_STRING,'button'),variant:makeProp(PROP_TYPE_STRING,'secondary')})),NAME_BUTTON);// --- Helper methods ---\n// Focus handler for toggle buttons\n// Needs class of 'focus' when focused\nvar handleFocus=function handleFocus(event){if(event.type==='focusin'){addClass(event.target,'focus');}else if(event.type==='focusout'){removeClass(event.target,'focus');}};// Is the requested button a link?\n// If tag prop is set to `a`, we use a <b-link> to get proper disabled handling\nvar isLink=function isLink(props){return isLink$1(props)||isTag(props.tag,'a');};// Is the button to be a toggle button?\nvar isToggle=function isToggle(props){return isBoolean(props.pressed);};// Is the button \"really\" a button?\nvar isButton=function isButton(props){return!(isLink(props)||props.tag&&!isTag(props.tag,'button'));};// Is the requested tag not a button or link?\nvar isNonStandardTag$1=function isNonStandardTag(props){return!isLink(props)&&!isButton(props);};// Compute required classes (non static classes)\nvar computeClass=function computeClass(props){var _ref;return[\"btn-\".concat(props.variant||'secondary'),(_ref={},_defineProperty(_ref,\"btn-\".concat(props.size),props.size),_defineProperty(_ref,'btn-block',props.block),_defineProperty(_ref,'rounded-pill',props.pill),_defineProperty(_ref,'rounded-0',props.squared&&!props.pill),_defineProperty(_ref,\"disabled\",props.disabled),_defineProperty(_ref,\"active\",props.pressed),_ref)];};// Compute the link props to pass to b-link (if required)\nvar computeLinkProps=function computeLinkProps(props){return isLink(props)?pluckProps(linkProps$7,props):{};};// Compute the attributes for a button\nvar computeAttrs=function computeAttrs(props,data){var button=isButton(props);var link=isLink(props);var toggle=isToggle(props);var nonStandardTag=isNonStandardTag$1(props);var hashLink=link&&props.href==='#';var role=data.attrs&&data.attrs.role?data.attrs.role:null;var tabindex=data.attrs?data.attrs.tabindex:null;if(nonStandardTag||hashLink){tabindex='0';}return{// Type only used for \"real\" buttons\ntype:button&&!link?props.type:null,// Disabled only set on \"real\" buttons\ndisabled:button?props.disabled:null,// We add a role of button when the tag is not a link or button for ARIA\n// Don't bork any role provided in `data.attrs` when `isLink` or `isButton`\n// Except when link has `href` of `#`\nrole:nonStandardTag||hashLink?'button':role,// We set the `aria-disabled` state for non-standard tags\n'aria-disabled':nonStandardTag?String(props.disabled):null,// For toggles, we need to set the pressed state for ARIA\n'aria-pressed':toggle?String(props.pressed):null,// `autocomplete=\"off\"` is needed in toggle mode to prevent some browsers\n// from remembering the previous setting when using the back button\nautocomplete:toggle?'off':null,// `tabindex` is used when the component is not a button\n// Links are tabbable, but don't allow disabled, while non buttons or links\n// are not tabbable, so we mimic that functionality by disabling tabbing\n// when disabled, and adding a `tabindex=\"0\"` to non buttons or non links\ntabindex:props.disabled&&!button?'-1':tabindex};};// --- Main component ---\n// @vue/component\nvar BButton=/*#__PURE__*/Vue__default['default'].extend({name:NAME_BUTTON,functional:true,props:props$2e,render:function render(h,_ref2){var props=_ref2.props,data=_ref2.data,listeners=_ref2.listeners,children=_ref2.children;var toggle=isToggle(props);var link=isLink(props);var nonStandardTag=isNonStandardTag$1(props);var hashLink=link&&props.href==='#';var on={keydown:function keydown(event){// When the link is a `href=\"#\"` or a non-standard tag (has `role=\"button\"`),\n// we add a keydown handlers for CODE_SPACE/CODE_ENTER\n/* istanbul ignore next */if(props.disabled||!(nonStandardTag||hashLink)){return;}var keyCode=event.keyCode;// Add CODE_SPACE handler for `href=\"#\"` and CODE_ENTER handler for non-standard tags\nif(keyCode===CODE_SPACE||keyCode===CODE_ENTER&&nonStandardTag){var target=event.currentTarget||event.target;stopEvent(event,{propagation:false});target.click();}},click:function click(event){/* istanbul ignore if: blink/button disabled should handle this */if(props.disabled&&isEvent(event)){stopEvent(event);}else if(toggle&&listeners&&listeners['update:pressed']){// Send `.sync` updates to any \"pressed\" prop (if `.sync` listeners)\n// `concat()` will normalize the value to an array without\n// double wrapping an array value in an array\nconcat(listeners['update:pressed']).forEach(function(fn){if(isFunction$1(fn)){fn(!props.pressed);}});}}};if(toggle){on.focusin=handleFocus;on.focusout=handleFocus;}var componentData={staticClass:'btn',class:computeClass(props),props:computeLinkProps(props),attrs:computeAttrs(props,data),on:on};return h(link?BLink:props.tag,a(data,componentData),children);}});var CLASS_NAME$2='b-avatar';var SIZES=['sm',null,'lg'];var FONT_SIZE_SCALE=0.4;var BADGE_FONT_SIZE_SCALE=FONT_SIZE_SCALE*0.7;// --- Helper methods ---\nvar computeSize=function computeSize(value){// Parse to number when value is a float-like string\nvalue=isString(value)&&isNumeric$1(value)?toFloat(value,0):value;// Convert all numbers to pixel values\nreturn isNumber(value)?\"\".concat(value,\"px\"):value||null;};// --- Props ---\nvar linkProps$6=omit(props$2f,['active','event','routerTag']);var props$2d=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},linkProps$6),{},{alt:makeProp(PROP_TYPE_STRING,'avatar'),ariaLabel:makeProp(PROP_TYPE_STRING),badge:makeProp(PROP_TYPE_BOOLEAN_STRING,false),badgeLeft:makeProp(PROP_TYPE_BOOLEAN,false),badgeOffset:makeProp(PROP_TYPE_STRING),badgeTop:makeProp(PROP_TYPE_BOOLEAN,false),badgeVariant:makeProp(PROP_TYPE_STRING,'primary'),button:makeProp(PROP_TYPE_BOOLEAN,false),buttonType:makeProp(PROP_TYPE_STRING,'button'),icon:makeProp(PROP_TYPE_STRING),rounded:makeProp(PROP_TYPE_BOOLEAN_STRING,false),size:makeProp(PROP_TYPE_NUMBER_STRING),square:makeProp(PROP_TYPE_BOOLEAN,false),src:makeProp(PROP_TYPE_STRING),text:makeProp(PROP_TYPE_STRING),variant:makeProp(PROP_TYPE_STRING,'secondary')})),NAME_AVATAR);// --- Main component ---\n// @vue/component\nvar BAvatar=/*#__PURE__*/Vue__default['default'].extend({name:NAME_AVATAR,mixins:[normalizeSlotMixin],inject:{bvAvatarGroup:{default:null}},props:props$2d,data:function data(){return{localSrc:this.src||null};},computed:{computedSize:function computedSize(){// Always use the avatar group size\nvar bvAvatarGroup=this.bvAvatarGroup;return computeSize(bvAvatarGroup?bvAvatarGroup.size:this.size);},computedVariant:function computedVariant(){var bvAvatarGroup=this.bvAvatarGroup;return bvAvatarGroup&&bvAvatarGroup.variant?bvAvatarGroup.variant:this.variant;},computedRounded:function computedRounded(){var bvAvatarGroup=this.bvAvatarGroup;var square=bvAvatarGroup&&bvAvatarGroup.square?true:this.square;var rounded=bvAvatarGroup&&bvAvatarGroup.rounded?bvAvatarGroup.rounded:this.rounded;return square?'0':rounded===''?true:rounded||'circle';},fontStyle:function fontStyle(){var size=this.computedSize;var fontSize=SIZES.indexOf(size)===-1?\"calc(\".concat(size,\" * \").concat(FONT_SIZE_SCALE,\")\"):null;return fontSize?{fontSize:fontSize}:{};},marginStyle:function marginStyle(){var size=this.computedSize,bvAvatarGroup=this.bvAvatarGroup;var overlapScale=bvAvatarGroup?bvAvatarGroup.overlapScale:0;var value=size&&overlapScale?\"calc(\".concat(size,\" * -\").concat(overlapScale,\")\"):null;return value?{marginLeft:value,marginRight:value}:{};},badgeStyle:function badgeStyle(){var size=this.computedSize,badgeTop=this.badgeTop,badgeLeft=this.badgeLeft,badgeOffset=this.badgeOffset;var offset=badgeOffset||'0px';return{fontSize:SIZES.indexOf(size)===-1?\"calc(\".concat(size,\" * \").concat(BADGE_FONT_SIZE_SCALE,\" )\"):null,top:badgeTop?offset:null,bottom:badgeTop?null:offset,left:badgeLeft?offset:null,right:badgeLeft?null:offset};}},watch:{src:function src(newValue,oldValue){if(newValue!==oldValue){this.localSrc=newValue||null;}}},methods:{onImgError:function onImgError(event){this.localSrc=null;this.$emit(EVENT_NAME_IMG_ERROR,event);},onClick:function onClick(event){this.$emit(EVENT_NAME_CLICK,event);}},render:function render(h){var _class2;var variant=this.computedVariant,disabled=this.disabled,rounded=this.computedRounded,icon=this.icon,src=this.localSrc,text=this.text,fontStyle=this.fontStyle,marginStyle=this.marginStyle,size=this.computedSize,button=this.button,type=this.buttonType,badge=this.badge,badgeVariant=this.badgeVariant,badgeStyle=this.badgeStyle;var link=!button&&isLink$1(this);var tag=button?BButton:link?BLink:'span';var alt=this.alt;var ariaLabel=this.ariaLabel||null;var $content=null;if(this.hasNormalizedSlot()){// Default slot overrides props\n$content=h('span',{staticClass:'b-avatar-custom'},[this.normalizeSlot()]);}else if(src){$content=h('img',{style:variant?{}:{width:'100%',height:'100%'},attrs:{src:src,alt:alt},on:{error:this.onImgError}});$content=h('span',{staticClass:'b-avatar-img'},[$content]);}else if(icon){$content=h(BIcon,{props:{icon:icon},attrs:{'aria-hidden':'true',alt:alt}});}else if(text){$content=h('span',{staticClass:'b-avatar-text',style:fontStyle},[h('span',text)]);}else{// Fallback default avatar content\n$content=h(BIconPersonFill,{attrs:{'aria-hidden':'true',alt:alt}});}var $badge=h();var hasBadgeSlot=this.hasNormalizedSlot(SLOT_NAME_BADGE);if(badge||badge===''||hasBadgeSlot){var badgeText=badge===true?'':badge;$badge=h('span',{staticClass:'b-avatar-badge',class:_defineProperty({},\"badge-\".concat(badgeVariant),badgeVariant),style:badgeStyle},[hasBadgeSlot?this.normalizeSlot(SLOT_NAME_BADGE):badgeText]);}var componentData={staticClass:CLASS_NAME$2,class:(_class2={},_defineProperty(_class2,\"\".concat(CLASS_NAME$2,\"-\").concat(size),size&&SIZES.indexOf(size)!==-1),_defineProperty(_class2,\"badge-\".concat(variant),!button&&variant),_defineProperty(_class2,\"rounded\",rounded===true),_defineProperty(_class2,\"rounded-\".concat(rounded),rounded&&rounded!==true),_defineProperty(_class2,\"disabled\",disabled),_class2),style:_objectSpread2$3(_objectSpread2$3({},marginStyle),{},{width:size,height:size}),attrs:{'aria-label':ariaLabel||null},props:button?{variant:variant,disabled:disabled,type:type}:link?pluckProps(linkProps$6,this):{},on:button||link?{click:this.onClick}:{}};return h(tag,componentData,[$content,$badge]);}});var props$2c=makePropsConfigurable({overlap:makeProp(PROP_TYPE_NUMBER_STRING,0.3),// Child avatars will prefer this prop (if set) over their own\nrounded:makeProp(PROP_TYPE_BOOLEAN_STRING,false),// Child avatars will always use this over their own size\nsize:makeProp(PROP_TYPE_STRING),// Child avatars will prefer this prop (if set) over their own\nsquare:makeProp(PROP_TYPE_BOOLEAN,false),tag:makeProp(PROP_TYPE_STRING,'div'),// Child avatars will prefer this variant over their own\nvariant:makeProp(PROP_TYPE_STRING)},NAME_AVATAR_GROUP);// --- Main component ---\n// @vue/component\nvar BAvatarGroup=/*#__PURE__*/Vue__default['default'].extend({name:NAME_AVATAR_GROUP,mixins:[normalizeSlotMixin],provide:function provide(){return{bvAvatarGroup:this};},props:props$2c,computed:{computedSize:function computedSize(){return computeSize(this.size);},overlapScale:function overlapScale(){return mathMin(mathMax(toFloat(this.overlap,0),0),1)/2;},paddingStyle:function paddingStyle(){var value=this.computedSize;value=value?\"calc(\".concat(value,\" * \").concat(this.overlapScale,\")\"):null;return value?{paddingLeft:value,paddingRight:value}:{};}},render:function render(h){var $inner=h('div',{staticClass:'b-avatar-group-inner',style:this.paddingStyle},this.normalizeSlot());return h(this.tag,{staticClass:'b-avatar-group',attrs:{role:'group'}},[$inner]);}});var AvatarPlugin=/*#__PURE__*/pluginFactory({components:{BAvatar:BAvatar,BAvatarGroup:BAvatarGroup}});var linkProps$5=omit(props$2f,['event','routerTag']);delete linkProps$5.href.default;delete linkProps$5.to.default;var props$2b=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},linkProps$5),{},{pill:makeProp(PROP_TYPE_BOOLEAN,false),tag:makeProp(PROP_TYPE_STRING,'span'),variant:makeProp(PROP_TYPE_STRING,'secondary')})),NAME_BADGE);// --- Main component ---\n// @vue/component\nvar BBadge=/*#__PURE__*/Vue__default['default'].extend({name:NAME_BADGE,functional:true,props:props$2b,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var active=props.active,disabled=props.disabled;var link=isLink$1(props);var tag=link?BLink:props.tag;var variant=props.variant||'secondary';return h(tag,a(data,{staticClass:'badge',class:[\"badge-\".concat(variant),{'badge-pill':props.pill,active:active,disabled:disabled}],props:link?pluckProps(linkProps$5,props):{}}),children);}});var BadgePlugin=/*#__PURE__*/pluginFactory({components:{BBadge:BBadge}});var stripTags=function stripTags(){var text=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'';return String(text).replace(RX_HTML_TAGS,'');};// Generate a `domProps` object for either `innerHTML`, `textContent` or an empty object\nvar htmlOrText=function htmlOrText(innerHTML,textContent){return innerHTML?{innerHTML:innerHTML}:textContent?{textContent:textContent}:{};};var props$2a=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},omit(props$2f,['event','routerTag'])),{},{ariaCurrent:makeProp(PROP_TYPE_STRING,'location'),html:makeProp(PROP_TYPE_STRING),text:makeProp(PROP_TYPE_STRING)})),NAME_BREADCRUMB_LINK);// --- Main component ---\n// @vue/component\nvar BBreadcrumbLink=/*#__PURE__*/Vue__default['default'].extend({name:NAME_BREADCRUMB_LINK,functional:true,props:props$2a,render:function render(h,_ref){var suppliedProps=_ref.props,data=_ref.data,children=_ref.children;var active=suppliedProps.active;var tag=active?'span':BLink;var componentData={attrs:{'aria-current':active?suppliedProps.ariaCurrent:null},props:pluckProps(props$2a,suppliedProps)};if(!children){componentData.domProps=htmlOrText(suppliedProps.html,suppliedProps.text);}return h(tag,a(data,componentData),children);}});var props$29=makePropsConfigurable(props$2a,NAME_BREADCRUMB_ITEM);// --- Main component ---\n// @vue/component\nvar BBreadcrumbItem=/*#__PURE__*/Vue__default['default'].extend({name:NAME_BREADCRUMB_ITEM,functional:true,props:props$29,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h('li',a(data,{staticClass:'breadcrumb-item',class:{active:props.active}}),[h(BBreadcrumbLink,{props:props},children)]);}});var props$28=makePropsConfigurable({items:makeProp(PROP_TYPE_ARRAY)},NAME_BREADCRUMB);// --- Main component ---\n// @vue/component\nvar BBreadcrumb=/*#__PURE__*/Vue__default['default'].extend({name:NAME_BREADCRUMB,functional:true,props:props$28,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var items=props.items;// Build child nodes from items, if given\nvar childNodes=children;if(isArray(items)){var activeDefined=false;childNodes=items.map(function(item,idx){if(!isObject(item)){item={text:toString(item)};}// Copy the value here so we can normalize it\nvar _item=item,active=_item.active;if(active){activeDefined=true;}// Auto-detect active by position in list\nif(!active&&!activeDefined){active=idx+1===items.length;}return h(BBreadcrumbItem,{props:_objectSpread2$3(_objectSpread2$3({},item),{},{active:active})});});}return h('ol',a(data,{staticClass:'breadcrumb'}),childNodes);}});var BreadcrumbPlugin=/*#__PURE__*/pluginFactory({components:{BBreadcrumb:BBreadcrumb,BBreadcrumbItem:BBreadcrumbItem,BBreadcrumbLink:BBreadcrumbLink}});var ButtonPlugin=/*#__PURE__*/pluginFactory({components:{BButton:BButton,BBtn:BButton,BButtonClose:BButtonClose,BBtnClose:BButtonClose}});var props$27=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},pick$1(props$2e,['size'])),{},{ariaRole:makeProp(PROP_TYPE_STRING,'group'),size:makeProp(PROP_TYPE_STRING),tag:makeProp(PROP_TYPE_STRING,'div'),vertical:makeProp(PROP_TYPE_BOOLEAN,false)})),NAME_BUTTON_GROUP);// --- Main component ---\n// @vue/component\nvar BButtonGroup=/*#__PURE__*/Vue__default['default'].extend({name:NAME_BUTTON_GROUP,functional:true,props:props$27,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,a(data,{class:_defineProperty({'btn-group':!props.vertical,'btn-group-vertical':props.vertical},\"btn-group-\".concat(props.size),props.size),attrs:{role:props.ariaRole}}),children);}});var ButtonGroupPlugin=/*#__PURE__*/pluginFactory({components:{BButtonGroup:BButtonGroup,BBtnGroup:BButtonGroup}});var ITEM_SELECTOR=['.btn:not(.disabled):not([disabled]):not(.dropdown-item)','.form-control:not(.disabled):not([disabled])','select:not(.disabled):not([disabled])','input[type=\"checkbox\"]:not(.disabled)','input[type=\"radio\"]:not(.disabled)'].join(',');// --- Props ---\nvar props$26=makePropsConfigurable({justify:makeProp(PROP_TYPE_BOOLEAN,false),keyNav:makeProp(PROP_TYPE_BOOLEAN,false)},NAME_BUTTON_TOOLBAR);// --- Main component ---\n// @vue/component\nvar BButtonToolbar=/*#__PURE__*/Vue__default['default'].extend({name:NAME_BUTTON_TOOLBAR,mixins:[normalizeSlotMixin],props:props$26,mounted:function mounted(){// Pre-set the tabindexes if the markup does not include\n// `tabindex=\"-1\"` on the toolbar items\nif(this.keyNav){this.getItems();}},methods:{getItems:function getItems(){var items=selectAll(ITEM_SELECTOR,this.$el);// Ensure `tabindex=\"-1\"` is set on every item\nitems.forEach(function(item){item.tabIndex=-1;});return items.filter(function(el){return isVisible(el);});},focusFirst:function focusFirst(){var items=this.getItems();attemptFocus(items[0]);},focusPrev:function focusPrev(event){var items=this.getItems();var index=items.indexOf(event.target);if(index>-1){items=items.slice(0,index).reverse();attemptFocus(items[0]);}},focusNext:function focusNext(event){var items=this.getItems();var index=items.indexOf(event.target);if(index>-1){items=items.slice(index+1);attemptFocus(items[0]);}},focusLast:function focusLast(){var items=this.getItems().reverse();attemptFocus(items[0]);},onFocusin:function onFocusin(event){var $el=this.$el;if(event.target===$el&&!contains($el,event.relatedTarget)){stopEvent(event);this.focusFirst(event);}},onKeydown:function onKeydown(event){var keyCode=event.keyCode,shiftKey=event.shiftKey;if(keyCode===CODE_UP||keyCode===CODE_LEFT){stopEvent(event);shiftKey?this.focusFirst(event):this.focusPrev(event);}else if(keyCode===CODE_DOWN||keyCode===CODE_RIGHT){stopEvent(event);shiftKey?this.focusLast(event):this.focusNext(event);}}},render:function render(h){var keyNav=this.keyNav;return h('div',{staticClass:'btn-toolbar',class:{'justify-content-between':this.justify},attrs:{role:'toolbar',tabindex:keyNav?'0':null},on:keyNav?{focusin:this.onFocusin,keydown:this.onKeydown}:{}},[this.normalizeSlot()]);}});var ButtonToolbarPlugin=/*#__PURE__*/pluginFactory({components:{BButtonToolbar:BButtonToolbar,BBtnToolbar:BButtonToolbar}});var CALENDAR_GREGORY='gregory';var CALENDAR_LONG='long';var CALENDAR_NARROW='narrow';var CALENDAR_SHORT='short';var DATE_FORMAT_2_DIGIT='2-digit';var DATE_FORMAT_NUMERIC='numeric';// Create or clone a date (`new Date(...)` shortcut)\nvar createDate=function createDate(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _construct(Date,args);};// Parse a date sting, or Date object, into a Date object (with no time information)\nvar parseYMD=function parseYMD(date){if(isString(date)&&RX_DATE.test(date.trim())){var _date$split$map=date.split(RX_DATE_SPLIT).map(function(v){return toInteger(v,1);}),_date$split$map2=_slicedToArray(_date$split$map,3),year=_date$split$map2[0],month=_date$split$map2[1],day=_date$split$map2[2];return createDate(year,month-1,day);}else if(isDate(date)){return createDate(date.getFullYear(),date.getMonth(),date.getDate());}return null;};// Format a date object as `YYYY-MM-DD` format\nvar formatYMD=function formatYMD(date){date=parseYMD(date);if(!date){return null;}var year=date.getFullYear();var month=\"0\".concat(date.getMonth()+1).slice(-2);var day=\"0\".concat(date.getDate()).slice(-2);return\"\".concat(year,\"-\").concat(month,\"-\").concat(day);};// Given a locale (or locales), resolve the browser available locale\nvar resolveLocale=function resolveLocale(locales)/* istanbul ignore next */{var calendar=arguments.length>1&&arguments[1]!==undefined?arguments[1]:CALENDAR_GREGORY;locales=concat(locales).filter(identity);var fmt=new Intl.DateTimeFormat(locales,{calendar:calendar});return fmt.resolvedOptions().locale;};// Create a `Intl.DateTimeFormat` formatter function\nvar createDateFormatter=function createDateFormatter(locale,options)/* istanbul ignore next */{var dtf=new Intl.DateTimeFormat(locale,options);return dtf.format;};// Determine if two dates are the same date (ignoring time portion)\nvar datesEqual=function datesEqual(date1,date2){// Returns true of the date portion of two date objects are equal\n// We don't compare the time portion\nreturn formatYMD(date1)===formatYMD(date2);};// --- Date \"math\" utility methods (for BCalendar component mainly) ---\nvar firstDateOfMonth=function firstDateOfMonth(date){date=createDate(date);date.setDate(1);return date;};var lastDateOfMonth=function lastDateOfMonth(date){date=createDate(date);date.setMonth(date.getMonth()+1);date.setDate(0);return date;};var addYears=function addYears(date,numberOfYears){date=createDate(date);var month=date.getMonth();date.setFullYear(date.getFullYear()+numberOfYears);// Handle Feb 29th for leap years\nif(date.getMonth()!==month){date.setDate(0);}return date;};var oneMonthAgo=function oneMonthAgo(date){date=createDate(date);var month=date.getMonth();date.setMonth(month-1);// Handle when days in month are different\nif(date.getMonth()===month){date.setDate(0);}return date;};var oneMonthAhead=function oneMonthAhead(date){date=createDate(date);var month=date.getMonth();date.setMonth(month+1);// Handle when days in month are different\nif(date.getMonth()===(month+2)%12){date.setDate(0);}return date;};var oneYearAgo=function oneYearAgo(date){return addYears(date,-1);};var oneYearAhead=function oneYearAhead(date){return addYears(date,1);};var oneDecadeAgo=function oneDecadeAgo(date){return addYears(date,-10);};var oneDecadeAhead=function oneDecadeAhead(date){return addYears(date,10);};// Helper function to constrain a date between two values\n// Always returns a `Date` object or `null` if no date passed\nvar constrainDate=function constrainDate(date){var min=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;var max=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;// Ensure values are `Date` objects (or `null`)\ndate=parseYMD(date);min=parseYMD(min)||date;max=parseYMD(max)||date;// Return a new `Date` object (or `null`)\nreturn date?date<min?min:date>max?max:date:null;};// Localization utilities\nvar RTL_LANGS=['ar','az','ckb','fa','he','ks','lrc','mzn','ps','sd','te','ug','ur','yi'].map(function(locale){return locale.toLowerCase();});// Returns true if the locale is RTL\nvar isLocaleRTL=function isLocaleRTL(locale){// Determines if the locale is RTL (only single locale supported)\nvar parts=toString(locale).toLowerCase().replace(RX_STRIP_LOCALE_MODS,'').split('-');var locale1=parts.slice(0,2).join('-');var locale2=parts[0];return arrayIncludes(RTL_LANGS,locale1)||arrayIncludes(RTL_LANGS,locale2);};// SSR safe client-side ID attribute generation\nvar props$25={id:makeProp(PROP_TYPE_STRING)};// --- Mixin ---\n// @vue/component\nvar idMixin=Vue__default['default'].extend({props:props$25,data:function data(){return{localId_:null};},computed:{safeId:function safeId(){// Computed property that returns a dynamic function for creating the ID\n// Reacts to changes in both `.id` and `.localId_` and regenerates a new function\nvar id=this.id||this.localId_;// We return a function that accepts an optional suffix string\n// So this computed prop looks and works like a method\n// but benefits from Vue's computed prop caching\nvar fn=function fn(suffix){if(!id){return null;}suffix=String(suffix||'').replace(/\\s+/g,'_');return suffix?id+'_'+suffix:id;};return fn;}},mounted:function mounted(){var _this=this;// `mounted()` only occurs client-side\nthis.$nextTick(function(){// Update DOM with auto-generated ID after mount\n// to prevent SSR hydration errors\n_this.localId_=\"__BVID__\".concat(_this[COMPONENT_UID_KEY]);});}});var _watch$j;var _makeModelMixin$j=makeModelMixin('value',{type:PROP_TYPE_DATE_STRING}),modelMixin$i=_makeModelMixin$j.mixin,modelProps$i=_makeModelMixin$j.props,MODEL_PROP_NAME$i=_makeModelMixin$j.prop,MODEL_EVENT_NAME$i=_makeModelMixin$j.event;// --- Props ---\nvar props$24=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),modelProps$i),{},{ariaControls:makeProp(PROP_TYPE_STRING),// Makes calendar the full width of its parent container\nblock:makeProp(PROP_TYPE_BOOLEAN,false),dateDisabledFn:makeProp(PROP_TYPE_FUNCTION),// `Intl.DateTimeFormat` object\ndateFormatOptions:makeProp(PROP_TYPE_OBJECT,{year:DATE_FORMAT_NUMERIC,month:CALENDAR_LONG,day:DATE_FORMAT_NUMERIC,weekday:CALENDAR_LONG}),// Function to set a class of (classes) on the date cell\n// if passed a string or an array\n// TODO:\n//   If the function returns an object, look for class prop for classes,\n//   and other props for handling events/details/descriptions\ndateInfoFn:makeProp(PROP_TYPE_FUNCTION),// 'ltr', 'rtl', or `null` (for auto detect)\ndirection:makeProp(PROP_TYPE_STRING),disabled:makeProp(PROP_TYPE_BOOLEAN,false),headerTag:makeProp(PROP_TYPE_STRING,'header'),// When `true`, renders a comment node, but keeps the component instance active\n// Mainly for <b-form-date>, so that we can get the component's value and locale\n// But we might just use separate date formatters, using the resolved locale\n// (adjusted for the gregorian calendar)\nhidden:makeProp(PROP_TYPE_BOOLEAN,false),// When `true` makes the selected date header `sr-only`\nhideHeader:makeProp(PROP_TYPE_BOOLEAN,false),// This specifies the calendar year/month/day that will be shown when\n// first opening the datepicker if no v-model value is provided\n// Default is the current date (or `min`/`max`)\ninitialDate:makeProp(PROP_TYPE_DATE_STRING),// Labels for buttons and keyboard shortcuts\nlabelCalendar:makeProp(PROP_TYPE_STRING,'Calendar'),labelCurrentMonth:makeProp(PROP_TYPE_STRING,'Current month'),labelHelp:makeProp(PROP_TYPE_STRING,'Use cursor keys to navigate calendar dates'),labelNav:makeProp(PROP_TYPE_STRING,'Calendar navigation'),labelNextDecade:makeProp(PROP_TYPE_STRING,'Next decade'),labelNextMonth:makeProp(PROP_TYPE_STRING,'Next month'),labelNextYear:makeProp(PROP_TYPE_STRING,'Next year'),labelNoDateSelected:makeProp(PROP_TYPE_STRING,'No date selected'),labelPrevDecade:makeProp(PROP_TYPE_STRING,'Previous decade'),labelPrevMonth:makeProp(PROP_TYPE_STRING,'Previous month'),labelPrevYear:makeProp(PROP_TYPE_STRING,'Previous year'),labelSelected:makeProp(PROP_TYPE_STRING,'Selected date'),labelToday:makeProp(PROP_TYPE_STRING,'Today'),// Locale(s) to use\n// Default is to use page/browser default setting\nlocale:makeProp(PROP_TYPE_ARRAY_STRING),max:makeProp(PROP_TYPE_DATE_STRING),min:makeProp(PROP_TYPE_DATE_STRING),// Variant color to use for the navigation buttons\nnavButtonVariant:makeProp(PROP_TYPE_STRING,'secondary'),// Disable highlighting today's date\nnoHighlightToday:makeProp(PROP_TYPE_BOOLEAN,false),noKeyNav:makeProp(PROP_TYPE_BOOLEAN,false),readonly:makeProp(PROP_TYPE_BOOLEAN,false),roleDescription:makeProp(PROP_TYPE_STRING),// Variant color to use for the selected date\nselectedVariant:makeProp(PROP_TYPE_STRING,'primary'),// When `true` enables the decade navigation buttons\nshowDecadeNav:makeProp(PROP_TYPE_BOOLEAN,false),// Day of week to start calendar on\n// `0` (Sunday), `1` (Monday), ... `6` (Saturday)\nstartWeekday:makeProp(PROP_TYPE_NUMBER_STRING,0),// Variant color to use for today's date (defaults to `selectedVariant`)\ntodayVariant:makeProp(PROP_TYPE_STRING),// Always return the `v-model` value as a date object\nvalueAsDate:makeProp(PROP_TYPE_BOOLEAN,false),// Format of the weekday names at the top of the calendar\n// `short` is typically a 3 letter abbreviation,\n// `narrow` is typically a single letter\n// `long` is the full week day name\n// Although some locales may override this (i.e `ar`, etc.)\nweekdayHeaderFormat:makeProp(PROP_TYPE_STRING,CALENDAR_SHORT,function(value){return arrayIncludes([CALENDAR_LONG,CALENDAR_SHORT,CALENDAR_NARROW],value);}),// Has no effect if prop `block` is set\nwidth:makeProp(PROP_TYPE_STRING,'270px')})),NAME_CALENDAR);// --- Main component ---\n// @vue/component\nvar BCalendar=Vue__default['default'].extend({name:NAME_CALENDAR,// Mixin order is important!\nmixins:[attrsMixin,idMixin,modelMixin$i,normalizeSlotMixin],props:props$24,data:function data(){var selected=formatYMD(this[MODEL_PROP_NAME$i])||'';return{// Selected date\nselectedYMD:selected,// Date in calendar grid that has `tabindex` of `0`\nactiveYMD:selected||formatYMD(constrainDate(this.initialDate||this.getToday()),this.min,this.max),// Will be true if the calendar grid has/contains focus\ngridHasFocus:false,// Flag to enable the `aria-live` region(s) after mount\n// to prevent screen reader \"outbursts\" when mounting\nisLive:false};},computed:{valueId:function valueId(){return this.safeId();},widgetId:function widgetId(){return this.safeId('_calendar-wrapper_');},navId:function navId(){return this.safeId('_calendar-nav_');},gridId:function gridId(){return this.safeId('_calendar-grid_');},gridCaptionId:function gridCaptionId(){return this.safeId('_calendar-grid-caption_');},gridHelpId:function gridHelpId(){return this.safeId('_calendar-grid-help_');},activeId:function activeId(){return this.activeYMD?this.safeId(\"_cell-\".concat(this.activeYMD,\"_\")):null;},// TODO: Use computed props to convert `YYYY-MM-DD` to `Date` object\nselectedDate:function selectedDate(){// Selected as a `Date` object\nreturn parseYMD(this.selectedYMD);},activeDate:function activeDate(){// Active as a `Date` object\nreturn parseYMD(this.activeYMD);},computedMin:function computedMin(){return parseYMD(this.min);},computedMax:function computedMax(){return parseYMD(this.max);},computedWeekStarts:function computedWeekStarts(){// `startWeekday` is a prop (constrained to `0` through `6`)\nreturn mathMax(toInteger(this.startWeekday,0),0)%7;},computedLocale:function computedLocale(){// Returns the resolved locale used by the calendar\nreturn resolveLocale(concat(this.locale).filter(identity),CALENDAR_GREGORY);},computedDateDisabledFn:function computedDateDisabledFn(){var dateDisabledFn=this.dateDisabledFn;return hasPropFunction(dateDisabledFn)?dateDisabledFn:function(){return false;};},// TODO: Change `dateInfoFn` to handle events and notes as well as classes\ncomputedDateInfoFn:function computedDateInfoFn(){var dateInfoFn=this.dateInfoFn;return hasPropFunction(dateInfoFn)?dateInfoFn:function(){return{};};},calendarLocale:function calendarLocale(){// This locale enforces the gregorian calendar (for use in formatter functions)\n// Needed because IE 11 resolves `ar-IR` as islamic-civil calendar\n// and IE 11 (and some other browsers) do not support the `calendar` option\n// And we currently only support the gregorian calendar\nvar fmt=new Intl.DateTimeFormat(this.computedLocale,{calendar:CALENDAR_GREGORY});var calendar=fmt.resolvedOptions().calendar;var locale=fmt.resolvedOptions().locale;/* istanbul ignore if: mainly for IE 11 and a few other browsers, hard to test in JSDOM */if(calendar!==CALENDAR_GREGORY){// Ensure the locale requests the gregorian calendar\n// Mainly for IE 11, and currently we can't handle non-gregorian calendars\n// TODO: Should we always return this value?\nlocale=locale.replace(/-u-.+$/i,'').concat('-u-ca-gregory');}return locale;},calendarYear:function calendarYear(){return this.activeDate.getFullYear();},calendarMonth:function calendarMonth(){return this.activeDate.getMonth();},calendarFirstDay:function calendarFirstDay(){// We set the time for this date to 12pm to work around\n// date formatting issues in Firefox and Safari\n// See: https://github.com/bootstrap-vue/bootstrap-vue/issues/5818\nreturn createDate(this.calendarYear,this.calendarMonth,1,12);},calendarDaysInMonth:function calendarDaysInMonth(){// We create a new date as to not mutate the original\nvar date=createDate(this.calendarFirstDay);date.setMonth(date.getMonth()+1,0);return date.getDate();},computedVariant:function computedVariant(){return\"btn-\".concat(this.selectedVariant||'primary');},computedTodayVariant:function computedTodayVariant(){return\"btn-outline-\".concat(this.todayVariant||this.selectedVariant||'primary');},computedNavButtonVariant:function computedNavButtonVariant(){return\"btn-outline-\".concat(this.navButtonVariant||'primary');},isRTL:function isRTL(){// `true` if the language requested is RTL\nvar dir=toString(this.direction).toLowerCase();if(dir==='rtl'){/* istanbul ignore next */return true;}else if(dir==='ltr'){/* istanbul ignore next */return false;}return isLocaleRTL(this.computedLocale);},context:function context(){var selectedYMD=this.selectedYMD,activeYMD=this.activeYMD;var selectedDate=parseYMD(selectedYMD);var activeDate=parseYMD(activeYMD);return{// The current value of the `v-model`\nselectedYMD:selectedYMD,selectedDate:selectedDate,selectedFormatted:selectedDate?this.formatDateString(selectedDate):this.labelNoDateSelected,// Which date cell is considered active due to navigation\nactiveYMD:activeYMD,activeDate:activeDate,activeFormatted:activeDate?this.formatDateString(activeDate):'',// `true` if the date is disabled (when using keyboard navigation)\ndisabled:this.dateDisabled(activeDate),// Locales used in formatting dates\nlocale:this.computedLocale,calendarLocale:this.calendarLocale,rtl:this.isRTL};},// Computed props that return a function reference\ndateOutOfRange:function dateOutOfRange(){// Check whether a date is within the min/max range\n// Returns a new function ref if the pops change\n// We do this as we need to trigger the calendar computed prop\n// to update when these props update\nvar min=this.computedMin,max=this.computedMax;return function(date){// Handle both `YYYY-MM-DD` and `Date` objects\ndate=parseYMD(date);return min&&date<min||max&&date>max;};},dateDisabled:function dateDisabled(){var _this=this;// Returns a function for validating if a date is within range\n// We grab this variables first to ensure a new function ref\n// is generated when the props value changes\n// We do this as we need to trigger the calendar computed prop\n// to update when these props update\nvar rangeFn=this.dateOutOfRange;// Return the function ref\nreturn function(date){// Handle both `YYYY-MM-DD` and `Date` objects\ndate=parseYMD(date);var ymd=formatYMD(date);return!!(rangeFn(date)||_this.computedDateDisabledFn(ymd,date));};},// Computed props that return date formatter functions\nformatDateString:function formatDateString(){// Returns a date formatter function\nreturn createDateFormatter(this.calendarLocale,_objectSpread2$3(_objectSpread2$3({// Ensure we have year, month, day shown for screen readers/ARIA\n// If users really want to leave one of these out, they can\n// pass `undefined` for the property value\nyear:DATE_FORMAT_NUMERIC,month:DATE_FORMAT_2_DIGIT,day:DATE_FORMAT_2_DIGIT},this.dateFormatOptions),{},{// Ensure hours/minutes/seconds are not shown\n// As we do not support the time portion (yet)\nhour:undefined,minute:undefined,second:undefined,// Ensure calendar is gregorian\ncalendar:CALENDAR_GREGORY}));},formatYearMonth:function formatYearMonth(){// Returns a date formatter function\nreturn createDateFormatter(this.calendarLocale,{year:DATE_FORMAT_NUMERIC,month:CALENDAR_LONG,calendar:CALENDAR_GREGORY});},formatWeekdayName:function formatWeekdayName(){// Long weekday name for weekday header aria-label\nreturn createDateFormatter(this.calendarLocale,{weekday:CALENDAR_LONG,calendar:CALENDAR_GREGORY});},formatWeekdayNameShort:function formatWeekdayNameShort(){// Weekday header cell format\n// defaults to 'short' 3 letter days, where possible\nreturn createDateFormatter(this.calendarLocale,{weekday:this.weekdayHeaderFormat||CALENDAR_SHORT,calendar:CALENDAR_GREGORY});},formatDay:function formatDay(){// Calendar grid day number formatter\n// We don't use DateTimeFormatter here as it can place extra\n// character(s) after the number (i.e the `zh` locale)\nvar nf=new Intl.NumberFormat([this.computedLocale],{style:'decimal',minimumIntegerDigits:1,minimumFractionDigits:0,maximumFractionDigits:0,notation:'standard'});// Return a formatter function instance\nreturn function(date){return nf.format(date.getDate());};},// Disabled states for the nav buttons\nprevDecadeDisabled:function prevDecadeDisabled(){var min=this.computedMin;return this.disabled||min&&lastDateOfMonth(oneDecadeAgo(this.activeDate))<min;},prevYearDisabled:function prevYearDisabled(){var min=this.computedMin;return this.disabled||min&&lastDateOfMonth(oneYearAgo(this.activeDate))<min;},prevMonthDisabled:function prevMonthDisabled(){var min=this.computedMin;return this.disabled||min&&lastDateOfMonth(oneMonthAgo(this.activeDate))<min;},thisMonthDisabled:function thisMonthDisabled(){// TODO: We could/should check if today is out of range\nreturn this.disabled;},nextMonthDisabled:function nextMonthDisabled(){var max=this.computedMax;return this.disabled||max&&firstDateOfMonth(oneMonthAhead(this.activeDate))>max;},nextYearDisabled:function nextYearDisabled(){var max=this.computedMax;return this.disabled||max&&firstDateOfMonth(oneYearAhead(this.activeDate))>max;},nextDecadeDisabled:function nextDecadeDisabled(){var max=this.computedMax;return this.disabled||max&&firstDateOfMonth(oneDecadeAhead(this.activeDate))>max;},// Calendar dates generation\ncalendar:function calendar(){var matrix=[];var firstDay=this.calendarFirstDay;var calendarYear=firstDay.getFullYear();var calendarMonth=firstDay.getMonth();var daysInMonth=this.calendarDaysInMonth;var startIndex=firstDay.getDay();// `0`..`6`\nvar weekOffset=(this.computedWeekStarts>startIndex?7:0)-this.computedWeekStarts;// Build the calendar matrix\nvar currentDay=0-weekOffset-startIndex;for(var week=0;week<6&&currentDay<daysInMonth;week++){// For each week\nmatrix[week]=[];// The following could be a map function\nfor(var j=0;j<7;j++){// For each day in week\ncurrentDay++;var date=createDate(calendarYear,calendarMonth,currentDay);var month=date.getMonth();var dayYMD=formatYMD(date);var dayDisabled=this.dateDisabled(date);// TODO: This could be a normalizer method\nvar dateInfo=this.computedDateInfoFn(dayYMD,parseYMD(dayYMD));dateInfo=isString(dateInfo)||isArray(dateInfo)?/* istanbul ignore next */{class:dateInfo}:isPlainObject(dateInfo)?_objectSpread2$3({class:''},dateInfo):/* istanbul ignore next */{class:''};matrix[week].push({ymd:dayYMD,// Cell content\nday:this.formatDay(date),label:this.formatDateString(date),// Flags for styling\nisThisMonth:month===calendarMonth,isDisabled:dayDisabled,// TODO: Handle other dateInfo properties such as notes/events\ninfo:dateInfo});}}return matrix;},calendarHeadings:function calendarHeadings(){var _this2=this;return this.calendar[0].map(function(d){return{text:_this2.formatWeekdayNameShort(parseYMD(d.ymd)),label:_this2.formatWeekdayName(parseYMD(d.ymd))};});}},watch:(_watch$j={},_defineProperty(_watch$j,MODEL_PROP_NAME$i,function(newValue,oldValue){var selected=formatYMD(newValue)||'';var old=formatYMD(oldValue)||'';if(!datesEqual(selected,old)){this.activeYMD=selected||this.activeYMD;this.selectedYMD=selected;}}),_defineProperty(_watch$j,\"selectedYMD\",function selectedYMD(newYMD,oldYMD){// TODO:\n//   Should we compare to `formatYMD(this.value)` and emit\n//   only if they are different?\nif(newYMD!==oldYMD){this.$emit(MODEL_EVENT_NAME$i,this.valueAsDate?parseYMD(newYMD)||null:newYMD||'');}}),_defineProperty(_watch$j,\"context\",function context(newValue,oldValue){if(!looseEqual(newValue,oldValue)){this.$emit(EVENT_NAME_CONTEXT,newValue);}}),_defineProperty(_watch$j,\"hidden\",function hidden(newValue){// Reset the active focused day when hidden\nthis.activeYMD=this.selectedYMD||formatYMD(this[MODEL_PROP_NAME$i]||this.constrainDate(this.initialDate||this.getToday()));// Enable/disable the live regions\nthis.setLive(!newValue);}),_watch$j),created:function created(){var _this3=this;this.$nextTick(function(){_this3.$emit(EVENT_NAME_CONTEXT,_this3.context);});},mounted:function mounted(){this.setLive(true);},/* istanbul ignore next */activated:function activated(){this.setLive(true);},/* istanbul ignore next */deactivated:function deactivated(){this.setLive(false);},beforeDestroy:function beforeDestroy(){this.setLive(false);},methods:{// Public method(s)\nfocus:function focus(){if(!this.disabled){attemptFocus(this.$refs.grid);}},blur:function blur(){if(!this.disabled){attemptBlur(this.$refs.grid);}},// Private methods\nsetLive:function setLive(on){var _this4=this;if(on){this.$nextTick(function(){requestAF(function(){_this4.isLive=true;});});}else{this.isLive=false;}},getToday:function getToday(){return parseYMD(createDate());},constrainDate:function constrainDate$1(date){// Constrains a date between min and max\n// returns a new `Date` object instance\nreturn constrainDate(date,this.computedMin,this.computedMax);},emitSelected:function emitSelected(date){var _this5=this;// Performed in a `$nextTick()` to (probably) ensure\n// the input event has emitted first\nthis.$nextTick(function(){_this5.$emit(EVENT_NAME_SELECTED,formatYMD(date)||'',parseYMD(date)||null);});},// Event handlers\nsetGridFocusFlag:function setGridFocusFlag(event){// Sets the gridHasFocus flag to make date \"button\" look focused\nthis.gridHasFocus=!this.disabled&&event.type==='focus';},onKeydownWrapper:function onKeydownWrapper(event){// Calendar keyboard navigation\n// Handles PAGEUP/PAGEDOWN/END/HOME/LEFT/UP/RIGHT/DOWN\n// Focuses grid after updating\nif(this.noKeyNav){/* istanbul ignore next */return;}var altKey=event.altKey,ctrlKey=event.ctrlKey,keyCode=event.keyCode;if(!arrayIncludes([CODE_PAGEUP,CODE_PAGEDOWN,CODE_END,CODE_HOME,CODE_LEFT,CODE_UP,CODE_RIGHT,CODE_DOWN],keyCode)){/* istanbul ignore next */return;}stopEvent(event);var activeDate=createDate(this.activeDate);var checkDate=createDate(this.activeDate);var day=activeDate.getDate();var constrainedToday=this.constrainDate(this.getToday());var isRTL=this.isRTL;if(keyCode===CODE_PAGEUP){// PAGEUP - Previous month/year\nactiveDate=(altKey?ctrlKey?oneDecadeAgo:oneYearAgo:oneMonthAgo)(activeDate);// We check the first day of month to be in rage\ncheckDate=createDate(activeDate);checkDate.setDate(1);}else if(keyCode===CODE_PAGEDOWN){// PAGEDOWN - Next month/year\nactiveDate=(altKey?ctrlKey?oneDecadeAhead:oneYearAhead:oneMonthAhead)(activeDate);// We check the last day of month to be in rage\ncheckDate=createDate(activeDate);checkDate.setMonth(checkDate.getMonth()+1);checkDate.setDate(0);}else if(keyCode===CODE_LEFT){// LEFT - Previous day (or next day for RTL)\nactiveDate.setDate(day+(isRTL?1:-1));activeDate=this.constrainDate(activeDate);checkDate=activeDate;}else if(keyCode===CODE_RIGHT){// RIGHT - Next day (or previous day for RTL)\nactiveDate.setDate(day+(isRTL?-1:1));activeDate=this.constrainDate(activeDate);checkDate=activeDate;}else if(keyCode===CODE_UP){// UP - Previous week\nactiveDate.setDate(day-7);activeDate=this.constrainDate(activeDate);checkDate=activeDate;}else if(keyCode===CODE_DOWN){// DOWN - Next week\nactiveDate.setDate(day+7);activeDate=this.constrainDate(activeDate);checkDate=activeDate;}else if(keyCode===CODE_HOME){// HOME - Today\nactiveDate=constrainedToday;checkDate=activeDate;}else if(keyCode===CODE_END){// END - Selected date, or today if no selected date\nactiveDate=parseYMD(this.selectedDate)||constrainedToday;checkDate=activeDate;}if(!this.dateOutOfRange(checkDate)&&!datesEqual(activeDate,this.activeDate)){// We only jump to date if within min/max\n// We don't check for individual disabled dates though (via user function)\nthis.activeYMD=formatYMD(activeDate);}// Ensure grid is focused\nthis.focus();},onKeydownGrid:function onKeydownGrid(event){// Pressing enter/space on grid to select active date\nvar keyCode=event.keyCode;var activeDate=this.activeDate;if(keyCode===CODE_ENTER||keyCode===CODE_SPACE){stopEvent(event);if(!this.disabled&&!this.readonly&&!this.dateDisabled(activeDate)){this.selectedYMD=formatYMD(activeDate);this.emitSelected(activeDate);}// Ensure grid is focused\nthis.focus();}},onClickDay:function onClickDay(day){// Clicking on a date \"button\" to select it\nvar selectedDate=this.selectedDate,activeDate=this.activeDate;var clickedDate=parseYMD(day.ymd);if(!this.disabled&&!day.isDisabled&&!this.dateDisabled(clickedDate)){if(!this.readonly){// If readonly mode, we don't set the selected date, just the active date\n// If the clicked date is equal to the already selected date, we don't update the model\nthis.selectedYMD=formatYMD(datesEqual(clickedDate,selectedDate)?selectedDate:clickedDate);this.emitSelected(clickedDate);}this.activeYMD=formatYMD(datesEqual(clickedDate,activeDate)?activeDate:createDate(clickedDate));// Ensure grid is focused\nthis.focus();}},gotoPrevDecade:function gotoPrevDecade(){this.activeYMD=formatYMD(this.constrainDate(oneDecadeAgo(this.activeDate)));},gotoPrevYear:function gotoPrevYear(){this.activeYMD=formatYMD(this.constrainDate(oneYearAgo(this.activeDate)));},gotoPrevMonth:function gotoPrevMonth(){this.activeYMD=formatYMD(this.constrainDate(oneMonthAgo(this.activeDate)));},gotoCurrentMonth:function gotoCurrentMonth(){// TODO: Maybe this goto date should be configurable?\nthis.activeYMD=formatYMD(this.constrainDate(this.getToday()));},gotoNextMonth:function gotoNextMonth(){this.activeYMD=formatYMD(this.constrainDate(oneMonthAhead(this.activeDate)));},gotoNextYear:function gotoNextYear(){this.activeYMD=formatYMD(this.constrainDate(oneYearAhead(this.activeDate)));},gotoNextDecade:function gotoNextDecade(){this.activeYMD=formatYMD(this.constrainDate(oneDecadeAhead(this.activeDate)));},onHeaderClick:function onHeaderClick(){if(!this.disabled){this.activeYMD=this.selectedYMD||formatYMD(this.getToday());this.focus();}}},render:function render(h){var _this6=this;// If `hidden` prop is set, render just a placeholder node\nif(this.hidden){return h();}var valueId=this.valueId,widgetId=this.widgetId,navId=this.navId,gridId=this.gridId,gridCaptionId=this.gridCaptionId,gridHelpId=this.gridHelpId,activeId=this.activeId,disabled=this.disabled,noKeyNav=this.noKeyNav,isLive=this.isLive,isRTL=this.isRTL,activeYMD=this.activeYMD,selectedYMD=this.selectedYMD,safeId=this.safeId;var hideDecadeNav=!this.showDecadeNav;var todayYMD=formatYMD(this.getToday());var highlightToday=!this.noHighlightToday;// Header showing current selected date\nvar $header=h('output',{staticClass:'form-control form-control-sm text-center',class:{'text-muted':disabled,readonly:this.readonly||disabled},attrs:{id:valueId,for:gridId,role:'status',tabindex:disabled?null:'-1',// Mainly for testing purposes, as we do not know\n// the exact format `Intl` will format the date string\n'data-selected':toString(selectedYMD),// We wait until after mount to enable `aria-live`\n// to prevent initial announcement on page render\n'aria-live':isLive?'polite':'off','aria-atomic':isLive?'true':null},on:{// Transfer focus/click to focus grid\n// and focus active date (or today if no selection)\nclick:this.onHeaderClick,focus:this.onHeaderClick}},this.selectedDate?[// We use `bdi` elements here in case the label doesn't match the locale\n// Although IE 11 does not deal with <BDI> at all (equivalent to a span)\nh('bdi',{staticClass:'sr-only'},\" (\".concat(toString(this.labelSelected),\") \")),h('bdi',this.formatDateString(this.selectedDate))]:this.labelNoDateSelected||\"\\xA0\"// '&nbsp;'\n);$header=h(this.headerTag,{staticClass:'b-calendar-header',class:{'sr-only':this.hideHeader},attrs:{title:this.selectedDate?this.labelSelectedDate||null:null}},[$header]);// Content for the date navigation buttons\nvar navScope={isRTL:isRTL};var navProps={shiftV:0.5};var navPrevProps=_objectSpread2$3(_objectSpread2$3({},navProps),{},{flipH:isRTL});var navNextProps=_objectSpread2$3(_objectSpread2$3({},navProps),{},{flipH:!isRTL});var $prevDecadeIcon=this.normalizeSlot(SLOT_NAME_NAV_PEV_DECADE,navScope)||h(BIconChevronBarLeft,{props:navPrevProps});var $prevYearIcon=this.normalizeSlot(SLOT_NAME_NAV_PEV_YEAR,navScope)||h(BIconChevronDoubleLeft,{props:navPrevProps});var $prevMonthIcon=this.normalizeSlot(SLOT_NAME_NAV_PEV_MONTH,navScope)||h(BIconChevronLeft,{props:navPrevProps});var $thisMonthIcon=this.normalizeSlot(SLOT_NAME_NAV_THIS_MONTH,navScope)||h(BIconCircleFill,{props:navProps});var $nextMonthIcon=this.normalizeSlot(SLOT_NAME_NAV_NEXT_MONTH,navScope)||h(BIconChevronLeft,{props:navNextProps});var $nextYearIcon=this.normalizeSlot(SLOT_NAME_NAV_NEXT_YEAR,navScope)||h(BIconChevronDoubleLeft,{props:navNextProps});var $nextDecadeIcon=this.normalizeSlot(SLOT_NAME_NAV_NEXT_DECADE,navScope)||h(BIconChevronBarLeft,{props:navNextProps});// Utility to create the date navigation buttons\nvar makeNavBtn=function makeNavBtn(content,label,handler,btnDisabled,shortcut){return h('button',{staticClass:'btn btn-sm border-0 flex-fill',class:[_this6.computedNavButtonVariant,{disabled:btnDisabled}],attrs:{title:label||null,type:'button',tabindex:noKeyNav?'-1':null,'aria-label':label||null,'aria-disabled':btnDisabled?'true':null,'aria-keyshortcuts':shortcut||null},on:btnDisabled?{}:{click:handler}},[h('div',{attrs:{'aria-hidden':'true'}},[content])]);};// Generate the date navigation buttons\nvar $nav=h('div',{staticClass:'b-calendar-nav d-flex',attrs:{id:navId,role:'group',tabindex:noKeyNav?'-1':null,'aria-hidden':disabled?'true':null,'aria-label':this.labelNav||null,'aria-controls':gridId}},[hideDecadeNav?h():makeNavBtn($prevDecadeIcon,this.labelPrevDecade,this.gotoPrevDecade,this.prevDecadeDisabled,'Ctrl+Alt+PageDown'),makeNavBtn($prevYearIcon,this.labelPrevYear,this.gotoPrevYear,this.prevYearDisabled,'Alt+PageDown'),makeNavBtn($prevMonthIcon,this.labelPrevMonth,this.gotoPrevMonth,this.prevMonthDisabled,'PageDown'),makeNavBtn($thisMonthIcon,this.labelCurrentMonth,this.gotoCurrentMonth,this.thisMonthDisabled,'Home'),makeNavBtn($nextMonthIcon,this.labelNextMonth,this.gotoNextMonth,this.nextMonthDisabled,'PageUp'),makeNavBtn($nextYearIcon,this.labelNextYear,this.gotoNextYear,this.nextYearDisabled,'Alt+PageUp'),hideDecadeNav?h():makeNavBtn($nextDecadeIcon,this.labelNextDecade,this.gotoNextDecade,this.nextDecadeDisabled,'Ctrl+Alt+PageUp')]);// Caption for calendar grid\nvar $gridCaption=h('div',{staticClass:'b-calendar-grid-caption text-center font-weight-bold',class:{'text-muted':disabled},attrs:{id:gridCaptionId,'aria-live':isLive?'polite':null,'aria-atomic':isLive?'true':null},key:'grid-caption'},this.formatYearMonth(this.calendarFirstDay));// Calendar weekday headings\nvar $gridWeekDays=h('div',{staticClass:'b-calendar-grid-weekdays row no-gutters border-bottom',attrs:{'aria-hidden':'true'}},this.calendarHeadings.map(function(d,idx){return h('small',{staticClass:'col text-truncate',class:{'text-muted':disabled},attrs:{title:d.label===d.text?null:d.label,'aria-label':d.label},key:idx},d.text);}));// Calendar day grid\nvar $gridBody=this.calendar.map(function(week){var $cells=week.map(function(day,dIndex){var _class;var isSelected=day.ymd===selectedYMD;var isActive=day.ymd===activeYMD;var isToday=day.ymd===todayYMD;var idCell=safeId(\"_cell-\".concat(day.ymd,\"_\"));// \"fake\" button\nvar $btn=h('span',{staticClass:'btn border-0 rounded-circle text-nowrap',// Should we add some classes to signify if today/selected/etc?\nclass:(_class={// Give the fake button a focus ring\nfocus:isActive&&_this6.gridHasFocus,// Styling\ndisabled:day.isDisabled||disabled,active:isSelected},_defineProperty(_class,_this6.computedVariant,isSelected),_defineProperty(_class,_this6.computedTodayVariant,isToday&&highlightToday&&!isSelected&&day.isThisMonth),_defineProperty(_class,'btn-outline-light',!(isToday&&highlightToday)&&!isSelected&&!isActive),_defineProperty(_class,'btn-light',!(isToday&&highlightToday)&&!isSelected&&isActive),_defineProperty(_class,'text-muted',!day.isThisMonth&&!isSelected),_defineProperty(_class,'text-dark',!(isToday&&highlightToday)&&!isSelected&&!isActive&&day.isThisMonth),_defineProperty(_class,'font-weight-bold',(isSelected||day.isThisMonth)&&!day.isDisabled),_class),on:{click:function click(){return _this6.onClickDay(day);}}},day.day);return h('div',// Cell with button\n{staticClass:'col p-0',class:day.isDisabled?'bg-light':day.info.class||'',attrs:{id:idCell,role:'button','data-date':day.ymd,// Primarily for testing purposes\n// Only days in the month are presented as buttons to screen readers\n'aria-hidden':day.isThisMonth?null:'true','aria-disabled':day.isDisabled||disabled?'true':null,'aria-label':[day.label,isSelected?\"(\".concat(_this6.labelSelected,\")\"):null,isToday?\"(\".concat(_this6.labelToday,\")\"):null].filter(identity).join(' '),// NVDA doesn't convey `aria-selected`, but does `aria-current`,\n// ChromeVox doesn't convey `aria-current`, but does `aria-selected`,\n// so we set both attributes for robustness\n'aria-selected':isSelected?'true':null,'aria-current':isSelected?'date':null},key:dIndex},[$btn]);});// Return the week \"row\"\n// We use the first day of the weeks YMD value as a\n// key for efficient DOM patching / element re-use\nreturn h('div',{staticClass:'row no-gutters',key:week[0].ymd},$cells);});$gridBody=h('div',{// A key is only required on the body if we add in transition support\nstaticClass:'b-calendar-grid-body',style:disabled?{pointerEvents:'none'}:{}// key: this.activeYMD.slice(0, -3)\n},$gridBody);var $gridHelp=h('div',{staticClass:'b-calendar-grid-help border-top small text-muted text-center bg-light',attrs:{id:gridHelpId}},[h('div',{staticClass:'small'},this.labelHelp)]);var $grid=h('div',{staticClass:'b-calendar-grid form-control h-auto text-center',attrs:{id:gridId,role:'application',tabindex:noKeyNav?'-1':disabled?null:'0','data-month':activeYMD.slice(0,-3),// `YYYY-MM`, mainly for testing\n'aria-roledescription':this.labelCalendar||null,'aria-labelledby':gridCaptionId,'aria-describedby':gridHelpId,// `aria-readonly` is not considered valid on `role=\"application\"`\n// https://www.w3.org/TR/wai-aria-1.1/#aria-readonly\n// 'aria-readonly': this.readonly && !disabled ? 'true' : null,\n'aria-disabled':disabled?'true':null,'aria-activedescendant':activeId},on:{keydown:this.onKeydownGrid,focus:this.setGridFocusFlag,blur:this.setGridFocusFlag},ref:'grid'},[$gridCaption,$gridWeekDays,$gridBody,$gridHelp]);// Optional bottom slot\nvar $slot=this.normalizeSlot();$slot=$slot?h('footer',{staticClass:'b-calendar-footer'},$slot):h();var $widget=h('div',{staticClass:'b-calendar-inner',style:this.block?{}:{width:this.width},attrs:{id:widgetId,dir:isRTL?'rtl':'ltr',lang:this.computedLocale||null,role:'group','aria-disabled':disabled?'true':null,// If datepicker controls an input, this will specify the ID of the input\n'aria-controls':this.ariaControls||null,// This should be a prop (so it can be changed to Date picker, etc, localized\n'aria-roledescription':this.roleDescription||null,'aria-describedby':[// Should the attr (if present) go last?\n// Or should this attr be a prop?\nthis.bvAttrs['aria-describedby'],valueId,gridHelpId].filter(identity).join(' ')},on:{keydown:this.onKeydownWrapper}},[$header,$nav,$grid,$slot]);// Wrap in an outer div that can be styled\nreturn h('div',{staticClass:'b-calendar',class:{'d-block':this.block}},[$widget]);}});var CalendarPlugin=/*#__PURE__*/pluginFactory({components:{BCalendar:BCalendar}});var props$23=makePropsConfigurable({bgVariant:makeProp(PROP_TYPE_STRING),borderVariant:makeProp(PROP_TYPE_STRING),tag:makeProp(PROP_TYPE_STRING,'div'),textVariant:makeProp(PROP_TYPE_STRING)},NAME_CARD);// --- Mixin ---\n// @vue/component\nVue__default['default'].extend({props:props$23});var props$22=makePropsConfigurable({title:makeProp(PROP_TYPE_STRING),titleTag:makeProp(PROP_TYPE_STRING,'h4')},NAME_CARD_TITLE);// --- Main component ---\n// @vue/component\nvar BCardTitle=/*#__PURE__*/Vue__default['default'].extend({name:NAME_CARD_TITLE,functional:true,props:props$22,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.titleTag,a(data,{staticClass:'card-title'}),children||toString(props.title));}});var props$21=makePropsConfigurable({subTitle:makeProp(PROP_TYPE_STRING),subTitleTag:makeProp(PROP_TYPE_STRING,'h6'),subTitleTextVariant:makeProp(PROP_TYPE_STRING,'muted')},NAME_CARD_SUB_TITLE);// --- Main component ---\n// @vue/component\nvar BCardSubTitle=/*#__PURE__*/Vue__default['default'].extend({name:NAME_CARD_SUB_TITLE,functional:true,props:props$21,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.subTitleTag,a(data,{staticClass:'card-subtitle',class:[props.subTitleTextVariant?\"text-\".concat(props.subTitleTextVariant):null]}),children||toString(props.subTitle));}});var props$20=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$22),props$21),copyProps(props$23,prefixPropName.bind(null,'body'))),{},{bodyClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),overlay:makeProp(PROP_TYPE_BOOLEAN,false)})),NAME_CARD_BODY);// --- Main component ---\n// @vue/component\nvar BCardBody=/*#__PURE__*/Vue__default['default'].extend({name:NAME_CARD_BODY,functional:true,props:props$20,render:function render(h,_ref){var _ref2;var props=_ref.props,data=_ref.data,children=_ref.children;var bodyBgVariant=props.bodyBgVariant,bodyBorderVariant=props.bodyBorderVariant,bodyTextVariant=props.bodyTextVariant;var $title=h();if(props.title){$title=h(BCardTitle,{props:pluckProps(props$22,props)});}var $subTitle=h();if(props.subTitle){$subTitle=h(BCardSubTitle,{props:pluckProps(props$21,props),class:['mb-2']});}return h(props.bodyTag,a(data,{staticClass:'card-body',class:[(_ref2={'card-img-overlay':props.overlay},_defineProperty(_ref2,\"bg-\".concat(bodyBgVariant),bodyBgVariant),_defineProperty(_ref2,\"border-\".concat(bodyBorderVariant),bodyBorderVariant),_defineProperty(_ref2,\"text-\".concat(bodyTextVariant),bodyTextVariant),_ref2),props.bodyClass]}),[$title,$subTitle,children]);}});var props$1$=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},copyProps(props$23,prefixPropName.bind(null,'header'))),{},{header:makeProp(PROP_TYPE_STRING),headerClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),headerHtml:makeProp(PROP_TYPE_STRING)})),NAME_CARD_HEADER);// --- Main component ---\n// @vue/component\nvar BCardHeader=/*#__PURE__*/Vue__default['default'].extend({name:NAME_CARD_HEADER,functional:true,props:props$1$,render:function render(h,_ref){var _ref2;var props=_ref.props,data=_ref.data,children=_ref.children;var headerBgVariant=props.headerBgVariant,headerBorderVariant=props.headerBorderVariant,headerTextVariant=props.headerTextVariant;return h(props.headerTag,a(data,{staticClass:'card-header',class:[props.headerClass,(_ref2={},_defineProperty(_ref2,\"bg-\".concat(headerBgVariant),headerBgVariant),_defineProperty(_ref2,\"border-\".concat(headerBorderVariant),headerBorderVariant),_defineProperty(_ref2,\"text-\".concat(headerTextVariant),headerTextVariant),_ref2)],domProps:children?{}:htmlOrText(props.headerHtml,props.header)}),children);}});var props$1_=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},copyProps(props$23,prefixPropName.bind(null,'footer'))),{},{footer:makeProp(PROP_TYPE_STRING),footerClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),footerHtml:makeProp(PROP_TYPE_STRING)})),NAME_CARD_FOOTER);// --- Main component ---\n// @vue/component\nvar BCardFooter=/*#__PURE__*/Vue__default['default'].extend({name:NAME_CARD_FOOTER,functional:true,props:props$1_,render:function render(h,_ref){var _ref2;var props=_ref.props,data=_ref.data,children=_ref.children;var footerBgVariant=props.footerBgVariant,footerBorderVariant=props.footerBorderVariant,footerTextVariant=props.footerTextVariant;return h(props.footerTag,a(data,{staticClass:'card-footer',class:[props.footerClass,(_ref2={},_defineProperty(_ref2,\"bg-\".concat(footerBgVariant),footerBgVariant),_defineProperty(_ref2,\"border-\".concat(footerBorderVariant),footerBorderVariant),_defineProperty(_ref2,\"text-\".concat(footerTextVariant),footerTextVariant),_ref2)],domProps:children?{}:htmlOrText(props.footerHtml,props.footer)}),children);}});// Blank image with fill template\nvar BLANK_TEMPLATE='<svg width=\"%{w}\" height=\"%{h}\" '+'xmlns=\"http://www.w3.org/2000/svg\" '+'viewBox=\"0 0 %{w} %{h}\" preserveAspectRatio=\"none\">'+'<rect width=\"100%\" height=\"100%\" style=\"fill:%{f};\"></rect>'+'</svg>';// --- Helper methods ---\nvar makeBlankImgSrc=function makeBlankImgSrc(width,height,color){var src=encodeURIComponent(BLANK_TEMPLATE.replace('%{w}',toString(width)).replace('%{h}',toString(height)).replace('%{f}',color));return\"data:image/svg+xml;charset=UTF-8,\".concat(src);};// --- Props ---\nvar props$1Z=makePropsConfigurable({alt:makeProp(PROP_TYPE_STRING),blank:makeProp(PROP_TYPE_BOOLEAN,false),blankColor:makeProp(PROP_TYPE_STRING,'transparent'),block:makeProp(PROP_TYPE_BOOLEAN,false),center:makeProp(PROP_TYPE_BOOLEAN,false),fluid:makeProp(PROP_TYPE_BOOLEAN,false),// Gives fluid images class `w-100` to make them grow to fit container\nfluidGrow:makeProp(PROP_TYPE_BOOLEAN,false),height:makeProp(PROP_TYPE_NUMBER_STRING),left:makeProp(PROP_TYPE_BOOLEAN,false),right:makeProp(PROP_TYPE_BOOLEAN,false),// Possible values:\n//   `false`: no rounding of corners\n//   `true`: slightly rounded corners\n//   'top': top corners rounded\n//   'right': right corners rounded\n//   'bottom': bottom corners rounded\n//   'left': left corners rounded\n//   'circle': circle/oval\n//   '0': force rounding off\nrounded:makeProp(PROP_TYPE_BOOLEAN_STRING,false),sizes:makeProp(PROP_TYPE_ARRAY_STRING),src:makeProp(PROP_TYPE_STRING),srcset:makeProp(PROP_TYPE_ARRAY_STRING),thumbnail:makeProp(PROP_TYPE_BOOLEAN,false),width:makeProp(PROP_TYPE_NUMBER_STRING)},NAME_IMG);// --- Main component ---\n// @vue/component\nvar BImg=/*#__PURE__*/Vue__default['default'].extend({name:NAME_IMG,functional:true,props:props$1Z,render:function render(h,_ref){var _class;var props=_ref.props,data=_ref.data;var alt=props.alt,src=props.src,block=props.block,fluidGrow=props.fluidGrow,rounded=props.rounded;var width=toInteger(props.width)||null;var height=toInteger(props.height)||null;var align=null;var srcset=concat(props.srcset).filter(identity).join(',');var sizes=concat(props.sizes).filter(identity).join(',');if(props.blank){if(!height&&width){height=width;}else if(!width&&height){width=height;}if(!width&&!height){width=1;height=1;}// Make a blank SVG image\nsrc=makeBlankImgSrc(width,height,props.blankColor||'transparent');// Disable srcset and sizes\nsrcset=null;sizes=null;}if(props.left){align='float-left';}else if(props.right){align='float-right';}else if(props.center){align='mx-auto';block=true;}return h('img',a(data,{attrs:{src:src,alt:alt,width:width?toString(width):null,height:height?toString(height):null,srcset:srcset||null,sizes:sizes||null},class:(_class={'img-thumbnail':props.thumbnail,'img-fluid':props.fluid||fluidGrow,'w-100':fluidGrow,rounded:rounded===''||rounded===true},_defineProperty(_class,\"rounded-\".concat(rounded),isString(rounded)&&rounded!==''),_defineProperty(_class,align,align),_defineProperty(_class,'d-block',block),_class)}));}});var props$1Y=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},pick$1(props$1Z,['src','alt','width','height','left','right'])),{},{bottom:makeProp(PROP_TYPE_BOOLEAN,false),end:makeProp(PROP_TYPE_BOOLEAN,false),start:makeProp(PROP_TYPE_BOOLEAN,false),top:makeProp(PROP_TYPE_BOOLEAN,false)})),NAME_CARD_IMG);// --- Main component ---\n// @vue/component\nvar BCardImg=/*#__PURE__*/Vue__default['default'].extend({name:NAME_CARD_IMG,functional:true,props:props$1Y,render:function render(h,_ref){var props=_ref.props,data=_ref.data;var src=props.src,alt=props.alt,width=props.width,height=props.height;var baseClass='card-img';if(props.top){baseClass+='-top';}else if(props.right||props.end){baseClass+='-right';}else if(props.bottom){baseClass+='-bottom';}else if(props.left||props.start){baseClass+='-left';}return h('img',a(data,{class:baseClass,attrs:{src:src,alt:alt,width:width,height:height}}));}});var cardImgProps=copyProps(props$1Y,prefixPropName.bind(null,'img'));cardImgProps.imgSrc.required=false;var props$1X=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$20),props$1$),props$1_),cardImgProps),props$23),{},{align:makeProp(PROP_TYPE_STRING),noBody:makeProp(PROP_TYPE_BOOLEAN,false)})),NAME_CARD);// --- Main component ---\n// @vue/component\nvar BCard=/*#__PURE__*/Vue__default['default'].extend({name:NAME_CARD,functional:true,props:props$1X,render:function render(h,_ref){var _class;var props=_ref.props,data=_ref.data,slots=_ref.slots,scopedSlots=_ref.scopedSlots;var imgSrc=props.imgSrc,imgLeft=props.imgLeft,imgRight=props.imgRight,imgStart=props.imgStart,imgEnd=props.imgEnd,imgBottom=props.imgBottom,header=props.header,headerHtml=props.headerHtml,footer=props.footer,footerHtml=props.footerHtml,align=props.align,textVariant=props.textVariant,bgVariant=props.bgVariant,borderVariant=props.borderVariant;var $scopedSlots=scopedSlots||{};var $slots=slots();var slotScope={};var $imgFirst=h();var $imgLast=h();if(imgSrc){var $img=h(BCardImg,{props:pluckProps(cardImgProps,props,unprefixPropName.bind(null,'img'))});if(imgBottom){$imgLast=$img;}else{$imgFirst=$img;}}var $header=h();var hasHeaderSlot=hasNormalizedSlot(SLOT_NAME_HEADER,$scopedSlots,$slots);if(hasHeaderSlot||header||headerHtml){$header=h(BCardHeader,{props:pluckProps(props$1$,props),domProps:hasHeaderSlot?{}:htmlOrText(headerHtml,header)},normalizeSlot(SLOT_NAME_HEADER,slotScope,$scopedSlots,$slots));}var $content=normalizeSlot(SLOT_NAME_DEFAULT,slotScope,$scopedSlots,$slots);// Wrap content in `<card-body>` when `noBody` prop set\nif(!props.noBody){$content=h(BCardBody,{props:pluckProps(props$20,props)},$content);// When the `overlap` prop is set we need to wrap the `<b-card-img>` and `<b-card-body>`\n// into a relative positioned wrapper to don't distract a potential header or footer\nif(props.overlay&&imgSrc){$content=h('div',{staticClass:'position-relative'},[$imgFirst,$content,$imgLast]);// Reset image variables since they are already in the wrapper\n$imgFirst=h();$imgLast=h();}}var $footer=h();var hasFooterSlot=hasNormalizedSlot(SLOT_NAME_FOOTER,$scopedSlots,$slots);if(hasFooterSlot||footer||footerHtml){$footer=h(BCardFooter,{props:pluckProps(props$1_,props),domProps:hasHeaderSlot?{}:htmlOrText(footerHtml,footer)},normalizeSlot(SLOT_NAME_FOOTER,slotScope,$scopedSlots,$slots));}return h(props.tag,a(data,{staticClass:'card',class:(_class={'flex-row':imgLeft||imgStart,'flex-row-reverse':(imgRight||imgEnd)&&!(imgLeft||imgStart)},_defineProperty(_class,\"text-\".concat(align),align),_defineProperty(_class,\"bg-\".concat(bgVariant),bgVariant),_defineProperty(_class,\"border-\".concat(borderVariant),borderVariant),_defineProperty(_class,\"text-\".concat(textVariant),textVariant),_class)}),[$imgFirst,$header,$content,$footer,$imgLast]);}});var OBSERVER_PROP_NAME='__bv__visibility_observer';var VisibilityObserver=/*#__PURE__*/function(){function VisibilityObserver(el,options,vnode){_classCallCheck(this,VisibilityObserver);this.el=el;this.callback=options.callback;this.margin=options.margin||0;this.once=options.once||false;this.observer=null;this.visible=undefined;this.doneOnce=false;// Create the observer instance (if possible)\nthis.createObserver(vnode);}_createClass(VisibilityObserver,[{key:\"createObserver\",value:function createObserver(vnode){var _this=this;// Remove any previous observer\nif(this.observer){/* istanbul ignore next */this.stop();}// Should only be called once and `callback` prop should be a function\nif(this.doneOnce||!isFunction$1(this.callback)){/* istanbul ignore next */return;}// Create the observer instance\ntry{// Future: Possibly add in other modifiers for left/right/top/bottom\n// offsets, root element reference, and thresholds\nthis.observer=new IntersectionObserver(this.handler.bind(this),{// `null` = 'viewport'\nroot:null,// Pixels away from view port to consider \"visible\"\nrootMargin:this.margin,// Intersection ratio of el and root (as a value from 0 to 1)\nthreshold:0});}catch(_unused){// No IntersectionObserver support, so just stop trying to observe\nthis.doneOnce=true;this.observer=undefined;this.callback(null);return;}// Start observing in a `$nextTick()` (to allow DOM to complete rendering)\n/* istanbul ignore next: IntersectionObserver not supported in JSDOM */vnode.context.$nextTick(function(){requestAF(function(){// Placed in an `if` just in case we were destroyed before\n// this `requestAnimationFrame` runs\nif(_this.observer){_this.observer.observe(_this.el);}});});}/* istanbul ignore next */},{key:\"handler\",value:function handler(entries){var entry=entries?entries[0]:{};var isIntersecting=Boolean(entry.isIntersecting||entry.intersectionRatio>0.0);if(isIntersecting!==this.visible){this.visible=isIntersecting;this.callback(isIntersecting);if(this.once&&this.visible){this.doneOnce=true;this.stop();}}}},{key:\"stop\",value:function stop(){/* istanbul ignore next */this.observer&&this.observer.disconnect();this.observer=null;}}]);return VisibilityObserver;}();var destroy$1=function destroy(el){var observer=el[OBSERVER_PROP_NAME];if(observer&&observer.stop){observer.stop();}delete el[OBSERVER_PROP_NAME];};var bind$1=function bind(el,_ref,vnode){var value=_ref.value,modifiers=_ref.modifiers;// `value` is the callback function\nvar options={margin:'0px',once:false,callback:value};// Parse modifiers\nkeys(modifiers).forEach(function(mod){/* istanbul ignore else: Until <b-img-lazy> is switched to use this directive */if(RX_DIGITS.test(mod)){options.margin=\"\".concat(mod,\"px\");}else if(mod.toLowerCase()==='once'){options.once=true;}});// Destroy any previous observer\ndestroy$1(el);// Create new observer\nel[OBSERVER_PROP_NAME]=new VisibilityObserver(el,options,vnode);// Store the current modifiers on the object (cloned)\nel[OBSERVER_PROP_NAME]._prevModifiers=clone(modifiers);};// When the directive options may have been updated (or element)\nvar componentUpdated$1=function componentUpdated(el,_ref2,vnode){var value=_ref2.value,oldValue=_ref2.oldValue,modifiers=_ref2.modifiers;// Compare value/oldValue and modifiers to see if anything has changed\n// and if so, destroy old observer and create new observer\n/* istanbul ignore next */modifiers=clone(modifiers);/* istanbul ignore next */if(el&&(value!==oldValue||!el[OBSERVER_PROP_NAME]||!looseEqual(modifiers,el[OBSERVER_PROP_NAME]._prevModifiers))){// Re-bind on element\nbind$1(el,{value:value,modifiers:modifiers},vnode);}};// When directive un-binds from element\nvar unbind$1=function unbind(el){// Remove the observer\ndestroy$1(el);};// Export the directive\nvar VBVisible={bind:bind$1,componentUpdated:componentUpdated$1,unbind:unbind$1};var _watch$i;var MODEL_PROP_NAME_SHOW$1='show';var MODEL_EVENT_NAME_SHOW$1=MODEL_EVENT_NAME_PREFIX+MODEL_PROP_NAME_SHOW$1;// --- Props ---\nvar imgProps$1=omit(props$1Z,['blank']);var props$1W=makePropsConfigurable(_objectSpread2$3(_objectSpread2$3({},imgProps$1),{},_defineProperty({blankHeight:makeProp(PROP_TYPE_NUMBER_STRING),// If `null`, a blank image is generated\nblankSrc:makeProp(PROP_TYPE_STRING,null),blankWidth:makeProp(PROP_TYPE_NUMBER_STRING),// Distance away from viewport (in pixels)\n// before being considered \"visible\"\noffset:makeProp(PROP_TYPE_NUMBER_STRING,360)},MODEL_PROP_NAME_SHOW$1,makeProp(PROP_TYPE_BOOLEAN,false))),NAME_IMG_LAZY);// --- Main component ---\n// @vue/component\nvar BImgLazy=/*#__PURE__*/Vue__default['default'].extend({name:NAME_IMG_LAZY,directives:{'b-visible':VBVisible},props:props$1W,data:function data(){return{isShown:this[MODEL_PROP_NAME_SHOW$1]};},computed:{computedSrc:function computedSrc(){var blankSrc=this.blankSrc;return!blankSrc||this.isShown?this.src:blankSrc;},computedBlank:function computedBlank(){return!(this.isShown||this.blankSrc);},computedWidth:function computedWidth(){var width=this.width;return this.isShown?width:this.blankWidth||width;},computedHeight:function computedHeight(){var height=this.height;return this.isShown?height:this.blankHeight||height;},computedSrcset:function computedSrcset(){var srcset=concat(this.srcset).filter(identity).join(',');return srcset&&(!this.blankSrc||this.isShown)?srcset:null;},computedSizes:function computedSizes(){var sizes=concat(this.sizes).filter(identity).join(',');return sizes&&(!this.blankSrc||this.isShown)?sizes:null;}},watch:(_watch$i={},_defineProperty(_watch$i,MODEL_PROP_NAME_SHOW$1,function(newValue,oldValue){if(newValue!==oldValue){// If `IntersectionObserver` support is not available, image is always shown\nvar visible=HAS_INTERACTION_OBSERVER_SUPPORT?newValue:true;this.isShown=visible;// Ensure the show prop is synced (when no `IntersectionObserver`)\nif(newValue!==visible){this.$nextTick(this.updateShowProp);}}}),_defineProperty(_watch$i,\"isShown\",function isShown(newValue,oldValue){// Update synched show prop\nif(newValue!==oldValue){this.updateShowProp();}}),_watch$i),mounted:function mounted(){// If `IntersectionObserver` is not available, image is always shown\nthis.isShown=HAS_INTERACTION_OBSERVER_SUPPORT?this[MODEL_PROP_NAME_SHOW$1]:true;},methods:{updateShowProp:function updateShowProp(){this.$emit(MODEL_EVENT_NAME_SHOW$1,this.isShown);},doShow:function doShow(visible){var _this=this;// If IntersectionObserver is not supported, the callback\n// will be called with `null` rather than `true` or `false`\nif((visible||visible===null)&&!this.isShown){// In a `requestAF()` to render the `blank` placeholder properly\n// for fast loading images in some browsers (i.e. Firefox)\nrequestAF(function(){_this.isShown=true;});}}},render:function render(h){var directives=[];if(!this.isShown){var _modifiers;// We only add the visible directive if we are not shown\ndirectives.push({// Visible directive will silently do nothing if\n// `IntersectionObserver` is not supported\nname:'b-visible',// Value expects a callback (passed one arg of `visible` = `true` or `false`)\nvalue:this.doShow,modifiers:(_modifiers={},_defineProperty(_modifiers,\"\".concat(toInteger(this.offset,0)),true),_defineProperty(_modifiers,\"once\",true),_modifiers)});}return h(BImg,{directives:directives,props:_objectSpread2$3(_objectSpread2$3({},pluckProps(imgProps$1,this.$props)),{},{// Computed value props\nsrc:this.computedSrc,blank:this.computedBlank,width:this.computedWidth,height:this.computedHeight,srcset:this.computedSrcset,sizes:this.computedSizes})});}});var props$1V=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},omit(props$1W,keys(props$1Z))),omit(props$1Y,['src','alt','width','height']))),NAME_CARD_IMG_LAZY);// --- Main component ---\n// @vue/component\nvar BCardImgLazy=/*#__PURE__*/Vue__default['default'].extend({name:NAME_CARD_IMG_LAZY,functional:true,props:props$1V,render:function render(h,_ref){var props=_ref.props,data=_ref.data;var baseClass='card-img';if(props.top){baseClass+='-top';}else if(props.right||props.end){baseClass+='-right';}else if(props.bottom){baseClass+='-bottom';}else if(props.left||props.start){baseClass+='-left';}return h(BImgLazy,a(data,{class:[baseClass],// Exclude `left` and `right` props before passing to `<b-img-lazy>`\nprops:omit(props,['left','right'])}));}});var props$1U=makePropsConfigurable({textTag:makeProp(PROP_TYPE_STRING,'p')},NAME_CARD_TEXT);// --- Main component ---\n// @vue/component\nvar BCardText=/*#__PURE__*/Vue__default['default'].extend({name:NAME_CARD_TEXT,functional:true,props:props$1U,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.textTag,a(data,{staticClass:'card-text'}),children);}});var props$1T=makePropsConfigurable({columns:makeProp(PROP_TYPE_BOOLEAN,false),deck:makeProp(PROP_TYPE_BOOLEAN,false),tag:makeProp(PROP_TYPE_STRING,'div')},NAME_CARD_GROUP);// --- Main component ---\n// @vue/component\nvar BCardGroup=/*#__PURE__*/Vue__default['default'].extend({name:NAME_CARD_GROUP,functional:true,props:props$1T,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,a(data,{class:props.deck?'card-deck':props.columns?'card-columns':'card-group'}),children);}});var CardPlugin=/*#__PURE__*/pluginFactory({components:{BCard:BCard,BCardHeader:BCardHeader,BCardBody:BCardBody,BCardTitle:BCardTitle,BCardSubTitle:BCardSubTitle,BCardFooter:BCardFooter,BCardImg:BCardImg,BCardImgLazy:BCardImgLazy,BCardText:BCardText,BCardGroup:BCardGroup}});var noop=function noop(){};/**\n   * Observe a DOM element changes, falls back to eventListener mode\n   * @param {Element} el The DOM element to observe\n   * @param {Function} callback callback to be called on change\n   * @param {object} [options={childList: true, subtree: true}] observe options\n   * @see https://stackoverflow.com/questions/3219758\n   */var observeDom=function observeDom(el,callback,options)/* istanbul ignore next: difficult to test in JSDOM */{// Handle cases where we might be passed a Vue instance\nel=el?el.$el||el:null;// Early exit when we have no element\n/* istanbul ignore next: difficult to test in JSDOM */if(!isElement(el)){return null;}// Exit and throw a warning when `MutationObserver` isn't available\nif(warnNoMutationObserverSupport('observeDom')){return null;}// Define a new observer\nvar obs=new MutationObs(function(mutations){var changed=false;// A mutation can contain several change records, so we loop\n// through them to see what has changed\n// We break out of the loop early if any \"significant\" change\n// has been detected\nfor(var i=0;i<mutations.length&&!changed;i++){// The mutation record\nvar mutation=mutations[i];// Mutation type\nvar type=mutation.type;// DOM node (could be any DOM node type - HTMLElement, Text, comment, etc.)\nvar target=mutation.target;// Detect whether a change happened based on type and target\nif(type==='characterData'&&target.nodeType===Node.TEXT_NODE){// We ignore nodes that are not TEXT (i.e. comments, etc.)\n// as they don't change layout\nchanged=true;}else if(type==='attributes'){changed=true;}else if(type==='childList'&&(mutation.addedNodes.length>0||mutation.removedNodes.length>0)){// This includes HTMLElement and text nodes being\n// added/removed/re-arranged\nchanged=true;}}// We only call the callback if a change that could affect\n// layout/size truly happened\nif(changed){callback();}});// Have the observer observe foo for changes in children, etc\nobs.observe(el,_objectSpread2$3({childList:true,subtree:true},options));// We return a reference to the observer so that `obs.disconnect()`\n// can be called if necessary\n// To reduce overhead when the root element is hidden\nreturn obs;};var _watch$h;var _makeModelMixin$i=makeModelMixin('value',{type:PROP_TYPE_NUMBER,defaultValue:0}),modelMixin$h=_makeModelMixin$i.mixin,modelProps$h=_makeModelMixin$i.props,MODEL_PROP_NAME$h=_makeModelMixin$i.prop,MODEL_EVENT_NAME$h=_makeModelMixin$i.event;// Slide directional classes\nvar DIRECTION={next:{dirClass:'carousel-item-left',overlayClass:'carousel-item-next'},prev:{dirClass:'carousel-item-right',overlayClass:'carousel-item-prev'}};// Fallback Transition duration (with a little buffer) in ms\nvar TRANS_DURATION=600+50;// Time for mouse compat events to fire after touch\nvar TOUCH_EVENT_COMPAT_WAIT=500;// Number of pixels to consider touch move a swipe\nvar SWIPE_THRESHOLD=40;// PointerEvent pointer types\nvar PointerType={TOUCH:'touch',PEN:'pen'};// Transition Event names\nvar TransitionEndEvents$1={WebkitTransition:'webkitTransitionEnd',MozTransition:'transitionend',OTransition:'otransitionend oTransitionEnd',transition:'transitionend'};// --- Helper methods ---\n// Return the browser specific transitionEnd event name\nvar getTransitionEndEvent=function getTransitionEndEvent(el){for(var name in TransitionEndEvents$1){if(!isUndefined(el.style[name])){return TransitionEndEvents$1[name];}}// Fallback\n/* istanbul ignore next */return null;};// --- Props ---\nvar props$1S=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),modelProps$h),{},{background:makeProp(PROP_TYPE_STRING),controls:makeProp(PROP_TYPE_BOOLEAN,false),// Enable cross-fade animation instead of slide animation\nfade:makeProp(PROP_TYPE_BOOLEAN,false),// Sniffed by carousel-slide\nimgHeight:makeProp(PROP_TYPE_NUMBER_STRING),// Sniffed by carousel-slide\nimgWidth:makeProp(PROP_TYPE_NUMBER_STRING),indicators:makeProp(PROP_TYPE_BOOLEAN,false),interval:makeProp(PROP_TYPE_NUMBER,5000),labelGotoSlide:makeProp(PROP_TYPE_STRING,'Goto slide'),labelIndicators:makeProp(PROP_TYPE_STRING,'Select a slide to display'),labelNext:makeProp(PROP_TYPE_STRING,'Next slide'),labelPrev:makeProp(PROP_TYPE_STRING,'Previous slide'),// Disable slide/fade animation\nnoAnimation:makeProp(PROP_TYPE_BOOLEAN,false),// Disable pause on hover\nnoHoverPause:makeProp(PROP_TYPE_BOOLEAN,false),// Sniffed by carousel-slide\nnoTouch:makeProp(PROP_TYPE_BOOLEAN,false),// Disable wrapping/looping when start/end is reached\nnoWrap:makeProp(PROP_TYPE_BOOLEAN,false)})),NAME_CAROUSEL);// --- Main component ---\n// @vue/component\nvar BCarousel=/*#__PURE__*/Vue__default['default'].extend({name:NAME_CAROUSEL,mixins:[idMixin,modelMixin$h,normalizeSlotMixin],provide:function provide(){return{bvCarousel:this};},props:props$1S,data:function data(){return{index:this[MODEL_PROP_NAME$h]||0,isSliding:false,transitionEndEvent:null,slides:[],direction:null,isPaused:!(toInteger(this.interval,0)>0),// Touch event handling values\ntouchStartX:0,touchDeltaX:0};},computed:{numSlides:function numSlides(){return this.slides.length;}},watch:(_watch$h={},_defineProperty(_watch$h,MODEL_PROP_NAME$h,function(newValue,oldValue){if(newValue!==oldValue){this.setSlide(toInteger(newValue,0));}}),_defineProperty(_watch$h,\"interval\",function interval(newValue,oldValue){/* istanbul ignore next */if(newValue===oldValue){return;}if(!newValue){// Pausing slide show\nthis.pause(false);}else{// Restarting or Changing interval\nthis.pause(true);this.start(false);}}),_defineProperty(_watch$h,\"isPaused\",function isPaused(newValue,oldValue){if(newValue!==oldValue){this.$emit(newValue?EVENT_NAME_PAUSED:EVENT_NAME_UNPAUSED);}}),_defineProperty(_watch$h,\"index\",function index(to,from){/* istanbul ignore next */if(to===from||this.isSliding){return;}this.doSlide(to,from);}),_watch$h),created:function created(){// Create private non-reactive props\nthis.$_interval=null;this.$_animationTimeout=null;this.$_touchTimeout=null;this.$_observer=null;// Set initial paused state\nthis.isPaused=!(toInteger(this.interval,0)>0);},mounted:function mounted(){// Cache current browser transitionend event name\nthis.transitionEndEvent=getTransitionEndEvent(this.$el)||null;// Get all slides\nthis.updateSlides();// Observe child changes so we can update slide list\nthis.setObserver(true);},beforeDestroy:function beforeDestroy(){this.clearInterval();this.clearAnimationTimeout();this.clearTouchTimeout();this.setObserver(false);},methods:{clearInterval:function(_clearInterval){function clearInterval(){return _clearInterval.apply(this,arguments);}clearInterval.toString=function(){return _clearInterval.toString();};return clearInterval;}(function(){clearInterval(this.$_interval);this.$_interval=null;}),clearAnimationTimeout:function clearAnimationTimeout(){clearTimeout(this.$_animationTimeout);this.$_animationTimeout=null;},clearTouchTimeout:function clearTouchTimeout(){clearTimeout(this.$_touchTimeout);this.$_touchTimeout=null;},setObserver:function setObserver(){var on=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;this.$_observer&&this.$_observer.disconnect();this.$_observer=null;if(on){this.$_observer=observeDom(this.$refs.inner,this.updateSlides.bind(this),{subtree:false,childList:true,attributes:true,attributeFilter:['id']});}},// Set slide\nsetSlide:function setSlide(slide){var _this=this;var direction=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;// Don't animate when page is not visible\n/* istanbul ignore if: difficult to test */if(IS_BROWSER&&document.visibilityState&&document.hidden){return;}var noWrap=this.noWrap;var numSlides=this.numSlides;// Make sure we have an integer (you never know!)\nslide=mathFloor(slide);// Don't do anything if nothing to slide to\nif(numSlides===0){return;}// Don't change slide while transitioning, wait until transition is done\nif(this.isSliding){// Schedule slide after sliding complete\nthis.$once(EVENT_NAME_SLIDING_END,function(){// Wrap in `requestAF()` to allow the slide to properly finish to avoid glitching\nrequestAF(function(){return _this.setSlide(slide,direction);});});return;}this.direction=direction;// Set new slide index\n// Wrap around if necessary (if no-wrap not enabled)\nthis.index=slide>=numSlides?noWrap?numSlides-1:0:slide<0?noWrap?0:numSlides-1:slide;// Ensure the v-model is synched up if no-wrap is enabled\n// and user tried to slide pass either ends\nif(noWrap&&this.index!==slide&&this.index!==this[MODEL_PROP_NAME$h]){this.$emit(MODEL_EVENT_NAME$h,this.index);}},// Previous slide\nprev:function prev(){this.setSlide(this.index-1,'prev');},// Next slide\nnext:function next(){this.setSlide(this.index+1,'next');},// Pause auto rotation\npause:function pause(event){if(!event){this.isPaused=true;}this.clearInterval();},// Start auto rotate slides\nstart:function start(event){if(!event){this.isPaused=false;}/* istanbul ignore next: most likely will never happen, but just in case */this.clearInterval();// Don't start if no interval, or less than 2 slides\nif(this.interval&&this.numSlides>1){this.$_interval=setInterval(this.next,mathMax(1000,this.interval));}},// Restart auto rotate slides when focus/hover leaves the carousel\n/* istanbul ignore next */restart:function restart(){if(!this.$el.contains(getActiveElement())){this.start();}},doSlide:function doSlide(to,from){var _this2=this;var isCycling=Boolean(this.interval);// Determine sliding direction\nvar direction=this.calcDirection(this.direction,from,to);var overlayClass=direction.overlayClass;var dirClass=direction.dirClass;// Determine current and next slides\nvar currentSlide=this.slides[from];var nextSlide=this.slides[to];// Don't do anything if there aren't any slides to slide to\nif(!currentSlide||!nextSlide){/* istanbul ignore next */return;}// Start animating\nthis.isSliding=true;if(isCycling){this.pause(false);}this.$emit(EVENT_NAME_SLIDING_START,to);// Update v-model\nthis.$emit(MODEL_EVENT_NAME$h,this.index);if(this.noAnimation){addClass(nextSlide,'active');removeClass(currentSlide,'active');this.isSliding=false;// Notify ourselves that we're done sliding (slid)\nthis.$nextTick(function(){return _this2.$emit(EVENT_NAME_SLIDING_END,to);});}else{addClass(nextSlide,overlayClass);// Trigger a reflow of next slide\nreflow(nextSlide);addClass(currentSlide,dirClass);addClass(nextSlide,dirClass);// Transition End handler\nvar called=false;/* istanbul ignore next: difficult to test */var onceTransEnd=function onceTransEnd(){if(called){return;}called=true;/* istanbul ignore if: transition events cant be tested in JSDOM */if(_this2.transitionEndEvent){var events=_this2.transitionEndEvent.split(/\\s+/);events.forEach(function(event){return eventOff(nextSlide,event,onceTransEnd,EVENT_OPTIONS_NO_CAPTURE);});}_this2.clearAnimationTimeout();removeClass(nextSlide,dirClass);removeClass(nextSlide,overlayClass);addClass(nextSlide,'active');removeClass(currentSlide,'active');removeClass(currentSlide,dirClass);removeClass(currentSlide,overlayClass);setAttr(currentSlide,'aria-current','false');setAttr(nextSlide,'aria-current','true');setAttr(currentSlide,'aria-hidden','true');setAttr(nextSlide,'aria-hidden','false');_this2.isSliding=false;_this2.direction=null;// Notify ourselves that we're done sliding (slid)\n_this2.$nextTick(function(){return _this2.$emit(EVENT_NAME_SLIDING_END,to);});};// Set up transitionend handler\n/* istanbul ignore if: transition events cant be tested in JSDOM */if(this.transitionEndEvent){var events=this.transitionEndEvent.split(/\\s+/);events.forEach(function(event){return eventOn(nextSlide,event,onceTransEnd,EVENT_OPTIONS_NO_CAPTURE);});}// Fallback to setTimeout()\nthis.$_animationTimeout=setTimeout(onceTransEnd,TRANS_DURATION);}if(isCycling){this.start(false);}},// Update slide list\nupdateSlides:function updateSlides(){this.pause(true);// Get all slides as DOM elements\nthis.slides=selectAll('.carousel-item',this.$refs.inner);var numSlides=this.slides.length;// Keep slide number in range\nvar index=mathMax(0,mathMin(mathFloor(this.index),numSlides-1));this.slides.forEach(function(slide,idx){var n=idx+1;if(idx===index){addClass(slide,'active');setAttr(slide,'aria-current','true');}else{removeClass(slide,'active');setAttr(slide,'aria-current','false');}setAttr(slide,'aria-posinset',String(n));setAttr(slide,'aria-setsize',String(numSlides));});// Set slide as active\nthis.setSlide(index);this.start(this.isPaused);},calcDirection:function calcDirection(){var direction=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var curIndex=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var nextIndex=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;if(!direction){return nextIndex>curIndex?DIRECTION.next:DIRECTION.prev;}return DIRECTION[direction];},handleClick:function handleClick(event,fn){var keyCode=event.keyCode;if(event.type==='click'||keyCode===CODE_SPACE||keyCode===CODE_ENTER){stopEvent(event);fn();}},/* istanbul ignore next: JSDOM doesn't support touch events */handleSwipe:function handleSwipe(){var absDeltaX=mathAbs(this.touchDeltaX);if(absDeltaX<=SWIPE_THRESHOLD){return;}var direction=absDeltaX/this.touchDeltaX;// Reset touch delta X\n// https://github.com/twbs/bootstrap/pull/28558\nthis.touchDeltaX=0;if(direction>0){// Swipe left\nthis.prev();}else if(direction<0){// Swipe right\nthis.next();}},/* istanbul ignore next: JSDOM doesn't support touch events */touchStart:function touchStart(event){if(HAS_POINTER_EVENT_SUPPORT&&PointerType[event.pointerType.toUpperCase()]){this.touchStartX=event.clientX;}else if(!HAS_POINTER_EVENT_SUPPORT){this.touchStartX=event.touches[0].clientX;}},/* istanbul ignore next: JSDOM doesn't support touch events */touchMove:function touchMove(event){// Ensure swiping with one touch and not pinching\nif(event.touches&&event.touches.length>1){this.touchDeltaX=0;}else{this.touchDeltaX=event.touches[0].clientX-this.touchStartX;}},/* istanbul ignore next: JSDOM doesn't support touch events */touchEnd:function touchEnd(event){if(HAS_POINTER_EVENT_SUPPORT&&PointerType[event.pointerType.toUpperCase()]){this.touchDeltaX=event.clientX-this.touchStartX;}this.handleSwipe();// If it's a touch-enabled device, mouseenter/leave are fired as\n// part of the mouse compatibility events on first tap - the carousel\n// would stop cycling until user tapped out of it;\n// here, we listen for touchend, explicitly pause the carousel\n// (as if it's the second time we tap on it, mouseenter compat event\n// is NOT fired) and after a timeout (to allow for mouse compatibility\n// events to fire) we explicitly restart cycling\nthis.pause(false);this.clearTouchTimeout();this.$_touchTimeout=setTimeout(this.start,TOUCH_EVENT_COMPAT_WAIT+mathMax(1000,this.interval));}},render:function render(h){var _this3=this;var indicators=this.indicators,background=this.background,noAnimation=this.noAnimation,noHoverPause=this.noHoverPause,noTouch=this.noTouch,index=this.index,isSliding=this.isSliding,pause=this.pause,restart=this.restart,touchStart=this.touchStart,touchEnd=this.touchEnd;var idInner=this.safeId('__BV_inner_');// Wrapper for slides\nvar $inner=h('div',{staticClass:'carousel-inner',attrs:{id:idInner,role:'list'},ref:'inner'},[this.normalizeSlot()]);// Prev and next controls\nvar $controls=h();if(this.controls){var makeControl=function makeControl(direction,label,handler){var handlerWrapper=function handlerWrapper(event){/* istanbul ignore next */if(!isSliding){_this3.handleClick(event,handler);}else{stopEvent(event,{propagation:false});}};return h('a',{staticClass:\"carousel-control-\".concat(direction),attrs:{href:'#',role:'button','aria-controls':idInner,'aria-disabled':isSliding?'true':null},on:{click:handlerWrapper,keydown:handlerWrapper}},[h('span',{staticClass:\"carousel-control-\".concat(direction,\"-icon\"),attrs:{'aria-hidden':'true'}}),h('span',{class:'sr-only'},[label])]);};$controls=[makeControl('prev',this.labelPrev,this.prev),makeControl('next',this.labelNext,this.next)];}// Indicators\nvar $indicators=h('ol',{staticClass:'carousel-indicators',directives:[{name:'show',value:indicators}],attrs:{id:this.safeId('__BV_indicators_'),'aria-hidden':indicators?'false':'true','aria-label':this.labelIndicators,'aria-owns':idInner}},this.slides.map(function(slide,i){var handler=function handler(event){_this3.handleClick(event,function(){_this3.setSlide(i);});};return h('li',{class:{active:i===index},attrs:{role:'button',id:_this3.safeId(\"__BV_indicator_\".concat(i+1,\"_\")),tabindex:indicators?'0':'-1','aria-current':i===index?'true':'false','aria-label':\"\".concat(_this3.labelGotoSlide,\" \").concat(i+1),'aria-describedby':slide.id||null,'aria-controls':idInner},on:{click:handler,keydown:handler},key:\"slide_\".concat(i)});}));var on={mouseenter:noHoverPause?noop:pause,mouseleave:noHoverPause?noop:restart,focusin:pause,focusout:restart,keydown:function keydown(event){/* istanbul ignore next */if(/input|textarea/i.test(event.target.tagName)){return;}var keyCode=event.keyCode;if(keyCode===CODE_LEFT||keyCode===CODE_RIGHT){stopEvent(event);_this3[keyCode===CODE_LEFT?'prev':'next']();}}};// Touch support event handlers for environment\nif(HAS_TOUCH_SUPPORT&&!noTouch){// Attach appropriate listeners (prepend event name with '&' for passive mode)\n/* istanbul ignore next: JSDOM doesn't support touch events */if(HAS_POINTER_EVENT_SUPPORT){on['&pointerdown']=touchStart;on['&pointerup']=touchEnd;}else{on['&touchstart']=touchStart;on['&touchmove']=this.touchMove;on['&touchend']=touchEnd;}}// Return the carousel\nreturn h('div',{staticClass:'carousel',class:{slide:!noAnimation,'carousel-fade':!noAnimation&&this.fade,'pointer-event':HAS_TOUCH_SUPPORT&&HAS_POINTER_EVENT_SUPPORT&&!noTouch},style:{background:background},attrs:{role:'region',id:this.safeId(),'aria-busy':isSliding?'true':'false'},on:on},[$inner,$controls,$indicators]);}});var imgProps={imgAlt:makeProp(PROP_TYPE_STRING),imgBlank:makeProp(PROP_TYPE_BOOLEAN,false),imgBlankColor:makeProp(PROP_TYPE_STRING,'transparent'),imgHeight:makeProp(PROP_TYPE_NUMBER_STRING),imgSrc:makeProp(PROP_TYPE_STRING),imgWidth:makeProp(PROP_TYPE_NUMBER_STRING)};var props$1R=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),imgProps),{},{background:makeProp(PROP_TYPE_STRING),caption:makeProp(PROP_TYPE_STRING),captionHtml:makeProp(PROP_TYPE_STRING),captionTag:makeProp(PROP_TYPE_STRING,'h3'),contentTag:makeProp(PROP_TYPE_STRING,'div'),contentVisibleUp:makeProp(PROP_TYPE_STRING),text:makeProp(PROP_TYPE_STRING),textHtml:makeProp(PROP_TYPE_STRING),textTag:makeProp(PROP_TYPE_STRING,'p')})),NAME_CAROUSEL_SLIDE);// --- Main component ---\n// @vue/component\nvar BCarouselSlide=/*#__PURE__*/Vue__default['default'].extend({name:NAME_CAROUSEL_SLIDE,mixins:[idMixin,normalizeSlotMixin],inject:{bvCarousel:{// Explicitly disable touch if not a child of carousel\ndefault:function _default(){return{noTouch:true};}}},props:props$1R,computed:{contentClasses:function contentClasses(){return[this.contentVisibleUp?'d-none':'',this.contentVisibleUp?\"d-\".concat(this.contentVisibleUp,\"-block\"):''];},computedWidth:function computedWidth(){// Use local width, or try parent width\nreturn this.imgWidth||this.bvCarousel.imgWidth||null;},computedHeight:function computedHeight(){// Use local height, or try parent height\nreturn this.imgHeight||this.bvCarousel.imgHeight||null;}},render:function render(h){var $img=this.normalizeSlot(SLOT_NAME_IMG);if(!$img&&(this.imgSrc||this.imgBlank)){var on={};// Touch support event handler\n/* istanbul ignore if: difficult to test in JSDOM */if(!this.bvCarousel.noTouch&&HAS_TOUCH_SUPPORT){on.dragstart=function(event){return stopEvent(event,{propagation:false});};}$img=h(BImg,{props:_objectSpread2$3(_objectSpread2$3({},pluckProps(imgProps,this.$props,unprefixPropName.bind(null,'img'))),{},{width:this.computedWidth,height:this.computedHeight,fluidGrow:true,block:true}),on:on});}var $contentChildren=[// Caption\nthis.caption||this.captionHtml?h(this.captionTag,{domProps:htmlOrText(this.captionHtml,this.caption)}):false,// Text\nthis.text||this.textHtml?h(this.textTag,{domProps:htmlOrText(this.textHtml,this.text)}):false,// Children\nthis.normalizeSlot()||false];var $content=h();if($contentChildren.some(identity)){$content=h(this.contentTag,{staticClass:'carousel-caption',class:this.contentClasses},$contentChildren.map(function($child){return $child||h();}));}return h('div',{staticClass:'carousel-item',style:{background:this.background||this.bvCarousel.background||null},attrs:{id:this.safeId(),role:'listitem'}},[$img,$content]);}});var CarouselPlugin=/*#__PURE*/pluginFactory({components:{BCarousel:BCarousel,BCarouselSlide:BCarouselSlide}});var CLASS_NAME_SHOW='show';// Generic collapse transion helper component\n// Transition event handler helpers\nvar onEnter=function onEnter(el){setStyle(el,'height',0);// In a `requestAF()` for `appear` to work\nrequestAF(function(){reflow(el);setStyle(el,'height',\"\".concat(el.scrollHeight,\"px\"));});};var onAfterEnter=function onAfterEnter(el){removeStyle(el,'height');};var onLeave=function onLeave(el){setStyle(el,'height','auto');setStyle(el,'display','block');setStyle(el,'height',\"\".concat(getBCR(el).height,\"px\"));reflow(el);setStyle(el,'height',0);};var onAfterLeave=function onAfterLeave(el){removeStyle(el,'height');};// --- Constants ---\n// Default transition props\n// `appear` will use the enter classes\nvar TRANSITION_PROPS={css:true,enterClass:'',enterActiveClass:'collapsing',enterToClass:'collapse show',leaveClass:'collapse show',leaveActiveClass:'collapsing',leaveToClass:'collapse'};// Default transition handlers\n// `appear` will use the enter handlers\nvar TRANSITION_HANDLERS={enter:onEnter,afterEnter:onAfterEnter,leave:onLeave,afterLeave:onAfterLeave};// --- Main component ---\nvar props$1Q={// // If `true` (and `visible` is `true` on mount), animate initially visible\nappear:makeProp(PROP_TYPE_BOOLEAN,false)};// --- Main component ---\n// @vue/component\nvar BVCollapse=/*#__PURE__*/Vue__default['default'].extend({name:NAME_COLLAPSE_HELPER,functional:true,props:props$1Q,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h('transition',// We merge in the `appear` prop last\na(data,{props:TRANSITION_PROPS,on:TRANSITION_HANDLERS},{props:props}),// Note: `<transition>` supports a single root element only\nchildren);}});var _watch$g;var ROOT_ACTION_EVENT_NAME_TOGGLE$2=getRootActionEventName(NAME_COLLAPSE,'toggle');var ROOT_ACTION_EVENT_NAME_REQUEST_STATE$2=getRootActionEventName(NAME_COLLAPSE,'request-state');var ROOT_EVENT_NAME_ACCORDION=getRootEventName(NAME_COLLAPSE,'accordion');var ROOT_EVENT_NAME_STATE$3=getRootEventName(NAME_COLLAPSE,'state');var ROOT_EVENT_NAME_SYNC_STATE$3=getRootEventName(NAME_COLLAPSE,'sync-state');var _makeModelMixin$h=makeModelMixin('visible',{type:PROP_TYPE_BOOLEAN,defaultValue:false}),modelMixin$g=_makeModelMixin$h.mixin,modelProps$g=_makeModelMixin$h.props,MODEL_PROP_NAME$g=_makeModelMixin$h.prop,MODEL_EVENT_NAME$g=_makeModelMixin$h.event;// --- Props ---\nvar props$1P=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),modelProps$g),{},{// If `true` (and `visible` is `true` on mount), animate initially visible\naccordion:makeProp(PROP_TYPE_STRING),appear:makeProp(PROP_TYPE_BOOLEAN,false),isNav:makeProp(PROP_TYPE_BOOLEAN,false),tag:makeProp(PROP_TYPE_STRING,'div')})),NAME_COLLAPSE);// --- Main component ---\n// @vue/component\nvar BCollapse=/*#__PURE__*/Vue__default['default'].extend({name:NAME_COLLAPSE,mixins:[idMixin,modelMixin$g,normalizeSlotMixin,listenOnRootMixin],props:props$1P,data:function data(){return{show:this[MODEL_PROP_NAME$g],transitioning:false};},computed:{classObject:function classObject(){var transitioning=this.transitioning;return{'navbar-collapse':this.isNav,collapse:!transitioning,show:this.show&&!transitioning};},slotScope:function slotScope(){var _this=this;return{visible:this.show,close:function close(){_this.show=false;}};}},watch:(_watch$g={},_defineProperty(_watch$g,MODEL_PROP_NAME$g,function(newValue){if(newValue!==this.show){this.show=newValue;}}),_defineProperty(_watch$g,\"show\",function show(newValue,oldValue){if(newValue!==oldValue){this.emitState();}}),_watch$g),created:function created(){this.show=this[MODEL_PROP_NAME$g];},mounted:function mounted(){var _this2=this;this.show=this[MODEL_PROP_NAME$g];// Listen for toggle events to open/close us\nthis.listenOnRoot(ROOT_ACTION_EVENT_NAME_TOGGLE$2,this.handleToggleEvent);// Listen to other collapses for accordion events\nthis.listenOnRoot(ROOT_EVENT_NAME_ACCORDION,this.handleAccordionEvent);if(this.isNav){// Set up handlers\nthis.setWindowEvents(true);this.handleResize();}this.$nextTick(function(){_this2.emitState();});// Listen for \"Sync state\" requests from `v-b-toggle`\nthis.listenOnRoot(ROOT_ACTION_EVENT_NAME_REQUEST_STATE$2,function(id){if(id===_this2.safeId()){_this2.$nextTick(_this2.emitSync);}});},updated:function updated(){// Emit a private event every time this component updates to ensure\n// the toggle button is in sync with the collapse's state\n// It is emitted regardless if the visible state changes\nthis.emitSync();},/* istanbul ignore next */deactivated:function deactivated(){if(this.isNav){this.setWindowEvents(false);}},/* istanbul ignore next */activated:function activated(){if(this.isNav){this.setWindowEvents(true);}this.emitSync();},beforeDestroy:function beforeDestroy(){// Trigger state emit if needed\nthis.show=false;if(this.isNav&&IS_BROWSER){this.setWindowEvents(false);}},methods:{setWindowEvents:function setWindowEvents(on){eventOnOff(on,window,'resize',this.handleResize,EVENT_OPTIONS_NO_CAPTURE);eventOnOff(on,window,'orientationchange',this.handleResize,EVENT_OPTIONS_NO_CAPTURE);},toggle:function toggle(){this.show=!this.show;},onEnter:function onEnter(){this.transitioning=true;// This should be moved out so we can add cancellable events\nthis.$emit(EVENT_NAME_SHOW);},onAfterEnter:function onAfterEnter(){this.transitioning=false;this.$emit(EVENT_NAME_SHOWN);},onLeave:function onLeave(){this.transitioning=true;// This should be moved out so we can add cancellable events\nthis.$emit(EVENT_NAME_HIDE);},onAfterLeave:function onAfterLeave(){this.transitioning=false;this.$emit(EVENT_NAME_HIDDEN);},emitState:function emitState(){var show=this.show,accordion=this.accordion;var id=this.safeId();this.$emit(MODEL_EVENT_NAME$g,show);// Let `v-b-toggle` know the state of this collapse\nthis.emitOnRoot(ROOT_EVENT_NAME_STATE$3,id,show);if(accordion&&show){// Tell the other collapses in this accordion to close\nthis.emitOnRoot(ROOT_EVENT_NAME_ACCORDION,id,accordion);}},emitSync:function emitSync(){// Emit a private event every time this component updates to ensure\n// the toggle button is in sync with the collapse's state\n// It is emitted regardless if the visible state changes\nthis.emitOnRoot(ROOT_EVENT_NAME_SYNC_STATE$3,this.safeId(),this.show);},checkDisplayBlock:function checkDisplayBlock(){// Check to see if the collapse has `display: block !important` set\n// We can't set `display: none` directly on `this.$el`, as it would\n// trigger a new transition to start (or cancel a current one)\nvar $el=this.$el;var restore=hasClass($el,CLASS_NAME_SHOW);removeClass($el,CLASS_NAME_SHOW);var isBlock=getCS($el).display==='block';if(restore){addClass($el,CLASS_NAME_SHOW);}return isBlock;},clickHandler:function clickHandler(event){var el=event.target;// If we are in a nav/navbar, close the collapse when non-disabled link clicked\n/* istanbul ignore next: can't test `getComputedStyle()` in JSDOM */if(!this.isNav||!el||getCS(this.$el).display!=='block'){return;}// Only close the collapse if it is not forced to be `display: block !important`\nif((matches(el,'.nav-link,.dropdown-item')||closest('.nav-link,.dropdown-item',el))&&!this.checkDisplayBlock()){this.show=false;}},handleToggleEvent:function handleToggleEvent(id){if(id===this.safeId()){this.toggle();}},handleAccordionEvent:function handleAccordionEvent(openedId,openAccordion){var accordion=this.accordion,show=this.show;if(!accordion||accordion!==openAccordion){return;}var isThis=openedId===this.safeId();// Open this collapse if not shown or\n// close this collapse if shown\nif(isThis&&!show||!isThis&&show){this.toggle();}},handleResize:function handleResize(){// Handler for orientation/resize to set collapsed state in nav/navbar\nthis.show=getCS(this.$el).display==='block';}},render:function render(h){var appear=this.appear;var $content=h(this.tag,{class:this.classObject,directives:[{name:'show',value:this.show}],attrs:{id:this.safeId()},on:{click:this.clickHandler}},this.normalizeSlot(SLOT_NAME_DEFAULT,this.slotScope));return h(BVCollapse,{props:{appear:appear},on:{enter:this.onEnter,afterEnter:this.onAfterEnter,leave:this.onLeave,afterLeave:this.onAfterLeave}},[$content]);}});// Classes to apply to trigger element\nvar CLASS_BV_TOGGLE_COLLAPSED='collapsed';var CLASS_BV_TOGGLE_NOT_COLLAPSED='not-collapsed';// Property key for handler storage\nvar BV_BASE='__BV_toggle';// Root event listener property (Function)\nvar BV_TOGGLE_ROOT_HANDLER=\"\".concat(BV_BASE,\"_HANDLER__\");// Trigger element click handler property (Function)\nvar BV_TOGGLE_CLICK_HANDLER=\"\".concat(BV_BASE,\"_CLICK__\");// Target visibility state property (Boolean)\nvar BV_TOGGLE_STATE=\"\".concat(BV_BASE,\"_STATE__\");// Target ID list property (Array)\nvar BV_TOGGLE_TARGETS=\"\".concat(BV_BASE,\"_TARGETS__\");// Commonly used strings\nvar STRING_FALSE='false';var STRING_TRUE='true';// Commonly used attribute names\nvar ATTR_ARIA_CONTROLS='aria-controls';var ATTR_ARIA_EXPANDED='aria-expanded';var ATTR_ROLE='role';var ATTR_TABINDEX='tabindex';// Commonly used style properties\nvar STYLE_OVERFLOW_ANCHOR='overflow-anchor';// Emitted control event for collapse (emitted to collapse)\nvar ROOT_ACTION_EVENT_NAME_TOGGLE$1=getRootActionEventName(NAME_COLLAPSE,'toggle');// Listen to event for toggle state update (emitted by collapse)\nvar ROOT_EVENT_NAME_STATE$2=getRootEventName(NAME_COLLAPSE,'state');// Private event emitted on `$root` to ensure the toggle state is always synced\n// Gets emitted even if the state of b-collapse has not changed\n// This event is NOT to be documented as people should not be using it\nvar ROOT_EVENT_NAME_SYNC_STATE$2=getRootEventName(NAME_COLLAPSE,'sync-state');// Private event we send to collapse to request state update sync event\nvar ROOT_ACTION_EVENT_NAME_REQUEST_STATE$1=getRootActionEventName(NAME_COLLAPSE,'request-state');var KEYDOWN_KEY_CODES=[CODE_ENTER,CODE_SPACE];// --- Helper methods ---\nvar isNonStandardTag=function isNonStandardTag(el){return!arrayIncludes(['button','a'],el.tagName.toLowerCase());};var getTargets=function getTargets(_ref,el){var modifiers=_ref.modifiers,arg=_ref.arg,value=_ref.value;// Any modifiers are considered target IDs\nvar targets=keys(modifiers||{});// If value is a string, split out individual targets (if space delimited)\nvalue=isString(value)?value.split(RX_SPACE_SPLIT):value;// Support target ID as link href (`href=\"#id\"`)\nif(isTag(el.tagName,'a')){var href=getAttr(el,'href')||'';if(RX_HASH_ID.test(href)){targets.push(href.replace(RX_HASH,''));}}// Add ID from `arg` (if provided), and support value\n// as a single string ID or an array of string IDs\n// If `value` is not an array or string, then it gets filtered out\nconcat(arg,value).forEach(function(t){return isString(t)&&targets.push(t);});// Return only unique and truthy target IDs\nreturn targets.filter(function(t,index,arr){return t&&arr.indexOf(t)===index;});};var removeClickListener=function removeClickListener(el){var handler=el[BV_TOGGLE_CLICK_HANDLER];if(handler){eventOff(el,'click',handler,EVENT_OPTIONS_PASSIVE);eventOff(el,'keydown',handler,EVENT_OPTIONS_PASSIVE);}el[BV_TOGGLE_CLICK_HANDLER]=null;};var addClickListener=function addClickListener(el,vnode){removeClickListener(el);if(vnode.context){var handler=function handler(event){if(!(event.type==='keydown'&&!arrayIncludes(KEYDOWN_KEY_CODES,event.keyCode))&&!isDisabled(el)){var targets=el[BV_TOGGLE_TARGETS]||[];targets.forEach(function(target){vnode.context.$root.$emit(ROOT_ACTION_EVENT_NAME_TOGGLE$1,target);});}};el[BV_TOGGLE_CLICK_HANDLER]=handler;eventOn(el,'click',handler,EVENT_OPTIONS_PASSIVE);if(isNonStandardTag(el)){eventOn(el,'keydown',handler,EVENT_OPTIONS_PASSIVE);}}};var removeRootListeners=function removeRootListeners(el,vnode){if(el[BV_TOGGLE_ROOT_HANDLER]&&vnode.context){vnode.context.$root.$off([ROOT_EVENT_NAME_STATE$2,ROOT_EVENT_NAME_SYNC_STATE$2],el[BV_TOGGLE_ROOT_HANDLER]);}el[BV_TOGGLE_ROOT_HANDLER]=null;};var addRootListeners=function addRootListeners(el,vnode){removeRootListeners(el,vnode);if(vnode.context){var handler=function handler(id,state){// `state` will be `true` if target is expanded\nif(arrayIncludes(el[BV_TOGGLE_TARGETS]||[],id)){// Set/Clear 'collapsed' visibility class state\nel[BV_TOGGLE_STATE]=state;// Set `aria-expanded` and class state on trigger element\nsetToggleState(el,state);}};el[BV_TOGGLE_ROOT_HANDLER]=handler;// Listen for toggle state changes (public) and sync (private)\nvnode.context.$root.$on([ROOT_EVENT_NAME_STATE$2,ROOT_EVENT_NAME_SYNC_STATE$2],handler);}};var setToggleState=function setToggleState(el,state){// State refers to the visibility of the collapse/sidebar\nif(state){removeClass(el,CLASS_BV_TOGGLE_COLLAPSED);addClass(el,CLASS_BV_TOGGLE_NOT_COLLAPSED);setAttr(el,ATTR_ARIA_EXPANDED,STRING_TRUE);}else{removeClass(el,CLASS_BV_TOGGLE_NOT_COLLAPSED);addClass(el,CLASS_BV_TOGGLE_COLLAPSED);setAttr(el,ATTR_ARIA_EXPANDED,STRING_FALSE);}};// Reset and remove a property from the provided element\nvar resetProp=function resetProp(el,prop){el[prop]=null;delete el[prop];};// Handle directive updates\nvar handleUpdate=function handleUpdate(el,binding,vnode){/* istanbul ignore next: should never happen */if(!IS_BROWSER||!vnode.context){return;}// If element is not a button or link, we add `role=\"button\"`\n// and `tabindex=\"0\"` for accessibility reasons\nif(isNonStandardTag(el)){if(!hasAttr(el,ATTR_ROLE)){setAttr(el,ATTR_ROLE,'button');}if(!hasAttr(el,ATTR_TABINDEX)){setAttr(el,ATTR_TABINDEX,'0');}}// Ensure the collapse class and `aria-*` attributes persist\n// after element is updated (either by parent re-rendering\n// or changes to this element or its contents)\nsetToggleState(el,el[BV_TOGGLE_STATE]);// Parse list of target IDs\nvar targets=getTargets(binding,el);// Ensure the `aria-controls` hasn't been overwritten\n// or removed when vnode updates\n// Also ensure to set `overflow-anchor` to `none` to prevent\n// the browser's scroll anchoring behavior\n/* istanbul ignore else */if(targets.length>0){setAttr(el,ATTR_ARIA_CONTROLS,targets.join(' '));setStyle(el,STYLE_OVERFLOW_ANCHOR,'none');}else{removeAttr(el,ATTR_ARIA_CONTROLS);removeStyle(el,STYLE_OVERFLOW_ANCHOR);}// Add/Update our click listener(s)\n// Wrap in a `requestAF()` to allow any previous\n// click handling to occur first\nrequestAF(function(){addClickListener(el,vnode);});// If targets array has changed, update\nif(!looseEqual(targets,el[BV_TOGGLE_TARGETS])){// Update targets array to element storage\nel[BV_TOGGLE_TARGETS]=targets;// Ensure `aria-controls` is up to date\n// Request a state update from targets so that we can\n// ensure expanded state is correct (in most cases)\ntargets.forEach(function(target){vnode.context.$root.$emit(ROOT_ACTION_EVENT_NAME_REQUEST_STATE$1,target);});}};/*\n   * Export our directive\n   */var VBToggle={bind:function bind(el,binding,vnode){// State is initially collapsed until we receive a state event\nel[BV_TOGGLE_STATE]=false;// Assume no targets initially\nel[BV_TOGGLE_TARGETS]=[];// Add our root listeners\naddRootListeners(el,vnode);// Initial update of trigger\nhandleUpdate(el,binding,vnode);},componentUpdated:handleUpdate,updated:handleUpdate,unbind:function unbind(el,binding,vnode){removeClickListener(el);// Remove our $root listener\nremoveRootListeners(el,vnode);// Reset custom props\nresetProp(el,BV_TOGGLE_ROOT_HANDLER);resetProp(el,BV_TOGGLE_CLICK_HANDLER);resetProp(el,BV_TOGGLE_STATE);resetProp(el,BV_TOGGLE_TARGETS);// Reset classes/attrs/styles\nremoveClass(el,CLASS_BV_TOGGLE_COLLAPSED);removeClass(el,CLASS_BV_TOGGLE_NOT_COLLAPSED);removeAttr(el,ATTR_ARIA_EXPANDED);removeAttr(el,ATTR_ARIA_CONTROLS);removeAttr(el,ATTR_ROLE);removeStyle(el,STYLE_OVERFLOW_ANCHOR);}};var VBTogglePlugin=/*#__PURE__*/pluginFactory({directives:{VBToggle:VBToggle}});var CollapsePlugin=/*#__PURE__*/pluginFactory({components:{BCollapse:BCollapse},plugins:{VBTogglePlugin:VBTogglePlugin}});/**!\n   * @fileOverview Kickass library to create and place poppers near their reference elements.\n   * @version 1.16.1\n   * @license\n   * Copyright (c) 2016 Federico Zivolo and contributors\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a copy\n   * of this software and associated documentation files (the \"Software\"), to deal\n   * in the Software without restriction, including without limitation the rights\n   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   * copies of the Software, and to permit persons to whom the Software is\n   * furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in all\n   * copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   * SOFTWARE.\n   */var isBrowser=typeof window!=='undefined'&&typeof document!=='undefined'&&typeof navigator!=='undefined';var timeoutDuration=function(){var longerTimeoutBrowsers=['Edge','Trident','Firefox'];for(var i=0;i<longerTimeoutBrowsers.length;i+=1){if(isBrowser&&navigator.userAgent.indexOf(longerTimeoutBrowsers[i])>=0){return 1;}}return 0;}();function microtaskDebounce(fn){var called=false;return function(){if(called){return;}called=true;window.Promise.resolve().then(function(){called=false;fn();});};}function taskDebounce(fn){var scheduled=false;return function(){if(!scheduled){scheduled=true;setTimeout(function(){scheduled=false;fn();},timeoutDuration);}};}var supportsMicroTasks=isBrowser&&window.Promise;/**\n  * Create a debounced version of a method, that's asynchronously deferred\n  * but called in the minimum time possible.\n  *\n  * @method\n  * @memberof Popper.Utils\n  * @argument {Function} fn\n  * @returns {Function}\n  */var debounce=supportsMicroTasks?microtaskDebounce:taskDebounce;/**\n   * Check if the given variable is a function\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Any} functionToCheck - variable to check\n   * @returns {Boolean} answer to: is a function?\n   */function isFunction(functionToCheck){var getType={};return functionToCheck&&getType.toString.call(functionToCheck)==='[object Function]';}/**\n   * Get CSS computed property of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Eement} element\n   * @argument {String} property\n   */function getStyleComputedProperty(element,property){if(element.nodeType!==1){return[];}// NOTE: 1 DOM access here\nvar window=element.ownerDocument.defaultView;var css=window.getComputedStyle(element,null);return property?css[property]:css;}/**\n   * Returns the parentNode or the host of the element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} parent\n   */function getParentNode(element){if(element.nodeName==='HTML'){return element;}return element.parentNode||element.host;}/**\n   * Returns the scrolling parent of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} scroll parent\n   */function getScrollParent(element){// Return body, `getScroll` will take care to get the correct `scrollTop` from it\nif(!element){return document.body;}switch(element.nodeName){case'HTML':case'BODY':return element.ownerDocument.body;case'#document':return element.body;}// Firefox want us to check `-x` and `-y` variations as well\nvar _getStyleComputedProp=getStyleComputedProperty(element),overflow=_getStyleComputedProp.overflow,overflowX=_getStyleComputedProp.overflowX,overflowY=_getStyleComputedProp.overflowY;if(/(auto|scroll|overlay)/.test(overflow+overflowY+overflowX)){return element;}return getScrollParent(getParentNode(element));}/**\n   * Returns the reference node of the reference object, or the reference object itself.\n   * @method\n   * @memberof Popper.Utils\n   * @param {Element|Object} reference - the reference element (the popper will be relative to this)\n   * @returns {Element} parent\n   */function getReferenceNode(reference){return reference&&reference.referenceNode?reference.referenceNode:reference;}var isIE11=isBrowser&&!!(window.MSInputMethodContext&&document.documentMode);var isIE10=isBrowser&&/MSIE 10/.test(navigator.userAgent);/**\n   * Determines if the browser is Internet Explorer\n   * @method\n   * @memberof Popper.Utils\n   * @param {Number} version to check\n   * @returns {Boolean} isIE\n   */function isIE(version){if(version===11){return isIE11;}if(version===10){return isIE10;}return isIE11||isIE10;}/**\n   * Returns the offset parent of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} offset parent\n   */function getOffsetParent(element){if(!element){return document.documentElement;}var noOffsetParent=isIE(10)?document.body:null;// NOTE: 1 DOM access here\nvar offsetParent=element.offsetParent||null;// Skip hidden elements which don't have an offsetParent\nwhile(offsetParent===noOffsetParent&&element.nextElementSibling){offsetParent=(element=element.nextElementSibling).offsetParent;}var nodeName=offsetParent&&offsetParent.nodeName;if(!nodeName||nodeName==='BODY'||nodeName==='HTML'){return element?element.ownerDocument.documentElement:document.documentElement;}// .offsetParent will return the closest TH, TD or TABLE in case\n// no offsetParent is present, I hate this job...\nif(['TH','TD','TABLE'].indexOf(offsetParent.nodeName)!==-1&&getStyleComputedProperty(offsetParent,'position')==='static'){return getOffsetParent(offsetParent);}return offsetParent;}function isOffsetContainer(element){var nodeName=element.nodeName;if(nodeName==='BODY'){return false;}return nodeName==='HTML'||getOffsetParent(element.firstElementChild)===element;}/**\n   * Finds the root node (document, shadowDOM root) of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} node\n   * @returns {Element} root node\n   */function getRoot(node){if(node.parentNode!==null){return getRoot(node.parentNode);}return node;}/**\n   * Finds the offset parent common to the two provided nodes\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element1\n   * @argument {Element} element2\n   * @returns {Element} common offset parent\n   */function findCommonOffsetParent(element1,element2){// This check is needed to avoid errors in case one of the elements isn't defined for any reason\nif(!element1||!element1.nodeType||!element2||!element2.nodeType){return document.documentElement;}// Here we make sure to give as \"start\" the element that comes first in the DOM\nvar order=element1.compareDocumentPosition(element2)&Node.DOCUMENT_POSITION_FOLLOWING;var start=order?element1:element2;var end=order?element2:element1;// Get common ancestor container\nvar range=document.createRange();range.setStart(start,0);range.setEnd(end,0);var commonAncestorContainer=range.commonAncestorContainer;// Both nodes are inside #document\nif(element1!==commonAncestorContainer&&element2!==commonAncestorContainer||start.contains(end)){if(isOffsetContainer(commonAncestorContainer)){return commonAncestorContainer;}return getOffsetParent(commonAncestorContainer);}// one of the nodes is inside shadowDOM, find which one\nvar element1root=getRoot(element1);if(element1root.host){return findCommonOffsetParent(element1root.host,element2);}else{return findCommonOffsetParent(element1,getRoot(element2).host);}}/**\n   * Gets the scroll value of the given element in the given side (top and left)\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @argument {String} side `top` or `left`\n   * @returns {number} amount of scrolled pixels\n   */function getScroll(element){var side=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'top';var upperSide=side==='top'?'scrollTop':'scrollLeft';var nodeName=element.nodeName;if(nodeName==='BODY'||nodeName==='HTML'){var html=element.ownerDocument.documentElement;var scrollingElement=element.ownerDocument.scrollingElement||html;return scrollingElement[upperSide];}return element[upperSide];}/*\n   * Sum or subtract the element scroll values (left and top) from a given rect object\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} rect - Rect object you want to change\n   * @param {HTMLElement} element - The element from the function reads the scroll values\n   * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n   * @return {Object} rect - The modifier rect object\n   */function includeScroll(rect,element){var subtract=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var scrollTop=getScroll(element,'top');var scrollLeft=getScroll(element,'left');var modifier=subtract?-1:1;rect.top+=scrollTop*modifier;rect.bottom+=scrollTop*modifier;rect.left+=scrollLeft*modifier;rect.right+=scrollLeft*modifier;return rect;}/*\n   * Helper to detect borders of a given element\n   * @method\n   * @memberof Popper.Utils\n   * @param {CSSStyleDeclaration} styles\n   * Result of `getStyleComputedProperty` on the given element\n   * @param {String} axis - `x` or `y`\n   * @return {number} borders - The borders size of the given axis\n   */function getBordersSize(styles,axis){var sideA=axis==='x'?'Left':'Top';var sideB=sideA==='Left'?'Right':'Bottom';return parseFloat(styles['border'+sideA+'Width'])+parseFloat(styles['border'+sideB+'Width']);}function getSize(axis,body,html,computedStyle){return Math.max(body['offset'+axis],body['scroll'+axis],html['client'+axis],html['offset'+axis],html['scroll'+axis],isIE(10)?parseInt(html['offset'+axis])+parseInt(computedStyle['margin'+(axis==='Height'?'Top':'Left')])+parseInt(computedStyle['margin'+(axis==='Height'?'Bottom':'Right')]):0);}function getWindowSizes(document){var body=document.body;var html=document.documentElement;var computedStyle=isIE(10)&&getComputedStyle(html);return{height:getSize('Height',body,html,computedStyle),width:getSize('Width',body,html,computedStyle)};}var classCallCheck=function(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}};var createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var defineProperty=function(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;};var _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};/**\n   * Given element offsets, generate an output similar to getBoundingClientRect\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Object} offsets\n   * @returns {Object} ClientRect like output\n   */function getClientRect(offsets){return _extends({},offsets,{right:offsets.left+offsets.width,bottom:offsets.top+offsets.height});}/**\n   * Get bounding client rect of given element\n   * @method\n   * @memberof Popper.Utils\n   * @param {HTMLElement} element\n   * @return {Object} client rect\n   */function getBoundingClientRect(element){var rect={};// IE10 10 FIX: Please, don't ask, the element isn't\n// considered in DOM in some circumstances...\n// This isn't reproducible in IE10 compatibility mode of IE11\ntry{if(isIE(10)){rect=element.getBoundingClientRect();var scrollTop=getScroll(element,'top');var scrollLeft=getScroll(element,'left');rect.top+=scrollTop;rect.left+=scrollLeft;rect.bottom+=scrollTop;rect.right+=scrollLeft;}else{rect=element.getBoundingClientRect();}}catch(e){}var result={left:rect.left,top:rect.top,width:rect.right-rect.left,height:rect.bottom-rect.top};// subtract scrollbar size from sizes\nvar sizes=element.nodeName==='HTML'?getWindowSizes(element.ownerDocument):{};var width=sizes.width||element.clientWidth||result.width;var height=sizes.height||element.clientHeight||result.height;var horizScrollbar=element.offsetWidth-width;var vertScrollbar=element.offsetHeight-height;// if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n// we make this check conditional for performance reasons\nif(horizScrollbar||vertScrollbar){var styles=getStyleComputedProperty(element);horizScrollbar-=getBordersSize(styles,'x');vertScrollbar-=getBordersSize(styles,'y');result.width-=horizScrollbar;result.height-=vertScrollbar;}return getClientRect(result);}function getOffsetRectRelativeToArbitraryNode(children,parent){var fixedPosition=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var isIE10=isIE(10);var isHTML=parent.nodeName==='HTML';var childrenRect=getBoundingClientRect(children);var parentRect=getBoundingClientRect(parent);var scrollParent=getScrollParent(children);var styles=getStyleComputedProperty(parent);var borderTopWidth=parseFloat(styles.borderTopWidth);var borderLeftWidth=parseFloat(styles.borderLeftWidth);// In cases where the parent is fixed, we must ignore negative scroll in offset calc\nif(fixedPosition&&isHTML){parentRect.top=Math.max(parentRect.top,0);parentRect.left=Math.max(parentRect.left,0);}var offsets=getClientRect({top:childrenRect.top-parentRect.top-borderTopWidth,left:childrenRect.left-parentRect.left-borderLeftWidth,width:childrenRect.width,height:childrenRect.height});offsets.marginTop=0;offsets.marginLeft=0;// Subtract margins of documentElement in case it's being used as parent\n// we do this only on HTML because it's the only element that behaves\n// differently when margins are applied to it. The margins are included in\n// the box of the documentElement, in the other cases not.\nif(!isIE10&&isHTML){var marginTop=parseFloat(styles.marginTop);var marginLeft=parseFloat(styles.marginLeft);offsets.top-=borderTopWidth-marginTop;offsets.bottom-=borderTopWidth-marginTop;offsets.left-=borderLeftWidth-marginLeft;offsets.right-=borderLeftWidth-marginLeft;// Attach marginTop and marginLeft because in some circumstances we may need them\noffsets.marginTop=marginTop;offsets.marginLeft=marginLeft;}if(isIE10&&!fixedPosition?parent.contains(scrollParent):parent===scrollParent&&scrollParent.nodeName!=='BODY'){offsets=includeScroll(offsets,parent);}return offsets;}function getViewportOffsetRectRelativeToArtbitraryNode(element){var excludeScroll=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var html=element.ownerDocument.documentElement;var relativeOffset=getOffsetRectRelativeToArbitraryNode(element,html);var width=Math.max(html.clientWidth,window.innerWidth||0);var height=Math.max(html.clientHeight,window.innerHeight||0);var scrollTop=!excludeScroll?getScroll(html):0;var scrollLeft=!excludeScroll?getScroll(html,'left'):0;var offset={top:scrollTop-relativeOffset.top+relativeOffset.marginTop,left:scrollLeft-relativeOffset.left+relativeOffset.marginLeft,width:width,height:height};return getClientRect(offset);}/**\n   * Check if the given element is fixed or is inside a fixed parent\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @argument {Element} customContainer\n   * @returns {Boolean} answer to \"isFixed?\"\n   */function isFixed(element){var nodeName=element.nodeName;if(nodeName==='BODY'||nodeName==='HTML'){return false;}if(getStyleComputedProperty(element,'position')==='fixed'){return true;}var parentNode=getParentNode(element);if(!parentNode){return false;}return isFixed(parentNode);}/**\n   * Finds the first parent of an element that has a transformed property defined\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} first transformed parent or documentElement\n   */function getFixedPositionOffsetParent(element){// This check is needed to avoid errors in case one of the elements isn't defined for any reason\nif(!element||!element.parentElement||isIE()){return document.documentElement;}var el=element.parentElement;while(el&&getStyleComputedProperty(el,'transform')==='none'){el=el.parentElement;}return el||document.documentElement;}/**\n   * Computed the boundaries limits and return them\n   * @method\n   * @memberof Popper.Utils\n   * @param {HTMLElement} popper\n   * @param {HTMLElement} reference\n   * @param {number} padding\n   * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n   * @param {Boolean} fixedPosition - Is in fixed position mode\n   * @returns {Object} Coordinates of the boundaries\n   */function getBoundaries(popper,reference,padding,boundariesElement){var fixedPosition=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;// NOTE: 1 DOM access here\nvar boundaries={top:0,left:0};var offsetParent=fixedPosition?getFixedPositionOffsetParent(popper):findCommonOffsetParent(popper,getReferenceNode(reference));// Handle viewport case\nif(boundariesElement==='viewport'){boundaries=getViewportOffsetRectRelativeToArtbitraryNode(offsetParent,fixedPosition);}else{// Handle other cases based on DOM element used as boundaries\nvar boundariesNode=void 0;if(boundariesElement==='scrollParent'){boundariesNode=getScrollParent(getParentNode(reference));if(boundariesNode.nodeName==='BODY'){boundariesNode=popper.ownerDocument.documentElement;}}else if(boundariesElement==='window'){boundariesNode=popper.ownerDocument.documentElement;}else{boundariesNode=boundariesElement;}var offsets=getOffsetRectRelativeToArbitraryNode(boundariesNode,offsetParent,fixedPosition);// In case of HTML, we need a different computation\nif(boundariesNode.nodeName==='HTML'&&!isFixed(offsetParent)){var _getWindowSizes=getWindowSizes(popper.ownerDocument),height=_getWindowSizes.height,width=_getWindowSizes.width;boundaries.top+=offsets.top-offsets.marginTop;boundaries.bottom=height+offsets.top;boundaries.left+=offsets.left-offsets.marginLeft;boundaries.right=width+offsets.left;}else{// for all the other DOM elements, this one is good\nboundaries=offsets;}}// Add paddings\npadding=padding||0;var isPaddingNumber=typeof padding==='number';boundaries.left+=isPaddingNumber?padding:padding.left||0;boundaries.top+=isPaddingNumber?padding:padding.top||0;boundaries.right-=isPaddingNumber?padding:padding.right||0;boundaries.bottom-=isPaddingNumber?padding:padding.bottom||0;return boundaries;}function getArea(_ref){var width=_ref.width,height=_ref.height;return width*height;}/**\n   * Utility used to transform the `auto` placement to the placement with more\n   * available space.\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function computeAutoPlacement(placement,refRect,popper,reference,boundariesElement){var padding=arguments.length>5&&arguments[5]!==undefined?arguments[5]:0;if(placement.indexOf('auto')===-1){return placement;}var boundaries=getBoundaries(popper,reference,padding,boundariesElement);var rects={top:{width:boundaries.width,height:refRect.top-boundaries.top},right:{width:boundaries.right-refRect.right,height:boundaries.height},bottom:{width:boundaries.width,height:boundaries.bottom-refRect.bottom},left:{width:refRect.left-boundaries.left,height:boundaries.height}};var sortedAreas=Object.keys(rects).map(function(key){return _extends({key:key},rects[key],{area:getArea(rects[key])});}).sort(function(a,b){return b.area-a.area;});var filteredAreas=sortedAreas.filter(function(_ref2){var width=_ref2.width,height=_ref2.height;return width>=popper.clientWidth&&height>=popper.clientHeight;});var computedPlacement=filteredAreas.length>0?filteredAreas[0].key:sortedAreas[0].key;var variation=placement.split('-')[1];return computedPlacement+(variation?'-'+variation:'');}/**\n   * Get offsets to the reference element\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} state\n   * @param {Element} popper - the popper element\n   * @param {Element} reference - the reference element (the popper will be relative to this)\n   * @param {Element} fixedPosition - is in fixed position mode\n   * @returns {Object} An object containing the offsets which will be applied to the popper\n   */function getReferenceOffsets(state,popper,reference){var fixedPosition=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;var commonOffsetParent=fixedPosition?getFixedPositionOffsetParent(popper):findCommonOffsetParent(popper,getReferenceNode(reference));return getOffsetRectRelativeToArbitraryNode(reference,commonOffsetParent,fixedPosition);}/**\n   * Get the outer sizes of the given element (offset size + margins)\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Object} object containing width and height properties\n   */function getOuterSizes(element){var window=element.ownerDocument.defaultView;var styles=window.getComputedStyle(element);var x=parseFloat(styles.marginTop||0)+parseFloat(styles.marginBottom||0);var y=parseFloat(styles.marginLeft||0)+parseFloat(styles.marginRight||0);var result={width:element.offsetWidth+y,height:element.offsetHeight+x};return result;}/**\n   * Get the opposite placement of the given one\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement\n   * @returns {String} flipped placement\n   */function getOppositePlacement(placement){var hash={left:'right',right:'left',bottom:'top',top:'bottom'};return placement.replace(/left|right|bottom|top/g,function(matched){return hash[matched];});}/**\n   * Get offsets to the popper\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} position - CSS position the Popper will get applied\n   * @param {HTMLElement} popper - the popper element\n   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n   * @param {String} placement - one of the valid placement options\n   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n   */function getPopperOffsets(popper,referenceOffsets,placement){placement=placement.split('-')[0];// Get popper node sizes\nvar popperRect=getOuterSizes(popper);// Add position, width and height to our offsets object\nvar popperOffsets={width:popperRect.width,height:popperRect.height};// depending by the popper placement we have to compute its offsets slightly differently\nvar isHoriz=['right','left'].indexOf(placement)!==-1;var mainSide=isHoriz?'top':'left';var secondarySide=isHoriz?'left':'top';var measurement=isHoriz?'height':'width';var secondaryMeasurement=!isHoriz?'height':'width';popperOffsets[mainSide]=referenceOffsets[mainSide]+referenceOffsets[measurement]/2-popperRect[measurement]/2;if(placement===secondarySide){popperOffsets[secondarySide]=referenceOffsets[secondarySide]-popperRect[secondaryMeasurement];}else{popperOffsets[secondarySide]=referenceOffsets[getOppositePlacement(secondarySide)];}return popperOffsets;}/**\n   * Mimics the `find` method of Array\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Array} arr\n   * @argument prop\n   * @argument value\n   * @returns index or -1\n   */function find(arr,check){// use native find if supported\nif(Array.prototype.find){return arr.find(check);}// use `filter` to obtain the same behavior of `find`\nreturn arr.filter(check)[0];}/**\n   * Return the index of the matching object\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Array} arr\n   * @argument prop\n   * @argument value\n   * @returns index or -1\n   */function findIndex(arr,prop,value){// use native findIndex if supported\nif(Array.prototype.findIndex){return arr.findIndex(function(cur){return cur[prop]===value;});}// use `find` + `indexOf` if `findIndex` isn't supported\nvar match=find(arr,function(obj){return obj[prop]===value;});return arr.indexOf(match);}/**\n   * Loop trough the list of modifiers and run them in order,\n   * each of them will then edit the data object.\n   * @method\n   * @memberof Popper.Utils\n   * @param {dataObject} data\n   * @param {Array} modifiers\n   * @param {String} ends - Optional modifier name used as stopper\n   * @returns {dataObject}\n   */function runModifiers(modifiers,data,ends){var modifiersToRun=ends===undefined?modifiers:modifiers.slice(0,findIndex(modifiers,'name',ends));modifiersToRun.forEach(function(modifier){if(modifier['function']){// eslint-disable-line dot-notation\nconsole.warn('`modifier.function` is deprecated, use `modifier.fn`!');}var fn=modifier['function']||modifier.fn;// eslint-disable-line dot-notation\nif(modifier.enabled&&isFunction(fn)){// Add properties to offsets to make them a complete clientRect object\n// we do this before each modifier to make sure the previous one doesn't\n// mess with these values\ndata.offsets.popper=getClientRect(data.offsets.popper);data.offsets.reference=getClientRect(data.offsets.reference);data=fn(data,modifier);}});return data;}/**\n   * Updates the position of the popper, computing the new offsets and applying\n   * the new style.<br />\n   * Prefer `scheduleUpdate` over `update` because of performance reasons.\n   * @method\n   * @memberof Popper\n   */function update(){// if popper is destroyed, don't perform any further update\nif(this.state.isDestroyed){return;}var data={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:false,offsets:{}};// compute reference element offsets\ndata.offsets.reference=getReferenceOffsets(this.state,this.popper,this.reference,this.options.positionFixed);// compute auto placement, store placement inside the data object,\n// modifiers will be able to edit `placement` if needed\n// and refer to originalPlacement to know the original value\ndata.placement=computeAutoPlacement(this.options.placement,data.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding);// store the computed placement inside `originalPlacement`\ndata.originalPlacement=data.placement;data.positionFixed=this.options.positionFixed;// compute the popper offsets\ndata.offsets.popper=getPopperOffsets(this.popper,data.offsets.reference,data.placement);data.offsets.popper.position=this.options.positionFixed?'fixed':'absolute';// run the modifiers\ndata=runModifiers(this.modifiers,data);// the first `update` will call `onCreate` callback\n// the other ones will call `onUpdate` callback\nif(!this.state.isCreated){this.state.isCreated=true;this.options.onCreate(data);}else{this.options.onUpdate(data);}}/**\n   * Helper used to know if the given modifier is enabled.\n   * @method\n   * @memberof Popper.Utils\n   * @returns {Boolean}\n   */function isModifierEnabled(modifiers,modifierName){return modifiers.some(function(_ref){var name=_ref.name,enabled=_ref.enabled;return enabled&&name===modifierName;});}/**\n   * Get the prefixed supported property name\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} property (camelCase)\n   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n   */function getSupportedPropertyName(property){var prefixes=[false,'ms','Webkit','Moz','O'];var upperProp=property.charAt(0).toUpperCase()+property.slice(1);for(var i=0;i<prefixes.length;i++){var prefix=prefixes[i];var toCheck=prefix?''+prefix+upperProp:property;if(typeof document.body.style[toCheck]!=='undefined'){return toCheck;}}return null;}/**\n   * Destroys the popper.\n   * @method\n   * @memberof Popper\n   */function destroy(){this.state.isDestroyed=true;// touch DOM only if `applyStyle` modifier is enabled\nif(isModifierEnabled(this.modifiers,'applyStyle')){this.popper.removeAttribute('x-placement');this.popper.style.position='';this.popper.style.top='';this.popper.style.left='';this.popper.style.right='';this.popper.style.bottom='';this.popper.style.willChange='';this.popper.style[getSupportedPropertyName('transform')]='';}this.disableEventListeners();// remove the popper if user explicitly asked for the deletion on destroy\n// do not use `remove` because IE11 doesn't support it\nif(this.options.removeOnDestroy){this.popper.parentNode.removeChild(this.popper);}return this;}/**\n   * Get the window associated with the element\n   * @argument {Element} element\n   * @returns {Window}\n   */function getWindow(element){var ownerDocument=element.ownerDocument;return ownerDocument?ownerDocument.defaultView:window;}function attachToScrollParents(scrollParent,event,callback,scrollParents){var isBody=scrollParent.nodeName==='BODY';var target=isBody?scrollParent.ownerDocument.defaultView:scrollParent;target.addEventListener(event,callback,{passive:true});if(!isBody){attachToScrollParents(getScrollParent(target.parentNode),event,callback,scrollParents);}scrollParents.push(target);}/**\n   * Setup needed event listeners used to update the popper position\n   * @method\n   * @memberof Popper.Utils\n   * @private\n   */function setupEventListeners(reference,options,state,updateBound){// Resize event listener on window\nstate.updateBound=updateBound;getWindow(reference).addEventListener('resize',state.updateBound,{passive:true});// Scroll event listener on scroll parents\nvar scrollElement=getScrollParent(reference);attachToScrollParents(scrollElement,'scroll',state.updateBound,state.scrollParents);state.scrollElement=scrollElement;state.eventsEnabled=true;return state;}/**\n   * It will add resize/scroll events and start recalculating\n   * position of the popper element when they are triggered.\n   * @method\n   * @memberof Popper\n   */function enableEventListeners(){if(!this.state.eventsEnabled){this.state=setupEventListeners(this.reference,this.options,this.state,this.scheduleUpdate);}}/**\n   * Remove event listeners used to update the popper position\n   * @method\n   * @memberof Popper.Utils\n   * @private\n   */function removeEventListeners(reference,state){// Remove resize event listener on window\ngetWindow(reference).removeEventListener('resize',state.updateBound);// Remove scroll event listener on scroll parents\nstate.scrollParents.forEach(function(target){target.removeEventListener('scroll',state.updateBound);});// Reset state\nstate.updateBound=null;state.scrollParents=[];state.scrollElement=null;state.eventsEnabled=false;return state;}/**\n   * It will remove resize/scroll events and won't recalculate popper position\n   * when they are triggered. It also won't trigger `onUpdate` callback anymore,\n   * unless you call `update` method manually.\n   * @method\n   * @memberof Popper\n   */function disableEventListeners(){if(this.state.eventsEnabled){cancelAnimationFrame(this.scheduleUpdate);this.state=removeEventListeners(this.reference,this.state);}}/**\n   * Tells if a given input is a number\n   * @method\n   * @memberof Popper.Utils\n   * @param {*} input to check\n   * @return {Boolean}\n   */function isNumeric(n){return n!==''&&!isNaN(parseFloat(n))&&isFinite(n);}/**\n   * Set the style to the given popper\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element - Element to apply the style to\n   * @argument {Object} styles\n   * Object with a list of properties and values which will be applied to the element\n   */function setStyles(element,styles){Object.keys(styles).forEach(function(prop){var unit='';// add unit if the value is numeric and is one of the following\nif(['width','height','top','right','bottom','left'].indexOf(prop)!==-1&&isNumeric(styles[prop])){unit='px';}element.style[prop]=styles[prop]+unit;});}/**\n   * Set the attributes to the given popper\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element - Element to apply the attributes to\n   * @argument {Object} styles\n   * Object with a list of properties and values which will be applied to the element\n   */function setAttributes(element,attributes){Object.keys(attributes).forEach(function(prop){var value=attributes[prop];if(value!==false){element.setAttribute(prop,attributes[prop]);}else{element.removeAttribute(prop);}});}/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} data.styles - List of style properties - values to apply to popper element\n   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The same data object\n   */function applyStyle(data){// any property present in `data.styles` will be applied to the popper,\n// in this way we can make the 3rd party modifiers add custom styles to it\n// Be aware, modifiers could override the properties defined in the previous\n// lines of this modifier!\nsetStyles(data.instance.popper,data.styles);// any property present in `data.attributes` will be applied to the popper,\n// they will be set as HTML attributes of the element\nsetAttributes(data.instance.popper,data.attributes);// if arrowElement is defined and arrowStyles has some properties\nif(data.arrowElement&&Object.keys(data.arrowStyles).length){setStyles(data.arrowElement,data.arrowStyles);}return data;}/**\n   * Set the x-placement attribute before everything else because it could be used\n   * to add margins to the popper margins needs to be calculated to get the\n   * correct popper offsets.\n   * @method\n   * @memberof Popper.modifiers\n   * @param {HTMLElement} reference - The reference element used to position the popper\n   * @param {HTMLElement} popper - The HTML element used as popper\n   * @param {Object} options - Popper.js options\n   */function applyStyleOnLoad(reference,popper,options,modifierOptions,state){// compute reference element offsets\nvar referenceOffsets=getReferenceOffsets(state,popper,reference,options.positionFixed);// compute auto placement, store placement inside the data object,\n// modifiers will be able to edit `placement` if needed\n// and refer to originalPlacement to know the original value\nvar placement=computeAutoPlacement(options.placement,referenceOffsets,popper,reference,options.modifiers.flip.boundariesElement,options.modifiers.flip.padding);popper.setAttribute('x-placement',placement);// Apply `position` to popper before anything else because\n// without the position applied we can't guarantee correct computations\nsetStyles(popper,{position:options.positionFixed?'fixed':'absolute'});return options;}/**\n   * @function\n   * @memberof Popper.Utils\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Boolean} shouldRound - If the offsets should be rounded at all\n   * @returns {Object} The popper's position offsets rounded\n   *\n   * The tale of pixel-perfect positioning. It's still not 100% perfect, but as\n   * good as it can be within reason.\n   * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n   *\n   * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n   * as well on High DPI screens).\n   *\n   * Firefox prefers no rounding for positioning and does not have blurriness on\n   * high DPI screens.\n   *\n   * Only horizontal placement and left/right values need to be considered.\n   */function getRoundedOffsets(data,shouldRound){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference;var round=Math.round,floor=Math.floor;var noRound=function noRound(v){return v;};var referenceWidth=round(reference.width);var popperWidth=round(popper.width);var isVertical=['left','right'].indexOf(data.placement)!==-1;var isVariation=data.placement.indexOf('-')!==-1;var sameWidthParity=referenceWidth%2===popperWidth%2;var bothOddWidth=referenceWidth%2===1&&popperWidth%2===1;var horizontalToInteger=!shouldRound?noRound:isVertical||isVariation||sameWidthParity?round:floor;var verticalToInteger=!shouldRound?noRound:round;return{left:horizontalToInteger(bothOddWidth&&!isVariation&&shouldRound?popper.left-1:popper.left),top:verticalToInteger(popper.top),bottom:verticalToInteger(popper.bottom),right:horizontalToInteger(popper.right)};}var isFirefox=isBrowser&&/Firefox/i.test(navigator.userAgent);/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function computeStyle(data,options){var x=options.x,y=options.y;var popper=data.offsets.popper;// Remove this legacy support in Popper.js v2\nvar legacyGpuAccelerationOption=find(data.instance.modifiers,function(modifier){return modifier.name==='applyStyle';}).gpuAcceleration;if(legacyGpuAccelerationOption!==undefined){console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');}var gpuAcceleration=legacyGpuAccelerationOption!==undefined?legacyGpuAccelerationOption:options.gpuAcceleration;var offsetParent=getOffsetParent(data.instance.popper);var offsetParentRect=getBoundingClientRect(offsetParent);// Styles\nvar styles={position:popper.position};var offsets=getRoundedOffsets(data,window.devicePixelRatio<2||!isFirefox);var sideA=x==='bottom'?'top':'bottom';var sideB=y==='right'?'left':'right';// if gpuAcceleration is set to `true` and transform is supported,\n//  we use `translate3d` to apply the position to the popper we\n// automatically use the supported prefixed version if needed\nvar prefixedProperty=getSupportedPropertyName('transform');// now, let's make a step back and look at this code closely (wtf?)\n// If the content of the popper grows once it's been positioned, it\n// may happen that the popper gets misplaced because of the new content\n// overflowing its reference element\n// To avoid this problem, we provide two options (x and y), which allow\n// the consumer to define the offset origin.\n// If we position a popper on top of a reference element, we can set\n// `x` to `top` to make the popper grow towards its top instead of\n// its bottom.\nvar left=void 0,top=void 0;if(sideA==='bottom'){// when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)\n// and not the bottom of the html element\nif(offsetParent.nodeName==='HTML'){top=-offsetParent.clientHeight+offsets.bottom;}else{top=-offsetParentRect.height+offsets.bottom;}}else{top=offsets.top;}if(sideB==='right'){if(offsetParent.nodeName==='HTML'){left=-offsetParent.clientWidth+offsets.right;}else{left=-offsetParentRect.width+offsets.right;}}else{left=offsets.left;}if(gpuAcceleration&&prefixedProperty){styles[prefixedProperty]='translate3d('+left+'px, '+top+'px, 0)';styles[sideA]=0;styles[sideB]=0;styles.willChange='transform';}else{// othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\nvar invertTop=sideA==='bottom'?-1:1;var invertLeft=sideB==='right'?-1:1;styles[sideA]=top*invertTop;styles[sideB]=left*invertLeft;styles.willChange=sideA+', '+sideB;}// Attributes\nvar attributes={'x-placement':data.placement};// Update `data` attributes, styles and arrowStyles\ndata.attributes=_extends({},attributes,data.attributes);data.styles=_extends({},styles,data.styles);data.arrowStyles=_extends({},data.offsets.arrow,data.arrowStyles);return data;}/**\n   * Helper used to know if the given modifier depends from another one.<br />\n   * It checks if the needed modifier is listed and enabled.\n   * @method\n   * @memberof Popper.Utils\n   * @param {Array} modifiers - list of modifiers\n   * @param {String} requestingName - name of requesting modifier\n   * @param {String} requestedName - name of requested modifier\n   * @returns {Boolean}\n   */function isModifierRequired(modifiers,requestingName,requestedName){var requesting=find(modifiers,function(_ref){var name=_ref.name;return name===requestingName;});var isRequired=!!requesting&&modifiers.some(function(modifier){return modifier.name===requestedName&&modifier.enabled&&modifier.order<requesting.order;});if(!isRequired){var _requesting='`'+requestingName+'`';var requested='`'+requestedName+'`';console.warn(requested+' modifier is required by '+_requesting+' modifier in order to work, be sure to include it before '+_requesting+'!');}return isRequired;}/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function arrow(data,options){var _data$offsets$arrow;// arrow depends on keepTogether in order to work\nif(!isModifierRequired(data.instance.modifiers,'arrow','keepTogether')){return data;}var arrowElement=options.element;// if arrowElement is a string, suppose it's a CSS selector\nif(typeof arrowElement==='string'){arrowElement=data.instance.popper.querySelector(arrowElement);// if arrowElement is not found, don't run the modifier\nif(!arrowElement){return data;}}else{// if the arrowElement isn't a query selector we must check that the\n// provided DOM node is child of its popper node\nif(!data.instance.popper.contains(arrowElement)){console.warn('WARNING: `arrow.element` must be child of its popper element!');return data;}}var placement=data.placement.split('-')[0];var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference;var isVertical=['left','right'].indexOf(placement)!==-1;var len=isVertical?'height':'width';var sideCapitalized=isVertical?'Top':'Left';var side=sideCapitalized.toLowerCase();var altSide=isVertical?'left':'top';var opSide=isVertical?'bottom':'right';var arrowElementSize=getOuterSizes(arrowElement)[len];//\n// extends keepTogether behavior making sure the popper and its\n// reference have enough pixels in conjunction\n//\n// top/left side\nif(reference[opSide]-arrowElementSize<popper[side]){data.offsets.popper[side]-=popper[side]-(reference[opSide]-arrowElementSize);}// bottom/right side\nif(reference[side]+arrowElementSize>popper[opSide]){data.offsets.popper[side]+=reference[side]+arrowElementSize-popper[opSide];}data.offsets.popper=getClientRect(data.offsets.popper);// compute center of the popper\nvar center=reference[side]+reference[len]/2-arrowElementSize/2;// Compute the sideValue using the updated popper offsets\n// take popper margin in account because we don't have this info available\nvar css=getStyleComputedProperty(data.instance.popper);var popperMarginSide=parseFloat(css['margin'+sideCapitalized]);var popperBorderSide=parseFloat(css['border'+sideCapitalized+'Width']);var sideValue=center-data.offsets.popper[side]-popperMarginSide-popperBorderSide;// prevent arrowElement from being placed not contiguously to its popper\nsideValue=Math.max(Math.min(popper[len]-arrowElementSize,sideValue),0);data.arrowElement=arrowElement;data.offsets.arrow=(_data$offsets$arrow={},defineProperty(_data$offsets$arrow,side,Math.round(sideValue)),defineProperty(_data$offsets$arrow,altSide,''),_data$offsets$arrow);return data;}/**\n   * Get the opposite placement variation of the given one\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement variation\n   * @returns {String} flipped placement variation\n   */function getOppositeVariation(variation){if(variation==='end'){return'start';}else if(variation==='start'){return'end';}return variation;}/**\n   * List of accepted placements to use as values of the `placement` option.<br />\n   * Valid placements are:\n   * - `auto`\n   * - `top`\n   * - `right`\n   * - `bottom`\n   * - `left`\n   *\n   * Each placement can have a variation from this list:\n   * - `-start`\n   * - `-end`\n   *\n   * Variations are interpreted easily if you think of them as the left to right\n   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n   * is right.<br />\n   * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n   *\n   * Some valid examples are:\n   * - `top-end` (on top of reference, right aligned)\n   * - `right-start` (on right of reference, top aligned)\n   * - `bottom` (on bottom, centered)\n   * - `auto-end` (on the side with more space available, alignment depends by placement)\n   *\n   * @static\n   * @type {Array}\n   * @enum {String}\n   * @readonly\n   * @method placements\n   * @memberof Popper\n   */var placements=['auto-start','auto','auto-end','top-start','top','top-end','right-start','right','right-end','bottom-end','bottom','bottom-start','left-end','left','left-start'];// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements=placements.slice(3);/**\n   * Given an initial placement, returns all the subsequent placements\n   * clockwise (or counter-clockwise).\n   *\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement - A valid placement (it accepts variations)\n   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n   * @returns {Array} placements including their variations\n   */function clockwise(placement){var counter=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var index=validPlacements.indexOf(placement);var arr=validPlacements.slice(index+1).concat(validPlacements.slice(0,index));return counter?arr.reverse():arr;}var BEHAVIORS={FLIP:'flip',CLOCKWISE:'clockwise',COUNTERCLOCKWISE:'counterclockwise'};/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function flip(data,options){// if `inner` modifier is enabled, we can't use the `flip` modifier\nif(isModifierEnabled(data.instance.modifiers,'inner')){return data;}if(data.flipped&&data.placement===data.originalPlacement){// seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\nreturn data;}var boundaries=getBoundaries(data.instance.popper,data.instance.reference,options.padding,options.boundariesElement,data.positionFixed);var placement=data.placement.split('-')[0];var placementOpposite=getOppositePlacement(placement);var variation=data.placement.split('-')[1]||'';var flipOrder=[];switch(options.behavior){case BEHAVIORS.FLIP:flipOrder=[placement,placementOpposite];break;case BEHAVIORS.CLOCKWISE:flipOrder=clockwise(placement);break;case BEHAVIORS.COUNTERCLOCKWISE:flipOrder=clockwise(placement,true);break;default:flipOrder=options.behavior;}flipOrder.forEach(function(step,index){if(placement!==step||flipOrder.length===index+1){return data;}placement=data.placement.split('-')[0];placementOpposite=getOppositePlacement(placement);var popperOffsets=data.offsets.popper;var refOffsets=data.offsets.reference;// using floor because the reference offsets may contain decimals we are not going to consider here\nvar floor=Math.floor;var overlapsRef=placement==='left'&&floor(popperOffsets.right)>floor(refOffsets.left)||placement==='right'&&floor(popperOffsets.left)<floor(refOffsets.right)||placement==='top'&&floor(popperOffsets.bottom)>floor(refOffsets.top)||placement==='bottom'&&floor(popperOffsets.top)<floor(refOffsets.bottom);var overflowsLeft=floor(popperOffsets.left)<floor(boundaries.left);var overflowsRight=floor(popperOffsets.right)>floor(boundaries.right);var overflowsTop=floor(popperOffsets.top)<floor(boundaries.top);var overflowsBottom=floor(popperOffsets.bottom)>floor(boundaries.bottom);var overflowsBoundaries=placement==='left'&&overflowsLeft||placement==='right'&&overflowsRight||placement==='top'&&overflowsTop||placement==='bottom'&&overflowsBottom;// flip the variation if required\nvar isVertical=['top','bottom'].indexOf(placement)!==-1;// flips variation if reference element overflows boundaries\nvar flippedVariationByRef=!!options.flipVariations&&(isVertical&&variation==='start'&&overflowsLeft||isVertical&&variation==='end'&&overflowsRight||!isVertical&&variation==='start'&&overflowsTop||!isVertical&&variation==='end'&&overflowsBottom);// flips variation if popper content overflows boundaries\nvar flippedVariationByContent=!!options.flipVariationsByContent&&(isVertical&&variation==='start'&&overflowsRight||isVertical&&variation==='end'&&overflowsLeft||!isVertical&&variation==='start'&&overflowsBottom||!isVertical&&variation==='end'&&overflowsTop);var flippedVariation=flippedVariationByRef||flippedVariationByContent;if(overlapsRef||overflowsBoundaries||flippedVariation){// this boolean to detect any flip loop\ndata.flipped=true;if(overlapsRef||overflowsBoundaries){placement=flipOrder[index+1];}if(flippedVariation){variation=getOppositeVariation(variation);}data.placement=placement+(variation?'-'+variation:'');// this object contains `position`, we want to preserve it along with\n// any additional property we may add in the future\ndata.offsets.popper=_extends({},data.offsets.popper,getPopperOffsets(data.instance.popper,data.offsets.reference,data.placement));data=runModifiers(data.instance.modifiers,data,'flip');}});return data;}/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function keepTogether(data){var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference;var placement=data.placement.split('-')[0];var floor=Math.floor;var isVertical=['top','bottom'].indexOf(placement)!==-1;var side=isVertical?'right':'bottom';var opSide=isVertical?'left':'top';var measurement=isVertical?'width':'height';if(popper[side]<floor(reference[opSide])){data.offsets.popper[opSide]=floor(reference[opSide])-popper[measurement];}if(popper[opSide]>floor(reference[side])){data.offsets.popper[opSide]=floor(reference[side]);}return data;}/**\n   * Converts a string containing value + unit into a px value number\n   * @function\n   * @memberof {modifiers~offset}\n   * @private\n   * @argument {String} str - Value + unit string\n   * @argument {String} measurement - `height` or `width`\n   * @argument {Object} popperOffsets\n   * @argument {Object} referenceOffsets\n   * @returns {Number|String}\n   * Value in pixels, or original string if no values were extracted\n   */function toValue(str,measurement,popperOffsets,referenceOffsets){// separate value from unit\nvar split=str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);var value=+split[1];var unit=split[2];// If it's not a number it's an operator, I guess\nif(!value){return str;}if(unit.indexOf('%')===0){var element=void 0;switch(unit){case'%p':element=popperOffsets;break;case'%':case'%r':default:element=referenceOffsets;}var rect=getClientRect(element);return rect[measurement]/100*value;}else if(unit==='vh'||unit==='vw'){// if is a vh or vw, we calculate the size based on the viewport\nvar size=void 0;if(unit==='vh'){size=Math.max(document.documentElement.clientHeight,window.innerHeight||0);}else{size=Math.max(document.documentElement.clientWidth,window.innerWidth||0);}return size/100*value;}else{// if is an explicit pixel unit, we get rid of the unit and keep the value\n// if is an implicit unit, it's px, and we return just the value\nreturn value;}}/**\n   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n   * @function\n   * @memberof {modifiers~offset}\n   * @private\n   * @argument {String} offset\n   * @argument {Object} popperOffsets\n   * @argument {Object} referenceOffsets\n   * @argument {String} basePlacement\n   * @returns {Array} a two cells array with x and y offsets in numbers\n   */function parseOffset(offset,popperOffsets,referenceOffsets,basePlacement){var offsets=[0,0];// Use height if placement is left or right and index is 0 otherwise use width\n// in this way the first offset will use an axis and the second one\n// will use the other one\nvar useHeight=['right','left'].indexOf(basePlacement)!==-1;// Split the offset string to obtain a list of values and operands\n// The regex addresses values with the plus or minus sign in front (+10, -20, etc)\nvar fragments=offset.split(/(\\+|\\-)/).map(function(frag){return frag.trim();});// Detect if the offset string contains a pair of values or a single one\n// they could be separated by comma or space\nvar divider=fragments.indexOf(find(fragments,function(frag){return frag.search(/,|\\s/)!==-1;}));if(fragments[divider]&&fragments[divider].indexOf(',')===-1){console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');}// If divider is found, we divide the list of values and operands to divide\n// them by ofset X and Y.\nvar splitRegex=/\\s*,\\s*|\\s+/;var ops=divider!==-1?[fragments.slice(0,divider).concat([fragments[divider].split(splitRegex)[0]]),[fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider+1))]:[fragments];// Convert the values with units to absolute pixels to allow our computations\nops=ops.map(function(op,index){// Most of the units rely on the orientation of the popper\nvar measurement=(index===1?!useHeight:useHeight)?'height':'width';var mergeWithPrevious=false;return op// This aggregates any `+` or `-` sign that aren't considered operators\n// e.g.: 10 + +5 => [10, +, +5]\n.reduce(function(a,b){if(a[a.length-1]===''&&['+','-'].indexOf(b)!==-1){a[a.length-1]=b;mergeWithPrevious=true;return a;}else if(mergeWithPrevious){a[a.length-1]+=b;mergeWithPrevious=false;return a;}else{return a.concat(b);}},[])// Here we convert the string values into number values (in px)\n.map(function(str){return toValue(str,measurement,popperOffsets,referenceOffsets);});});// Loop trough the offsets arrays and execute the operations\nops.forEach(function(op,index){op.forEach(function(frag,index2){if(isNumeric(frag)){offsets[index]+=frag*(op[index2-1]==='-'?-1:1);}});});return offsets;}/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @argument {Number|String} options.offset=0\n   * The offset value as described in the modifier description\n   * @returns {Object} The data object, properly modified\n   */function offset(data,_ref){var offset=_ref.offset;var placement=data.placement,_data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference;var basePlacement=placement.split('-')[0];var offsets=void 0;if(isNumeric(+offset)){offsets=[+offset,0];}else{offsets=parseOffset(offset,popper,reference,basePlacement);}if(basePlacement==='left'){popper.top+=offsets[0];popper.left-=offsets[1];}else if(basePlacement==='right'){popper.top+=offsets[0];popper.left+=offsets[1];}else if(basePlacement==='top'){popper.left+=offsets[0];popper.top-=offsets[1];}else if(basePlacement==='bottom'){popper.left+=offsets[0];popper.top+=offsets[1];}data.popper=popper;return data;}/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function preventOverflow(data,options){var boundariesElement=options.boundariesElement||getOffsetParent(data.instance.popper);// If offsetParent is the reference element, we really want to\n// go one step up and use the next offsetParent as reference to\n// avoid to make this modifier completely useless and look like broken\nif(data.instance.reference===boundariesElement){boundariesElement=getOffsetParent(boundariesElement);}// NOTE: DOM access here\n// resets the popper's position so that the document size can be calculated excluding\n// the size of the popper element itself\nvar transformProp=getSupportedPropertyName('transform');var popperStyles=data.instance.popper.style;// assignment to help minification\nvar top=popperStyles.top,left=popperStyles.left,transform=popperStyles[transformProp];popperStyles.top='';popperStyles.left='';popperStyles[transformProp]='';var boundaries=getBoundaries(data.instance.popper,data.instance.reference,options.padding,boundariesElement,data.positionFixed);// NOTE: DOM access here\n// restores the original style properties after the offsets have been computed\npopperStyles.top=top;popperStyles.left=left;popperStyles[transformProp]=transform;options.boundaries=boundaries;var order=options.priority;var popper=data.offsets.popper;var check={primary:function primary(placement){var value=popper[placement];if(popper[placement]<boundaries[placement]&&!options.escapeWithReference){value=Math.max(popper[placement],boundaries[placement]);}return defineProperty({},placement,value);},secondary:function secondary(placement){var mainSide=placement==='right'?'left':'top';var value=popper[mainSide];if(popper[placement]>boundaries[placement]&&!options.escapeWithReference){value=Math.min(popper[mainSide],boundaries[placement]-(placement==='right'?popper.width:popper.height));}return defineProperty({},mainSide,value);}};order.forEach(function(placement){var side=['left','top'].indexOf(placement)!==-1?'primary':'secondary';popper=_extends({},popper,check[side](placement));});data.offsets.popper=popper;return data;}/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function shift(data){var placement=data.placement;var basePlacement=placement.split('-')[0];var shiftvariation=placement.split('-')[1];// if shift shiftvariation is specified, run the modifier\nif(shiftvariation){var _data$offsets=data.offsets,reference=_data$offsets.reference,popper=_data$offsets.popper;var isVertical=['bottom','top'].indexOf(basePlacement)!==-1;var side=isVertical?'left':'top';var measurement=isVertical?'width':'height';var shiftOffsets={start:defineProperty({},side,reference[side]),end:defineProperty({},side,reference[side]+reference[measurement]-popper[measurement])};data.offsets.popper=_extends({},popper,shiftOffsets[shiftvariation]);}return data;}/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function hide(data){if(!isModifierRequired(data.instance.modifiers,'hide','preventOverflow')){return data;}var refRect=data.offsets.reference;var bound=find(data.instance.modifiers,function(modifier){return modifier.name==='preventOverflow';}).boundaries;if(refRect.bottom<bound.top||refRect.left>bound.right||refRect.top>bound.bottom||refRect.right<bound.left){// Avoid unnecessary DOM access if visibility hasn't changed\nif(data.hide===true){return data;}data.hide=true;data.attributes['x-out-of-boundaries']='';}else{// Avoid unnecessary DOM access if visibility hasn't changed\nif(data.hide===false){return data;}data.hide=false;data.attributes['x-out-of-boundaries']=false;}return data;}/**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */function inner(data){var placement=data.placement;var basePlacement=placement.split('-')[0];var _data$offsets=data.offsets,popper=_data$offsets.popper,reference=_data$offsets.reference;var isHoriz=['left','right'].indexOf(basePlacement)!==-1;var subtractLength=['top','left'].indexOf(basePlacement)===-1;popper[isHoriz?'left':'top']=reference[basePlacement]-(subtractLength?popper[isHoriz?'width':'height']:0);data.placement=getOppositePlacement(placement);data.offsets.popper=getClientRect(popper);return data;}/**\n   * Modifier function, each modifier can have a function of this type assigned\n   * to its `fn` property.<br />\n   * These functions will be called on each update, this means that you must\n   * make sure they are performant enough to avoid performance bottlenecks.\n   *\n   * @function ModifierFn\n   * @argument {dataObject} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {dataObject} The data object, properly modified\n   */ /**\n   * Modifiers are plugins used to alter the behavior of your poppers.<br />\n   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n   * needed by the library.\n   *\n   * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n   * All the other properties are configurations that could be tweaked.\n   * @namespace modifiers\n   */var modifiers={/**\n     * Modifier used to shift the popper on the start or end of its reference\n     * element.<br />\n     * It will read the variation of the `placement` property.<br />\n     * It can be one either `-end` or `-start`.\n     * @memberof modifiers\n     * @inner\n     */shift:{/** @prop {number} order=100 - Index used to define the order of execution */order:100,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:shift},/**\n     * The `offset` modifier can shift your popper on both its axis.\n     *\n     * It accepts the following units:\n     * - `px` or unit-less, interpreted as pixels\n     * - `%` or `%r`, percentage relative to the length of the reference element\n     * - `%p`, percentage relative to the length of the popper element\n     * - `vw`, CSS viewport width unit\n     * - `vh`, CSS viewport height unit\n     *\n     * For length is intended the main axis relative to the placement of the popper.<br />\n     * This means that if the placement is `top` or `bottom`, the length will be the\n     * `width`. In case of `left` or `right`, it will be the `height`.\n     *\n     * You can provide a single value (as `Number` or `String`), or a pair of values\n     * as `String` divided by a comma or one (or more) white spaces.<br />\n     * The latter is a deprecated method because it leads to confusion and will be\n     * removed in v2.<br />\n     * Additionally, it accepts additions and subtractions between different units.\n     * Note that multiplications and divisions aren't supported.\n     *\n     * Valid examples are:\n     * ```\n     * 10\n     * '10%'\n     * '10, 10'\n     * '10%, 10'\n     * '10 + 10%'\n     * '10 - 5vh + 3%'\n     * '-10px + 5vh, 5px - 6%'\n     * ```\n     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n     *\n     * @memberof modifiers\n     * @inner\n     */offset:{/** @prop {number} order=200 - Index used to define the order of execution */order:200,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:offset,/** @prop {Number|String} offset=0\n       * The offset value as described in the modifier description\n       */offset:0},/**\n     * Modifier used to prevent the popper from being positioned outside the boundary.\n     *\n     * A scenario exists where the reference itself is not within the boundaries.<br />\n     * We can say it has \"escaped the boundaries\"  or just \"escaped\".<br />\n     * In this case we need to decide whether the popper should either:\n     *\n     * - detach from the reference and remain \"trapped\" in the boundaries, or\n     * - if it should ignore the boundary and \"escape with its reference\"\n     *\n     * When `escapeWithReference` is set to`true` and reference is completely\n     * outside its boundaries, the popper will overflow (or completely leave)\n     * the boundaries in order to remain attached to the edge of the reference.\n     *\n     * @memberof modifiers\n     * @inner\n     */preventOverflow:{/** @prop {number} order=300 - Index used to define the order of execution */order:300,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:preventOverflow,/**\n       * @prop {Array} [priority=['left','right','top','bottom']]\n       * Popper will try to prevent overflow following these priorities by default,\n       * then, it could overflow on the left and on top of the `boundariesElement`\n       */priority:['left','right','top','bottom'],/**\n       * @prop {number} padding=5\n       * Amount of pixel used to define a minimum distance between the boundaries\n       * and the popper. This makes sure the popper always has a little padding\n       * between the edges of its container\n       */padding:5,/**\n       * @prop {String|HTMLElement} boundariesElement='scrollParent'\n       * Boundaries used by the modifier. Can be `scrollParent`, `window`,\n       * `viewport` or any DOM element.\n       */boundariesElement:'scrollParent'},/**\n     * Modifier used to make sure the reference and its popper stay near each other\n     * without leaving any gap between the two. Especially useful when the arrow is\n     * enabled and you want to ensure that it points to its reference element.\n     * It cares only about the first axis. You can still have poppers with margin\n     * between the popper and its reference element.\n     * @memberof modifiers\n     * @inner\n     */keepTogether:{/** @prop {number} order=400 - Index used to define the order of execution */order:400,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:keepTogether},/**\n     * This modifier is used to move the `arrowElement` of the popper to make\n     * sure it is positioned between the reference element and its popper element.\n     * It will read the outer size of the `arrowElement` node to detect how many\n     * pixels of conjunction are needed.\n     *\n     * It has no effect if no `arrowElement` is provided.\n     * @memberof modifiers\n     * @inner\n     */arrow:{/** @prop {number} order=500 - Index used to define the order of execution */order:500,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:arrow,/** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */element:'[x-arrow]'},/**\n     * Modifier used to flip the popper's placement when it starts to overlap its\n     * reference element.\n     *\n     * Requires the `preventOverflow` modifier before it in order to work.\n     *\n     * **NOTE:** this modifier will interrupt the current update cycle and will\n     * restart it if it detects the need to flip the placement.\n     * @memberof modifiers\n     * @inner\n     */flip:{/** @prop {number} order=600 - Index used to define the order of execution */order:600,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:flip,/**\n       * @prop {String|Array} behavior='flip'\n       * The behavior used to change the popper's placement. It can be one of\n       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n       * placements (with optional variations)\n       */behavior:'flip',/**\n       * @prop {number} padding=5\n       * The popper will flip if it hits the edges of the `boundariesElement`\n       */padding:5,/**\n       * @prop {String|HTMLElement} boundariesElement='viewport'\n       * The element which will define the boundaries of the popper position.\n       * The popper will never be placed outside of the defined boundaries\n       * (except if `keepTogether` is enabled)\n       */boundariesElement:'viewport',/**\n       * @prop {Boolean} flipVariations=false\n       * The popper will switch placement variation between `-start` and `-end` when\n       * the reference element overlaps its boundaries.\n       *\n       * The original placement should have a set variation.\n       */flipVariations:false,/**\n       * @prop {Boolean} flipVariationsByContent=false\n       * The popper will switch placement variation between `-start` and `-end` when\n       * the popper element overlaps its reference boundaries.\n       *\n       * The original placement should have a set variation.\n       */flipVariationsByContent:false},/**\n     * Modifier used to make the popper flow toward the inner of the reference element.\n     * By default, when this modifier is disabled, the popper will be placed outside\n     * the reference element.\n     * @memberof modifiers\n     * @inner\n     */inner:{/** @prop {number} order=700 - Index used to define the order of execution */order:700,/** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */enabled:false,/** @prop {ModifierFn} */fn:inner},/**\n     * Modifier used to hide the popper when its reference element is outside of the\n     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n     * be used to hide with a CSS selector the popper when its reference is\n     * out of boundaries.\n     *\n     * Requires the `preventOverflow` modifier before it in order to work.\n     * @memberof modifiers\n     * @inner\n     */hide:{/** @prop {number} order=800 - Index used to define the order of execution */order:800,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:hide},/**\n     * Computes the style that will be applied to the popper element to gets\n     * properly positioned.\n     *\n     * Note that this modifier will not touch the DOM, it just prepares the styles\n     * so that `applyStyle` modifier can apply it. This separation is useful\n     * in case you need to replace `applyStyle` with a custom implementation.\n     *\n     * This modifier has `850` as `order` value to maintain backward compatibility\n     * with previous versions of Popper.js. Expect the modifiers ordering method\n     * to change in future major versions of the library.\n     *\n     * @memberof modifiers\n     * @inner\n     */computeStyle:{/** @prop {number} order=850 - Index used to define the order of execution */order:850,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:computeStyle,/**\n       * @prop {Boolean} gpuAcceleration=true\n       * If true, it uses the CSS 3D transformation to position the popper.\n       * Otherwise, it will use the `top` and `left` properties\n       */gpuAcceleration:true,/**\n       * @prop {string} [x='bottom']\n       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n       * Change this if your popper should grow in a direction different from `bottom`\n       */x:'bottom',/**\n       * @prop {string} [x='left']\n       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n       * Change this if your popper should grow in a direction different from `right`\n       */y:'right'},/**\n     * Applies the computed styles to the popper element.\n     *\n     * All the DOM manipulations are limited to this modifier. This is useful in case\n     * you want to integrate Popper.js inside a framework or view library and you\n     * want to delegate all the DOM manipulations to it.\n     *\n     * Note that if you disable this modifier, you must make sure the popper element\n     * has its position set to `absolute` before Popper.js can do its work!\n     *\n     * Just disable this modifier and define your own to achieve the desired effect.\n     *\n     * @memberof modifiers\n     * @inner\n     */applyStyle:{/** @prop {number} order=900 - Index used to define the order of execution */order:900,/** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */enabled:true,/** @prop {ModifierFn} */fn:applyStyle,/** @prop {Function} */onLoad:applyStyleOnLoad,/**\n       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n       * @prop {Boolean} gpuAcceleration=true\n       * If true, it uses the CSS 3D transformation to position the popper.\n       * Otherwise, it will use the `top` and `left` properties\n       */gpuAcceleration:undefined}};/**\n   * The `dataObject` is an object containing all the information used by Popper.js.\n   * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n   * @name dataObject\n   * @property {Object} data.instance The Popper.js instance\n   * @property {String} data.placement Placement applied to popper\n   * @property {String} data.originalPlacement Placement originally defined on init\n   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper\n   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n   * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)\n   * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)\n   * @property {Object} data.boundaries Offsets of the popper boundaries\n   * @property {Object} data.offsets The measurements of popper, reference and arrow elements\n   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n   */ /**\n   * Default options provided to Popper.js constructor.<br />\n   * These can be overridden using the `options` argument of Popper.js.<br />\n   * To override an option, simply pass an object with the same\n   * structure of the `options` object, as the 3rd argument. For example:\n   * ```\n   * new Popper(ref, pop, {\n   *   modifiers: {\n   *     preventOverflow: { enabled: false }\n   *   }\n   * })\n   * ```\n   * @type {Object}\n   * @static\n   * @memberof Popper\n   */var Defaults={/**\n     * Popper's placement.\n     * @prop {Popper.placements} placement='bottom'\n     */placement:'bottom',/**\n     * Set this to true if you want popper to position it self in 'fixed' mode\n     * @prop {Boolean} positionFixed=false\n     */positionFixed:false,/**\n     * Whether events (resize, scroll) are initially enabled.\n     * @prop {Boolean} eventsEnabled=true\n     */eventsEnabled:true,/**\n     * Set to true if you want to automatically remove the popper when\n     * you call the `destroy` method.\n     * @prop {Boolean} removeOnDestroy=false\n     */removeOnDestroy:false,/**\n     * Callback called when the popper is created.<br />\n     * By default, it is set to no-op.<br />\n     * Access Popper.js instance with `data.instance`.\n     * @prop {onCreate}\n     */onCreate:function onCreate(){},/**\n     * Callback called when the popper is updated. This callback is not called\n     * on the initialization/creation of the popper, but only on subsequent\n     * updates.<br />\n     * By default, it is set to no-op.<br />\n     * Access Popper.js instance with `data.instance`.\n     * @prop {onUpdate}\n     */onUpdate:function onUpdate(){},/**\n     * List of modifiers used to modify the offsets before they are applied to the popper.\n     * They provide most of the functionalities of Popper.js.\n     * @prop {modifiers}\n     */modifiers:modifiers};/**\n   * @callback onCreate\n   * @param {dataObject} data\n   */ /**\n   * @callback onUpdate\n   * @param {dataObject} data\n   */ // Utils\n// Methods\nvar Popper=function(){/**\n     * Creates a new Popper.js instance.\n     * @class Popper\n     * @param {Element|referenceObject} reference - The reference element used to position the popper\n     * @param {Element} popper - The HTML / XML element used as the popper\n     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n     * @return {Object} instance - The generated Popper.js instance\n     */function Popper(reference,popper){var _this=this;var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};classCallCheck(this,Popper);this.scheduleUpdate=function(){return requestAnimationFrame(_this.update);};// make update() debounced, so that it only runs at most once-per-tick\nthis.update=debounce(this.update.bind(this));// with {} we create a new object with the options inside it\nthis.options=_extends({},Popper.Defaults,options);// init state\nthis.state={isDestroyed:false,isCreated:false,scrollParents:[]};// get reference and popper elements (allow jQuery wrappers)\nthis.reference=reference&&reference.jquery?reference[0]:reference;this.popper=popper&&popper.jquery?popper[0]:popper;// Deep merge modifiers options\nthis.options.modifiers={};Object.keys(_extends({},Popper.Defaults.modifiers,options.modifiers)).forEach(function(name){_this.options.modifiers[name]=_extends({},Popper.Defaults.modifiers[name]||{},options.modifiers?options.modifiers[name]:{});});// Refactoring modifiers' list (Object => Array)\nthis.modifiers=Object.keys(this.options.modifiers).map(function(name){return _extends({name:name},_this.options.modifiers[name]);})// sort the modifiers by order\n.sort(function(a,b){return a.order-b.order;});// modifiers have the ability to execute arbitrary code when Popper.js get inited\n// such code is executed in the same order of its modifier\n// they could add new properties to their options configuration\n// BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\nthis.modifiers.forEach(function(modifierOptions){if(modifierOptions.enabled&&isFunction(modifierOptions.onLoad)){modifierOptions.onLoad(_this.reference,_this.popper,_this.options,modifierOptions,_this.state);}});// fire the first update to position the popper in the right place\nthis.update();var eventsEnabled=this.options.eventsEnabled;if(eventsEnabled){// setup event listeners, they will take care of update the position in specific situations\nthis.enableEventListeners();}this.state.eventsEnabled=eventsEnabled;}// We can't use class properties because they don't get listed in the\n// class prototype and break stuff like Sinon stubs\ncreateClass(Popper,[{key:'update',value:function update$$1(){return update.call(this);}},{key:'destroy',value:function destroy$$1(){return destroy.call(this);}},{key:'enableEventListeners',value:function enableEventListeners$$1(){return enableEventListeners.call(this);}},{key:'disableEventListeners',value:function disableEventListeners$$1(){return disableEventListeners.call(this);}/**\n       * Schedules an update. It will run on the next UI update available.\n       * @method scheduleUpdate\n       * @memberof Popper\n       */ /**\n       * Collection of utilities useful when writing custom modifiers.\n       * Starting from version 1.7, this method is available only if you\n       * include `popper-utils.js` before `popper.js`.\n       *\n       * **DEPRECATION**: This way to access PopperUtils is deprecated\n       * and will be removed in v2! Use the PopperUtils module directly instead.\n       * Due to the high instability of the methods contained in Utils, we can't\n       * guarantee them to follow semver. Use them at your own risk!\n       * @static\n       * @private\n       * @type {Object}\n       * @deprecated since version 1.8\n       * @member Utils\n       * @memberof Popper\n       */}]);return Popper;}();/**\n   * The `referenceObject` is an object that provides an interface compatible with Popper.js\n   * and lets you use it as replacement of a real DOM node.<br />\n   * You can use this method to position a popper relatively to a set of coordinates\n   * in case you don't have a DOM node to use as reference.\n   *\n   * ```\n   * new Popper(referenceObject, popperNode);\n   * ```\n   *\n   * NB: This feature isn't supported in Internet Explorer 10.\n   * @name referenceObject\n   * @property {Function} data.getBoundingClientRect\n   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n   * @property {number} data.clientWidth\n   * An ES6 getter that will return the width of the virtual reference element.\n   * @property {number} data.clientHeight\n   * An ES6 getter that will return the height of the virtual reference element.\n   */Popper.Utils=(typeof window!=='undefined'?window:__webpack_require__.g).PopperUtils;Popper.placements=placements;Popper.Defaults=Defaults;var PLACEMENT_TOP_START='top-start';var PLACEMENT_TOP_END='top-end';var PLACEMENT_BOTTOM_START='bottom-start';var PLACEMENT_BOTTOM_END='bottom-end';var PLACEMENT_RIGHT_START='right-start';var PLACEMENT_LEFT_START='left-start';var BvEvent=/*#__PURE__*/function(){function BvEvent(type){var eventInit=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,BvEvent);// Start by emulating native Event constructor\nif(!type){/* istanbul ignore next */throw new TypeError(\"Failed to construct '\".concat(this.constructor.name,\"'. 1 argument required, \").concat(arguments.length,\" given.\"));}// Merge defaults first, the eventInit, and the type last\n// so it can't be overwritten\nassign(this,BvEvent.Defaults,this.constructor.Defaults,eventInit,{type:type});// Freeze some props as readonly, but leave them enumerable\ndefineProperties(this,{type:readonlyDescriptor(),cancelable:readonlyDescriptor(),nativeEvent:readonlyDescriptor(),target:readonlyDescriptor(),relatedTarget:readonlyDescriptor(),vueTarget:readonlyDescriptor(),componentId:readonlyDescriptor()});// Create a private variable using closure scoping\nvar defaultPrevented=false;// Recreate preventDefault method. One way setter\nthis.preventDefault=function preventDefault(){if(this.cancelable){defaultPrevented=true;}};// Create `defaultPrevented` publicly accessible prop that\n// can only be altered by the preventDefault method\ndefineProperty$1(this,'defaultPrevented',{enumerable:true,get:function get(){return defaultPrevented;}});}_createClass(BvEvent,null,[{key:\"Defaults\",get:function get(){return{type:'',cancelable:true,nativeEvent:null,target:null,relatedTarget:null,vueTarget:null,componentId:null};}}]);return BvEvent;}();var clickOutMixin=Vue__default['default'].extend({data:function data(){return{listenForClickOut:false};},watch:{listenForClickOut:function listenForClickOut(newValue,oldValue){if(newValue!==oldValue){eventOff(this.clickOutElement,this.clickOutEventName,this._clickOutHandler,EVENT_OPTIONS_NO_CAPTURE);if(newValue){eventOn(this.clickOutElement,this.clickOutEventName,this._clickOutHandler,EVENT_OPTIONS_NO_CAPTURE);}}}},beforeCreate:function beforeCreate(){// Declare non-reactive properties\nthis.clickOutElement=null;this.clickOutEventName=null;},mounted:function mounted(){if(!this.clickOutElement){this.clickOutElement=document;}if(!this.clickOutEventName){this.clickOutEventName='click';}if(this.listenForClickOut){eventOn(this.clickOutElement,this.clickOutEventName,this._clickOutHandler,EVENT_OPTIONS_NO_CAPTURE);}},beforeDestroy:function beforeDestroy(){eventOff(this.clickOutElement,this.clickOutEventName,this._clickOutHandler,EVENT_OPTIONS_NO_CAPTURE);},methods:{isClickOut:function isClickOut(event){return!contains(this.$el,event.target);},_clickOutHandler:function _clickOutHandler(event){if(this.clickOutHandler&&this.isClickOut(event)){this.clickOutHandler(event);}}}});var focusInMixin=Vue__default['default'].extend({data:function data(){return{listenForFocusIn:false};},watch:{listenForFocusIn:function listenForFocusIn(newValue,oldValue){if(newValue!==oldValue){eventOff(this.focusInElement,'focusin',this._focusInHandler,EVENT_OPTIONS_NO_CAPTURE);if(newValue){eventOn(this.focusInElement,'focusin',this._focusInHandler,EVENT_OPTIONS_NO_CAPTURE);}}}},beforeCreate:function beforeCreate(){// Declare non-reactive properties\nthis.focusInElement=null;},mounted:function mounted(){if(!this.focusInElement){this.focusInElement=document;}if(this.listenForFocusIn){eventOn(this.focusInElement,'focusin',this._focusInHandler,EVENT_OPTIONS_NO_CAPTURE);}},beforeDestroy:function beforeDestroy(){eventOff(this.focusInElement,'focusin',this._focusInHandler,EVENT_OPTIONS_NO_CAPTURE);},methods:{_focusInHandler:function _focusInHandler(event){if(this.focusInHandler){this.focusInHandler(event);}}}});var ROOT_EVENT_NAME_SHOWN=getRootEventName(NAME_DROPDOWN,EVENT_NAME_SHOWN);var ROOT_EVENT_NAME_HIDDEN=getRootEventName(NAME_DROPDOWN,EVENT_NAME_HIDDEN);// CSS selectors\nvar SELECTOR_FORM_CHILD='.dropdown form';var SELECTOR_ITEM=['.dropdown-item','.b-dropdown-form'].map(function(selector){return\"\".concat(selector,\":not(.disabled):not([disabled])\");}).join(', ');// --- Helper methods ---\n// Return an array of visible items\nvar filterVisibles=function filterVisibles(els){return(els||[]).filter(isVisible);};// --- Props ---\nvar props$1O=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},props$25),{},{// String: `scrollParent`, `window` or `viewport`\n// HTMLElement: HTML Element reference\nboundary:makeProp([HTMLElement,PROP_TYPE_STRING],'scrollParent'),disabled:makeProp(PROP_TYPE_BOOLEAN,false),// Place left if possible\ndropleft:makeProp(PROP_TYPE_BOOLEAN,false),// Place right if possible\ndropright:makeProp(PROP_TYPE_BOOLEAN,false),// Place on top if possible\ndropup:makeProp(PROP_TYPE_BOOLEAN,false),// Disable auto-flipping of menu from bottom <=> top\nnoFlip:makeProp(PROP_TYPE_BOOLEAN,false),// Number of pixels or a CSS unit value to offset menu\n// (i.e. `1px`, `1rem`, etc.)\noffset:makeProp(PROP_TYPE_NUMBER_STRING,0),popperOpts:makeProp(PROP_TYPE_OBJECT,{}),// Right align menu (default is left align)\nright:makeProp(PROP_TYPE_BOOLEAN,false)})),NAME_DROPDOWN);// --- Mixin ---\n// @vue/component\nvar dropdownMixin=Vue__default['default'].extend({mixins:[idMixin,listenOnRootMixin,clickOutMixin,focusInMixin],provide:function provide(){return{bvDropdown:this};},inject:{bvNavbar:{default:null}},props:props$1O,data:function data(){return{visible:false,visibleChangePrevented:false};},computed:{inNavbar:function inNavbar(){return!isNull(this.bvNavbar);},toggler:function toggler(){var toggle=this.$refs.toggle;return toggle?toggle.$el||toggle:null;},directionClass:function directionClass(){if(this.dropup){return'dropup';}else if(this.dropright){return'dropright';}else if(this.dropleft){return'dropleft';}return'';},boundaryClass:function boundaryClass(){// Position `static` is needed to allow menu to \"breakout\" of the `scrollParent`\n// boundaries when boundary is anything other than `scrollParent`\n// See: https://github.com/twbs/bootstrap/issues/24251#issuecomment-341413786\nreturn this.boundary!=='scrollParent'&&!this.inNavbar?'position-static':'';},hideDelay:function hideDelay(){return this.inNavbar?HAS_TOUCH_SUPPORT?300:50:0;}},watch:{visible:function visible(newValue,oldValue){if(this.visibleChangePrevented){this.visibleChangePrevented=false;return;}if(newValue!==oldValue){var eventName=newValue?EVENT_NAME_SHOW:EVENT_NAME_HIDE;var bvEvent=new BvEvent(eventName,{cancelable:true,vueTarget:this,target:this.$refs.menu,relatedTarget:null,componentId:this.safeId?this.safeId():this.id||null});this.emitEvent(bvEvent);if(bvEvent.defaultPrevented){// Reset value and exit if canceled\nthis.visibleChangePrevented=true;this.visible=oldValue;// Just in case a child element triggered `this.hide(true)`\nthis.$off(EVENT_NAME_HIDDEN,this.focusToggler);return;}if(newValue){this.showMenu();}else{this.hideMenu();}}},disabled:function disabled(newValue,oldValue){if(newValue!==oldValue&&newValue&&this.visible){// Hide dropdown if disabled changes to true\nthis.visible=false;}}},created:function created(){// Create private non-reactive props\nthis.$_popper=null;this.$_hideTimeout=null;},/* istanbul ignore next */deactivated:function deactivated(){// In case we are inside a `<keep-alive>`\nthis.visible=false;this.whileOpenListen(false);this.destroyPopper();},beforeDestroy:function beforeDestroy(){this.visible=false;this.whileOpenListen(false);this.destroyPopper();this.clearHideTimeout();},methods:{// Event emitter\nemitEvent:function emitEvent(bvEvent){var type=bvEvent.type;this.emitOnRoot(getRootEventName(NAME_DROPDOWN,type),bvEvent);this.$emit(type,bvEvent);},showMenu:function showMenu(){var _this=this;if(this.disabled){/* istanbul ignore next */return;}// Only instantiate Popper.js when dropdown is not in `<b-navbar>`\nif(!this.inNavbar){if(typeof Popper==='undefined'){/* istanbul ignore next */warn('Popper.js not found. Falling back to CSS positioning',NAME_DROPDOWN);}else{// For dropup with alignment we use the parent element as popper container\nvar el=this.dropup&&this.right||this.split?this.$el:this.$refs.toggle;// Make sure we have a reference to an element, not a component!\nel=el.$el||el;// Instantiate Popper.js\nthis.createPopper(el);}}// Ensure other menus are closed\nthis.emitOnRoot(ROOT_EVENT_NAME_SHOWN,this);// Enable listeners\nthis.whileOpenListen(true);// Wrap in `$nextTick()` to ensure menu is fully rendered/shown\nthis.$nextTick(function(){// Focus on the menu container on show\n_this.focusMenu();// Emit the shown event\n_this.$emit(EVENT_NAME_SHOWN);});},hideMenu:function hideMenu(){this.whileOpenListen(false);this.emitOnRoot(ROOT_EVENT_NAME_HIDDEN,this);this.$emit(EVENT_NAME_HIDDEN);this.destroyPopper();},createPopper:function createPopper(element){this.destroyPopper();this.$_popper=new Popper(element,this.$refs.menu,this.getPopperConfig());},// Ensure popper event listeners are removed cleanly\ndestroyPopper:function destroyPopper(){this.$_popper&&this.$_popper.destroy();this.$_popper=null;},// Instructs popper to re-computes the dropdown position\n// useful if the content changes size\nupdatePopper:function updatePopper(){try{this.$_popper.scheduleUpdate();}catch(_unused){}},clearHideTimeout:function clearHideTimeout(){clearTimeout(this.$_hideTimeout);this.$_hideTimeout=null;},getPopperConfig:function getPopperConfig(){var placement=PLACEMENT_BOTTOM_START;if(this.dropup){placement=this.right?PLACEMENT_TOP_END:PLACEMENT_TOP_START;}else if(this.dropright){placement=PLACEMENT_RIGHT_START;}else if(this.dropleft){placement=PLACEMENT_LEFT_START;}else if(this.right){placement=PLACEMENT_BOTTOM_END;}var popperConfig={placement:placement,modifiers:{offset:{offset:this.offset||0},flip:{enabled:!this.noFlip}}};var boundariesElement=this.boundary;if(boundariesElement){popperConfig.modifiers.preventOverflow={boundariesElement:boundariesElement};}return mergeDeep(popperConfig,this.popperOpts||{});},// Turn listeners on/off while open\nwhileOpenListen:function whileOpenListen(isOpen){// Hide the dropdown when clicked outside\nthis.listenForClickOut=isOpen;// Hide the dropdown when it loses focus\nthis.listenForFocusIn=isOpen;// Hide the dropdown when another dropdown is opened\nvar method=isOpen?'$on':'$off';this.$root[method](ROOT_EVENT_NAME_SHOWN,this.rootCloseListener);},rootCloseListener:function rootCloseListener(vm){if(vm!==this){this.visible=false;}},// Public method to show dropdown\nshow:function show(){var _this2=this;if(this.disabled){return;}// Wrap in a `requestAF()` to allow any previous\n// click handling to occur first\nrequestAF(function(){_this2.visible=true;});},// Public method to hide dropdown\nhide:function hide(){var refocus=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;/* istanbul ignore next */if(this.disabled){return;}this.visible=false;if(refocus){// Child element is closing the dropdown on click\nthis.$once(EVENT_NAME_HIDDEN,this.focusToggler);}},// Called only by a button that toggles the menu\ntoggle:function toggle(event){event=event||{};// Early exit when not a click event or ENTER, SPACE or DOWN were pressed\nvar _event=event,type=_event.type,keyCode=_event.keyCode;if(type!=='click'&&!(type==='keydown'&&[CODE_ENTER,CODE_SPACE,CODE_DOWN].indexOf(keyCode)!==-1)){/* istanbul ignore next */return;}/* istanbul ignore next */if(this.disabled){this.visible=false;return;}this.$emit(EVENT_NAME_TOGGLE,event);stopEvent(event);// Toggle visibility\nif(this.visible){this.hide(true);}else{this.show();}},// Mousedown handler for the toggle\n/* istanbul ignore next */onMousedown:function onMousedown(event){// We prevent the 'mousedown' event for the toggle to stop the\n// 'focusin' event from being fired\n// The event would otherwise be picked up by the global 'focusin'\n// listener and there is no cross-browser solution to detect it\n// relates to the toggle click\n// The 'click' event will still be fired and we handle closing\n// other dropdowns there too\n// See https://github.com/bootstrap-vue/bootstrap-vue/issues/4328\nstopEvent(event,{propagation:false});},// Called from dropdown menu context\nonKeydown:function onKeydown(event){var keyCode=event.keyCode;if(keyCode===CODE_ESC){// Close on ESC\nthis.onEsc(event);}else if(keyCode===CODE_DOWN){// Down Arrow\nthis.focusNext(event,false);}else if(keyCode===CODE_UP){// Up Arrow\nthis.focusNext(event,true);}},// If user presses ESC, close the menu\nonEsc:function onEsc(event){if(this.visible){this.visible=false;stopEvent(event);// Return focus to original trigger button\nthis.$once(EVENT_NAME_HIDDEN,this.focusToggler);}},// Called only in split button mode, for the split button\nonSplitClick:function onSplitClick(event){/* istanbul ignore next */if(this.disabled){this.visible=false;return;}this.$emit(EVENT_NAME_CLICK,event);},// Shared hide handler between click-out and focus-in events\nhideHandler:function hideHandler(event){var _this3=this;var target=event.target;if(this.visible&&!contains(this.$refs.menu,target)&&!contains(this.toggler,target)){this.clearHideTimeout();this.$_hideTimeout=setTimeout(function(){return _this3.hide();},this.hideDelay);}},// Document click-out listener\nclickOutHandler:function clickOutHandler(event){this.hideHandler(event);},// Document focus-in listener\nfocusInHandler:function focusInHandler(event){this.hideHandler(event);},// Keyboard nav\nfocusNext:function focusNext(event,up){var _this4=this;// Ignore key up/down on form elements\nvar target=event.target;if(!this.visible||event&&closest(SELECTOR_FORM_CHILD,target)){/* istanbul ignore next: should never happen */return;}stopEvent(event);this.$nextTick(function(){var items=_this4.getItems();if(items.length<1){/* istanbul ignore next: should never happen */return;}var index=items.indexOf(target);if(up&&index>0){index--;}else if(!up&&index<items.length-1){index++;}if(index<0){/* istanbul ignore next: should never happen */index=0;}_this4.focusItem(index,items);});},focusItem:function focusItem(index,items){var el=items.find(function(el,i){return i===index;});attemptFocus(el);},getItems:function getItems(){// Get all items\nreturn filterVisibles(selectAll(SELECTOR_ITEM,this.$refs.menu));},focusMenu:function focusMenu(){attemptFocus(this.$refs.menu);},focusToggler:function focusToggler(){var _this5=this;this.$nextTick(function(){attemptFocus(_this5.toggler);});}}});var props$1N=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),props$1O),{},{block:makeProp(PROP_TYPE_BOOLEAN,false),html:makeProp(PROP_TYPE_STRING),// If `true`, only render menu contents when open\nlazy:makeProp(PROP_TYPE_BOOLEAN,false),menuClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),noCaret:makeProp(PROP_TYPE_BOOLEAN,false),role:makeProp(PROP_TYPE_STRING,'menu'),size:makeProp(PROP_TYPE_STRING),split:makeProp(PROP_TYPE_BOOLEAN,false),splitButtonType:makeProp(PROP_TYPE_STRING,'button',function(value){return arrayIncludes(['button','submit','reset'],value);}),splitClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),splitHref:makeProp(PROP_TYPE_STRING),splitTo:makeProp(PROP_TYPE_OBJECT_STRING),splitVariant:makeProp(PROP_TYPE_STRING),text:makeProp(PROP_TYPE_STRING),toggleAttrs:makeProp(PROP_TYPE_OBJECT,{}),toggleClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),toggleTag:makeProp(PROP_TYPE_STRING,'button'),// TODO: This really should be `toggleLabel`\ntoggleText:makeProp(PROP_TYPE_STRING,'Toggle dropdown'),variant:makeProp(PROP_TYPE_STRING,'secondary')})),NAME_DROPDOWN);// --- Main component ---\n// @vue/component\nvar BDropdown=/*#__PURE__*/Vue__default['default'].extend({name:NAME_DROPDOWN,mixins:[idMixin,dropdownMixin,normalizeSlotMixin],props:props$1N,computed:{dropdownClasses:function dropdownClasses(){var block=this.block,split=this.split;return[this.directionClass,this.boundaryClass,{show:this.visible,// The 'btn-group' class is required in `split` mode for button alignment\n// It needs also to be applied when `block` is disabled to allow multiple\n// dropdowns to be aligned one line\n'btn-group':split||!block,// When `block` is enabled and we are in `split` mode the 'd-flex' class\n// needs to be applied to allow the buttons to stretch to full width\n'd-flex':block&&split}];},menuClasses:function menuClasses(){return[this.menuClass,{'dropdown-menu-right':this.right,show:this.visible}];},toggleClasses:function toggleClasses(){var split=this.split;return[this.toggleClass,{'dropdown-toggle-split':split,'dropdown-toggle-no-caret':this.noCaret&&!split}];}},render:function render(h){var visible=this.visible,variant=this.variant,size=this.size,block=this.block,disabled=this.disabled,split=this.split,role=this.role,hide=this.hide,toggle=this.toggle;var commonProps={variant:variant,size:size,block:block,disabled:disabled};var $buttonChildren=this.normalizeSlot(SLOT_NAME_BUTTON_CONTENT);var buttonContentDomProps=this.hasNormalizedSlot(SLOT_NAME_BUTTON_CONTENT)?{}:htmlOrText(this.html,this.text);var $split=h();if(split){var splitTo=this.splitTo,splitHref=this.splitHref,splitButtonType=this.splitButtonType;var btnProps=_objectSpread2$3(_objectSpread2$3({},commonProps),{},{variant:this.splitVariant||variant});// We add these as needed due to <router-link> issues with\n// defined property with `undefined`/`null` values\nif(splitTo){btnProps.to=splitTo;}else if(splitHref){btnProps.href=splitHref;}else if(splitButtonType){btnProps.type=splitButtonType;}$split=h(BButton,{class:this.splitClass,attrs:{id:this.safeId('_BV_button_')},props:btnProps,domProps:buttonContentDomProps,on:{click:this.onSplitClick},ref:'button'},$buttonChildren);// Overwrite button content for the toggle when in `split` mode\n$buttonChildren=[h('span',{class:['sr-only']},[this.toggleText])];buttonContentDomProps={};}var ariaHasPopupRoles=['menu','listbox','tree','grid','dialog'];var $toggle=h(BButton,{staticClass:'dropdown-toggle',class:this.toggleClasses,attrs:_objectSpread2$3(_objectSpread2$3({},this.toggleAttrs),{},{// Must have attributes\nid:this.safeId('_BV_toggle_'),'aria-haspopup':ariaHasPopupRoles.includes(role)?role:'false','aria-expanded':toString(visible)}),props:_objectSpread2$3(_objectSpread2$3({},commonProps),{},{tag:this.toggleTag,block:block&&!split}),domProps:buttonContentDomProps,on:{mousedown:this.onMousedown,click:toggle,keydown:toggle// Handle ENTER, SPACE and DOWN\n},ref:'toggle'},$buttonChildren);var $menu=h('ul',{staticClass:'dropdown-menu',class:this.menuClasses,attrs:{role:role,tabindex:'-1','aria-labelledby':this.safeId(split?'_BV_button_':'_BV_toggle_')},on:{keydown:this.onKeydown// Handle UP, DOWN and ESC\n},ref:'menu'},[!this.lazy||visible?this.normalizeSlot(SLOT_NAME_DEFAULT,{hide:hide}):h()]);return h('div',{staticClass:'dropdown b-dropdown',class:this.dropdownClasses,attrs:{id:this.safeId()}},[$split,$toggle,$menu]);}});var linkProps$4=omit(props$2f,['event','routerTag']);var props$1M=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},linkProps$4),{},{linkClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),variant:makeProp(PROP_TYPE_STRING)})),NAME_DROPDOWN_ITEM);// --- Main component ---\n// @vue/component\nvar BDropdownItem=/*#__PURE__*/Vue__default['default'].extend({name:NAME_DROPDOWN_ITEM,mixins:[attrsMixin,normalizeSlotMixin],inject:{bvDropdown:{default:null}},inheritAttrs:false,props:props$1M,computed:{computedAttrs:function computedAttrs(){return _objectSpread2$3(_objectSpread2$3({},this.bvAttrs),{},{role:'menuitem'});}},methods:{closeDropdown:function closeDropdown(){var _this=this;// Close on next animation frame to allow <b-link> time to process\nrequestAF(function(){if(_this.bvDropdown){_this.bvDropdown.hide(true);}});},onClick:function onClick(event){this.$emit(EVENT_NAME_CLICK,event);this.closeDropdown();}},render:function render(h){var linkClass=this.linkClass,variant=this.variant,active=this.active,disabled=this.disabled,onClick=this.onClick,bvAttrs=this.bvAttrs;return h('li',{class:bvAttrs.class,style:bvAttrs.style,attrs:{role:'presentation'}},[h(BLink,{staticClass:'dropdown-item',class:[linkClass,_defineProperty({},\"text-\".concat(variant),variant&&!(active||disabled))],props:pluckProps(linkProps$4,this.$props),attrs:this.computedAttrs,on:{click:onClick},ref:'item'},this.normalizeSlot())]);}});var props$1L=makePropsConfigurable({active:makeProp(PROP_TYPE_BOOLEAN,false),activeClass:makeProp(PROP_TYPE_STRING,'active'),buttonClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),disabled:makeProp(PROP_TYPE_BOOLEAN,false),variant:makeProp(PROP_TYPE_STRING)},NAME_DROPDOWN_ITEM_BUTTON);// --- Main component ---\n// @vue/component\nvar BDropdownItemButton=/*#__PURE__*/Vue__default['default'].extend({name:NAME_DROPDOWN_ITEM_BUTTON,mixins:[attrsMixin,normalizeSlotMixin],inject:{bvDropdown:{default:null}},inheritAttrs:false,props:props$1L,computed:{computedAttrs:function computedAttrs(){return _objectSpread2$3(_objectSpread2$3({},this.bvAttrs),{},{role:'menuitem',type:'button',disabled:this.disabled});}},methods:{closeDropdown:function closeDropdown(){if(this.bvDropdown){this.bvDropdown.hide(true);}},onClick:function onClick(event){this.$emit(EVENT_NAME_CLICK,event);this.closeDropdown();}},render:function render(h){var _ref;var active=this.active,variant=this.variant,bvAttrs=this.bvAttrs;return h('li',{class:bvAttrs.class,style:bvAttrs.style,attrs:{role:'presentation'}},[h('button',{staticClass:'dropdown-item',class:[this.buttonClass,(_ref={},_defineProperty(_ref,this.activeClass,active),_defineProperty(_ref,\"text-\".concat(variant),variant&&!(active||this.disabled)),_ref)],attrs:this.computedAttrs,on:{click:this.onClick},ref:'button'},this.normalizeSlot())]);}});var props$1K=makePropsConfigurable({id:makeProp(PROP_TYPE_STRING),tag:makeProp(PROP_TYPE_STRING,'header'),variant:makeProp(PROP_TYPE_STRING)},NAME_DROPDOWN_HEADER);// --- Main component ---\n// @vue/component\nvar BDropdownHeader=/*#__PURE__*/Vue__default['default'].extend({name:NAME_DROPDOWN_HEADER,functional:true,props:props$1K,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var tag=props.tag,variant=props.variant;return h('li',a(omit(data,['attrs']),{attrs:{role:'presentation'}}),[h(tag,{staticClass:'dropdown-header',class:_defineProperty({},\"text-\".concat(variant),variant),attrs:_objectSpread2$3(_objectSpread2$3({},data.attrs||{}),{},{id:props.id||null,role:isTag(tag,'header')?null:'heading'}),ref:'header'},children)]);}});var props$1J=makePropsConfigurable({tag:makeProp(PROP_TYPE_STRING,'hr')},NAME_DROPDOWN_DIVIDER);// --- Main component ---\n// @vue/component\nvar BDropdownDivider=/*#__PURE__*/Vue__default['default'].extend({name:NAME_DROPDOWN_DIVIDER,functional:true,props:props$1J,render:function render(h,_ref){var props=_ref.props,data=_ref.data;return h('li',a(omit(data,['attrs']),{attrs:{role:'presentation'}}),[h(props.tag,{staticClass:'dropdown-divider',attrs:_objectSpread2$3(_objectSpread2$3({},data.attrs||{}),{},{role:'separator','aria-orientation':'horizontal'}),ref:'divider'})]);}});var props$1I=makePropsConfigurable({id:makeProp(PROP_TYPE_STRING),inline:makeProp(PROP_TYPE_BOOLEAN,false),novalidate:makeProp(PROP_TYPE_BOOLEAN,false),validated:makeProp(PROP_TYPE_BOOLEAN,false)},NAME_FORM);// --- Main component ---\n// @vue/component\nvar BForm=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM,functional:true,props:props$1I,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h('form',a(data,{class:{'form-inline':props.inline,'was-validated':props.validated},attrs:{id:props.id,novalidate:props.novalidate}}),children);}});var props$1H=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},props$1I),{},{disabled:makeProp(PROP_TYPE_BOOLEAN,false),formClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)})),NAME_DROPDOWN_FORM);// --- Main component ---\n// @vue/component\nvar BDropdownForm=/*#__PURE__*/Vue__default['default'].extend({name:NAME_DROPDOWN_FORM,functional:true,props:props$1H,render:function render(h,_ref){var props=_ref.props,data=_ref.data,listeners=_ref.listeners,children=_ref.children;return h('li',a(omit(data,['attrs','on']),{attrs:{role:'presentation'}}),[h(BForm,{staticClass:'b-dropdown-form',class:[props.formClass,{disabled:props.disabled}],props:props,attrs:_objectSpread2$3(_objectSpread2$3({},data.attrs||{}),{},{disabled:props.disabled,// Tab index of -1 for keyboard navigation\ntabindex:props.disabled?null:'-1'}),on:listeners,ref:'form'},children)]);}});var props$1G=makePropsConfigurable({tag:makeProp(PROP_TYPE_STRING,'p'),textClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),variant:makeProp(PROP_TYPE_STRING)},NAME_DROPDOWN_TEXT);// --- Main component ---\n// @vue/component\nvar BDropdownText=/*#__PURE__*/Vue__default['default'].extend({name:NAME_DROPDOWN_TEXT,functional:true,props:props$1G,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var tag=props.tag,textClass=props.textClass,variant=props.variant;return h('li',a(omit(data,['attrs']),{attrs:{role:'presentation'}}),[h(tag,{staticClass:'b-dropdown-text',class:[textClass,_defineProperty({},\"text-\".concat(variant),variant)],props:props,attrs:data.attrs||{},ref:'text'},children)]);}});var props$1F=makePropsConfigurable({ariaDescribedby:makeProp(PROP_TYPE_STRING),header:makeProp(PROP_TYPE_STRING),headerClasses:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),headerTag:makeProp(PROP_TYPE_STRING,'header'),headerVariant:makeProp(PROP_TYPE_STRING),id:makeProp(PROP_TYPE_STRING)},NAME_DROPDOWN_GROUP);// --- Main component ---\n// @vue/component\nvar BDropdownGroup=/*#__PURE__*/Vue__default['default'].extend({name:NAME_DROPDOWN_GROUP,functional:true,props:props$1F,render:function render(h,_ref){var props=_ref.props,data=_ref.data,slots=_ref.slots,scopedSlots=_ref.scopedSlots;var id=props.id,variant=props.variant,header=props.header,headerTag=props.headerTag;var $slots=slots();var $scopedSlots=scopedSlots||{};var slotScope={};var headerId=id?\"_bv_\".concat(id,\"_group_dd_header\"):null;var $header=h();if(hasNormalizedSlot(SLOT_NAME_HEADER,$scopedSlots,$slots)||header){$header=h(headerTag,{staticClass:'dropdown-header',class:[props.headerClasses,_defineProperty({},\"text-\".concat(variant),variant)],attrs:{id:headerId,role:isTag(headerTag,'header')?null:'heading'}},normalizeSlot(SLOT_NAME_HEADER,slotScope,$scopedSlots,$slots)||header);}return h('li',a(omit(data,['attrs']),{attrs:{role:'presentation'}}),[$header,h('ul',{staticClass:'list-unstyled',attrs:_objectSpread2$3(_objectSpread2$3({},data.attrs||{}),{},{id:id,role:'group','aria-describedby':[headerId,props.ariaDescribedBy].filter(identity).join(' ').trim()||null})},normalizeSlot(SLOT_NAME_DEFAULT,slotScope,$scopedSlots,$slots))]);}});var DropdownPlugin=/*#__PURE__*/pluginFactory({components:{BDropdown:BDropdown,BDd:BDropdown,BDropdownItem:BDropdownItem,BDdItem:BDropdownItem,BDropdownItemButton:BDropdownItemButton,BDropdownItemBtn:BDropdownItemButton,BDdItemButton:BDropdownItemButton,BDdItemBtn:BDropdownItemButton,BDropdownHeader:BDropdownHeader,BDdHeader:BDropdownHeader,BDropdownDivider:BDropdownDivider,BDdDivider:BDropdownDivider,BDropdownForm:BDropdownForm,BDdForm:BDropdownForm,BDropdownText:BDropdownText,BDdText:BDropdownText,BDropdownGroup:BDropdownGroup,BDdGroup:BDropdownGroup}});var TYPES$2=['iframe','embed','video','object','img','b-img','b-img-lazy'];// --- Props ---\nvar props$1E=makePropsConfigurable({aspect:makeProp(PROP_TYPE_STRING,'16by9'),tag:makeProp(PROP_TYPE_STRING,'div'),type:makeProp(PROP_TYPE_STRING,'iframe',function(value){return arrayIncludes(TYPES$2,value);})},NAME_EMBED);// --- Main component ---\n// @vue/component\nvar BEmbed=/*#__PURE__*/Vue__default['default'].extend({name:NAME_EMBED,functional:true,props:props$1E,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var aspect=props.aspect;return h(props.tag,{staticClass:'embed-responsive',class:_defineProperty({},\"embed-responsive-\".concat(aspect),aspect),ref:data.ref},[h(props.type,a(omit(data,['ref']),{staticClass:'embed-responsive-item'}),children)]);}});var EmbedPlugin=/*#__PURE__*/pluginFactory({components:{BEmbed:BEmbed}});var OPTIONS_OBJECT_DEPRECATED_MSG='Setting prop \"options\" to an object is deprecated. Use the array format instead.';// --- Props ---\nvar props$1D=makePropsConfigurable({disabledField:makeProp(PROP_TYPE_STRING,'disabled'),htmlField:makeProp(PROP_TYPE_STRING,'html'),options:makeProp(PROP_TYPE_ARRAY_OBJECT,[]),textField:makeProp(PROP_TYPE_STRING,'text'),valueField:makeProp(PROP_TYPE_STRING,'value')},'formOptionControls');// --- Mixin ---\n// @vue/component\nvar formOptionsMixin=Vue__default['default'].extend({props:props$1D,computed:{formOptions:function formOptions(){return this.normalizeOptions(this.options);}},methods:{normalizeOption:function normalizeOption(option){var key=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;// When the option is an object, normalize it\nif(isPlainObject(option)){var value=get(option,this.valueField);var text=get(option,this.textField);return{value:isUndefined(value)?key||text:value,text:stripTags(String(isUndefined(text)?key:text)),html:get(option,this.htmlField),disabled:Boolean(get(option,this.disabledField))};}// Otherwise create an `<option>` object from the given value\nreturn{value:key||option,text:stripTags(String(option)),disabled:false};},normalizeOptions:function normalizeOptions(options){var _this=this;// Normalize the given options array\nif(isArray(options)){return options.map(function(option){return _this.normalizeOption(option);});}else if(isPlainObject(options)){// Deprecate the object options format\nwarn(OPTIONS_OBJECT_DEPRECATED_MSG,this.$options.name);// Normalize a `options` object to an array of options\nreturn keys(options).map(function(key){return _this.normalizeOption(options[key]||{},key);});}// If not an array or object, return an empty array\n/* istanbul ignore next */return[];}}});var props$1C=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},props$1D),{},{id:makeProp(PROP_TYPE_STRING,undefined,true)// Required\n})),NAME_FORM_DATALIST);// --- Main component ---\n// @vue/component\nvar BFormDatalist=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_DATALIST,mixins:[formOptionsMixin,normalizeSlotMixin],props:props$1C,render:function render(h){var id=this.id;var $options=this.formOptions.map(function(option,index){var value=option.value,text=option.text,html=option.html,disabled=option.disabled;return h('option',{attrs:{value:value,disabled:disabled},domProps:htmlOrText(html,text),key:\"option_\".concat(index)});});return h('datalist',{attrs:{id:id}},[$options,this.normalizeSlot()]);}});var props$1B=makePropsConfigurable({id:makeProp(PROP_TYPE_STRING),inline:makeProp(PROP_TYPE_BOOLEAN,false),tag:makeProp(PROP_TYPE_STRING,'small'),textVariant:makeProp(PROP_TYPE_STRING,'muted')},NAME_FORM_TEXT);// --- Main component ---\n// @vue/component\nvar BFormText=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_TEXT,functional:true,props:props$1B,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,a(data,{class:_defineProperty({'form-text':!props.inline},\"text-\".concat(props.textVariant),props.textVariant),attrs:{id:props.id}}),children);}});var props$1A=makePropsConfigurable({ariaLive:makeProp(PROP_TYPE_STRING),forceShow:makeProp(PROP_TYPE_BOOLEAN,false),id:makeProp(PROP_TYPE_STRING),role:makeProp(PROP_TYPE_STRING),// Tri-state prop: `true`, `false`, or `null`\nstate:makeProp(PROP_TYPE_BOOLEAN,null),tag:makeProp(PROP_TYPE_STRING,'div'),tooltip:makeProp(PROP_TYPE_BOOLEAN,false)},NAME_FORM_INVALID_FEEDBACK);// --- Main component ---\n// @vue/component\nvar BFormInvalidFeedback=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_INVALID_FEEDBACK,functional:true,props:props$1A,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var tooltip=props.tooltip,ariaLive=props.ariaLive;var show=props.forceShow===true||props.state===false;return h(props.tag,a(data,{class:{'d-block':show,'invalid-feedback':!tooltip,'invalid-tooltip':tooltip},attrs:{id:props.id||null,role:props.role||null,'aria-live':ariaLive||null,'aria-atomic':ariaLive?'true':null}}),children);}});var props$1z=makePropsConfigurable({ariaLive:makeProp(PROP_TYPE_STRING),forceShow:makeProp(PROP_TYPE_BOOLEAN,false),id:makeProp(PROP_TYPE_STRING),role:makeProp(PROP_TYPE_STRING),// Tri-state prop: `true`, `false`, or `null`\nstate:makeProp(PROP_TYPE_BOOLEAN,null),tag:makeProp(PROP_TYPE_STRING,'div'),tooltip:makeProp(PROP_TYPE_BOOLEAN,false)},NAME_FORM_VALID_FEEDBACK);// --- Main component ---\n// @vue/component\nvar BFormValidFeedback=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_VALID_FEEDBACK,functional:true,props:props$1z,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var tooltip=props.tooltip,ariaLive=props.ariaLive;var show=props.forceShow===true||props.state===true;return h(props.tag,a(data,{class:{'d-block':show,'valid-feedback':!tooltip,'valid-tooltip':tooltip},attrs:{id:props.id||null,role:props.role||null,'aria-live':ariaLive||null,'aria-atomic':ariaLive?'true':null}}),children);}});var props$1y=makePropsConfigurable({tag:makeProp(PROP_TYPE_STRING,'div')},NAME_FORM_ROW);// --- Main component ---\n// @vue/component\nvar BFormRow=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_ROW,functional:true,props:props$1y,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,a(data,{staticClass:'form-row'}),children);}});var FormPlugin=/*#__PURE__*/pluginFactory({components:{BForm:BForm,BFormDatalist:BFormDatalist,BDatalist:BFormDatalist,BFormText:BFormText,BFormInvalidFeedback:BFormInvalidFeedback,BFormFeedback:BFormInvalidFeedback,BFormValidFeedback:BFormValidFeedback,// Added here for convenience\nBFormRow:BFormRow}});// BFormRow is not exported here as a named export, as it is exported by Layout\nvar looseIndexOf=function looseIndexOf(array,value){for(var i=0;i<array.length;i++){if(looseEqual(array[i],value)){return i;}}return-1;};var SELECTOR='input, textarea, select';// --- Props ---\nvar props$1x=makePropsConfigurable({autofocus:makeProp(PROP_TYPE_BOOLEAN,false),disabled:makeProp(PROP_TYPE_BOOLEAN,false),form:makeProp(PROP_TYPE_STRING),id:makeProp(PROP_TYPE_STRING),name:makeProp(PROP_TYPE_STRING),required:makeProp(PROP_TYPE_BOOLEAN,false)},'formControls');// --- Mixin ---\n// @vue/component\nvar formControlMixin=Vue__default['default'].extend({props:props$1x,mounted:function mounted(){this.handleAutofocus();},/* istanbul ignore next */activated:function activated(){this.handleAutofocus();},methods:{handleAutofocus:function handleAutofocus(){var _this=this;this.$nextTick(function(){requestAF(function(){var el=_this.$el;if(_this.autofocus&&isVisible(el)){if(!matches(el,SELECTOR)){el=select(SELECTOR,el);}attemptFocus(el);}});});}}});var props$1w=makePropsConfigurable({plain:makeProp(PROP_TYPE_BOOLEAN,false)},'formControls');// --- Mixin ---\n// @vue/component\nvar formCustomMixin=Vue__default['default'].extend({props:props$1w,computed:{custom:function custom(){return!this.plain;}}});var props$1v=makePropsConfigurable({size:makeProp(PROP_TYPE_STRING)},'formControls');// --- Mixin ---\n// @vue/component\nvar formSizeMixin=Vue__default['default'].extend({props:props$1v,computed:{sizeFormClass:function sizeFormClass(){return[this.size?\"form-control-\".concat(this.size):null];}}});/* Form control contextual state class computation\n   *\n   * Returned class is either 'is-valid' or 'is-invalid' based on the 'state' prop\n   * state can be one of five values:\n   *  - true for is-valid\n   *  - false for is-invalid\n   *  - null for no contextual state\n   */var props$1u=makePropsConfigurable({// Tri-state prop: true, false, null (or undefined)\nstate:makeProp(PROP_TYPE_BOOLEAN,null)},'formState');// --- Mixin ---\n// @vue/component\nvar formStateMixin=Vue__default['default'].extend({props:props$1u,computed:{computedState:function computedState(){// If not a boolean, ensure that value is null\nreturn isBoolean(this.state)?this.state:null;},stateClass:function stateClass(){var state=this.computedState;return state===true?'is-valid':state===false?'is-invalid':null;},computedAriaInvalid:function computedAriaInvalid(){var ariaInvalid=this.ariaInvalid;if(ariaInvalid===true||ariaInvalid==='true'||ariaInvalid===''){return'true';}return this.computedState===false?'true':ariaInvalid;}}});var _watch$f,_methods;var _makeModelMixin$g=makeModelMixin('checked',{defaultValue:null}),modelMixin$f=_makeModelMixin$g.mixin,modelProps$f=_makeModelMixin$g.props,MODEL_PROP_NAME$f=_makeModelMixin$g.prop,MODEL_EVENT_NAME$f=_makeModelMixin$g.event;var props$1t=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),modelProps$f),props$1x),props$1v),props$1u),props$1w),{},{ariaLabel:makeProp(PROP_TYPE_STRING),ariaLabelledby:makeProp(PROP_TYPE_STRING),// Only applicable in standalone mode (non group)\nbutton:makeProp(PROP_TYPE_BOOLEAN,false),// Only applicable when rendered with button style\nbuttonVariant:makeProp(PROP_TYPE_STRING),inline:makeProp(PROP_TYPE_BOOLEAN,false),value:makeProp(PROP_TYPE_ANY)})),'formRadioCheckControls');// --- Mixin ---\n// @vue/component\nvar formRadioCheckMixin=Vue__default['default'].extend({mixins:[attrsMixin,idMixin,modelMixin$f,normalizeSlotMixin,formControlMixin,formSizeMixin,formStateMixin,formCustomMixin],inheritAttrs:false,props:props$1t,data:function data(){return{localChecked:this.isGroup?this.bvGroup[MODEL_PROP_NAME$f]:this[MODEL_PROP_NAME$f],hasFocus:false};},computed:{computedLocalChecked:{get:function get(){return this.isGroup?this.bvGroup.localChecked:this.localChecked;},set:function set(value){if(this.isGroup){this.bvGroup.localChecked=value;}else{this.localChecked=value;}}},isChecked:function isChecked(){return looseEqual(this.value,this.computedLocalChecked);},isRadio:function isRadio(){return true;},isGroup:function isGroup(){// Is this check/radio a child of check-group or radio-group?\nreturn!!this.bvGroup;},isBtnMode:function isBtnMode(){// Support button style in single input mode\nreturn this.isGroup?this.bvGroup.buttons:this.button;},isPlain:function isPlain(){return this.isBtnMode?false:this.isGroup?this.bvGroup.plain:this.plain;},isCustom:function isCustom(){return this.isBtnMode?false:!this.isPlain;},isSwitch:function isSwitch(){// Custom switch styling (checkboxes only)\nreturn this.isBtnMode||this.isRadio||this.isPlain?false:this.isGroup?this.bvGroup.switches:this.switch;},isInline:function isInline(){return this.isGroup?this.bvGroup.inline:this.inline;},isDisabled:function isDisabled(){// Child can be disabled while parent isn't, but is always disabled if group is\nreturn this.isGroup?this.bvGroup.disabled||this.disabled:this.disabled;},isRequired:function isRequired(){// Required only works when a name is provided for the input(s)\n// Child can only be required when parent is\n// Groups will always have a name (either user supplied or auto generated)\nreturn this.computedName&&(this.isGroup?this.bvGroup.required:this.required);},computedName:function computedName(){// Group name preferred over local name\nreturn(this.isGroup?this.bvGroup.groupName:this.name)||null;},computedForm:function computedForm(){return(this.isGroup?this.bvGroup.form:this.form)||null;},computedSize:function computedSize(){return(this.isGroup?this.bvGroup.size:this.size)||'';},computedState:function computedState(){return this.isGroup?this.bvGroup.computedState:isBoolean(this.state)?this.state:null;},computedButtonVariant:function computedButtonVariant(){// Local variant preferred over group variant\nvar buttonVariant=this.buttonVariant;if(buttonVariant){return buttonVariant;}if(this.isGroup&&this.bvGroup.buttonVariant){return this.bvGroup.buttonVariant;}return'secondary';},buttonClasses:function buttonClasses(){var _ref;var computedSize=this.computedSize;return['btn',\"btn-\".concat(this.computedButtonVariant),(_ref={},_defineProperty(_ref,\"btn-\".concat(computedSize),computedSize),_defineProperty(_ref,\"disabled\",this.isDisabled),_defineProperty(_ref,\"active\",this.isChecked),_defineProperty(_ref,\"focus\",this.hasFocus),_ref)];},computedAttrs:function computedAttrs(){var disabled=this.isDisabled,required=this.isRequired;return _objectSpread2$3(_objectSpread2$3({},this.bvAttrs),{},{id:this.safeId(),type:this.isRadio?'radio':'checkbox',name:this.computedName,form:this.computedForm,disabled:disabled,required:required,'aria-required':required||null,'aria-label':this.ariaLabel||null,'aria-labelledby':this.ariaLabelledby||null});}},watch:(_watch$f={},_defineProperty(_watch$f,MODEL_PROP_NAME$f,function(){this[\"\".concat(MODEL_PROP_NAME$f,\"Watcher\")].apply(this,arguments);}),_defineProperty(_watch$f,\"computedLocalChecked\",function computedLocalChecked(){this.computedLocalCheckedWatcher.apply(this,arguments);}),_watch$f),methods:(_methods={},_defineProperty(_methods,\"\".concat(MODEL_PROP_NAME$f,\"Watcher\"),function Watcher(newValue){if(!looseEqual(newValue,this.computedLocalChecked)){this.computedLocalChecked=newValue;}}),_defineProperty(_methods,\"computedLocalCheckedWatcher\",function computedLocalCheckedWatcher(newValue,oldValue){if(!looseEqual(newValue,oldValue)){this.$emit(MODEL_EVENT_NAME$f,newValue);}}),_defineProperty(_methods,\"handleChange\",function handleChange(_ref2){var _this=this;var checked=_ref2.target.checked;var value=this.value;var localChecked=checked?value:null;this.computedLocalChecked=value;// Fire events in a `$nextTick()` to ensure the `v-model` is updated\nthis.$nextTick(function(){// Change is only emitted on user interaction\n_this.$emit(EVENT_NAME_CHANGE,localChecked);// If this is a child of a group, we emit a change event on it as well\nif(_this.isGroup){_this.bvGroup.$emit(EVENT_NAME_CHANGE,localChecked);}});}),_defineProperty(_methods,\"handleFocus\",function handleFocus(event){// When in buttons mode, we need to add 'focus' class to label when input focused\n// As it is the hidden input which has actual focus\nif(event.target){if(event.type==='focus'){this.hasFocus=true;}else if(event.type==='blur'){this.hasFocus=false;}}}),_defineProperty(_methods,\"focus\",function focus(){if(!this.isDisabled){attemptFocus(this.$refs.input);}}),_defineProperty(_methods,\"blur\",function blur(){if(!this.isDisabled){attemptBlur(this.$refs.input);}}),_methods),render:function render(h){var isRadio=this.isRadio,isBtnMode=this.isBtnMode,isPlain=this.isPlain,isCustom=this.isCustom,isInline=this.isInline,isSwitch=this.isSwitch,computedSize=this.computedSize,bvAttrs=this.bvAttrs;var $content=this.normalizeSlot();var $input=h('input',{class:[{'form-check-input':isPlain,'custom-control-input':isCustom,// https://github.com/bootstrap-vue/bootstrap-vue/issues/2911\n'position-static':isPlain&&!$content},isBtnMode?'':this.stateClass],directives:[{name:'model',value:this.computedLocalChecked}],attrs:this.computedAttrs,domProps:{value:this.value,checked:this.isChecked},on:_objectSpread2$3({change:this.handleChange},isBtnMode?{focus:this.handleFocus,blur:this.handleFocus}:{}),key:'input',ref:'input'});if(isBtnMode){var $button=h('label',{class:this.buttonClasses},[$input,$content]);if(!this.isGroup){// Standalone button mode, so wrap in 'btn-group-toggle'\n// and flag it as inline-block to mimic regular buttons\n$button=h('div',{class:['btn-group-toggle','d-inline-block']},[$button]);}return $button;}// If no label content in plain mode we dont render the label\n// See: https://github.com/bootstrap-vue/bootstrap-vue/issues/2911\nvar $label=h();if(!(isPlain&&!$content)){$label=h('label',{class:{'form-check-label':isPlain,'custom-control-label':isCustom},attrs:{for:this.safeId()}},$content);}return h('div',{class:[_defineProperty({'form-check':isPlain,'form-check-inline':isPlain&&isInline,'custom-control':isCustom,'custom-control-inline':isCustom&&isInline,'custom-checkbox':isCustom&&!isRadio&&!isSwitch,'custom-switch':isSwitch,'custom-radio':isCustom&&isRadio},\"b-custom-control-\".concat(computedSize),computedSize&&!isBtnMode),bvAttrs.class],style:bvAttrs.style},[$input,$label]);}});var _objectSpread2$2;var MODEL_PROP_NAME_INDETERMINATE='indeterminate';var MODEL_EVENT_NAME_INDETERMINATE=MODEL_EVENT_NAME_PREFIX+MODEL_PROP_NAME_INDETERMINATE;// --- Props ---\nvar props$1s=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},props$1t),{},(_objectSpread2$2={},_defineProperty(_objectSpread2$2,MODEL_PROP_NAME_INDETERMINATE,makeProp(PROP_TYPE_BOOLEAN,false)),_defineProperty(_objectSpread2$2,\"switch\",makeProp(PROP_TYPE_BOOLEAN,false)),_defineProperty(_objectSpread2$2,\"uncheckedValue\",makeProp(PROP_TYPE_ANY,false)),_defineProperty(_objectSpread2$2,\"value\",makeProp(PROP_TYPE_ANY,true)),_objectSpread2$2))),NAME_FORM_CHECKBOX);// --- Main component ---\n// @vue/component\nvar BFormCheckbox=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_CHECKBOX,mixins:[formRadioCheckMixin],inject:{bvGroup:{from:'bvCheckGroup',default:null}},props:props$1s,computed:{isChecked:function isChecked(){var value=this.value,checked=this.computedLocalChecked;return isArray(checked)?looseIndexOf(checked,value)>-1:looseEqual(checked,value);},isRadio:function isRadio(){return false;}},watch:_defineProperty({},MODEL_PROP_NAME_INDETERMINATE,function(newValue,oldValue){if(!looseEqual(newValue,oldValue)){this.setIndeterminate(newValue);}}),mounted:function mounted(){// Set initial indeterminate state\nthis.setIndeterminate(this[MODEL_PROP_NAME_INDETERMINATE]);},methods:{computedLocalCheckedWatcher:function computedLocalCheckedWatcher(newValue,oldValue){if(!looseEqual(newValue,oldValue)){this.$emit(MODEL_EVENT_NAME$f,newValue);var $input=this.$refs.input;if($input){this.$emit(MODEL_EVENT_NAME_INDETERMINATE,$input.indeterminate);}}},handleChange:function handleChange(_ref){var _this=this;var _ref$target=_ref.target,checked=_ref$target.checked,indeterminate=_ref$target.indeterminate;var value=this.value,uncheckedValue=this.uncheckedValue;// Update `computedLocalChecked`\nvar localChecked=this.computedLocalChecked;if(isArray(localChecked)){var index=looseIndexOf(localChecked,value);if(checked&&index<0){// Add value to array\nlocalChecked=localChecked.concat(value);}else if(!checked&&index>-1){// Remove value from array\nlocalChecked=localChecked.slice(0,index).concat(localChecked.slice(index+1));}}else{localChecked=checked?value:uncheckedValue;}this.computedLocalChecked=localChecked;// Fire events in a `$nextTick()` to ensure the `v-model` is updated\nthis.$nextTick(function(){// Change is only emitted on user interaction\n_this.$emit(EVENT_NAME_CHANGE,localChecked);// If this is a child of a group, we emit a change event on it as well\nif(_this.isGroup){_this.bvGroup.$emit(EVENT_NAME_CHANGE,localChecked);}_this.$emit(MODEL_EVENT_NAME_INDETERMINATE,indeterminate);});},setIndeterminate:function setIndeterminate(state){// Indeterminate only supported in single checkbox mode\nif(isArray(this.computedLocalChecked)){state=false;}var $input=this.$refs.input;if($input){$input.indeterminate=state;// Emit update event to prop\nthis.$emit(MODEL_EVENT_NAME_INDETERMINATE,state);}}}});var props$1r=makePropsConfigurable(props$1t,NAME_FORM_RADIO);// --- Main component ---\n// @vue/component\nvar BFormRadio=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_RADIO,mixins:[formRadioCheckMixin],inject:{bvGroup:{from:'bvRadioGroup',default:false}},props:props$1r,watch:{computedLocalChecked:function computedLocalChecked(newValue,oldValue){if(!looseEqual(newValue,oldValue)){this.$emit(MODEL_EVENT_NAME$f,newValue);}}}});var _watch$e;// Attributes to pass down to checks/radios instead of applying them to the group\nvar PASS_DOWN_ATTRS=['aria-describedby','aria-labelledby'];var _makeModelMixin$f=makeModelMixin('checked'),modelMixin$e=_makeModelMixin$f.mixin,modelProps$e=_makeModelMixin$f.props,MODEL_PROP_NAME$e=_makeModelMixin$f.prop,MODEL_EVENT_NAME$e=_makeModelMixin$f.event;var props$1q=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),modelProps$e),props$1x),props$1D),props$1v),props$1u),props$1w),{},{ariaInvalid:makeProp(PROP_TYPE_BOOLEAN_STRING,false),// Only applicable when rendered with button style\nbuttonVariant:makeProp(PROP_TYPE_STRING),// Render as button style\nbuttons:makeProp(PROP_TYPE_BOOLEAN,false),stacked:makeProp(PROP_TYPE_BOOLEAN,false),validated:makeProp(PROP_TYPE_BOOLEAN,false)})),'formRadioCheckGroups');// --- Mixin ---\n// @vue/component\nvar formRadioCheckGroupMixin=Vue__default['default'].extend({mixins:[idMixin,modelMixin$e,normalizeSlotMixin,formControlMixin,formOptionsMixin,formSizeMixin,formStateMixin,formCustomMixin],inheritAttrs:false,props:props$1q,data:function data(){return{localChecked:this[MODEL_PROP_NAME$e]};},computed:{inline:function inline(){return!this.stacked;},groupName:function groupName(){// Checks/Radios tied to the same model must have the same name,\n// especially for ARIA accessibility\nreturn this.name||this.safeId();},groupClasses:function groupClasses(){var inline=this.inline,size=this.size,validated=this.validated;var classes={'was-validated':validated};if(this.buttons){classes=[classes,'btn-group-toggle',_defineProperty({'btn-group':inline,'btn-group-vertical':!inline},\"btn-group-\".concat(size),size)];}return classes;}},watch:(_watch$e={},_defineProperty(_watch$e,MODEL_PROP_NAME$e,function(newValue){if(!looseEqual(newValue,this.localChecked)){this.localChecked=newValue;}}),_defineProperty(_watch$e,\"localChecked\",function localChecked(newValue,oldValue){if(!looseEqual(newValue,oldValue)){this.$emit(MODEL_EVENT_NAME$e,newValue);}}),_watch$e),render:function render(h){var _this=this;var isRadioGroup=this.isRadioGroup;var attrs=pick$1(this.$attrs,PASS_DOWN_ATTRS);var optionComponent=isRadioGroup?BFormRadio:BFormCheckbox;var $inputs=this.formOptions.map(function(option,index){var key=\"BV_option_\".concat(index);return h(optionComponent,{props:{// Individual radios or checks can be disabled in a group\ndisabled:option.disabled||false,id:_this.safeId(key),value:option.value// We don't need to include these, since the input's will know they are inside here\n// form: this.form || null,\n// name: this.groupName,\n// required: Boolean(this.name && this.required),\n// state: this.state\n},attrs:attrs,key:key},[h('span',{domProps:htmlOrText(option.html,option.text)})]);});return h('div',{class:[this.groupClasses,'bv-no-focus-ring'],attrs:_objectSpread2$3(_objectSpread2$3({},omit(this.$attrs,PASS_DOWN_ATTRS)),{},{'aria-invalid':this.computedAriaInvalid,'aria-required':this.required?'true':null,id:this.safeId(),role:isRadioGroup?'radiogroup':'group',// Add `tabindex=\"-1\"` to allow group to be focused if needed by screen readers\ntabindex:'-1'})},[this.normalizeSlot(SLOT_NAME_FIRST),$inputs,this.normalizeSlot()]);}});var _objectSpread2$1;var props$1p=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},props$1q),{},(_objectSpread2$1={},_defineProperty(_objectSpread2$1,MODEL_PROP_NAME$e,makeProp(PROP_TYPE_ARRAY,[])),_defineProperty(_objectSpread2$1,\"switches\",makeProp(PROP_TYPE_BOOLEAN,false)),_objectSpread2$1))),NAME_FORM_CHECKBOX_GROUP);// --- Main component ---\n// @vue/component\nvar BFormCheckboxGroup=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_CHECKBOX_GROUP,// Includes render function\nmixins:[formRadioCheckGroupMixin],provide:function provide(){return{bvCheckGroup:this};},props:props$1p,computed:{isRadioGroup:function isRadioGroup(){return false;}}});var FormCheckboxPlugin=/*#__PURE__*/pluginFactory({components:{BFormCheckbox:BFormCheckbox,BCheckbox:BFormCheckbox,BCheck:BFormCheckbox,BFormCheckboxGroup:BFormCheckboxGroup,BCheckboxGroup:BFormCheckboxGroup,BCheckGroup:BFormCheckboxGroup}});// v-b-hover directive\nvar PROP$2='__BV_hover_handler__';var MOUSEENTER='mouseenter';var MOUSELEAVE='mouseleave';// --- Helper methods ---\nvar createListener=function createListener(handler){var listener=function listener(event){handler(event.type===MOUSEENTER,event);};listener.fn=handler;return listener;};var updateListeners=function updateListeners(on,el,listener){eventOnOff(on,el,MOUSEENTER,listener,EVENT_OPTIONS_NO_CAPTURE);eventOnOff(on,el,MOUSELEAVE,listener,EVENT_OPTIONS_NO_CAPTURE);};// --- Directive bind/unbind/update handler ---\nvar directive=function directive(el,_ref){var _ref$value=_ref.value,handler=_ref$value===void 0?null:_ref$value;if(IS_BROWSER){var listener=el[PROP$2];var hasListener=isFunction$1(listener);var handlerChanged=!(hasListener&&listener.fn===handler);if(hasListener&&handlerChanged){updateListeners(false,el,listener);delete el[PROP$2];}if(isFunction$1(handler)&&handlerChanged){el[PROP$2]=createListener(handler);updateListeners(true,el,el[PROP$2]);}}};// VBHover directive\nvar VBHover={bind:directive,componentUpdated:directive,unbind:function unbind(el){directive(el,{value:null});}};var props$1o=sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),props$1v),props$1u),omit(props$1O,['disabled'])),omit(props$1x,['autofocus'])),{},{// When `true`, renders a `btn-group` wrapper and visually hides the label\nbuttonOnly:makeProp(PROP_TYPE_BOOLEAN,false),// Applicable in button mode only\nbuttonVariant:makeProp(PROP_TYPE_STRING,'secondary'),// This is the value shown in the label\n// Defaults back to `value`\nformattedValue:makeProp(PROP_TYPE_STRING),// Value placed in `.sr-only` span inside label when value is present\nlabelSelected:makeProp(PROP_TYPE_STRING),lang:makeProp(PROP_TYPE_STRING),// Extra classes to apply to the `dropdown-menu` div\nmenuClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),// This is the value placed on the hidden input when no value selected\nplaceholder:makeProp(PROP_TYPE_STRING),readonly:makeProp(PROP_TYPE_BOOLEAN,false),// Tri-state prop: `true`, `false` or `null`\nrtl:makeProp(PROP_TYPE_BOOLEAN,null),value:makeProp(PROP_TYPE_STRING,'')}));// --- Main component ---\n// @vue/component\nvar BVFormBtnLabelControl=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_BUTTON_LABEL_CONTROL,directives:{'b-hover':VBHover},mixins:[idMixin,formSizeMixin,formStateMixin,dropdownMixin,normalizeSlotMixin],props:props$1o,data:function data(){return{isHovered:false,hasFocus:false};},computed:{idButton:function idButton(){return this.safeId();},idLabel:function idLabel(){return this.safeId('_value_');},idMenu:function idMenu(){return this.safeId('_dialog_');},idWrapper:function idWrapper(){return this.safeId('_outer_');},computedDir:function computedDir(){return this.rtl===true?'rtl':this.rtl===false?'ltr':null;}},methods:{focus:function focus(){if(!this.disabled){attemptFocus(this.$refs.toggle);}},blur:function blur(){if(!this.disabled){attemptBlur(this.$refs.toggle);}},setFocus:function setFocus(event){this.hasFocus=event.type==='focus';},handleHover:function handleHover(hovered){this.isHovered=hovered;}},render:function render(h){var _class;var idButton=this.idButton,idLabel=this.idLabel,idMenu=this.idMenu,idWrapper=this.idWrapper,disabled=this.disabled,readonly=this.readonly,required=this.required,name=this.name,state=this.state,visible=this.visible,size=this.size,isHovered=this.isHovered,hasFocus=this.hasFocus,labelSelected=this.labelSelected,buttonVariant=this.buttonVariant,buttonOnly=this.buttonOnly;var value=toString(this.value)||'';var invalid=state===false||required&&!value;var btnScope={isHovered:isHovered,hasFocus:hasFocus,state:state,opened:visible};var $button=h('button',{staticClass:'btn',class:(_class={},_defineProperty(_class,\"btn-\".concat(buttonVariant),buttonOnly),_defineProperty(_class,\"btn-\".concat(size),size),_defineProperty(_class,'h-auto',!buttonOnly),_defineProperty(_class,'dropdown-toggle',buttonOnly),_defineProperty(_class,'dropdown-toggle-no-caret',buttonOnly),_class),attrs:{id:idButton,type:'button',disabled:disabled,'aria-haspopup':'dialog','aria-expanded':visible?'true':'false','aria-invalid':invalid?'true':null,'aria-required':required?'true':null},directives:[{name:'b-hover',value:this.handleHover}],on:{mousedown:this.onMousedown,click:this.toggle,keydown:this.toggle,// Handle ENTER, SPACE and DOWN\n'!focus':this.setFocus,'!blur':this.setFocus},ref:'toggle'},[this.hasNormalizedSlot(SLOT_NAME_BUTTON_CONTENT)?this.normalizeSlot(SLOT_NAME_BUTTON_CONTENT,btnScope):/* istanbul ignore next */h(BIconChevronDown,{props:{scale:1.25}})]);// Hidden input\nvar $hidden=h();if(name&&!disabled){$hidden=h('input',{attrs:{type:'hidden',name:name||null,form:this.form||null,value:value}});}// Dropdown content\nvar $menu=h('div',{staticClass:'dropdown-menu',class:[this.menuClass,{show:visible,'dropdown-menu-right':this.right}],attrs:{id:idMenu,role:'dialog',tabindex:'-1','aria-modal':'false','aria-labelledby':idLabel},on:{keydown:this.onKeydown// Handle ESC\n},ref:'menu'},[this.normalizeSlot(SLOT_NAME_DEFAULT,{opened:visible})]);// Value label\nvar $label=h('label',{class:buttonOnly?'sr-only'// Hidden in button only mode\n:['form-control',// Mute the text if showing the placeholder\n{'text-muted':!value},this.stateClass,this.sizeFormClass],attrs:{id:idLabel,for:idButton,'aria-invalid':invalid?'true':null,'aria-required':required?'true':null},directives:[{name:'b-hover',value:this.handleHover}],on:{// Disable bubbling of the click event to\n// prevent menu from closing and re-opening\n'!click':/* istanbul ignore next */function click(event){stopEvent(event,{preventDefault:false});}}},[value?this.formattedValue||value:this.placeholder||'',// Add the selected label for screen readers when a value is provided\nvalue&&labelSelected?h('bdi',{staticClass:'sr-only'},labelSelected):'']);// Return the custom form control wrapper\nreturn h('div',{staticClass:'b-form-btn-label-control dropdown',class:[this.directionClass,this.boundaryClass,[{'btn-group':buttonOnly,'form-control':!buttonOnly,focus:hasFocus&&!buttonOnly,show:visible,'is-valid':state===true,'is-invalid':state===false},buttonOnly?null:this.sizeFormClass]],attrs:{id:idWrapper,role:buttonOnly?null:'group',lang:this.lang||null,dir:this.computedDir,'aria-disabled':disabled,'aria-readonly':readonly&&!disabled,'aria-labelledby':idLabel,'aria-invalid':state===false||required&&!value?'true':null,'aria-required':required?'true':null}},[$button,$hidden,$menu,$label]);}});var _watch$d;var _makeModelMixin$e=makeModelMixin('value',{type:PROP_TYPE_DATE_STRING}),modelMixin$d=_makeModelMixin$e.mixin,modelProps$d=_makeModelMixin$e.props,MODEL_PROP_NAME$d=_makeModelMixin$e.prop,MODEL_EVENT_NAME$d=_makeModelMixin$e.event;// --- Props ---\nvar calendarProps=omit(props$24,['block','hidden','id','noKeyNav','roleDescription','value','width']);var formBtnLabelControlProps$1=omit(props$1o,['formattedValue','id','lang','rtl','value']);var props$1n=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),modelProps$d),calendarProps),formBtnLabelControlProps$1),{},{// Width of the calendar dropdown\ncalendarWidth:makeProp(PROP_TYPE_STRING,'270px'),closeButton:makeProp(PROP_TYPE_BOOLEAN,false),closeButtonVariant:makeProp(PROP_TYPE_STRING,'outline-secondary'),// Dark mode\ndark:makeProp(PROP_TYPE_BOOLEAN,false),labelCloseButton:makeProp(PROP_TYPE_STRING,'Close'),labelResetButton:makeProp(PROP_TYPE_STRING,'Reset'),labelTodayButton:makeProp(PROP_TYPE_STRING,'Select today'),noCloseOnSelect:makeProp(PROP_TYPE_BOOLEAN,false),resetButton:makeProp(PROP_TYPE_BOOLEAN,false),resetButtonVariant:makeProp(PROP_TYPE_STRING,'outline-danger'),resetValue:makeProp(PROP_TYPE_DATE_STRING),todayButton:makeProp(PROP_TYPE_BOOLEAN,false),todayButtonVariant:makeProp(PROP_TYPE_STRING,'outline-primary')})),NAME_FORM_DATEPICKER);// --- Main component ---\n// @vue/component\nvar BFormDatepicker=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_DATEPICKER,mixins:[idMixin,modelMixin$d],props:props$1n,data:function data(){return{// We always use `YYYY-MM-DD` value internally\nlocalYMD:formatYMD(this[MODEL_PROP_NAME$d])||'',// If the popup is open\nisVisible:false,// Context data from BCalendar\nlocalLocale:null,isRTL:false,formattedValue:'',activeYMD:''};},computed:{calendarYM:function calendarYM(){// Returns the calendar year/month\n// Returns the `YYYY-MM` portion of the active calendar date\nreturn this.activeYMD.slice(0,-3);},computedLang:function computedLang(){return(this.localLocale||'').replace(/-u-.*$/i,'')||null;},computedResetValue:function computedResetValue(){return formatYMD(constrainDate(this.resetValue))||'';}},watch:(_watch$d={},_defineProperty(_watch$d,MODEL_PROP_NAME$d,function(newValue){this.localYMD=formatYMD(newValue)||'';}),_defineProperty(_watch$d,\"localYMD\",function localYMD(newValue){// We only update the v-model when the datepicker is open\nif(this.isVisible){this.$emit(MODEL_EVENT_NAME$d,this.valueAsDate?parseYMD(newValue)||null:newValue||'');}}),_defineProperty(_watch$d,\"calendarYM\",function calendarYM(newValue,oldValue){// Displayed calendar month has changed\n// So possibly the calendar height has changed...\n// We need to update popper computed position\nif(newValue!==oldValue&&oldValue){try{this.$refs.control.updatePopper();}catch(_unused){}}}),_watch$d),methods:{// Public methods\nfocus:function focus(){if(!this.disabled){attemptFocus(this.$refs.control);}},blur:function blur(){if(!this.disabled){attemptBlur(this.$refs.control);}},// Private methods\nsetAndClose:function setAndClose(ymd){var _this=this;this.localYMD=ymd;// Close calendar popup, unless `noCloseOnSelect`\nif(!this.noCloseOnSelect){this.$nextTick(function(){_this.$refs.control.hide(true);});}},onSelected:function onSelected(ymd){var _this2=this;this.$nextTick(function(){_this2.setAndClose(ymd);});},onInput:function onInput(ymd){if(this.localYMD!==ymd){this.localYMD=ymd;}},onContext:function onContext(ctx){var activeYMD=ctx.activeYMD,isRTL=ctx.isRTL,locale=ctx.locale,selectedYMD=ctx.selectedYMD,selectedFormatted=ctx.selectedFormatted;this.isRTL=isRTL;this.localLocale=locale;this.formattedValue=selectedFormatted;this.localYMD=selectedYMD;this.activeYMD=activeYMD;// Re-emit the context event\nthis.$emit(EVENT_NAME_CONTEXT,ctx);},onTodayButton:function onTodayButton(){// Set to today (or min/max if today is out of range)\nthis.setAndClose(formatYMD(constrainDate(createDate(),this.min,this.max)));},onResetButton:function onResetButton(){this.setAndClose(this.computedResetValue);},onCloseButton:function onCloseButton(){this.$refs.control.hide(true);},// Menu handlers\nonShow:function onShow(){this.isVisible=true;},onShown:function onShown(){var _this3=this;this.$nextTick(function(){attemptFocus(_this3.$refs.calendar);_this3.$emit(EVENT_NAME_SHOWN);});},onHidden:function onHidden(){this.isVisible=false;this.$emit(EVENT_NAME_HIDDEN);},// Render helpers\ndefaultButtonFn:function defaultButtonFn(_ref){var isHovered=_ref.isHovered,hasFocus=_ref.hasFocus;return this.$createElement(isHovered||hasFocus?BIconCalendarFill:BIconCalendar,{attrs:{'aria-hidden':'true'}});}},render:function render(h){var localYMD=this.localYMD,disabled=this.disabled,readonly=this.readonly,dark=this.dark,$props=this.$props,$scopedSlots=this.$scopedSlots;var placeholder=isUndefinedOrNull(this.placeholder)?this.labelNoDateSelected:this.placeholder;// Optional footer buttons\nvar $footer=[];if(this.todayButton){var label=this.labelTodayButton;$footer.push(h(BButton,{props:{disabled:disabled||readonly,size:'sm',variant:this.todayButtonVariant},attrs:{'aria-label':label||null},on:{click:this.onTodayButton}},label));}if(this.resetButton){var _label=this.labelResetButton;$footer.push(h(BButton,{props:{disabled:disabled||readonly,size:'sm',variant:this.resetButtonVariant},attrs:{'aria-label':_label||null},on:{click:this.onResetButton}},_label));}if(this.closeButton){var _label2=this.labelCloseButton;$footer.push(h(BButton,{props:{disabled:disabled,size:'sm',variant:this.closeButtonVariant},attrs:{'aria-label':_label2||null},on:{click:this.onCloseButton}},_label2));}if($footer.length>0){$footer=[h('div',{staticClass:'b-form-date-controls d-flex flex-wrap',class:{'justify-content-between':$footer.length>1,'justify-content-end':$footer.length<2}},$footer)];}var $calendar=h(BCalendar,{staticClass:'b-form-date-calendar w-100',props:_objectSpread2$3(_objectSpread2$3({},pluckProps(calendarProps,$props)),{},{hidden:!this.isVisible,value:localYMD,valueAsDate:false,width:this.calendarWidth}),on:{selected:this.onSelected,input:this.onInput,context:this.onContext},scopedSlots:pick$1($scopedSlots,['nav-prev-decade','nav-prev-year','nav-prev-month','nav-this-month','nav-next-month','nav-next-year','nav-next-decade']),key:'calendar',ref:'calendar'},$footer);return h(BVFormBtnLabelControl,{staticClass:'b-form-datepicker',props:_objectSpread2$3(_objectSpread2$3({},pluckProps(formBtnLabelControlProps$1,$props)),{},{formattedValue:localYMD?this.formattedValue:'',id:this.safeId(),lang:this.computedLang,menuClass:[{'bg-dark':dark,'text-light':dark},this.menuClass],placeholder:placeholder,rtl:this.isRTL,value:localYMD}),on:{show:this.onShow,shown:this.onShown,hidden:this.onHidden},scopedSlots:_defineProperty({},SLOT_NAME_BUTTON_CONTENT,$scopedSlots[SLOT_NAME_BUTTON_CONTENT]||this.defaultButtonFn),ref:'control'},[$calendar]);}});var FormDatepickerPlugin=/*#__PURE__*/pluginFactory({components:{BFormDatepicker:BFormDatepicker,BDatepicker:BFormDatepicker}});var _watch$c;var _makeModelMixin$d=makeModelMixin('value',{type:[PROP_TYPE_ARRAY,File],defaultValue:null,validator:function validator(value){/* istanbul ignore next */if(value===''){warn(VALUE_EMPTY_DEPRECATED_MSG,NAME_FORM_FILE);return true;}return isUndefinedOrNull(value)||isValidValue(value);}}),modelMixin$c=_makeModelMixin$d.mixin,modelProps$c=_makeModelMixin$d.props,MODEL_PROP_NAME$c=_makeModelMixin$d.prop,MODEL_EVENT_NAME$c=_makeModelMixin$d.event;var VALUE_EMPTY_DEPRECATED_MSG='Setting \"value\"/\"v-model\" to an empty string for reset is deprecated. Set to \"null\" instead.';// --- Helper methods ---\nvar isValidValue=function isValidValue(value){return isFile(value)||isArray(value)&&value.every(function(v){return isValidValue(v);});};// Helper method to \"safely\" get the entry from a data-transfer item\n/* istanbul ignore next: not supported in JSDOM */var getDataTransferItemEntry=function getDataTransferItemEntry(item){return isFunction$1(item.getAsEntry)?item.getAsEntry():isFunction$1(item.webkitGetAsEntry)?item.webkitGetAsEntry():null;};// Drop handler function to get all files\n/* istanbul ignore next: not supported in JSDOM */var getAllFileEntries=function getAllFileEntries(dataTransferItemList){var traverseDirectories=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return Promise.all(from(dataTransferItemList).filter(function(item){return item.kind==='file';}).map(function(item){var entry=getDataTransferItemEntry(item);if(entry){if(entry.isDirectory&&traverseDirectories){return getAllFileEntriesInDirectory(entry.createReader(),\"\".concat(entry.name,\"/\"));}else if(entry.isFile){return new Promise(function(resolve){entry.file(function(file){file.$path='';resolve(file);});});}}return null;}).filter(identity));};// Get all the file entries (recursive) in a directory\n/* istanbul ignore next: not supported in JSDOM */var getAllFileEntriesInDirectory=function getAllFileEntriesInDirectory(directoryReader){var path=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'';return new Promise(function(resolve){var entryPromises=[];var readDirectoryEntries=function readDirectoryEntries(){directoryReader.readEntries(function(entries){if(entries.length===0){resolve(Promise.all(entryPromises).then(function(entries){return flatten(entries);}));}else{entryPromises.push(Promise.all(entries.map(function(entry){if(entry){if(entry.isDirectory){return getAllFileEntriesInDirectory(entry.createReader(),\"\".concat(path).concat(entry.name,\"/\"));}else if(entry.isFile){return new Promise(function(resolve){entry.file(function(file){file.$path=\"\".concat(path).concat(file.name);resolve(file);});});}}return null;}).filter(identity)));readDirectoryEntries();}});};readDirectoryEntries();});};// --- Props ---\nvar props$1m=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),modelProps$c),props$1x),props$1w),props$1u),props$1v),{},{accept:makeProp(PROP_TYPE_STRING,''),browseText:makeProp(PROP_TYPE_STRING,'Browse'),// Instruct input to capture from camera\ncapture:makeProp(PROP_TYPE_BOOLEAN,false),directory:makeProp(PROP_TYPE_BOOLEAN,false),dropPlaceholder:makeProp(PROP_TYPE_STRING,'Drop files here'),fileNameFormatter:makeProp(PROP_TYPE_FUNCTION),multiple:makeProp(PROP_TYPE_BOOLEAN,false),noDrop:makeProp(PROP_TYPE_BOOLEAN,false),noDropPlaceholder:makeProp(PROP_TYPE_STRING,'Not allowed'),// TODO:\n//   Should we deprecate this and only support flat file structures?\n//   Nested file structures are only supported when files are dropped\n//   A Chromium \"bug\" prevents `webkitEntries` from being populated\n//   on the file input's `change` event and is marked as \"WontFix\"\n//   Mozilla implemented the behavior the same way as Chromium\n//   See: https://bugs.chromium.org/p/chromium/issues/detail?id=138987\n//   See: https://bugzilla.mozilla.org/show_bug.cgi?id=1326031\nnoTraverse:makeProp(PROP_TYPE_BOOLEAN,false),placeholder:makeProp(PROP_TYPE_STRING,'No file chosen')})),NAME_FORM_FILE);// --- Main component ---\n// @vue/component\nvar BFormFile=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_FILE,mixins:[attrsMixin,idMixin,modelMixin$c,normalizeSlotMixin,formControlMixin,formStateMixin,formCustomMixin,normalizeSlotMixin],inheritAttrs:false,props:props$1m,data:function data(){return{files:[],dragging:false,// IE 11 doesn't respect setting `event.dataTransfer.dropEffect`,\n// so we handle it ourselves as well\n// https://stackoverflow.com/a/46915971/2744776\ndropAllowed:!this.noDrop,hasFocus:false};},computed:{// Convert `accept` to an array of `[{ RegExpr, isMime }, ...]`\ncomputedAccept:function computedAccept(){var accept=this.accept;accept=(accept||'').trim().split(/[,\\s]+/).filter(identity);// Allow any file type/extension\nif(accept.length===0){return null;}return accept.map(function(extOrType){var prop='name';var startMatch='^';var endMatch='$';if(RX_EXTENSION.test(extOrType)){// File extension /\\.ext$/\nstartMatch='';}else{// MIME type /^mime\\/.+$/ or /^mime\\/type$/\nprop='type';if(RX_STAR.test(extOrType)){endMatch='.+$';// Remove trailing `*`\nextOrType=extOrType.slice(0,-1);}}// Escape all RegExp special chars\nextOrType=escapeRegExp(extOrType);var rx=new RegExp(\"\".concat(startMatch).concat(extOrType).concat(endMatch));return{rx:rx,prop:prop};});},computedCapture:function computedCapture(){var capture=this.capture;return capture===true||capture===''?true:capture||null;},computedAttrs:function computedAttrs(){var name=this.name,disabled=this.disabled,required=this.required,form=this.form,computedCapture=this.computedCapture,accept=this.accept,multiple=this.multiple,directory=this.directory;return _objectSpread2$3(_objectSpread2$3({},this.bvAttrs),{},{type:'file',id:this.safeId(),name:name,disabled:disabled,required:required,form:form||null,capture:computedCapture,accept:accept||null,multiple:multiple,directory:directory,webkitdirectory:directory,'aria-required':required?'true':null});},computedFileNameFormatter:function computedFileNameFormatter(){var fileNameFormatter=this.fileNameFormatter;return hasPropFunction(fileNameFormatter)?fileNameFormatter:this.defaultFileNameFormatter;},clonedFiles:function clonedFiles(){return cloneDeep(this.files);},flattenedFiles:function flattenedFiles(){return flattenDeep(this.files);},fileNames:function fileNames(){return this.flattenedFiles.map(function(file){return file.name;});},labelContent:function labelContent(){// Draging active\n/* istanbul ignore next: used by drag/drop which can't be tested easily */if(this.dragging&&!this.noDrop){return(// TODO: Add additional scope with file count, and other not-allowed reasons\nthis.normalizeSlot(SLOT_NAME_DROP_PLACEHOLDER,{allowed:this.dropAllowed})||(this.dropAllowed?this.dropPlaceholder:this.$createElement('span',{staticClass:'text-danger'},this.noDropPlaceholder)));}// No file chosen\nif(this.files.length===0){return this.normalizeSlot(SLOT_NAME_PLACEHOLDER)||this.placeholder;}var flattenedFiles=this.flattenedFiles,clonedFiles=this.clonedFiles,fileNames=this.fileNames,computedFileNameFormatter=this.computedFileNameFormatter;// There is a slot for formatting the files/names\nif(this.hasNormalizedSlot(SLOT_NAME_FILE_NAME)){return this.normalizeSlot(SLOT_NAME_FILE_NAME,{files:flattenedFiles,filesTraversed:clonedFiles,names:fileNames});}return computedFileNameFormatter(flattenedFiles,clonedFiles,fileNames);}},watch:(_watch$c={},_defineProperty(_watch$c,MODEL_PROP_NAME$c,function(newValue){if(!newValue||isArray(newValue)&&newValue.length===0){this.reset();}}),_defineProperty(_watch$c,\"files\",function files(newValue,oldValue){if(!looseEqual(newValue,oldValue)){var multiple=this.multiple,noTraverse=this.noTraverse;var files=!multiple||noTraverse?flattenDeep(newValue):newValue;this.$emit(MODEL_EVENT_NAME$c,multiple?files:files[0]||null);}}),_watch$c),created:function created(){// Create private non-reactive props\nthis.$_form=null;},mounted:function mounted(){// Listen for form reset events, to reset the file input\nvar $form=closest('form',this.$el);if($form){eventOn($form,'reset',this.reset,EVENT_OPTIONS_PASSIVE);this.$_form=$form;}},beforeDestroy:function beforeDestroy(){var $form=this.$_form;if($form){eventOff($form,'reset',this.reset,EVENT_OPTIONS_PASSIVE);}},methods:{isFileValid:function isFileValid(file){if(!file){return false;}var accept=this.computedAccept;return accept?accept.some(function(a){return a.rx.test(file[a.prop]);}):true;},isFilesArrayValid:function isFilesArrayValid(files){var _this=this;return isArray(files)?files.every(function(file){return _this.isFileValid(file);}):this.isFileValid(files);},defaultFileNameFormatter:function defaultFileNameFormatter(flattenedFiles,clonedFiles,fileNames){return fileNames.join(', ');},setFiles:function setFiles(files){// Reset the dragging flags\nthis.dropAllowed=!this.noDrop;this.dragging=false;// Set the selected files\nthis.files=this.multiple?this.directory?files:flattenDeep(files):flattenDeep(files).slice(0,1);},/* istanbul ignore next: used by Drag/Drop */setInputFiles:function setInputFiles(files){// Try an set the file input files array so that `required`\n// constraint works for dropped files (will fail in IE11 though)\n// To be used only when dropping files\ntry{// Firefox < 62 workaround exploiting https://bugzilla.mozilla.org/show_bug.cgi?id=1422655\nvar dataTransfer=new ClipboardEvent('').clipboardData||new DataTransfer();// Add flattened files to temp `dataTransfer` object to get a true `FileList` array\nflattenDeep(cloneDeep(files)).forEach(function(file){// Make sure to remove the custom `$path` attribute\ndelete file.$path;dataTransfer.items.add(file);});this.$refs.input.files=dataTransfer.files;}catch(_unused){}},reset:function reset(){// IE 11 doesn't support setting `$input.value` to `''` or `null`\n// So we use this little extra hack to reset the value, just in case\n// This also appears to work on modern browsers as well\n// Wrapped in try in case IE 11 or mobile Safari crap out\ntry{var $input=this.$refs.input;$input.value='';$input.type='';$input.type='file';}catch(_unused2){}this.files=[];},handleFiles:function handleFiles(files){var isDrop=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(isDrop){// When dropped, make sure to filter files with the internal `accept` logic\nvar filteredFiles=files.filter(this.isFilesArrayValid);// Only update files when we have any after filtering\nif(filteredFiles.length>0){this.setFiles(filteredFiles);// Try an set the file input's files array so that `required`\n// constraint works for dropped files (will fail in IE 11 though)\nthis.setInputFiles(filteredFiles);}}else{// We always update the files from the `change` event\nthis.setFiles(files);}},focusHandler:function focusHandler(event){// Bootstrap v4 doesn't have focus styling for custom file input\n// Firefox has a `[type=file]:focus ~ sibling` selector issue,\n// so we add a `focus` class to get around these bugs\nif(this.plain||event.type==='focusout'){this.hasFocus=false;}else{// Add focus styling for custom file input\nthis.hasFocus=true;}},onChange:function onChange(event){var _this2=this;var type=event.type,target=event.target,_event$dataTransfer=event.dataTransfer,dataTransfer=_event$dataTransfer===void 0?{}:_event$dataTransfer;var isDrop=type==='drop';// Always emit original event\nthis.$emit(EVENT_NAME_CHANGE,event);var items=from(dataTransfer.items||[]);if(HAS_PROMISE_SUPPORT&&items.length>0&&!isNull(getDataTransferItemEntry(items[0]))){// Drop handling for modern browsers\n// Supports nested directory structures in `directory` mode\n/* istanbul ignore next: not supported in JSDOM */getAllFileEntries(items,this.directory).then(function(files){return _this2.handleFiles(files,isDrop);});}else{// Standard file input handling (native file input change event),\n// or fallback drop mode (IE 11 / Opera) which don't support `directory` mode\nvar files=from(target.files||dataTransfer.files||[]).map(function(file){// Add custom `$path` property to each file (to be consistent with drop mode)\nfile.$path=file.webkitRelativePath||'';return file;});this.handleFiles(files,isDrop);}},onDragenter:function onDragenter(event){stopEvent(event);this.dragging=true;var _event$dataTransfer2=event.dataTransfer,dataTransfer=_event$dataTransfer2===void 0?{}:_event$dataTransfer2;// Early exit when the input or dropping is disabled\nif(this.noDrop||this.disabled||!this.dropAllowed){// Show deny feedback\n/* istanbul ignore next: not supported in JSDOM */dataTransfer.dropEffect='none';this.dropAllowed=false;return;}/* istanbul ignore next: not supported in JSDOM */dataTransfer.dropEffect='copy';},// Note this event fires repeatedly while the mouse is over the dropzone at\n// intervals in the milliseconds, so avoid doing much processing in here\nonDragover:function onDragover(event){stopEvent(event);this.dragging=true;var _event$dataTransfer3=event.dataTransfer,dataTransfer=_event$dataTransfer3===void 0?{}:_event$dataTransfer3;// Early exit when the input or dropping is disabled\nif(this.noDrop||this.disabled||!this.dropAllowed){// Show deny feedback\n/* istanbul ignore next: not supported in JSDOM */dataTransfer.dropEffect='none';this.dropAllowed=false;return;}/* istanbul ignore next: not supported in JSDOM */dataTransfer.dropEffect='copy';},onDragleave:function onDragleave(event){var _this3=this;stopEvent(event);this.$nextTick(function(){_this3.dragging=false;// Reset `dropAllowed` to default\n_this3.dropAllowed=!_this3.noDrop;});},// Triggered by a file drop onto drop target\nonDrop:function onDrop(event){var _this4=this;stopEvent(event);this.dragging=false;// Early exit when the input or dropping is disabled\nif(this.noDrop||this.disabled||!this.dropAllowed){this.$nextTick(function(){// Reset `dropAllowed` to default\n_this4.dropAllowed=!_this4.noDrop;});return;}this.onChange(event);}},render:function render(h){var custom=this.custom,plain=this.plain,size=this.size,dragging=this.dragging,stateClass=this.stateClass,bvAttrs=this.bvAttrs;// Form Input\nvar $input=h('input',{class:[{'form-control-file':plain,'custom-file-input':custom,focus:custom&&this.hasFocus},stateClass],// With IE 11, the input gets in the \"way\" of the drop events,\n// so we move it out of the way by putting it behind the label\n// Bootstrap v4 has it in front\nstyle:custom?{zIndex:-5}:{},attrs:this.computedAttrs,on:{change:this.onChange,focusin:this.focusHandler,focusout:this.focusHandler,reset:this.reset},ref:'input'});if(plain){return $input;}// Overlay label\nvar $label=h('label',{staticClass:'custom-file-label',class:{dragging:dragging},attrs:{for:this.safeId(),// This goes away in Bootstrap v5\n'data-browse':this.browseText||null}},[h('span',{staticClass:'d-block form-file-text',// `pointer-events: none` is used to make sure\n// the drag events fire only on the label\nstyle:{pointerEvents:'none'}},[this.labelContent])]);// Return rendered custom file input\nreturn h('div',{staticClass:'custom-file b-form-file',class:[_defineProperty({},\"b-custom-control-\".concat(size),size),stateClass,bvAttrs.class],style:bvAttrs.style,attrs:{id:this.safeId('_BV_file_outer_')},on:{dragenter:this.onDragenter,dragover:this.onDragover,dragleave:this.onDragleave,drop:this.onDrop}},[$input,$label]);}});var FormFilePlugin=/*#__PURE__*/pluginFactory({components:{BFormFile:BFormFile,BFile:BFormFile}});var escapeChar=function escapeChar(value){return'\\\\'+value;};// The `cssEscape()` util is based on this `CSS.escape()` polyfill:\n// https://github.com/mathiasbynens/CSS.escape\nvar cssEscape=function cssEscape(value){value=toString(value);var length=value.length;var firstCharCode=value.charCodeAt(0);return value.split('').reduce(function(result,char,index){var charCode=value.charCodeAt(index);// If the character is NULL (U+0000), use (U+FFFD) as replacement\nif(charCode===0x0000){return result+\"\\uFFFD\";}// If the character ...\nif(// ... is U+007F OR\ncharCode===0x007f||// ... is in the range [\\1-\\1F] (U+0001 to U+001F) OR ...\ncharCode>=0x0001&&charCode<=0x001f||// ... is the first character and is in the range [0-9] (U+0030 to U+0039) OR ...\nindex===0&&charCode>=0x0030&&charCode<=0x0039||// ... is the second character and is in the range [0-9] (U+0030 to U+0039)\n// and the first character is a `-` (U+002D) ...\nindex===1&&charCode>=0x0030&&charCode<=0x0039&&firstCharCode===0x002d){// ... https://drafts.csswg.org/cssom/#escape-a-character-as-code-point\nreturn result+escapeChar(\"\".concat(charCode.toString(16),\" \"));}// If the character ...\nif(// ... is the first character AND ...\nindex===0&&// ... is a `-` (U+002D) AND ...\ncharCode===0x002d&&// ... there is no second character ...\nlength===1){// ... use the escaped character\nreturn result+escapeChar(char);}// If the character ...\nif(// ... is greater than or equal to U+0080 OR ...\ncharCode>=0x0080||// ... is `-` (U+002D) OR ...\ncharCode===0x002d||// ... is `_` (U+005F) OR ...\ncharCode===0x005f||// ... is in the range [0-9] (U+0030 to U+0039) OR ...\ncharCode>=0x0030&&charCode<=0x0039||// ... is in the range [A-Z] (U+0041 to U+005A) OR ...\ncharCode>=0x0041&&charCode<=0x005a||// ... is in the range [a-z] (U+0061 to U+007A) ...\ncharCode>=0x0061&&charCode<=0x007a){// ... use the character itself\nreturn result+char;}// Otherwise use the escaped character\n// See: https://drafts.csswg.org/cssom/#escape-a-character\nreturn result+escapeChar(char);},'');};var ALIGN_SELF_VALUES=['auto','start','end','center','baseline','stretch'];// --- Helper methods ---\n// Compute a breakpoint class name\nvar computeBreakpoint=function computeBreakpoint(type,breakpoint,value){var className=type;if(isUndefinedOrNull(value)||value===false){return undefined;}if(breakpoint){className+=\"-\".concat(breakpoint);}// Handling the boolean style prop when accepting `[Boolean, String, Number]`\n// means Vue will not convert `<b-col sm></b-col>` to `sm: true` for us\n// Since the default is `false`, '' indicates the prop's presence\nif(type==='col'&&(value===''||value===true)){// .col-md\nreturn lowerCase(className);}// .order-md-6\nclassName+=\"-\".concat(value);return lowerCase(className);};// Memoized function for better performance on generating class names\nvar computeBreakpointClass=memoize(computeBreakpoint);// Cached copy of the breakpoint prop names\nvar breakpointPropMap=create(null);// --- Props ---\n// Prop generator for lazy generation of props\nvar generateProps$2=function generateProps(){// Grab the breakpoints from the cached config (exclude the '' (xs) breakpoint)\nvar breakpoints=getBreakpointsUpCached().filter(identity);// i.e. 'col-sm', 'col-md-6', 'col-lg-auto', ...\nvar breakpointCol=breakpoints.reduce(function(props,breakpoint){props[breakpoint]=makeProp(PROP_TYPE_BOOLEAN_NUMBER_STRING);return props;},create(null));// i.e. 'offset-md-1', 'offset-lg-12', ...\nvar breakpointOffset=breakpoints.reduce(function(props,breakpoint){props[suffixPropName(breakpoint,'offset')]=makeProp(PROP_TYPE_NUMBER_STRING);return props;},create(null));// i.e. 'order-md-1', 'order-lg-12', ...\nvar breakpointOrder=breakpoints.reduce(function(props,breakpoint){props[suffixPropName(breakpoint,'order')]=makeProp(PROP_TYPE_NUMBER_STRING);return props;},create(null));// For loop doesn't need to check `.hasOwnProperty()`\n// when using an object created from `null`\nbreakpointPropMap=assign(create(null),{col:keys(breakpointCol),offset:keys(breakpointOffset),order:keys(breakpointOrder)});// Return the generated props\nreturn makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},breakpointCol),breakpointOffset),breakpointOrder),{},{// Flex alignment\nalignSelf:makeProp(PROP_TYPE_STRING,null,function(value){return arrayIncludes(ALIGN_SELF_VALUES,value);}),// Generic flexbox 'col' (xs)\ncol:makeProp(PROP_TYPE_BOOLEAN,false),// i.e. 'col-1', 'col-2', 'col-auto', ...\ncols:makeProp(PROP_TYPE_NUMBER_STRING),offset:makeProp(PROP_TYPE_NUMBER_STRING),order:makeProp(PROP_TYPE_NUMBER_STRING),tag:makeProp(PROP_TYPE_STRING,'div')})),NAME_COL);};// --- Main component ---\n// We do not use Vue.extend here as that would evaluate the props\n// immediately, which we do not want to happen\n// @vue/component\nvar BCol={name:NAME_COL,functional:true,get props(){// Allow props to be lazy evaled on first access and\n// then they become a non-getter afterwards.\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#Smart_self-overwriting_lazy_getters\ndelete this.props;// eslint-disable-next-line no-return-assign\nreturn this.props=generateProps$2();},render:function render(h,_ref){var _classList$push;var props=_ref.props,data=_ref.data,children=_ref.children;var cols=props.cols,offset=props.offset,order=props.order,alignSelf=props.alignSelf;var classList=[];// Loop through `col`, `offset`, `order` breakpoint props\nfor(var type in breakpointPropMap){// Returns colSm, offset, offsetSm, orderMd, etc.\nvar _keys=breakpointPropMap[type];for(var i=0;i<_keys.length;i++){// computeBreakpoint(col, colSm => Sm, value=[String, Number, Boolean])\nvar c=computeBreakpointClass(type,_keys[i].replace(type,''),props[_keys[i]]);// If a class is returned, push it onto the array.\nif(c){classList.push(c);}}}var hasColClasses=classList.some(function(className){return RX_COL_CLASS.test(className);});classList.push((_classList$push={// Default to .col if no other col-{bp}-* classes generated nor `cols` specified.\ncol:props.col||!hasColClasses&&!cols},_defineProperty(_classList$push,\"col-\".concat(cols),cols),_defineProperty(_classList$push,\"offset-\".concat(offset),offset),_defineProperty(_classList$push,\"order-\".concat(order),order),_defineProperty(_classList$push,\"align-self-\".concat(alignSelf),alignSelf),_classList$push));return h(props.tag,a(data,{class:classList}),children);}};var INPUTS=['input','select','textarea'];// Selector for finding first input in the form group\nvar INPUT_SELECTOR=INPUTS.map(function(v){return\"\".concat(v,\":not([disabled])\");}).join();// A list of interactive elements (tag names) inside `<b-form-group>`'s legend\nvar LEGEND_INTERACTIVE_ELEMENTS=[].concat(INPUTS,['a','button','label']);// --- Props ---\n// Prop generator for lazy generation of props\nvar generateProps$1=function generateProps(){return makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),props$1u),getBreakpointsUpCached().reduce(function(props,breakpoint){// i.e. 'content-cols', 'content-cols-sm', 'content-cols-md', ...\nprops[suffixPropName(breakpoint,'contentCols')]=makeProp(PROP_TYPE_BOOLEAN_NUMBER_STRING);// i.e. 'label-align', 'label-align-sm', 'label-align-md', ...\nprops[suffixPropName(breakpoint,'labelAlign')]=makeProp(PROP_TYPE_STRING);// i.e. 'label-cols', 'label-cols-sm', 'label-cols-md', ...\nprops[suffixPropName(breakpoint,'labelCols')]=makeProp(PROP_TYPE_BOOLEAN_NUMBER_STRING);return props;},create(null))),{},{description:makeProp(PROP_TYPE_STRING),disabled:makeProp(PROP_TYPE_BOOLEAN,false),feedbackAriaLive:makeProp(PROP_TYPE_STRING,'assertive'),invalidFeedback:makeProp(PROP_TYPE_STRING),label:makeProp(PROP_TYPE_STRING),labelClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),labelFor:makeProp(PROP_TYPE_STRING),labelSize:makeProp(PROP_TYPE_STRING),labelSrOnly:makeProp(PROP_TYPE_BOOLEAN,false),tooltip:makeProp(PROP_TYPE_BOOLEAN,false),validFeedback:makeProp(PROP_TYPE_STRING),validated:makeProp(PROP_TYPE_BOOLEAN,false)})),NAME_FORM_GROUP);};// --- Main component ---\n// We do not use `Vue.extend()` here as that would evaluate the props\n// immediately, which we do not want to happen\n// @vue/component\nvar BFormGroup={name:NAME_FORM_GROUP,mixins:[idMixin,formStateMixin,normalizeSlotMixin],get props(){// Allow props to be lazy evaled on first access and\n// then they become a non-getter afterwards\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#Smart_self-overwriting_lazy_getters\ndelete this.props;// eslint-disable-next-line no-return-assign\nreturn this.props=generateProps$1();},data:function data(){return{ariaDescribedby:null};},computed:{contentColProps:function contentColProps(){return this.getColProps(this.$props,'content');},labelAlignClasses:function labelAlignClasses(){return this.getAlignClasses(this.$props,'label');},labelColProps:function labelColProps(){return this.getColProps(this.$props,'label');},isHorizontal:function isHorizontal(){// Determine if the form group will be rendered horizontal\n// based on the existence of 'content-col' or 'label-col' props\nreturn keys(this.contentColProps).length>0||keys(this.labelColProps).length>0;}},watch:{ariaDescribedby:function ariaDescribedby(newValue,oldValue){if(newValue!==oldValue){this.updateAriaDescribedby(newValue,oldValue);}}},mounted:function mounted(){var _this=this;this.$nextTick(function(){// Set `aria-describedby` on the input specified by `labelFor`\n// We do this in a `$nextTick()` to ensure the children have finished rendering\n_this.updateAriaDescribedby(_this.ariaDescribedby);});},methods:{getAlignClasses:function getAlignClasses(props,prefix){return getBreakpointsUpCached().reduce(function(result,breakpoint){var propValue=props[suffixPropName(breakpoint,\"\".concat(prefix,\"Align\"))]||null;if(propValue){result.push(['text',breakpoint,propValue].filter(identity).join('-'));}return result;},[]);},getColProps:function getColProps(props,prefix){return getBreakpointsUpCached().reduce(function(result,breakpoint){var propValue=props[suffixPropName(breakpoint,\"\".concat(prefix,\"Cols\"))];// Handle case where the prop's value is an empty string,\n// which represents `true`\npropValue=propValue===''?true:propValue||false;if(!isBoolean(propValue)&&propValue!=='auto'){// Convert to column size to number\npropValue=toInteger(propValue,0);// Ensure column size is greater than `0`\npropValue=propValue>0?propValue:false;}// Add the prop to the list of props to give to `<b-col>`\n// If breakpoint is '' (`${prefix}Cols` is `true`), then we use\n// the 'col' prop to make equal width at 'xs'\nif(propValue){result[breakpoint||(isBoolean(propValue)?'col':'cols')]=propValue;}return result;},{});},// Sets the `aria-describedby` attribute on the input if `labelFor` is set\n// Optionally accepts a string of IDs to remove as the second parameter\n// Preserves any `aria-describedby` value(s) user may have on input\nupdateAriaDescribedby:function updateAriaDescribedby(newValue,oldValue){var labelFor=this.labelFor;if(IS_BROWSER&&labelFor){// We need to escape `labelFor` since it can be user-provided\nvar $input=select(\"#\".concat(cssEscape(labelFor)),this.$refs.content);if($input){var attr='aria-describedby';var newIds=(newValue||'').split(RX_SPACE_SPLIT);var oldIds=(oldValue||'').split(RX_SPACE_SPLIT);// Update ID list, preserving any original IDs\n// and ensuring the ID's are unique\nvar ids=(getAttr($input,attr)||'').split(RX_SPACE_SPLIT).filter(function(id){return!arrayIncludes(oldIds,id);}).concat(newIds).filter(function(id,index,ids){return ids.indexOf(id)===index;}).filter(identity).join(' ').trim();if(ids){setAttr($input,attr,ids);}else{removeAttr($input,attr);}}}},onLegendClick:function onLegendClick(event){// Don't do anything if `labelFor` is set\n/* istanbul ignore next: clicking a label will focus the input, so no need to test */if(this.labelFor){return;}var target=event.target;var tagName=target?target.tagName:'';// If clicked an interactive element inside legend,\n// we just let the default happen\n/* istanbul ignore next */if(LEGEND_INTERACTIVE_ELEMENTS.indexOf(tagName)!==-1){return;}// If only a single input, focus it, emulating label behaviour\nvar inputs=selectAll(INPUT_SELECTOR,this.$refs.content).filter(isVisible);if(inputs.length===1){attemptFocus(inputs[0]);}}},render:function render(h){var state=this.computedState,feedbackAriaLive=this.feedbackAriaLive,isHorizontal=this.isHorizontal,labelFor=this.labelFor,normalizeSlot=this.normalizeSlot,safeId=this.safeId,tooltip=this.tooltip;var id=safeId();var isFieldset=!labelFor;var $label=h();var labelContent=normalizeSlot(SLOT_NAME_LABEL)||this.label;var labelId=labelContent?safeId('_BV_label_'):null;if(labelContent||isHorizontal){var labelSize=this.labelSize,labelColProps=this.labelColProps;var labelTag=isFieldset?'legend':'label';if(this.labelSrOnly){if(labelContent){$label=h(labelTag,{class:'sr-only',attrs:{id:labelId,for:labelFor||null}},[labelContent]);}$label=h(isHorizontal?BCol:'div',{props:isHorizontal?labelColProps:{}},[$label]);}else{$label=h(isHorizontal?BCol:labelTag,{on:isFieldset?{click:this.onLegendClick}:{},props:isHorizontal?_objectSpread2$3(_objectSpread2$3({},labelColProps),{},{tag:labelTag}):{},attrs:{id:labelId,for:labelFor||null,// We add a `tabindex` to legend so that screen readers\n// will properly read the `aria-labelledby` in IE\ntabindex:isFieldset?'-1':null},class:[// Hide the focus ring on the legend\nisFieldset?'bv-no-focus-ring':'',// When horizontal or if a legend is rendered, add 'col-form-label' class\n// for correct sizing as Bootstrap has inconsistent font styling for\n// legend in non-horizontal form groups\n// See: https://github.com/twbs/bootstrap/issues/27805\nisHorizontal||isFieldset?'col-form-label':'',// Emulate label padding top of `0` on legend when not horizontal\n!isHorizontal&&isFieldset?'pt-0':'',// If not horizontal and not a legend, we add 'd-block' class to label\n// so that label-align works\n!isHorizontal&&!isFieldset?'d-block':'',labelSize?\"col-form-label-\".concat(labelSize):'',this.labelAlignClasses,this.labelClass]},[labelContent]);}}var $invalidFeedback=h();var invalidFeedbackContent=normalizeSlot(SLOT_NAME_INVALID_FEEDBACK)||this.invalidFeedback;var invalidFeedbackId=invalidFeedbackContent?safeId('_BV_feedback_invalid_'):null;if(invalidFeedbackContent){$invalidFeedback=h(BFormInvalidFeedback,{props:{ariaLive:feedbackAriaLive,id:invalidFeedbackId,// If state is explicitly `false`, always show the feedback\nstate:state,tooltip:tooltip},attrs:{tabindex:invalidFeedbackContent?'-1':null}},[invalidFeedbackContent]);}var $validFeedback=h();var validFeedbackContent=normalizeSlot(SLOT_NAME_VALID_FEEDBACK)||this.validFeedback;var validFeedbackId=validFeedbackContent?safeId('_BV_feedback_valid_'):null;if(validFeedbackContent){$validFeedback=h(BFormValidFeedback,{props:{ariaLive:feedbackAriaLive,id:validFeedbackId,// If state is explicitly `true`, always show the feedback\nstate:state,tooltip:tooltip},attrs:{tabindex:validFeedbackContent?'-1':null}},[validFeedbackContent]);}var $description=h();var descriptionContent=normalizeSlot(SLOT_NAME_DESCRIPTION)||this.description;var descriptionId=descriptionContent?safeId('_BV_description_'):null;if(descriptionContent){$description=h(BFormText,{attrs:{id:descriptionId,tabindex:'-1'}},[descriptionContent]);}// Update `ariaDescribedby`\n// Screen readers will read out any content linked to by `aria-describedby`\n// even if the content is hidden with `display: none;`, hence we only include\n// feedback IDs if the form group's state is explicitly valid or invalid\nvar ariaDescribedby=this.ariaDescribedby=[descriptionId,state===false?invalidFeedbackId:null,state===true?validFeedbackId:null].filter(identity).join(' ')||null;var $content=h(isHorizontal?BCol:'div',{props:isHorizontal?this.contentColProps:{},ref:'content'},[normalizeSlot(SLOT_NAME_DEFAULT,{ariaDescribedby:ariaDescribedby,descriptionId:descriptionId,id:id,labelId:labelId})||h(),$invalidFeedback,$validFeedback,$description]);// Return it wrapped in a form group\n// Note: Fieldsets do not support adding `row` or `form-row` directly\n// to them due to browser specific render issues, so we move the `form-row`\n// to an inner wrapper div when horizontal and using a fieldset\nreturn h(isFieldset?'fieldset':isHorizontal?BFormRow:'div',{staticClass:'form-group',class:[{'was-validated':this.validated},this.stateClass],attrs:{id:id,disabled:isFieldset?this.disabled:null,role:isFieldset?null:'group','aria-invalid':this.computedAriaInvalid,// Only apply `aria-labelledby` if we are a horizontal fieldset\n// as the legend is no longer a direct child of fieldset\n'aria-labelledby':isFieldset&&isHorizontal?labelId:null}},isHorizontal&&isFieldset?[h(BFormRow,[$label,$content])]:[$label,$content]);}};var FormGroupPlugin=/*#__PURE__*/pluginFactory({components:{BFormGroup:BFormGroup,BFormFieldset:BFormGroup}});var formSelectionMixin=Vue__default['default'].extend({computed:{selectionStart:{// Expose selectionStart for formatters, etc\ncache:false,/* istanbul ignore next */get:function get(){return this.$refs.input.selectionStart;},/* istanbul ignore next */set:function set(val){this.$refs.input.selectionStart=val;}},selectionEnd:{// Expose selectionEnd for formatters, etc\ncache:false,/* istanbul ignore next */get:function get(){return this.$refs.input.selectionEnd;},/* istanbul ignore next */set:function set(val){this.$refs.input.selectionEnd=val;}},selectionDirection:{// Expose selectionDirection for formatters, etc\ncache:false,/* istanbul ignore next */get:function get(){return this.$refs.input.selectionDirection;},/* istanbul ignore next */set:function set(val){this.$refs.input.selectionDirection=val;}}},methods:{/* istanbul ignore next */select:function select(){var _this$$refs$input;// For external handler that may want a select() method\n(_this$$refs$input=this.$refs.input).select.apply(_this$$refs$input,arguments);},/* istanbul ignore next */setSelectionRange:function setSelectionRange(){var _this$$refs$input2;// For external handler that may want a setSelectionRange(a,b,c) method\n(_this$$refs$input2=this.$refs.input).setSelectionRange.apply(_this$$refs$input2,arguments);},/* istanbul ignore next */setRangeText:function setRangeText(){var _this$$refs$input3;// For external handler that may want a setRangeText(a,b,c) method\n(_this$$refs$input3=this.$refs.input).setRangeText.apply(_this$$refs$input3,arguments);}}});var _makeModelMixin$c=makeModelMixin('value',{type:PROP_TYPE_NUMBER_STRING,defaultValue:'',event:EVENT_NAME_UPDATE}),modelMixin$b=_makeModelMixin$c.mixin,modelProps$b=_makeModelMixin$c.props,MODEL_PROP_NAME$b=_makeModelMixin$c.prop,MODEL_EVENT_NAME$b=_makeModelMixin$c.event;var props$1l=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},modelProps$b),{},{ariaInvalid:makeProp(PROP_TYPE_BOOLEAN_STRING,false),autocomplete:makeProp(PROP_TYPE_STRING),// Debounce timeout (in ms). Not applicable with `lazy` prop\ndebounce:makeProp(PROP_TYPE_NUMBER_STRING,0),formatter:makeProp(PROP_TYPE_FUNCTION),// Only update the `v-model` on blur/change events\nlazy:makeProp(PROP_TYPE_BOOLEAN,false),lazyFormatter:makeProp(PROP_TYPE_BOOLEAN,false),number:makeProp(PROP_TYPE_BOOLEAN,false),placeholder:makeProp(PROP_TYPE_STRING),plaintext:makeProp(PROP_TYPE_BOOLEAN,false),readonly:makeProp(PROP_TYPE_BOOLEAN,false),trim:makeProp(PROP_TYPE_BOOLEAN,false)})),'formTextControls');// --- Mixin ---\n// @vue/component\nvar formTextMixin=Vue__default['default'].extend({mixins:[modelMixin$b],props:props$1l,data:function data(){var value=this[MODEL_PROP_NAME$b];return{localValue:toString(value),vModelValue:this.modifyValue(value)};},computed:{computedClass:function computedClass(){var plaintext=this.plaintext,type=this.type;var isRange=type==='range';var isColor=type==='color';return[{// Range input needs class `custom-range`\n'custom-range':isRange,// `plaintext` not supported by `type=\"range\"` or `type=\"color\"`\n'form-control-plaintext':plaintext&&!isRange&&!isColor,// `form-control` not used by `type=\"range\"` or `plaintext`\n// Always used by `type=\"color\"`\n'form-control':isColor||!plaintext&&!isRange},this.sizeFormClass,this.stateClass];},computedDebounce:function computedDebounce(){// Ensure we have a positive number equal to or greater than 0\nreturn mathMax(toInteger(this.debounce,0),0);},hasFormatter:function hasFormatter(){return hasPropFunction(this.formatter);}},watch:_defineProperty({},MODEL_PROP_NAME$b,function(newValue){var stringifyValue=toString(newValue);var modifiedValue=this.modifyValue(newValue);if(stringifyValue!==this.localValue||modifiedValue!==this.vModelValue){// Clear any pending debounce timeout, as we are overwriting the user input\nthis.clearDebounce();// Update the local values\nthis.localValue=stringifyValue;this.vModelValue=modifiedValue;}}),created:function created(){// Create private non-reactive props\nthis.$_inputDebounceTimer=null;},beforeDestroy:function beforeDestroy(){this.clearDebounce();},methods:{clearDebounce:function clearDebounce(){clearTimeout(this.$_inputDebounceTimer);this.$_inputDebounceTimer=null;},formatValue:function formatValue(value,event){var force=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;value=toString(value);if(this.hasFormatter&&(!this.lazyFormatter||force)){value=this.formatter(value,event);}return value;},modifyValue:function modifyValue(value){value=toString(value);// Emulate `.trim` modifier behaviour\nif(this.trim){value=value.trim();}// Emulate `.number` modifier behaviour\nif(this.number){value=toFloat(value,value);}return value;},updateValue:function updateValue(value){var _this=this;var force=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var lazy=this.lazy;if(lazy&&!force){return;}// Make sure to always clear the debounce when `updateValue()`\n// is called, even when the v-model hasn't changed\nthis.clearDebounce();// Define the shared update logic in a method to be able to use\n// it for immediate and debounced value changes\nvar doUpdate=function doUpdate(){value=_this.modifyValue(value);if(value!==_this.vModelValue){_this.vModelValue=value;_this.$emit(MODEL_EVENT_NAME$b,value);}else if(_this.hasFormatter){// When the `vModelValue` hasn't changed but the actual input value\n// is out of sync, make sure to change it to the given one\n// Usually caused by browser autocomplete and how it triggers the\n// change or input event, or depending on the formatter function\n// https://github.com/bootstrap-vue/bootstrap-vue/issues/2657\n// https://github.com/bootstrap-vue/bootstrap-vue/issues/3498\n/* istanbul ignore next: hard to test */var $input=_this.$refs.input;/* istanbul ignore if: hard to test out of sync value */if($input&&value!==$input.value){$input.value=value;}}};// Only debounce the value update when a value greater than `0`\n// is set and we are not in lazy mode or this is a forced update\nvar debounce=this.computedDebounce;if(debounce>0&&!lazy&&!force){this.$_inputDebounceTimer=setTimeout(doUpdate,debounce);}else{// Immediately update the v-model\ndoUpdate();}},onInput:function onInput(event){// `event.target.composing` is set by Vue\n// https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/directives/model.js\n// TODO: Is this needed now with the latest Vue?\n/* istanbul ignore if: hard to test composition events */if(event.target.composing){return;}var value=event.target.value;var formattedValue=this.formatValue(value,event);// Exit when the `formatter` function strictly returned `false`\n// or prevented the input event\n/* istanbul ignore next */if(formattedValue===false||event.defaultPrevented){stopEvent(event,{propagation:false});return;}this.localValue=formattedValue;this.updateValue(formattedValue);this.$emit(EVENT_NAME_INPUT,formattedValue);},onChange:function onChange(event){var value=event.target.value;var formattedValue=this.formatValue(value,event);// Exit when the `formatter` function strictly returned `false`\n// or prevented the input event\n/* istanbul ignore next */if(formattedValue===false||event.defaultPrevented){stopEvent(event,{propagation:false});return;}this.localValue=formattedValue;this.updateValue(formattedValue,true);this.$emit(EVENT_NAME_CHANGE,formattedValue);},onBlur:function onBlur(event){// Apply the `localValue` on blur to prevent cursor jumps\n// on mobile browsers (e.g. caused by autocomplete)\nvar value=event.target.value;var formattedValue=this.formatValue(value,event,true);if(formattedValue!==false){// We need to use the modified value here to apply the\n// `.trim` and `.number` modifiers properly\nthis.localValue=toString(this.modifyValue(formattedValue));// We pass the formatted value here since the `updateValue` method\n// handles the modifiers itself\nthis.updateValue(formattedValue,true);}// Emit native blur event\nthis.$emit(EVENT_NAME_BLUR,event);},focus:function focus(){// For external handler that may want a focus method\nif(!this.disabled){attemptFocus(this.$el);}},blur:function blur(){// For external handler that may want a blur method\nif(!this.disabled){attemptBlur(this.$el);}}}});var formValidityMixin=Vue__default['default'].extend({computed:{validity:{// Expose validity property\ncache:false,/* istanbul ignore next */get:function get(){return this.$refs.input.validity;}},validationMessage:{// Expose validationMessage property\ncache:false,/* istanbul ignore next */get:function get(){return this.$refs.input.validationMessage;}},willValidate:{// Expose willValidate property\ncache:false,/* istanbul ignore next */get:function get(){return this.$refs.input.willValidate;}}},methods:{/* istanbul ignore next */setCustomValidity:function setCustomValidity(){var _this$$refs$input;// For external handler that may want a setCustomValidity(...) method\nreturn(_this$$refs$input=this.$refs.input).setCustomValidity.apply(_this$$refs$input,arguments);},/* istanbul ignore next */checkValidity:function checkValidity(){var _this$$refs$input2;// For external handler that may want a checkValidity(...) method\nreturn(_this$$refs$input2=this.$refs.input).checkValidity.apply(_this$$refs$input2,arguments);},/* istanbul ignore next */reportValidity:function reportValidity(){var _this$$refs$input3;// For external handler that may want a reportValidity(...) method\nreturn(_this$$refs$input3=this.$refs.input).reportValidity.apply(_this$$refs$input3,arguments);}}});// Valid supported input types\nvar TYPES$1=['text','password','email','number','url','tel','search','range','color','date','time','datetime','datetime-local','month','week'];// --- Props ---\nvar props$1k=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),props$1x),props$1v),props$1u),props$1l),{},{list:makeProp(PROP_TYPE_STRING),max:makeProp(PROP_TYPE_NUMBER_STRING),min:makeProp(PROP_TYPE_NUMBER_STRING),// Disable mousewheel to prevent wheel from changing values (i.e. number/date)\nnoWheel:makeProp(PROP_TYPE_BOOLEAN,false),step:makeProp(PROP_TYPE_NUMBER_STRING),type:makeProp(PROP_TYPE_STRING,'text',function(type){return arrayIncludes(TYPES$1,type);})})),NAME_FORM_INPUT);// --- Main component ---\n// @vue/component\nvar BFormInput=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_INPUT,// Mixin order is important!\nmixins:[listenersMixin,idMixin,formControlMixin,formSizeMixin,formStateMixin,formTextMixin,formSelectionMixin,formValidityMixin],props:props$1k,computed:{localType:function localType(){// We only allow certain types\nvar type=this.type;return arrayIncludes(TYPES$1,type)?type:'text';},computedAttrs:function computedAttrs(){var type=this.localType,name=this.name,form=this.form,disabled=this.disabled,placeholder=this.placeholder,required=this.required,min=this.min,max=this.max,step=this.step;return{id:this.safeId(),name:name,form:form,type:type,disabled:disabled,placeholder:placeholder,required:required,autocomplete:this.autocomplete||null,readonly:this.readonly||this.plaintext,min:min,max:max,step:step,list:type!=='password'?this.list:null,'aria-required':required?'true':null,'aria-invalid':this.computedAriaInvalid};},computedListeners:function computedListeners(){return _objectSpread2$3(_objectSpread2$3({},this.bvListeners),{},{input:this.onInput,change:this.onChange,blur:this.onBlur});}},watch:{noWheel:function noWheel(newValue){this.setWheelStopper(newValue);}},mounted:function mounted(){this.setWheelStopper(this.noWheel);},/* istanbul ignore next */deactivated:function deactivated(){// Turn off listeners when keep-alive component deactivated\n/* istanbul ignore next */this.setWheelStopper(false);},/* istanbul ignore next */activated:function activated(){// Turn on listeners (if no-wheel) when keep-alive component activated\n/* istanbul ignore next */this.setWheelStopper(this.noWheel);},beforeDestroy:function beforeDestroy(){/* istanbul ignore next */this.setWheelStopper(false);},methods:{setWheelStopper:function setWheelStopper(on){var input=this.$el;// We use native events, so that we don't interfere with propagation\neventOnOff(on,input,'focus',this.onWheelFocus);eventOnOff(on,input,'blur',this.onWheelBlur);if(!on){eventOff(document,'wheel',this.stopWheel);}},onWheelFocus:function onWheelFocus(){eventOn(document,'wheel',this.stopWheel);},onWheelBlur:function onWheelBlur(){eventOff(document,'wheel',this.stopWheel);},stopWheel:function stopWheel(event){stopEvent(event,{propagation:false});attemptBlur(this.$el);}},render:function render(h){return h('input',{class:this.computedClass,attrs:this.computedAttrs,domProps:{value:this.localValue},on:this.computedListeners,ref:'input'});}});var FormInputPlugin=/*#__PURE__*/pluginFactory({components:{BFormInput:BFormInput,BInput:BFormInput}});var props$1j=makePropsConfigurable(props$1q,NAME_FORM_RADIO_GROUP);// --- Main component ---\n// @vue/component\nvar BFormRadioGroup=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_RADIO_GROUP,mixins:[formRadioCheckGroupMixin],provide:function provide(){return{bvRadioGroup:this};},props:props$1j,computed:{isRadioGroup:function isRadioGroup(){return true;}}});var FormRadioPlugin=/*#__PURE__*/pluginFactory({components:{BFormRadio:BFormRadio,BRadio:BFormRadio,BFormRadioGroup:BFormRadioGroup,BRadioGroup:BFormRadioGroup}});var _watch$b;var _makeModelMixin$b=makeModelMixin('value',{type:PROP_TYPE_NUMBER_STRING,event:EVENT_NAME_CHANGE}),modelMixin$a=_makeModelMixin$b.mixin,modelProps$a=_makeModelMixin$b.props,MODEL_PROP_NAME$a=_makeModelMixin$b.prop,MODEL_EVENT_NAME$a=_makeModelMixin$b.event;var MIN_STARS=3;var DEFAULT_STARS=5;// --- Helper methods ---\nvar computeStars=function computeStars(stars){return mathMax(MIN_STARS,toInteger(stars,DEFAULT_STARS));};var clampValue=function clampValue(value,min,max){return mathMax(mathMin(value,max),min);};// --- Helper components ---\n// @vue/component\nvar BVFormRatingStar=Vue__default['default'].extend({name:NAME_FORM_RATING_STAR,mixins:[normalizeSlotMixin],props:{disabled:makeProp(PROP_TYPE_BOOLEAN,false),// If parent is focused\nfocused:makeProp(PROP_TYPE_BOOLEAN,false),hasClear:makeProp(PROP_TYPE_BOOLEAN,false),rating:makeProp(PROP_TYPE_NUMBER,0),readonly:makeProp(PROP_TYPE_BOOLEAN,false),star:makeProp(PROP_TYPE_NUMBER,0),variant:makeProp(PROP_TYPE_STRING)},methods:{onClick:function onClick(event){if(!this.disabled&&!this.readonly){stopEvent(event,{propagation:false});this.$emit(EVENT_NAME_SELECTED,this.star);}}},render:function render(h){var rating=this.rating,star=this.star,focused=this.focused,hasClear=this.hasClear,variant=this.variant,disabled=this.disabled,readonly=this.readonly;var minStar=hasClear?0:1;var type=rating>=star?'full':rating>=star-0.5?'half':'empty';var slotScope={variant:variant,disabled:disabled,readonly:readonly};return h('span',{staticClass:'b-rating-star',class:{// When not hovered, we use this class to focus the current (or first) star\nfocused:focused&&rating===star||!toInteger(rating)&&star===minStar,// We add type classes to we can handle RTL styling\n'b-rating-star-empty':type==='empty','b-rating-star-half':type==='half','b-rating-star-full':type==='full'},attrs:{tabindex:!disabled&&!readonly?'-1':null},on:{click:this.onClick}},[h('span',{staticClass:'b-rating-icon'},[this.normalizeSlot(type,slotScope)])]);}});// --- Props ---\nvar props$1i=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),modelProps$a),omit(props$1x,['required','autofocus'])),props$1v),{},{// CSS color string (overrides variant)\ncolor:makeProp(PROP_TYPE_STRING),iconClear:makeProp(PROP_TYPE_STRING,'x'),iconEmpty:makeProp(PROP_TYPE_STRING,'star'),iconFull:makeProp(PROP_TYPE_STRING,'star-fill'),iconHalf:makeProp(PROP_TYPE_STRING,'star-half'),inline:makeProp(PROP_TYPE_BOOLEAN,false),// Locale for the formatted value (if shown)\n// Defaults to the browser locale. Falls back to `en`\nlocale:makeProp(PROP_TYPE_ARRAY_STRING),noBorder:makeProp(PROP_TYPE_BOOLEAN,false),precision:makeProp(PROP_TYPE_NUMBER_STRING),readonly:makeProp(PROP_TYPE_BOOLEAN,false),showClear:makeProp(PROP_TYPE_BOOLEAN,false),showValue:makeProp(PROP_TYPE_BOOLEAN,false),showValueMax:makeProp(PROP_TYPE_BOOLEAN,false),stars:makeProp(PROP_TYPE_NUMBER_STRING,DEFAULT_STARS,function(value){return toInteger(value)>=MIN_STARS;}),variant:makeProp(PROP_TYPE_STRING)})),NAME_FORM_RATING);// --- Main component ---\n// @vue/component\nvar BFormRating=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_RATING,components:{BIconStar:BIconStar,BIconStarHalf:BIconStarHalf,BIconStarFill:BIconStarFill,BIconX:BIconX},mixins:[idMixin,modelMixin$a,formSizeMixin],props:props$1i,data:function data(){var value=toFloat(this[MODEL_PROP_NAME$a],null);var stars=computeStars(this.stars);return{localValue:isNull(value)?null:clampValue(value,0,stars),hasFocus:false};},computed:{computedStars:function computedStars(){return computeStars(this.stars);},computedRating:function computedRating(){var value=toFloat(this.localValue,0);var precision=toInteger(this.precision,3);// We clamp the value between `0` and stars\nreturn clampValue(toFloat(value.toFixed(precision)),0,this.computedStars);},computedLocale:function computedLocale(){var locales=concat(this.locale).filter(identity);var nf=new Intl.NumberFormat(locales);return nf.resolvedOptions().locale;},isInteractive:function isInteractive(){return!this.disabled&&!this.readonly;},isRTL:function isRTL(){return isLocaleRTL(this.computedLocale);},formattedRating:function formattedRating(){var precision=toInteger(this.precision);var showValueMax=this.showValueMax;var locale=this.computedLocale;var formatOptions={notation:'standard',minimumFractionDigits:isNaN(precision)?0:precision,maximumFractionDigits:isNaN(precision)?3:precision};var stars=this.computedStars.toLocaleString(locale);var value=this.localValue;value=isNull(value)?showValueMax?'-':'':value.toLocaleString(locale,formatOptions);return showValueMax?\"\".concat(value,\"/\").concat(stars):value;}},watch:(_watch$b={},_defineProperty(_watch$b,MODEL_PROP_NAME$a,function(newValue,oldValue){if(newValue!==oldValue){var value=toFloat(newValue,null);this.localValue=isNull(value)?null:clampValue(value,0,this.computedStars);}}),_defineProperty(_watch$b,\"localValue\",function localValue(newValue,oldValue){if(newValue!==oldValue&&newValue!==(this.value||0)){this.$emit(MODEL_EVENT_NAME$a,newValue||null);}}),_defineProperty(_watch$b,\"disabled\",function disabled(newValue){if(newValue){this.hasFocus=false;this.blur();}}),_watch$b),methods:{// --- Public methods ---\nfocus:function focus(){if(!this.disabled){attemptFocus(this.$el);}},blur:function blur(){if(!this.disabled){attemptBlur(this.$el);}},// --- Private methods ---\nonKeydown:function onKeydown(event){var keyCode=event.keyCode;if(this.isInteractive&&arrayIncludes([CODE_LEFT,CODE_DOWN,CODE_RIGHT,CODE_UP],keyCode)){stopEvent(event,{propagation:false});var value=toInteger(this.localValue,0);var min=this.showClear?0:1;var stars=this.computedStars;// In RTL mode, LEFT/RIGHT are swapped\nvar amountRtl=this.isRTL?-1:1;if(keyCode===CODE_LEFT){this.localValue=clampValue(value-amountRtl,min,stars)||null;}else if(keyCode===CODE_RIGHT){this.localValue=clampValue(value+amountRtl,min,stars);}else if(keyCode===CODE_DOWN){this.localValue=clampValue(value-1,min,stars)||null;}else if(keyCode===CODE_UP){this.localValue=clampValue(value+1,min,stars);}}},onSelected:function onSelected(value){if(this.isInteractive){this.localValue=value;}},onFocus:function onFocus(event){this.hasFocus=!this.isInteractive?false:event.type==='focus';},// --- Render methods ---\nrenderIcon:function renderIcon(icon){return this.$createElement(BIcon,{props:{icon:icon,variant:this.disabled||this.color?null:this.variant||null}});},iconEmptyFn:function iconEmptyFn(){return this.renderIcon(this.iconEmpty);},iconHalfFn:function iconHalfFn(){return this.renderIcon(this.iconHalf);},iconFullFn:function iconFullFn(){return this.renderIcon(this.iconFull);},iconClearFn:function iconClearFn(){return this.$createElement(BIcon,{props:{icon:this.iconClear}});}},render:function render(h){var _this=this;var disabled=this.disabled,readonly=this.readonly,name=this.name,form=this.form,inline=this.inline,variant=this.variant,color=this.color,noBorder=this.noBorder,hasFocus=this.hasFocus,computedRating=this.computedRating,computedStars=this.computedStars,formattedRating=this.formattedRating,showClear=this.showClear,isRTL=this.isRTL,isInteractive=this.isInteractive,$scopedSlots=this.$scopedSlots;var $content=[];if(showClear&&!disabled&&!readonly){var $icon=h('span',{staticClass:'b-rating-icon'},[($scopedSlots[SLOT_NAME_ICON_CLEAR]||this.iconClearFn)()]);$content.push(h('span',{staticClass:'b-rating-star b-rating-star-clear flex-grow-1',class:{focused:hasFocus&&computedRating===0},attrs:{tabindex:isInteractive?'-1':null},on:{click:function click(){return _this.onSelected(null);}},key:'clear'},[$icon]));}for(var index=0;index<computedStars;index++){var value=index+1;$content.push(h(BVFormRatingStar,{staticClass:'flex-grow-1',style:color&&!disabled?{color:color}:{},props:{rating:computedRating,star:value,variant:disabled?null:variant||null,disabled:disabled,readonly:readonly,focused:hasFocus,hasClear:showClear},on:{selected:this.onSelected},scopedSlots:{empty:$scopedSlots[SLOT_NAME_ICON_EMPTY]||this.iconEmptyFn,half:$scopedSlots[SLOT_NAME_ICON_HALF]||this.iconHalfFn,full:$scopedSlots[SLOT_NAME_ICON_FULL]||this.iconFullFn},key:index}));}if(name){$content.push(h('input',{attrs:{type:'hidden',value:isNull(this.localValue)?'':computedRating,name:name,form:form||null},key:'hidden'}));}if(this.showValue){$content.push(h('b',{staticClass:'b-rating-value flex-grow-1',attrs:{'aria-hidden':'true'},key:'value'},toString(formattedRating)));}return h('output',{staticClass:'b-rating form-control align-items-center',class:[{'d-inline-flex':inline,'d-flex':!inline,'border-0':noBorder,disabled:disabled,readonly:!disabled&&readonly},this.sizeFormClass],attrs:{id:this.safeId(),dir:isRTL?'rtl':'ltr',tabindex:disabled?null:'0',disabled:disabled,role:'slider','aria-disabled':disabled?'true':null,'aria-readonly':!disabled&&readonly?'true':null,'aria-live':'off','aria-valuemin':showClear?'0':'1','aria-valuemax':toString(computedStars),'aria-valuenow':computedRating?toString(computedRating):null},on:{keydown:this.onKeydown,focus:this.onFocus,blur:this.onFocus}},$content);}});var FormRatingPlugin=/*#__PURE__*/pluginFactory({components:{BFormRating:BFormRating,BRating:BFormRating}});var _makeModelMixin$a=makeModelMixin('value'),mixin=_makeModelMixin$a.mixin,props$1h=_makeModelMixin$a.props,prop=_makeModelMixin$a.prop,event=_makeModelMixin$a.event;var props$1g=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},props$1D),{},{labelField:makeProp(PROP_TYPE_STRING,'label'),optionsField:makeProp(PROP_TYPE_STRING,'options')})),'formOptions');// --- Mixin ---\n// @vue/component\nvar optionsMixin=Vue__default['default'].extend({mixins:[formOptionsMixin],props:props$1g,methods:{normalizeOption:function normalizeOption(option){var key=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;// When the option is an object, normalize it\nif(isPlainObject(option)){var value=get(option,this.valueField);var text=get(option,this.textField);var options=get(option,this.optionsField,null);// When it has options, create an `<optgroup>` object\nif(!isNull(options)){return{label:String(get(option,this.labelField)||text),options:this.normalizeOptions(options)};}// Otherwise create an `<option>` object\nreturn{value:isUndefined(value)?key||text:value,text:String(isUndefined(text)?key:text),html:get(option,this.htmlField),disabled:Boolean(get(option,this.disabledField))};}// Otherwise create an `<option>` object from the given value\nreturn{value:key||option,text:String(option),disabled:false};}}});var props$1f=makePropsConfigurable({disabled:makeProp(PROP_TYPE_BOOLEAN,false),value:makeProp(PROP_TYPE_ANY,undefined,true)// Required\n},NAME_FORM_SELECT_OPTION);// --- Main component ---\n// @vue/component\nvar BFormSelectOption=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_SELECT_OPTION,functional:true,props:props$1f,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var value=props.value,disabled=props.disabled;return h('option',a(data,{attrs:{disabled:disabled},domProps:{value:value}}),children);}});var props$1e=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},props$1D),{},{label:makeProp(PROP_TYPE_STRING,undefined,true)// Required\n})),NAME_FORM_SELECT_OPTION_GROUP);// --- Main component ---\n// @vue/component\nvar BFormSelectOptionGroup=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_SELECT_OPTION_GROUP,mixins:[normalizeSlotMixin,formOptionsMixin],props:props$1e,render:function render(h){var label=this.label;var $options=this.formOptions.map(function(option,index){var value=option.value,text=option.text,html=option.html,disabled=option.disabled;return h(BFormSelectOption,{attrs:{value:value,disabled:disabled},domProps:htmlOrText(html,text),key:\"option_\".concat(index)});});return h('optgroup',{attrs:{label:label}},[this.normalizeSlot(SLOT_NAME_FIRST),$options,this.normalizeSlot()]);}});var props$1d=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),props$1h),props$1x),props$1w),props$1v),props$1u),{},{ariaInvalid:makeProp(PROP_TYPE_BOOLEAN_STRING,false),multiple:makeProp(PROP_TYPE_BOOLEAN,false),// Browsers default size to `0`, which shows 4 rows in most browsers in multiple mode\n// Size of `1` can bork out Firefox\nselectSize:makeProp(PROP_TYPE_NUMBER,0)})),NAME_FORM_SELECT);// --- Main component ---\n// @vue/component\nvar BFormSelect=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_SELECT,mixins:[idMixin,mixin,formControlMixin,formSizeMixin,formStateMixin,formCustomMixin,optionsMixin,normalizeSlotMixin],props:props$1d,data:function data(){return{localValue:this[prop]};},computed:{computedSelectSize:function computedSelectSize(){// Custom selects with a size of zero causes the arrows to be hidden,\n// so dont render the size attribute in this case\nreturn!this.plain&&this.selectSize===0?null:this.selectSize;},inputClass:function inputClass(){return[this.plain?'form-control':'custom-select',this.size&&this.plain?\"form-control-\".concat(this.size):null,this.size&&!this.plain?\"custom-select-\".concat(this.size):null,this.stateClass];}},watch:{value:function value(newValue){this.localValue=newValue;},localValue:function localValue(){this.$emit(event,this.localValue);}},methods:{focus:function focus(){attemptFocus(this.$refs.input);},blur:function blur(){attemptBlur(this.$refs.input);},onChange:function onChange(event){var _this=this;var target=event.target;var selectedValue=from(target.options).filter(function(o){return o.selected;}).map(function(o){return'_value'in o?o._value:o.value;});this.localValue=target.multiple?selectedValue:selectedValue[0];this.$nextTick(function(){_this.$emit(EVENT_NAME_CHANGE,_this.localValue);});}},render:function render(h){var name=this.name,disabled=this.disabled,required=this.required,size=this.computedSelectSize,value=this.localValue;var $options=this.formOptions.map(function(option,index){var value=option.value,label=option.label,options=option.options,disabled=option.disabled;var key=\"option_\".concat(index);return isArray(options)?h(BFormSelectOptionGroup,{props:{label:label,options:options},key:key}):h(BFormSelectOption,{props:{value:value,disabled:disabled},domProps:htmlOrText(option.html,option.text),key:key});});return h('select',{class:this.inputClass,attrs:{id:this.safeId(),name:name,form:this.form||null,multiple:this.multiple||null,size:size,disabled:disabled,required:required,'aria-required':required?'true':null,'aria-invalid':this.computedAriaInvalid},on:{change:this.onChange},directives:[{name:'model',value:value}],ref:'input'},[this.normalizeSlot(SLOT_NAME_FIRST),$options,this.normalizeSlot()]);}});var FormSelectPlugin=/*#__PURE__*/pluginFactory({components:{BFormSelect:BFormSelect,BFormSelectOption:BFormSelectOption,BFormSelectOptionGroup:BFormSelectOptionGroup,BSelect:BFormSelect,BSelectOption:BFormSelectOption,BSelectOptionGroup:BFormSelectOptionGroup}});var _watch$a;var _makeModelMixin$9=makeModelMixin('value',{// Should this really be String, to match native number inputs?\ntype:PROP_TYPE_BOOLEAN_NUMBER}),modelMixin$9=_makeModelMixin$9.mixin,modelProps$9=_makeModelMixin$9.props,MODEL_PROP_NAME$9=_makeModelMixin$9.prop,MODEL_EVENT_NAME$9=_makeModelMixin$9.event;// Default for spin button range and step\nvar DEFAULT_MIN=1;var DEFAULT_MAX=100;var DEFAULT_STEP=1;// Delay before auto-repeat in ms\nvar DEFAULT_REPEAT_DELAY=500;// Repeat interval in ms\nvar DEFAULT_REPEAT_INTERVAL=100;// Repeat rate increased after number of repeats\nvar DEFAULT_REPEAT_THRESHOLD=10;// Repeat speed multiplier (step multiplier, must be an integer)\nvar DEFAULT_REPEAT_MULTIPLIER=4;var KEY_CODES=[CODE_UP,CODE_DOWN,CODE_HOME,CODE_END,CODE_PAGEUP,CODE_PAGEDOWN];// --- Props ---\nvar props$1c=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),modelProps$9),omit(props$1x,['required','autofocus'])),props$1v),props$1u),{},{ariaControls:makeProp(PROP_TYPE_STRING),ariaLabel:makeProp(PROP_TYPE_STRING),formatterFn:makeProp(PROP_TYPE_FUNCTION),inline:makeProp(PROP_TYPE_BOOLEAN,false),labelDecrement:makeProp(PROP_TYPE_STRING,'Decrement'),labelIncrement:makeProp(PROP_TYPE_STRING,'Increment'),locale:makeProp(PROP_TYPE_ARRAY_STRING),max:makeProp(PROP_TYPE_NUMBER_STRING,DEFAULT_MAX),min:makeProp(PROP_TYPE_NUMBER_STRING,DEFAULT_MIN),placeholder:makeProp(PROP_TYPE_STRING),readonly:makeProp(PROP_TYPE_BOOLEAN,false),repeatDelay:makeProp(PROP_TYPE_NUMBER_STRING,DEFAULT_REPEAT_DELAY),repeatInterval:makeProp(PROP_TYPE_NUMBER_STRING,DEFAULT_REPEAT_INTERVAL),repeatStepMultiplier:makeProp(PROP_TYPE_NUMBER_STRING,DEFAULT_REPEAT_MULTIPLIER),repeatThreshold:makeProp(PROP_TYPE_NUMBER_STRING,DEFAULT_REPEAT_THRESHOLD),step:makeProp(PROP_TYPE_NUMBER_STRING,DEFAULT_STEP),vertical:makeProp(PROP_TYPE_BOOLEAN,false),wrap:makeProp(PROP_TYPE_BOOLEAN,false)})),NAME_FORM_SPINBUTTON);// --- Main Component ---\n// @vue/component\nvar BFormSpinbutton=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_SPINBUTTON,// Mixin order is important!\nmixins:[attrsMixin,idMixin,modelMixin$9,formSizeMixin,formStateMixin,normalizeSlotMixin],inheritAttrs:false,props:props$1c,data:function data(){return{localValue:toFloat(this[MODEL_PROP_NAME$9],null),hasFocus:false};},computed:{spinId:function spinId(){return this.safeId();},computedInline:function computedInline(){return this.inline&&!this.vertical;},computedReadonly:function computedReadonly(){return this.readonly&&!this.disabled;},computedRequired:function computedRequired(){return this.required&&!this.computedReadonly&&!this.disabled;},computedStep:function computedStep(){return toFloat(this.step,DEFAULT_STEP);},computedMin:function computedMin(){return toFloat(this.min,DEFAULT_MIN);},computedMax:function computedMax(){// We round down to the nearest maximum step value\nvar max=toFloat(this.max,DEFAULT_MAX);var step=this.computedStep;var min=this.computedMin;return mathFloor((max-min)/step)*step+min;},computedDelay:function computedDelay(){var delay=toInteger(this.repeatDelay,0);return delay>0?delay:DEFAULT_REPEAT_DELAY;},computedInterval:function computedInterval(){var interval=toInteger(this.repeatInterval,0);return interval>0?interval:DEFAULT_REPEAT_INTERVAL;},computedThreshold:function computedThreshold(){return mathMax(toInteger(this.repeatThreshold,DEFAULT_REPEAT_THRESHOLD),1);},computedStepMultiplier:function computedStepMultiplier(){return mathMax(toInteger(this.repeatStepMultiplier,DEFAULT_REPEAT_MULTIPLIER),1);},computedPrecision:function computedPrecision(){// Quick and dirty way to get the number of decimals\nvar step=this.computedStep;return mathFloor(step)===step?0:(step.toString().split('.')[1]||'').length;},computedMultiplier:function computedMultiplier(){return mathPow(10,this.computedPrecision||0);},valueAsFixed:function valueAsFixed(){var value=this.localValue;return isNull(value)?'':value.toFixed(this.computedPrecision);},computedLocale:function computedLocale(){var locales=concat(this.locale).filter(identity);var nf=new Intl.NumberFormat(locales);return nf.resolvedOptions().locale;},computedRTL:function computedRTL(){return isLocaleRTL(this.computedLocale);},defaultFormatter:function defaultFormatter(){// Returns and `Intl.NumberFormat` formatter method reference\nvar precision=this.computedPrecision;var nf=new Intl.NumberFormat(this.computedLocale,{style:'decimal',useGrouping:false,minimumIntegerDigits:1,minimumFractionDigits:precision,maximumFractionDigits:precision,notation:'standard'});// Return the format method reference\nreturn nf.format;},computedFormatter:function computedFormatter(){var formatterFn=this.formatterFn;return hasPropFunction(formatterFn)?formatterFn:this.defaultFormatter;},computedAttrs:function computedAttrs(){return _objectSpread2$3(_objectSpread2$3({},this.bvAttrs),{},{role:'group',lang:this.computedLocale,tabindex:this.disabled?null:'-1',title:this.ariaLabel});},computedSpinAttrs:function computedSpinAttrs(){var spinId=this.spinId,value=this.localValue,required=this.computedRequired,disabled=this.disabled,state=this.state,computedFormatter=this.computedFormatter;var hasValue=!isNull(value);return _objectSpread2$3(_objectSpread2$3({dir:this.computedRTL?'rtl':'ltr'},this.bvAttrs),{},{id:spinId,role:'spinbutton',tabindex:disabled?null:'0','aria-live':'off','aria-label':this.ariaLabel||null,'aria-controls':this.ariaControls||null,// TODO: May want to check if the value is in range\n'aria-invalid':state===false||!hasValue&&required?'true':null,'aria-required':required?'true':null,// These attrs are required for role spinbutton\n'aria-valuemin':toString(this.computedMin),'aria-valuemax':toString(this.computedMax),// These should be `null` if the value is out of range\n// They must also be non-existent attrs if the value is out of range or `null`\n'aria-valuenow':hasValue?value:null,'aria-valuetext':hasValue?computedFormatter(value):null});}},watch:(_watch$a={},_defineProperty(_watch$a,MODEL_PROP_NAME$9,function(value){this.localValue=toFloat(value,null);}),_defineProperty(_watch$a,\"localValue\",function localValue(value){this.$emit(MODEL_EVENT_NAME$9,value);}),_defineProperty(_watch$a,\"disabled\",function disabled(_disabled){if(_disabled){this.clearRepeat();}}),_defineProperty(_watch$a,\"readonly\",function readonly(_readonly){if(_readonly){this.clearRepeat();}}),_watch$a),created:function created(){// Create non reactive properties\nthis.$_autoDelayTimer=null;this.$_autoRepeatTimer=null;this.$_keyIsDown=false;},beforeDestroy:function beforeDestroy(){this.clearRepeat();},/* istanbul ignore next */deactivated:function deactivated(){this.clearRepeat();},methods:{// --- Public methods ---\nfocus:function focus(){if(!this.disabled){attemptFocus(this.$refs.spinner);}},blur:function blur(){if(!this.disabled){attemptBlur(this.$refs.spinner);}},// --- Private methods ---\nemitChange:function emitChange(){this.$emit(EVENT_NAME_CHANGE,this.localValue);},stepValue:function stepValue(direction){// Sets a new incremented or decremented value, supporting optional wrapping\n// Direction is either +1 or -1 (or a multiple thereof)\nvar value=this.localValue;if(!this.disabled&&!isNull(value)){var step=this.computedStep*direction;var min=this.computedMin;var max=this.computedMax;var multiplier=this.computedMultiplier;var wrap=this.wrap;// We ensure that the value steps like a native input\nvalue=mathRound((value-min)/step)*step+min+step;// We ensure that precision is maintained (decimals)\nvalue=mathRound(value*multiplier)/multiplier;// Handle if wrapping is enabled\nthis.localValue=value>max?wrap?min:max:value<min?wrap?max:min:value;}},onFocusBlur:function onFocusBlur(event){this.hasFocus=this.disabled?false:event.type==='focus';},stepUp:function stepUp(){var multiplier=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var value=this.localValue;if(isNull(value)){this.localValue=this.computedMin;}else{this.stepValue(+1*multiplier);}},stepDown:function stepDown(){var multiplier=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var value=this.localValue;if(isNull(value)){this.localValue=this.wrap?this.computedMax:this.computedMin;}else{this.stepValue(-1*multiplier);}},onKeydown:function onKeydown(event){var keyCode=event.keyCode,altKey=event.altKey,ctrlKey=event.ctrlKey,metaKey=event.metaKey;/* istanbul ignore if */if(this.disabled||this.readonly||altKey||ctrlKey||metaKey){return;}if(arrayIncludes(KEY_CODES,keyCode)){// https://w3c.github.io/aria-practices/#spinbutton\nstopEvent(event,{propagation:false});/* istanbul ignore if */if(this.$_keyIsDown){// Keypress is already in progress\nreturn;}this.resetTimers();if(arrayIncludes([CODE_UP,CODE_DOWN],keyCode)){// The following use the custom auto-repeat handling\nthis.$_keyIsDown=true;if(keyCode===CODE_UP){this.handleStepRepeat(event,this.stepUp);}else if(keyCode===CODE_DOWN){this.handleStepRepeat(event,this.stepDown);}}else{// These use native OS key repeating\nif(keyCode===CODE_PAGEUP){this.stepUp(this.computedStepMultiplier);}else if(keyCode===CODE_PAGEDOWN){this.stepDown(this.computedStepMultiplier);}else if(keyCode===CODE_HOME){this.localValue=this.computedMin;}else if(keyCode===CODE_END){this.localValue=this.computedMax;}}}},onKeyup:function onKeyup(event){// Emit a change event when the keyup happens\nvar keyCode=event.keyCode,altKey=event.altKey,ctrlKey=event.ctrlKey,metaKey=event.metaKey;/* istanbul ignore if */if(this.disabled||this.readonly||altKey||ctrlKey||metaKey){return;}if(arrayIncludes(KEY_CODES,keyCode)){stopEvent(event,{propagation:false});this.resetTimers();this.$_keyIsDown=false;this.emitChange();}},handleStepRepeat:function handleStepRepeat(event,stepper){var _this=this;var _ref=event||{},type=_ref.type,button=_ref.button;if(!this.disabled&&!this.readonly){/* istanbul ignore if */if(type==='mousedown'&&button){// We only respond to left (main === 0) button clicks\nreturn;}this.resetTimers();// Step the counter initially\nstepper(1);var threshold=this.computedThreshold;var multiplier=this.computedStepMultiplier;var delay=this.computedDelay;var interval=this.computedInterval;// Initiate the delay/repeat interval\nthis.$_autoDelayTimer=setTimeout(function(){var count=0;_this.$_autoRepeatTimer=setInterval(function(){// After N initial repeats, we increase the incrementing step amount\n// We do this to minimize screen reader announcements of the value\n// (values are announced every change, which can be chatty for SR users)\n// And to make it easer to select a value when the range is large\nstepper(count<threshold?1:multiplier);count++;},interval);},delay);}},onMouseup:function onMouseup(event){// `<body>` listener, only enabled when mousedown starts\nvar _ref2=event||{},type=_ref2.type,button=_ref2.button;/* istanbul ignore if */if(type==='mouseup'&&button){// Ignore non left button (main === 0) mouse button click\nreturn;}stopEvent(event,{propagation:false});this.resetTimers();this.setMouseup(false);// Trigger the change event\nthis.emitChange();},setMouseup:function setMouseup(on){// Enable or disabled the body mouseup/touchend handlers\n// Use try/catch to handle case when called server side\ntry{eventOnOff(on,document.body,'mouseup',this.onMouseup,false);eventOnOff(on,document.body,'touchend',this.onMouseup,false);}catch(_unused){}},resetTimers:function resetTimers(){clearTimeout(this.$_autoDelayTimer);clearInterval(this.$_autoRepeatTimer);this.$_autoDelayTimer=null;this.$_autoRepeatTimer=null;},clearRepeat:function clearRepeat(){this.resetTimers();this.setMouseup(false);this.$_keyIsDown=false;}},render:function render(h){var _this2=this;var spinId=this.spinId,value=this.localValue,inline=this.computedInline,readonly=this.computedReadonly,vertical=this.vertical,disabled=this.disabled,computedFormatter=this.computedFormatter;var hasValue=!isNull(value);var makeButton=function makeButton(stepper,label,IconCmp,keyRef,shortcut,btnDisabled,slotName){var $icon=h(IconCmp,{props:{scale:_this2.hasFocus?1.5:1.25},attrs:{'aria-hidden':'true'}});var scope={hasFocus:_this2.hasFocus};var handler=function handler(event){if(!disabled&&!readonly){stopEvent(event,{propagation:false});_this2.setMouseup(true);// Since we `preventDefault()`, we must manually focus the button\nattemptFocus(event.currentTarget);_this2.handleStepRepeat(event,stepper);}};return h('button',{staticClass:'btn btn-sm border-0 rounded-0',class:{'py-0':!vertical},attrs:{tabindex:'-1',type:'button',disabled:disabled||readonly||btnDisabled,'aria-disabled':disabled||readonly||btnDisabled?'true':null,'aria-controls':spinId,'aria-label':label||null,'aria-keyshortcuts':shortcut||null},on:{mousedown:handler,touchstart:handler},key:keyRef||null,ref:keyRef},[_this2.normalizeSlot(slotName,scope)||$icon]);};// TODO: Add button disabled state when `wrap` is `false` and at value max/min\nvar $increment=makeButton(this.stepUp,this.labelIncrement,BIconPlus,'inc','ArrowUp',false,SLOT_NAME_INCREMENT);var $decrement=makeButton(this.stepDown,this.labelDecrement,BIconDash,'dec','ArrowDown',false,SLOT_NAME_DECREMENT);var $hidden=h();if(this.name&&!disabled){$hidden=h('input',{attrs:{type:'hidden',name:this.name,form:this.form||null,// TODO: Should this be set to '' if value is out of range?\nvalue:this.valueAsFixed},key:'hidden'});}var $spin=h(// We use 'output' element to make this accept a `<label for=\"id\">` (Except IE)\n'output',{staticClass:'flex-grow-1',class:{'d-flex':vertical,'align-self-center':!vertical,'align-items-center':vertical,'border-top':vertical,'border-bottom':vertical,'border-left':!vertical,'border-right':!vertical},attrs:this.computedSpinAttrs,key:'output',ref:'spinner'},[h('bdi',hasValue?computedFormatter(value):this.placeholder||'')]);return h('div',{staticClass:'b-form-spinbutton form-control',class:[{disabled:disabled,readonly:readonly,focus:this.hasFocus,'d-inline-flex':inline||vertical,'d-flex':!inline&&!vertical,'align-items-stretch':!vertical,'flex-column':vertical},this.sizeFormClass,this.stateClass],attrs:this.computedAttrs,on:{keydown:this.onKeydown,keyup:this.onKeyup,// We use capture phase (`!` prefix) since focus and blur do not bubble\n'!focus':this.onFocusBlur,'!blur':this.onFocusBlur}},vertical?[$increment,$hidden,$spin,$decrement]:[$decrement,$hidden,$spin,$increment]);}});var FormSpinbuttonPlugin=/*#__PURE__*/pluginFactory({components:{BFormSpinbutton:BFormSpinbutton,BSpinbutton:BFormSpinbutton}});var props$1b=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},props$25),{},{disabled:makeProp(PROP_TYPE_BOOLEAN,false),noRemove:makeProp(PROP_TYPE_BOOLEAN,false),pill:makeProp(PROP_TYPE_BOOLEAN,false),removeLabel:makeProp(PROP_TYPE_STRING,'Remove tag'),tag:makeProp(PROP_TYPE_STRING,'span'),title:makeProp(PROP_TYPE_STRING),variant:makeProp(PROP_TYPE_STRING,'secondary')})),NAME_FORM_TAG);// --- Main component ---\n// @vue/component\nvar BFormTag=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_TAG,mixins:[idMixin,normalizeSlotMixin],props:props$1b,methods:{onRemove:function onRemove(event){var type=event.type,keyCode=event.keyCode;if(!this.disabled&&(type==='click'||type==='keydown'&&keyCode===CODE_DELETE)){this.$emit(EVENT_NAME_REMOVE);}}},render:function render(h){var title=this.title,tag=this.tag,variant=this.variant,pill=this.pill,disabled=this.disabled;var tagId=this.safeId();var tagLabelId=this.safeId('_taglabel_');var $remove=h();if(!this.noRemove&&!disabled){$remove=h(BButtonClose,{staticClass:'b-form-tag-remove',props:{ariaLabel:this.removeLabel},attrs:{'aria-controls':tagId,'aria-describedby':tagLabelId,'aria-keyshortcuts':'Delete'},on:{click:this.onRemove,keydown:this.onRemove}});}var $tag=h('span',{staticClass:'b-form-tag-content flex-grow-1 text-truncate',attrs:{id:tagLabelId}},this.normalizeSlot()||title);return h(BBadge,{staticClass:'b-form-tag d-inline-flex align-items-baseline mw-100',class:{disabled:disabled},props:{tag:tag,variant:variant,pill:pill},attrs:{id:tagId,title:title||null,'aria-labelledby':tagLabelId}},[$tag,$remove]);}});var _watch$9;var _makeModelMixin$8=makeModelMixin('value',{type:PROP_TYPE_ARRAY,defaultValue:[]}),modelMixin$8=_makeModelMixin$8.mixin,modelProps$8=_makeModelMixin$8.props,MODEL_PROP_NAME$8=_makeModelMixin$8.prop,MODEL_EVENT_NAME$8=_makeModelMixin$8.event;// Supported input types (for built in input)\nvar TYPES=['text','email','tel','url','number'];// Default ignore input focus selector\nvar DEFAULT_INPUT_FOCUS_SELECTOR=['.b-form-tag','button','input','select'].join(' ');// --- Helper methods ---\n// Escape special chars in string and replace\n// contiguous spaces with a whitespace match\nvar escapeRegExpChars=function escapeRegExpChars(str){return escapeRegExp(str).replace(RX_SPACES,'\\\\s');};// Remove leading/trailing spaces from array of tags and remove duplicates\nvar cleanTags=function cleanTags(tags){return concat(tags).map(function(tag){return trim(toString(tag));}).filter(function(tag,index,arr){return tag.length>0&&arr.indexOf(tag)===index;});};// Processes an input/change event, normalizing string or event argument\nvar processEventValue=function processEventValue(event){return isString(event)?event:isEvent(event)?event.target.value||'':'';};// Returns a fresh empty `tagsState` object\nvar cleanTagsState=function cleanTagsState(){return{all:[],valid:[],invalid:[],duplicate:[]};};// --- Props ---\nvar props$1a=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),modelProps$8),props$1x),props$1v),props$1u),{},{addButtonText:makeProp(PROP_TYPE_STRING,'Add'),addButtonVariant:makeProp(PROP_TYPE_STRING,'outline-secondary'),// Enable change event triggering tag addition\n// Handy if using <select> as the input\naddOnChange:makeProp(PROP_TYPE_BOOLEAN,false),duplicateTagText:makeProp(PROP_TYPE_STRING,'Duplicate tag(s)'),feedbackAriaLive:makeProp(PROP_TYPE_STRING,'assertive'),// Disable the input focus behavior when clicking\n// on element matching the selector (or selectors)\nignoreInputFocusSelector:makeProp(PROP_TYPE_ARRAY_STRING,DEFAULT_INPUT_FOCUS_SELECTOR),// Additional attributes to add to the input element\ninputAttrs:makeProp(PROP_TYPE_OBJECT,{}),inputClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),inputId:makeProp(PROP_TYPE_STRING),inputType:makeProp(PROP_TYPE_STRING,'text',function(value){return arrayIncludes(TYPES,value);}),invalidTagText:makeProp(PROP_TYPE_STRING,'Invalid tag(s)'),limit:makeProp(PROP_TYPE_NUMBER),limitTagsText:makeProp(PROP_TYPE_STRING,'Tag limit reached'),// Disable ENTER key from triggering tag addition\nnoAddOnEnter:makeProp(PROP_TYPE_BOOLEAN,false),// Disable the focus ring on the root element\nnoOuterFocus:makeProp(PROP_TYPE_BOOLEAN,false),noTagRemove:makeProp(PROP_TYPE_BOOLEAN,false),placeholder:makeProp(PROP_TYPE_STRING,'Add tag...'),// Enable deleting last tag in list when CODE_BACKSPACE is\n// pressed and input is empty\nremoveOnDelete:makeProp(PROP_TYPE_BOOLEAN,false),// Character (or characters) that trigger adding tags\nseparator:makeProp(PROP_TYPE_ARRAY_STRING),tagClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),tagPills:makeProp(PROP_TYPE_BOOLEAN,false),tagRemoveLabel:makeProp(PROP_TYPE_STRING,'Remove tag'),tagRemovedLabel:makeProp(PROP_TYPE_STRING,'Tag removed'),tagValidator:makeProp(PROP_TYPE_FUNCTION),tagVariant:makeProp(PROP_TYPE_STRING,'secondary')})),NAME_FORM_TAGS);// --- Main component ---\n// @vue/component\nvar BFormTags=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_TAGS,mixins:[listenersMixin,idMixin,modelMixin$8,formControlMixin,formSizeMixin,formStateMixin,normalizeSlotMixin],props:props$1a,data:function data(){return{hasFocus:false,newTag:'',tags:[],// Tags that were removed\nremovedTags:[],// Populated when tags are parsed\ntagsState:cleanTagsState(),focusState:null};},computed:{computedInputId:function computedInputId(){return this.inputId||this.safeId('__input__');},computedInputType:function computedInputType(){// We only allow certain types\nreturn arrayIncludes(TYPES,this.inputType)?this.inputType:'text';},computedInputAttrs:function computedInputAttrs(){var disabled=this.disabled,form=this.form;return _objectSpread2$3(_objectSpread2$3({},this.inputAttrs),{},{// Must have attributes\nid:this.computedInputId,value:this.newTag,disabled:disabled,form:form});},computedInputHandlers:function computedInputHandlers(){return _objectSpread2$3(_objectSpread2$3({},omit(this.bvListeners,[EVENT_NAME_FOCUSIN,EVENT_NAME_FOCUSOUT])),{},{blur:this.onInputBlur,change:this.onInputChange,focus:this.onInputFocus,input:this.onInputInput,keydown:this.onInputKeydown,reset:this.reset});},computedSeparator:function computedSeparator(){// Merge the array into a string\nreturn concat(this.separator).filter(isString).filter(identity).join('');},computedSeparatorRegExp:function computedSeparatorRegExp(){// We use a computed prop here to precompile the RegExp\n// The RegExp is a character class RE in the form of `/[abc]+/`\n// where a, b, and c are the valid separator characters\n// -> `tags = str.split(/[abc]+/).filter(t => t)`\nvar separator=this.computedSeparator;return separator?new RegExp(\"[\".concat(escapeRegExpChars(separator),\"]+\")):null;},computedJoiner:function computedJoiner(){// When tag(s) are invalid or duplicate, we leave them\n// in the input so that the user can see them\n// If there are more than one tag in the input, we use the\n// first separator character as the separator in the input\n// We append a space if the first separator is not a space\nvar joiner=this.computedSeparator.charAt(0);return joiner!==' '?\"\".concat(joiner,\" \"):joiner;},computeIgnoreInputFocusSelector:function computeIgnoreInputFocusSelector(){// Normalize to an single selector with selectors separated by `,`\nreturn concat(this.ignoreInputFocusSelector).filter(identity).join(',').trim();},disableAddButton:function disableAddButton(){var _this=this;// If 'Add' button should be disabled\n// If the input contains at least one tag that can\n// be added, then the 'Add' button should be enabled\nvar newTag=trim(this.newTag);return newTag===''||!this.splitTags(newTag).some(function(t){return!arrayIncludes(_this.tags,t)&&_this.validateTag(t);});},duplicateTags:function duplicateTags(){return this.tagsState.duplicate;},hasDuplicateTags:function hasDuplicateTags(){return this.duplicateTags.length>0;},invalidTags:function invalidTags(){return this.tagsState.invalid;},hasInvalidTags:function hasInvalidTags(){return this.invalidTags.length>0;},isLimitReached:function isLimitReached(){var limit=this.limit;return isNumber(limit)&&limit>=0&&this.tags.length>=limit;}},watch:(_watch$9={},_defineProperty(_watch$9,MODEL_PROP_NAME$8,function(newValue){this.tags=cleanTags(newValue);}),_defineProperty(_watch$9,\"tags\",function tags(newValue,oldValue){// Update the `v-model` (if it differs from the value prop)\nif(!looseEqual(newValue,this[MODEL_PROP_NAME$8])){this.$emit(MODEL_EVENT_NAME$8,newValue);}if(!looseEqual(newValue,oldValue)){newValue=concat(newValue).filter(identity);oldValue=concat(oldValue).filter(identity);this.removedTags=oldValue.filter(function(old){return!arrayIncludes(newValue,old);});}}),_defineProperty(_watch$9,\"tagsState\",function tagsState(newValue,oldValue){// Emit a tag-state event when the `tagsState` object changes\nif(!looseEqual(newValue,oldValue)){this.$emit(EVENT_NAME_TAG_STATE,newValue.valid,newValue.invalid,newValue.duplicate);}}),_watch$9),created:function created(){// We do this in created to make sure an input event emits\n// if the cleaned tags are not equal to the value prop\nthis.tags=cleanTags(this[MODEL_PROP_NAME$8]);},mounted:function mounted(){// Listen for form reset events, to reset the tags input\nvar $form=closest('form',this.$el);if($form){eventOn($form,'reset',this.reset,EVENT_OPTIONS_PASSIVE);}},beforeDestroy:function beforeDestroy(){var $form=closest('form',this.$el);if($form){eventOff($form,'reset',this.reset,EVENT_OPTIONS_PASSIVE);}},methods:{addTag:function addTag(newTag){newTag=isString(newTag)?newTag:this.newTag;/* istanbul ignore next */if(this.disabled||trim(newTag)===''||this.isLimitReached){// Early exit\nreturn;}var parsed=this.parseTags(newTag);// Add any new tags to the `tags` array, or if the\n// array of `allTags` is empty, we clear the input\nif(parsed.valid.length>0||parsed.all.length===0){// Clear the user input element (and leave in any invalid/duplicate tag(s)\n/* istanbul ignore if: full testing to be added later */if(matches(this.getInput(),'select')){// The following is needed to properly\n// work with `<select>` elements\nthis.newTag='';}else{var invalidAndDuplicates=[].concat(_toConsumableArray$1(parsed.invalid),_toConsumableArray$1(parsed.duplicate));this.newTag=parsed.all.filter(function(tag){return arrayIncludes(invalidAndDuplicates,tag);}).join(this.computedJoiner).concat(invalidAndDuplicates.length>0?this.computedJoiner.charAt(0):'');}}if(parsed.valid.length>0){// We add the new tags in one atomic operation\n// to trigger reactivity once (instead of once per tag)\n// We do this after we update the new tag input value\n// `concat()` can be faster than array spread, when both args are arrays\nthis.tags=concat(this.tags,parsed.valid);}this.tagsState=parsed;// Attempt to re-focus the input (specifically for when using the Add\n// button, as the button disappears after successfully adding a tag\nthis.focus();},removeTag:function removeTag(tag){/* istanbul ignore next */if(this.disabled){return;}// TODO:\n//   Add `onRemoveTag(tag)` user method, which if returns `false`\n//   will prevent the tag from being removed (i.e. confirmation)\n//   Or emit cancelable `BvEvent`\nthis.tags=this.tags.filter(function(t){return t!==tag;});},reset:function reset(){var _this2=this;this.newTag='';this.tags=[];this.$nextTick(function(){_this2.removedTags=[];_this2.tagsState=cleanTagsState();});},// --- Input element event handlers ---\nonInputInput:function onInputInput(event){/* istanbul ignore next: hard to test composition events */if(this.disabled||isEvent(event)&&event.target.composing){// `event.target.composing` is set by Vue (`v-model` directive)\n// https://github.com/vuejs/vue/blob/dev/src/platforms/web/runtime/directives/model.js\nreturn;}var newTag=processEventValue(event);var separatorRe=this.computedSeparatorRegExp;if(this.newTag!==newTag){this.newTag=newTag;}// We ignore leading whitespace for the following\nnewTag=trimLeft(newTag);if(separatorRe&&separatorRe.test(newTag.slice(-1))){// A trailing separator character was entered, so add the tag(s)\n// Note: More than one tag on input event is possible via copy/paste\nthis.addTag();}else{// Validate (parse tags) on input event\nthis.tagsState=newTag===''?cleanTagsState():this.parseTags(newTag);}},onInputChange:function onInputChange(event){// Change is triggered on `<input>` blur, or `<select>` selected\n// This event is opt-in\nif(!this.disabled&&this.addOnChange){var newTag=processEventValue(event);/* istanbul ignore next */if(this.newTag!==newTag){this.newTag=newTag;}this.addTag();}},onInputKeydown:function onInputKeydown(event){// Early exit\n/* istanbul ignore next */if(this.disabled||!isEvent(event)){return;}var keyCode=event.keyCode;var value=event.target.value||'';/* istanbul ignore else: testing to be added later */if(!this.noAddOnEnter&&keyCode===CODE_ENTER){// Attempt to add the tag when user presses enter\nstopEvent(event,{propagation:false});this.addTag();}else if(this.removeOnDelete&&(keyCode===CODE_BACKSPACE||keyCode===CODE_DELETE)&&value===''){// Remove the last tag if the user pressed backspace/delete and the input is empty\nstopEvent(event,{propagation:false});this.tags=this.tags.slice(0,-1);}},// --- Wrapper event handlers ---\nonClick:function onClick(event){var _this3=this;var ignoreFocusSelector=this.computeIgnoreInputFocusSelector;if(!ignoreFocusSelector||!closest(ignoreFocusSelector,event.target,true)){this.$nextTick(function(){_this3.focus();});}},onInputFocus:function onInputFocus(event){var _this4=this;if(this.focusState!=='out'){this.focusState='in';this.$nextTick(function(){requestAF(function(){if(_this4.hasFocus){_this4.$emit(EVENT_NAME_FOCUS,event);_this4.focusState=null;}});});}},onInputBlur:function onInputBlur(event){var _this5=this;if(this.focusState!=='in'){this.focusState='out';this.$nextTick(function(){requestAF(function(){if(!_this5.hasFocus){_this5.$emit(EVENT_NAME_BLUR,event);_this5.focusState=null;}});});}},onFocusin:function onFocusin(event){this.hasFocus=true;this.$emit(EVENT_NAME_FOCUSIN,event);},onFocusout:function onFocusout(event){this.hasFocus=false;this.$emit(EVENT_NAME_FOCUSOUT,event);},handleAutofocus:function handleAutofocus(){var _this6=this;this.$nextTick(function(){requestAF(function(){if(_this6.autofocus){_this6.focus();}});});},// --- Public methods ---\nfocus:function focus(){if(!this.disabled){attemptFocus(this.getInput());}},blur:function blur(){if(!this.disabled){attemptBlur(this.getInput());}},// --- Private methods ---\nsplitTags:function splitTags(newTag){// Split the input into an array of raw tags\nnewTag=toString(newTag);var separatorRe=this.computedSeparatorRegExp;// Split the tag(s) via the optional separator\n// Normally only a single tag is provided, but copy/paste\n// can enter multiple tags in a single operation\nreturn(separatorRe?newTag.split(separatorRe):[newTag]).map(trim).filter(identity);},parseTags:function parseTags(newTag){var _this7=this;// Takes `newTag` value and parses it into `validTags`,\n// `invalidTags`, and duplicate tags as an object\n// Split the input into raw tags\nvar tags=this.splitTags(newTag);// Base results\nvar parsed={all:tags,valid:[],invalid:[],duplicate:[]};// Parse the unique tags\ntags.forEach(function(tag){if(arrayIncludes(_this7.tags,tag)||arrayIncludes(parsed.valid,tag)){// Unique duplicate tags\nif(!arrayIncludes(parsed.duplicate,tag)){parsed.duplicate.push(tag);}}else if(_this7.validateTag(tag)){// We only add unique/valid tags\nparsed.valid.push(tag);}else{// Unique invalid tags\nif(!arrayIncludes(parsed.invalid,tag)){parsed.invalid.push(tag);}}});return parsed;},validateTag:function validateTag(tag){var tagValidator=this.tagValidator;return hasPropFunction(tagValidator)?tagValidator(tag):true;},getInput:function getInput(){// Returns the input element reference (or null if not found)\n// We need to escape `computedInputId` since it can be user-provided\nreturn select(\"#\".concat(cssEscape(this.computedInputId)),this.$el);},// Default User Interface render\ndefaultRender:function defaultRender(_ref){var addButtonText=_ref.addButtonText,addButtonVariant=_ref.addButtonVariant,addTag=_ref.addTag,disableAddButton=_ref.disableAddButton,disabled=_ref.disabled,duplicateTagText=_ref.duplicateTagText,inputAttrs=_ref.inputAttrs,inputClass=_ref.inputClass,inputHandlers=_ref.inputHandlers,inputType=_ref.inputType,invalidTagText=_ref.invalidTagText,isDuplicate=_ref.isDuplicate,isInvalid=_ref.isInvalid,isLimitReached=_ref.isLimitReached,limitTagsText=_ref.limitTagsText,noTagRemove=_ref.noTagRemove,placeholder=_ref.placeholder,removeTag=_ref.removeTag,tagClass=_ref.tagClass,tagPills=_ref.tagPills,tagRemoveLabel=_ref.tagRemoveLabel,tagVariant=_ref.tagVariant,tags=_ref.tags;var h=this.$createElement;// Make the list of tags\nvar $tags=tags.map(function(tag){tag=toString(tag);return h(BFormTag,{class:tagClass,// `BFormTag` will auto generate an ID\n// so we do not need to set the ID prop\nprops:{disabled:disabled,noRemove:noTagRemove,pill:tagPills,removeLabel:tagRemoveLabel,tag:'li',title:tag,variant:tagVariant},on:{remove:function remove(){return removeTag(tag);}},key:\"tags_\".concat(tag)},tag);});// Feedback IDs if needed\nvar invalidFeedbackId=invalidTagText&&isInvalid?this.safeId('__invalid_feedback__'):null;var duplicateFeedbackId=duplicateTagText&&isDuplicate?this.safeId('__duplicate_feedback__'):null;var limitFeedbackId=limitTagsText&&isLimitReached?this.safeId('__limit_feedback__'):null;// Compute the `aria-describedby` attribute value\nvar ariaDescribedby=[inputAttrs['aria-describedby'],invalidFeedbackId,duplicateFeedbackId,limitFeedbackId].filter(identity).join(' ');// Input\nvar $input=h('input',{staticClass:'b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0',class:inputClass,style:{outline:0,minWidth:'5rem'},attrs:_objectSpread2$3(_objectSpread2$3({},inputAttrs),{},{'aria-describedby':ariaDescribedby||null,type:inputType,placeholder:placeholder||null}),domProps:{value:inputAttrs.value},on:inputHandlers,// Directive needed to get `event.target.composing` set (if needed)\ndirectives:[{name:'model',value:inputAttrs.value}],ref:'input'});// Add button\nvar $button=h(BButton,{staticClass:'b-form-tags-button py-0',class:{// Only show the button if the tag can be added\n// We use the `invisible` class instead of not rendering\n// the button, so that we maintain layout to prevent\n// the user input from jumping around\ninvisible:disableAddButton},style:{fontSize:'90%'},props:{disabled:disableAddButton||isLimitReached,variant:addButtonVariant},on:{click:function click(){return addTag();}},ref:'button'},[this.normalizeSlot(SLOT_NAME_ADD_BUTTON_TEXT)||addButtonText]);// ID of the tags + input `<ul>` list\n// Note we could concatenate `inputAttrs.id` with '__tag_list__'\n// but `inputId` may be `null` until after mount\n// `safeId()` returns `null`, if no user provided ID,\n// until after mount when a unique ID is generated\nvar tagListId=this.safeId('__tag_list__');var $field=h('li',{staticClass:'b-form-tags-field flex-grow-1',attrs:{role:'none','aria-live':'off','aria-controls':tagListId},key:'tags_field'},[h('div',{staticClass:'d-flex',attrs:{role:'group'}},[$input,$button])]);// Wrap in an unordered list element (we use a list for accessibility)\nvar $ul=h('ul',{staticClass:'b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center',attrs:{id:tagListId},key:'tags_list'},[$tags,$field]);// Assemble the feedback\nvar $feedback=h();if(invalidTagText||duplicateTagText||limitTagsText){// Add an aria live region for the invalid/duplicate tag\n// messages if the user has not disabled the messages\nvar ariaLive=this.feedbackAriaLive,joiner=this.computedJoiner;// Invalid tag feedback if needed (error)\nvar $invalid=h();if(invalidFeedbackId){$invalid=h(BFormInvalidFeedback,{props:{id:invalidFeedbackId,ariaLive:ariaLive,forceShow:true},key:'tags_invalid_feedback'},[this.invalidTagText,': ',this.invalidTags.join(joiner)]);}// Duplicate tag feedback if needed (warning, not error)\nvar $duplicate=h();if(duplicateFeedbackId){$duplicate=h(BFormText,{props:{id:duplicateFeedbackId,ariaLive:ariaLive},key:'tags_duplicate_feedback'},[this.duplicateTagText,': ',this.duplicateTags.join(joiner)]);}// Limit tags feedback if needed (warning, not error)\nvar $limit=h();if(limitFeedbackId){$limit=h(BFormText,{props:{id:limitFeedbackId,ariaLive:ariaLive},key:'tags_limit_feedback'},[limitTagsText]);}$feedback=h('div',{attrs:{'aria-live':'polite','aria-atomic':'true'},key:'tags_feedback'},[$invalid,$duplicate,$limit]);}// Return the content\nreturn[$ul,$feedback];}},render:function render(h){var name=this.name,disabled=this.disabled,required=this.required,form=this.form,tags=this.tags,computedInputId=this.computedInputId,hasFocus=this.hasFocus,noOuterFocus=this.noOuterFocus;// Scoped slot properties\nvar scope=_objectSpread2$3({// Array of tags (shallow copy to prevent mutations)\ntags:tags.slice(),// <input> v-bind:inputAttrs\ninputAttrs:this.computedInputAttrs,// We don't include this in the attrs, as users may want to override this\ninputType:this.computedInputType,// <input> v-on:inputHandlers\ninputHandlers:this.computedInputHandlers,// Methods\nremoveTag:this.removeTag,addTag:this.addTag,reset:this.reset,// <input> :id=\"inputId\"\ninputId:computedInputId,// Invalid/Duplicate state information\nisInvalid:this.hasInvalidTags,invalidTags:this.invalidTags.slice(),isDuplicate:this.hasDuplicateTags,duplicateTags:this.duplicateTags.slice(),isLimitReached:this.isLimitReached,// If the 'Add' button should be disabled\ndisableAddButton:this.disableAddButton},pick$1(this.$props,['addButtonText','addButtonVariant','disabled','duplicateTagText','form','inputClass','invalidTagText','limit','limitTagsText','noTagRemove','placeholder','required','separator','size','state','tagClass','tagPills','tagRemoveLabel','tagVariant']));// Generate the user interface\nvar $content=this.normalizeSlot(SLOT_NAME_DEFAULT,scope)||this.defaultRender(scope);// Generate the `aria-live` region for the current value(s)\nvar $output=h('output',{staticClass:'sr-only',attrs:{id:this.safeId('__selected_tags__'),role:'status',for:computedInputId,'aria-live':hasFocus?'polite':'off','aria-atomic':'true','aria-relevant':'additions text'}},this.tags.join(', '));// Removed tag live region\nvar $removed=h('div',{staticClass:'sr-only',attrs:{id:this.safeId('__removed_tags__'),role:'status','aria-live':hasFocus?'assertive':'off','aria-atomic':'true'}},this.removedTags.length>0?\"(\".concat(this.tagRemovedLabel,\") \").concat(this.removedTags.join(', ')):'');// Add hidden inputs for form submission\nvar $hidden=h();if(name&&!disabled){// We add hidden inputs for each tag if a name is provided\n// When there are currently no tags, a visually hidden input\n// with empty value is rendered for proper required handling\nvar hasTags=tags.length>0;$hidden=(hasTags?tags:['']).map(function(tag){return h('input',{class:{'sr-only':!hasTags},attrs:{type:hasTags?'hidden':'text',value:tag,required:required,name:name,form:form},key:\"tag_input_\".concat(tag)});});}// Return the rendered output\nreturn h('div',{staticClass:'b-form-tags form-control h-auto',class:[{focus:hasFocus&&!noOuterFocus&&!disabled,disabled:disabled},this.sizeFormClass,this.stateClass],attrs:{id:this.safeId(),role:'group',tabindex:disabled||noOuterFocus?null:'-1','aria-describedby':this.safeId('__selected_tags__')},on:{click:this.onClick,focusin:this.onFocusin,focusout:this.onFocusout}},[$output,$removed,$content,$hidden]);}});var FormTagsPlugin=/*#__PURE__*/pluginFactory({components:{BFormTags:BFormTags,BTags:BFormTags,BFormTag:BFormTag,BTag:BFormTag}});var props$19=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),props$1x),props$1v),props$1u),props$1l),{},{maxRows:makeProp(PROP_TYPE_NUMBER_STRING),// When in auto resize mode, disable shrinking to content height\nnoAutoShrink:makeProp(PROP_TYPE_BOOLEAN,false),// Disable the resize handle of textarea\nnoResize:makeProp(PROP_TYPE_BOOLEAN,false),rows:makeProp(PROP_TYPE_NUMBER_STRING,2),// 'soft', 'hard' or 'off'\n// Browser default is 'soft'\nwrap:makeProp(PROP_TYPE_STRING,'soft')})),NAME_FORM_TEXTAREA);// --- Main component ---\n// @vue/component\nvar BFormTextarea=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_TEXTAREA,directives:{'b-visible':VBVisible},// Mixin order is important!\nmixins:[listenersMixin,idMixin,listenOnRootMixin,formControlMixin,formSizeMixin,formStateMixin,formTextMixin,formSelectionMixin,formValidityMixin],props:props$19,data:function data(){return{heightInPx:null};},computed:{computedStyle:function computedStyle(){var styles={// Setting `noResize` to true will disable the ability for the user to\n// manually resize the textarea. We also disable when in auto height mode\nresize:!this.computedRows||this.noResize?'none':null};if(!this.computedRows){// Conditionally set the computed CSS height when auto rows/height is enabled\n// We avoid setting the style to `null`, which can override user manual resize handle\nstyles.height=this.heightInPx;// We always add a vertical scrollbar to the textarea when auto-height is\n// enabled so that the computed height calculation returns a stable value\nstyles.overflowY='scroll';}return styles;},computedMinRows:function computedMinRows(){// Ensure rows is at least 2 and positive (2 is the native textarea value)\n// A value of 1 can cause issues in some browsers, and most browsers\n// only support 2 as the smallest value\nreturn mathMax(toInteger(this.rows,2),2);},computedMaxRows:function computedMaxRows(){return mathMax(this.computedMinRows,toInteger(this.maxRows,0));},computedRows:function computedRows(){// This is used to set the attribute 'rows' on the textarea\n// If auto-height is enabled, then we return `null` as we use CSS to control height\nreturn this.computedMinRows===this.computedMaxRows?this.computedMinRows:null;},computedAttrs:function computedAttrs(){var disabled=this.disabled,required=this.required;return{id:this.safeId(),name:this.name||null,form:this.form||null,disabled:disabled,placeholder:this.placeholder||null,required:required,autocomplete:this.autocomplete||null,readonly:this.readonly||this.plaintext,rows:this.computedRows,wrap:this.wrap||null,'aria-required':this.required?'true':null,'aria-invalid':this.computedAriaInvalid};},computedListeners:function computedListeners(){return _objectSpread2$3(_objectSpread2$3({},this.bvListeners),{},{input:this.onInput,change:this.onChange,blur:this.onBlur});}},watch:{localValue:function localValue(){this.setHeight();}},mounted:function mounted(){this.setHeight();},methods:{// Called by intersection observer directive\n/* istanbul ignore next */visibleCallback:function visibleCallback(visible){if(visible){// We use a `$nextTick()` here just to make sure any\n// transitions or portalling have completed\nthis.$nextTick(this.setHeight);}},setHeight:function setHeight(){var _this=this;this.$nextTick(function(){requestAF(function(){_this.heightInPx=_this.computeHeight();});});},/* istanbul ignore next: can't test getComputedStyle in JSDOM */computeHeight:function computeHeight(){if(this.$isServer||!isNull(this.computedRows)){return null;}var el=this.$el;// Element must be visible (not hidden) and in document\n// Must be checked after above checks\nif(!isVisible(el)){return null;}// Get current computed styles\nvar computedStyle=getCS(el);// Height of one line of text in px\nvar lineHeight=toFloat(computedStyle.lineHeight,1);// Calculate height of border and padding\nvar border=toFloat(computedStyle.borderTopWidth,0)+toFloat(computedStyle.borderBottomWidth,0);var padding=toFloat(computedStyle.paddingTop,0)+toFloat(computedStyle.paddingBottom,0);// Calculate offset\nvar offset=border+padding;// Minimum height for min rows (which must be 2 rows or greater for cross-browser support)\nvar minHeight=lineHeight*this.computedMinRows+offset;// Get the current style height (with `px` units)\nvar oldHeight=getStyle(el,'height')||computedStyle.height;// Probe scrollHeight by temporarily changing the height to `auto`\nsetStyle(el,'height','auto');var scrollHeight=el.scrollHeight;// Place the original old height back on the element, just in case `computedProp`\n// returns the same value as before\nsetStyle(el,'height',oldHeight);// Calculate content height in 'rows' (scrollHeight includes padding but not border)\nvar contentRows=mathMax((scrollHeight-padding)/lineHeight,2);// Calculate number of rows to display (limited within min/max rows)\nvar rows=mathMin(mathMax(contentRows,this.computedMinRows),this.computedMaxRows);// Calculate the required height of the textarea including border and padding (in pixels)\nvar height=mathMax(mathCeil(rows*lineHeight+offset),minHeight);// Computed height remains the larger of `oldHeight` and new `height`,\n// when height is in `sticky` mode (prop `no-auto-shrink` is true)\nif(this.noAutoShrink&&toFloat(oldHeight,0)>height){return oldHeight;}// Return the new computed CSS height in px units\nreturn\"\".concat(height,\"px\");}},render:function render(h){return h('textarea',{class:this.computedClass,style:this.computedStyle,directives:[{name:'b-visible',value:this.visibleCallback,// If textarea is within 640px of viewport, consider it visible\nmodifiers:{'640':true}}],attrs:this.computedAttrs,domProps:{value:this.localValue},on:this.computedListeners,ref:'input'});}});var FormTextareaPlugin=/*#__PURE__*/pluginFactory({components:{BFormTextarea:BFormTextarea,BTextarea:BFormTextarea}});var _watch$8;var _makeModelMixin$7=makeModelMixin('value',{type:PROP_TYPE_STRING,defaultValue:''}),modelMixin$7=_makeModelMixin$7.mixin,modelProps$7=_makeModelMixin$7.props,MODEL_PROP_NAME$7=_makeModelMixin$7.prop,MODEL_EVENT_NAME$7=_makeModelMixin$7.event;var NUMERIC='numeric';// --- Helper methods ---\nvar padLeftZeros=function padLeftZeros(value){return\"00\".concat(value||'').slice(-2);};var parseHMS=function parseHMS(value){value=toString(value);var hh=null,mm=null,ss=null;if(RX_TIME.test(value)){var _value$split$map=value.split(':').map(function(v){return toInteger(v,null);});var _value$split$map2=_slicedToArray(_value$split$map,3);hh=_value$split$map2[0];mm=_value$split$map2[1];ss=_value$split$map2[2];}return{hours:isUndefinedOrNull(hh)?null:hh,minutes:isUndefinedOrNull(mm)?null:mm,seconds:isUndefinedOrNull(ss)?null:ss,ampm:isUndefinedOrNull(hh)||hh<12?0:1};};var formatHMS=function formatHMS(_ref){var hours=_ref.hours,minutes=_ref.minutes,seconds=_ref.seconds;var requireSeconds=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(isNull(hours)||isNull(minutes)||requireSeconds&&isNull(seconds)){return'';}var hms=[hours,minutes,requireSeconds?seconds:0];return hms.map(padLeftZeros).join(':');};// --- Props ---\nvar props$18=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),modelProps$7),pick$1(props$1c,['labelIncrement','labelDecrement'])),{},{// ID of label element\nariaLabelledby:makeProp(PROP_TYPE_STRING),disabled:makeProp(PROP_TYPE_BOOLEAN,false),footerTag:makeProp(PROP_TYPE_STRING,'footer'),headerTag:makeProp(PROP_TYPE_STRING,'header'),hidden:makeProp(PROP_TYPE_BOOLEAN,false),hideHeader:makeProp(PROP_TYPE_BOOLEAN,false),// Explicitly force 12 or 24 hour time\n// Default is to use resolved locale for 12/24 hour display\n// Tri-state: `true` = 12, `false` = 24, `null` = auto\nhour12:makeProp(PROP_TYPE_BOOLEAN,null),labelAm:makeProp(PROP_TYPE_STRING,'AM'),labelAmpm:makeProp(PROP_TYPE_STRING,'AM/PM'),labelHours:makeProp(PROP_TYPE_STRING,'Hours'),labelMinutes:makeProp(PROP_TYPE_STRING,'Minutes'),labelNoTimeSelected:makeProp(PROP_TYPE_STRING,'No time selected'),labelPm:makeProp(PROP_TYPE_STRING,'PM'),labelSeconds:makeProp(PROP_TYPE_STRING,'Seconds'),labelSelected:makeProp(PROP_TYPE_STRING,'Selected time'),locale:makeProp(PROP_TYPE_ARRAY_STRING),minutesStep:makeProp(PROP_TYPE_NUMBER_STRING,1),readonly:makeProp(PROP_TYPE_BOOLEAN,false),secondsStep:makeProp(PROP_TYPE_NUMBER_STRING,1),// If `true`, show the second spinbutton\nshowSeconds:makeProp(PROP_TYPE_BOOLEAN,false)})),NAME_TIME);// --- Main component ---\n// @vue/component\nvar BTime=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TIME,mixins:[idMixin,modelMixin$7,normalizeSlotMixin],props:props$18,data:function data(){var parsed=parseHMS(this[MODEL_PROP_NAME$7]||'');return{// Spin button models\nmodelHours:parsed.hours,modelMinutes:parsed.minutes,modelSeconds:parsed.seconds,modelAmpm:parsed.ampm,// Internal flag to enable aria-live regions\nisLive:false};},computed:{computedHMS:function computedHMS(){var hours=this.modelHours;var minutes=this.modelMinutes;var seconds=this.modelSeconds;return formatHMS({hours:hours,minutes:minutes,seconds:seconds},this.showSeconds);},resolvedOptions:function resolvedOptions(){// Resolved locale options\nvar locale=concat(this.locale).filter(identity);var options={hour:NUMERIC,minute:NUMERIC,second:NUMERIC};if(!isUndefinedOrNull(this.hour12)){// Force 12 or 24 hour clock\noptions.hour12=!!this.hour12;}var dtf=new Intl.DateTimeFormat(locale,options);var resolved=dtf.resolvedOptions();var hour12=resolved.hour12||false;// IE 11 doesn't resolve the hourCycle, so we make\n// an assumption and fall back to common values\nvar hourCycle=resolved.hourCycle||(hour12?'h12':'h23');return{locale:resolved.locale,hour12:hour12,hourCycle:hourCycle};},computedLocale:function computedLocale(){return this.resolvedOptions.locale;},computedLang:function computedLang(){return(this.computedLocale||'').replace(/-u-.*$/,'');},computedRTL:function computedRTL(){return isLocaleRTL(this.computedLang);},computedHourCycle:function computedHourCycle(){// h11, h12, h23, or h24\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Locale/hourCycle\n// h12 - Hour system using 112. Corresponds to 'h' in patterns. The 12 hour clock, with midnight starting at 12:00 am\n// h23 - Hour system using 023. Corresponds to 'H' in patterns. The 24 hour clock, with midnight starting at 0:00\n// h11 - Hour system using 011. Corresponds to 'K' in patterns. The 12 hour clock, with midnight starting at 0:00 am\n// h24 - Hour system using 124. Corresponds to 'k' in pattern. The 24 hour clock, with midnight starting at 24:00\n// For h12 or h24, we visually format 00 hours as 12\nreturn this.resolvedOptions.hourCycle;},is12Hour:function is12Hour(){return!!this.resolvedOptions.hour12;},context:function context(){return{locale:this.computedLocale,isRTL:this.computedRTL,hourCycle:this.computedHourCycle,hour12:this.is12Hour,hours:this.modelHours,minutes:this.modelMinutes,seconds:this.showSeconds?this.modelSeconds:0,value:this.computedHMS,formatted:this.formattedTimeString};},valueId:function valueId(){return this.safeId()||null;},computedAriaLabelledby:function computedAriaLabelledby(){return[this.ariaLabelledby,this.valueId].filter(identity).join(' ')||null;},timeFormatter:function timeFormatter(){// Returns a formatter function reference\n// The formatter converts the time to a localized string\nvar options={hour12:this.is12Hour,hourCycle:this.computedHourCycle,hour:NUMERIC,minute:NUMERIC,timeZone:'UTC'};if(this.showSeconds){options.second=NUMERIC;}// Formats the time as a localized string\nreturn createDateFormatter(this.computedLocale,options);},numberFormatter:function numberFormatter(){// Returns a formatter function reference\n// The formatter always formats as 2 digits and is localized\nvar nf=new Intl.NumberFormat(this.computedLocale,{style:'decimal',minimumIntegerDigits:2,minimumFractionDigits:0,maximumFractionDigits:0,notation:'standard'});return nf.format;},formattedTimeString:function formattedTimeString(){var hours=this.modelHours;var minutes=this.modelMinutes;var seconds=this.showSeconds?this.modelSeconds||0:0;if(this.computedHMS){return this.timeFormatter(createDate(Date.UTC(0,0,1,hours,minutes,seconds)));}return this.labelNoTimeSelected||' ';},spinScopedSlots:function spinScopedSlots(){var h=this.$createElement;return{increment:function increment(_ref2){var hasFocus=_ref2.hasFocus;return h(BIconChevronUp,{props:{scale:hasFocus?1.5:1.25},attrs:{'aria-hidden':'true'}});},decrement:function decrement(_ref3){var hasFocus=_ref3.hasFocus;return h(BIconChevronUp,{props:{flipV:true,scale:hasFocus?1.5:1.25},attrs:{'aria-hidden':'true'}});}};}},watch:(_watch$8={},_defineProperty(_watch$8,MODEL_PROP_NAME$7,function(newValue,oldValue){if(newValue!==oldValue&&!looseEqual(parseHMS(newValue),parseHMS(this.computedHMS))){var _parseHMS=parseHMS(newValue),hours=_parseHMS.hours,minutes=_parseHMS.minutes,seconds=_parseHMS.seconds,ampm=_parseHMS.ampm;this.modelHours=hours;this.modelMinutes=minutes;this.modelSeconds=seconds;this.modelAmpm=ampm;}}),_defineProperty(_watch$8,\"computedHMS\",function computedHMS(newValue,oldValue){if(newValue!==oldValue){this.$emit(MODEL_EVENT_NAME$7,newValue);}}),_defineProperty(_watch$8,\"context\",function context(newValue,oldValue){if(!looseEqual(newValue,oldValue)){this.$emit(EVENT_NAME_CONTEXT,newValue);}}),_defineProperty(_watch$8,\"modelAmpm\",function modelAmpm(newValue,oldValue){var _this=this;if(newValue!==oldValue){var hours=isNull(this.modelHours)?0:this.modelHours;this.$nextTick(function(){if(newValue===0&&hours>11){// Switched to AM\n_this.modelHours=hours-12;}else if(newValue===1&&hours<12){// Switched to PM\n_this.modelHours=hours+12;}});}}),_defineProperty(_watch$8,\"modelHours\",function modelHours(newHours,oldHours){if(newHours!==oldHours){this.modelAmpm=newHours>11?1:0;}}),_watch$8),created:function created(){var _this2=this;this.$nextTick(function(){_this2.$emit(EVENT_NAME_CONTEXT,_this2.context);});},mounted:function mounted(){this.setLive(true);},/* istanbul ignore next */activated:function activated(){this.setLive(true);},/* istanbul ignore next */deactivated:function deactivated(){this.setLive(false);},beforeDestroy:function beforeDestroy(){this.setLive(false);},methods:{// Public methods\nfocus:function focus(){if(!this.disabled){// We focus the first spin button\nattemptFocus(this.$refs.spinners[0]);}},blur:function blur(){if(!this.disabled){var activeElement=getActiveElement();if(contains(this.$el,activeElement)){attemptBlur(activeElement);}}},// Formatters for the spin buttons\nformatHours:function formatHours(hh){var hourCycle=this.computedHourCycle;// We always store 0-23, but format based on h11/h12/h23/h24 formats\nhh=this.is12Hour&&hh>12?hh-12:hh;// Determine how 00:00 and 12:00 are shown\nhh=hh===0&&hourCycle==='h12'?12:hh===0&&hourCycle==='h24'?/* istanbul ignore next */24:hh===12&&hourCycle==='h11'?/* istanbul ignore next */0:hh;return this.numberFormatter(hh);},formatMinutes:function formatMinutes(mm){return this.numberFormatter(mm);},formatSeconds:function formatSeconds(ss){return this.numberFormatter(ss);},formatAmpm:function formatAmpm(ampm){// These should come from label props???\n// `ampm` should always be a value of `0` or `1`\nreturn ampm===0?this.labelAm:ampm===1?this.labelPm:'';},// Spinbutton on change handlers\nsetHours:function setHours(value){this.modelHours=value;},setMinutes:function setMinutes(value){this.modelMinutes=value;},setSeconds:function setSeconds(value){this.modelSeconds=value;},setAmpm:function setAmpm(value){this.modelAmpm=value;},onSpinLeftRight:function onSpinLeftRight(){var event=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var type=event.type,keyCode=event.keyCode;if(!this.disabled&&type==='keydown'&&(keyCode===CODE_LEFT||keyCode===CODE_RIGHT)){stopEvent(event);var spinners=this.$refs.spinners||[];var index=spinners.map(function(cmp){return!!cmp.hasFocus;}).indexOf(true);index=index+(keyCode===CODE_LEFT?-1:1);index=index>=spinners.length?0:index<0?spinners.length-1:index;attemptFocus(spinners[index]);}},setLive:function setLive(on){var _this3=this;if(on){this.$nextTick(function(){requestAF(function(){_this3.isLive=true;});});}else{this.isLive=false;}}},render:function render(h){var _this4=this;// If hidden, we just render a placeholder comment\n/* istanbul ignore if */if(this.hidden){return h();}var disabled=this.disabled,readonly=this.readonly,locale=this.computedLocale,ariaLabelledby=this.computedAriaLabelledby,labelIncrement=this.labelIncrement,labelDecrement=this.labelDecrement,valueId=this.valueId,focusHandler=this.focus;var spinIds=[];// Helper method to render a spinbutton\nvar makeSpinbutton=function makeSpinbutton(handler,key,classes){var spinbuttonProps=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};var id=_this4.safeId(\"_spinbutton_\".concat(key,\"_\"))||null;spinIds.push(id);return h(BFormSpinbutton,{class:classes,props:_objectSpread2$3({id:id,placeholder:'--',vertical:true,required:true,disabled:disabled,readonly:readonly,locale:locale,labelIncrement:labelIncrement,labelDecrement:labelDecrement,wrap:true,ariaControls:valueId,min:0},spinbuttonProps),scopedSlots:_this4.spinScopedSlots,on:{// We use `change` event to minimize SR verbosity\n// As the spinbutton will announce each value change\n// and we don't want the formatted time to be announced\n// on each value input if repeat is happening\nchange:handler},key:key,ref:'spinners',refInFor:true});};// Helper method to return a \"colon\" separator\nvar makeColon=function makeColon(){return h('div',{staticClass:'d-flex flex-column',class:{'text-muted':disabled||readonly},attrs:{'aria-hidden':'true'}},[h(BIconCircleFill,{props:{shiftV:4,scale:0.5}}),h(BIconCircleFill,{props:{shiftV:-4,scale:0.5}})]);};var $spinners=[];// Hours\n$spinners.push(makeSpinbutton(this.setHours,'hours','b-time-hours',{value:this.modelHours,max:23,step:1,formatterFn:this.formatHours,ariaLabel:this.labelHours}));// Spacer\n$spinners.push(makeColon());// Minutes\n$spinners.push(makeSpinbutton(this.setMinutes,'minutes','b-time-minutes',{value:this.modelMinutes,max:59,step:this.minutesStep||1,formatterFn:this.formatMinutes,ariaLabel:this.labelMinutes}));if(this.showSeconds){// Spacer\n$spinners.push(makeColon());// Seconds\n$spinners.push(makeSpinbutton(this.setSeconds,'seconds','b-time-seconds',{value:this.modelSeconds,max:59,step:this.secondsStep||1,formatterFn:this.formatSeconds,ariaLabel:this.labelSeconds}));}// AM/PM ?\nif(this.is12Hour){// TODO:\n//   If locale is RTL, unshift this instead of push?\n//   And switch class `ml-2` to `mr-2`\n//   Note some LTR locales (i.e. zh) also place AM/PM to the left\n$spinners.push(makeSpinbutton(this.setAmpm,'ampm','b-time-ampm',{value:this.modelAmpm,max:1,formatterFn:this.formatAmpm,ariaLabel:this.labelAmpm,// We set `required` as `false`, since this always has a value\nrequired:false}));}// Assemble spinners\n$spinners=h('div',{staticClass:'d-flex align-items-center justify-content-center mx-auto',attrs:{role:'group',tabindex:disabled||readonly?null:'-1','aria-labelledby':ariaLabelledby},on:{keydown:this.onSpinLeftRight,click:/* istanbul ignore next */function click(event){if(event.target===event.currentTarget){focusHandler();}}}},$spinners);// Selected type display\nvar $value=h('output',{staticClass:'form-control form-control-sm text-center',class:{disabled:disabled||readonly},attrs:{id:valueId,role:'status',for:spinIds.filter(identity).join(' ')||null,tabindex:disabled?null:'-1','aria-live':this.isLive?'polite':'off','aria-atomic':'true'},on:{// Transfer focus/click to focus hours spinner\nclick:focusHandler,focus:focusHandler}},[h('bdi',this.formattedTimeString),this.computedHMS?h('span',{staticClass:'sr-only'},\" (\".concat(this.labelSelected,\") \")):'']);var $header=h(this.headerTag,{staticClass:'b-time-header',class:{'sr-only':this.hideHeader}},[$value]);var $content=this.normalizeSlot();var $footer=$content?h(this.footerTag,{staticClass:'b-time-footer'},$content):h();return h('div',{staticClass:'b-time d-inline-flex flex-column text-center',attrs:{role:'group',lang:this.computedLang||null,'aria-labelledby':ariaLabelledby||null,'aria-disabled':disabled?'true':null,'aria-readonly':readonly&&!disabled?'true':null}},[$header,$spinners,$footer]);}});var _watch$7;var _makeModelMixin$6=makeModelMixin('value',{type:PROP_TYPE_STRING,defaultValue:''}),modelMixin$6=_makeModelMixin$6.mixin,modelProps$6=_makeModelMixin$6.props,MODEL_PROP_NAME$6=_makeModelMixin$6.prop,MODEL_EVENT_NAME$6=_makeModelMixin$6.event;// --- Props ---\nvar timeProps=omit(props$18,['hidden','id','value']);var formBtnLabelControlProps=omit(props$1o,['formattedValue','id','lang','rtl','value']);var props$17=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),modelProps$6),timeProps),formBtnLabelControlProps),{},{closeButtonVariant:makeProp(PROP_TYPE_STRING,'outline-secondary'),labelCloseButton:makeProp(PROP_TYPE_STRING,'Close'),labelNowButton:makeProp(PROP_TYPE_STRING,'Select now'),labelResetButton:makeProp(PROP_TYPE_STRING,'Reset'),noCloseButton:makeProp(PROP_TYPE_BOOLEAN,false),nowButton:makeProp(PROP_TYPE_BOOLEAN,false),nowButtonVariant:makeProp(PROP_TYPE_STRING,'outline-primary'),resetButton:makeProp(PROP_TYPE_BOOLEAN,false),resetButtonVariant:makeProp(PROP_TYPE_STRING,'outline-danger'),resetValue:makeProp(PROP_TYPE_DATE_STRING)})),NAME_FORM_TIMEPICKER);// --- Main component ---\n// @vue/component\nvar BFormTimepicker=/*#__PURE__*/Vue__default['default'].extend({name:NAME_FORM_TIMEPICKER,mixins:[idMixin,modelMixin$6],props:props$17,data:function data(){return{// We always use `HH:mm:ss` value internally\nlocalHMS:this[MODEL_PROP_NAME$6]||'',// Context data from BTime\nlocalLocale:null,isRTL:false,formattedValue:'',// If the menu is opened\nisVisible:false};},computed:{computedLang:function computedLang(){return(this.localLocale||'').replace(/-u-.*$/i,'')||null;}},watch:(_watch$7={},_defineProperty(_watch$7,MODEL_PROP_NAME$6,function(newValue){this.localHMS=newValue||'';}),_defineProperty(_watch$7,\"localHMS\",function localHMS(newValue){// We only update the v-model value when the timepicker\n// is open, to prevent cursor jumps when bound to a\n// text input in button only mode\nif(this.isVisible){this.$emit(MODEL_EVENT_NAME$6,newValue||'');}}),_watch$7),methods:{// Public methods\nfocus:function focus(){if(!this.disabled){attemptFocus(this.$refs.control);}},blur:function blur(){if(!this.disabled){attemptBlur(this.$refs.control);}},// Private methods\nsetAndClose:function setAndClose(value){var _this=this;this.localHMS=value;this.$nextTick(function(){_this.$refs.control.hide(true);});},onInput:function onInput(hms){if(this.localHMS!==hms){this.localHMS=hms;}},onContext:function onContext(ctx){var isRTL=ctx.isRTL,locale=ctx.locale,value=ctx.value,formatted=ctx.formatted;this.isRTL=isRTL;this.localLocale=locale;this.formattedValue=formatted;this.localHMS=value||'';// Re-emit the context event\nthis.$emit(EVENT_NAME_CONTEXT,ctx);},onNowButton:function onNowButton(){var now=new Date();var hours=now.getHours();var minutes=now.getMinutes();var seconds=this.showSeconds?now.getSeconds():0;var value=[hours,minutes,seconds].map(function(v){return\"00\".concat(v||'').slice(-2);}).join(':');this.setAndClose(value);},onResetButton:function onResetButton(){this.setAndClose(this.resetValue);},onCloseButton:function onCloseButton(){this.$refs.control.hide(true);},onShow:function onShow(){this.isVisible=true;},onShown:function onShown(){var _this2=this;this.$nextTick(function(){attemptFocus(_this2.$refs.time);_this2.$emit(EVENT_NAME_SHOWN);});},onHidden:function onHidden(){this.isVisible=false;this.$emit(EVENT_NAME_HIDDEN);},// Render function helpers\ndefaultButtonFn:function defaultButtonFn(_ref){var isHovered=_ref.isHovered,hasFocus=_ref.hasFocus;return this.$createElement(isHovered||hasFocus?BIconClockFill:BIconClock,{attrs:{'aria-hidden':'true'}});}},render:function render(h){var localHMS=this.localHMS,disabled=this.disabled,readonly=this.readonly,$props=this.$props;var placeholder=isUndefinedOrNull(this.placeholder)?this.labelNoTimeSelected:this.placeholder;// Footer buttons\nvar $footer=[];if(this.nowButton){var label=this.labelNowButton;$footer.push(h(BButton,{props:{size:'sm',disabled:disabled||readonly,variant:this.nowButtonVariant},attrs:{'aria-label':label||null},on:{click:this.onNowButton},key:'now-btn'},label));}if(this.resetButton){if($footer.length>0){// Add a \"spacer\" between buttons ('&nbsp;')\n$footer.push(h('span',\"\\xA0\"));}var _label=this.labelResetButton;$footer.push(h(BButton,{props:{size:'sm',disabled:disabled||readonly,variant:this.resetButtonVariant},attrs:{'aria-label':_label||null},on:{click:this.onResetButton},key:'reset-btn'},_label));}if(!this.noCloseButton){// Add a \"spacer\" between buttons ('&nbsp;')\nif($footer.length>0){$footer.push(h('span',\"\\xA0\"));}var _label2=this.labelCloseButton;$footer.push(h(BButton,{props:{size:'sm',disabled:disabled,variant:this.closeButtonVariant},attrs:{'aria-label':_label2||null},on:{click:this.onCloseButton},key:'close-btn'},_label2));}if($footer.length>0){$footer=[h('div',{staticClass:'b-form-date-controls d-flex flex-wrap',class:{'justify-content-between':$footer.length>1,'justify-content-end':$footer.length<2}},$footer)];}var $time=h(BTime,{staticClass:'b-form-time-control',props:_objectSpread2$3(_objectSpread2$3({},pluckProps(timeProps,$props)),{},{value:localHMS,hidden:!this.isVisible}),on:{input:this.onInput,context:this.onContext},ref:'time'},$footer);return h(BVFormBtnLabelControl,{staticClass:'b-form-timepicker',props:_objectSpread2$3(_objectSpread2$3({},pluckProps(formBtnLabelControlProps,$props)),{},{id:this.safeId(),value:localHMS,formattedValue:localHMS?this.formattedValue:'',placeholder:placeholder,rtl:this.isRTL,lang:this.computedLang}),on:{show:this.onShow,shown:this.onShown,hidden:this.onHidden},scopedSlots:_defineProperty({},SLOT_NAME_BUTTON_CONTENT,this.$scopedSlots[SLOT_NAME_BUTTON_CONTENT]||this.defaultButtonFn),ref:'control'},[$time]);}});var FormTimepickerPlugin=/*#__PURE__*/pluginFactory({components:{BFormTimepicker:BFormTimepicker,BTimepicker:BFormTimepicker}});var ImagePlugin=/*#__PURE__*/pluginFactory({components:{BImg:BImg,BImgLazy:BImgLazy}});var props$16=makePropsConfigurable({tag:makeProp(PROP_TYPE_STRING,'div')},NAME_INPUT_GROUP_TEXT);// --- Main component ---\n// @vue/component\nvar BInputGroupText=/*#__PURE__*/Vue__default['default'].extend({name:NAME_INPUT_GROUP_TEXT,functional:true,props:props$16,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,a(data,{staticClass:'input-group-text'}),children);}});var props$15=makePropsConfigurable({append:makeProp(PROP_TYPE_BOOLEAN,false),id:makeProp(PROP_TYPE_STRING),isText:makeProp(PROP_TYPE_BOOLEAN,false),tag:makeProp(PROP_TYPE_STRING,'div')},NAME_INPUT_GROUP_ADDON);// --- Main component ---\n// @vue/component\nvar BInputGroupAddon=/*#__PURE__*/Vue__default['default'].extend({name:NAME_INPUT_GROUP_ADDON,functional:true,props:props$15,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var append=props.append;return h(props.tag,a(data,{class:{'input-group-append':append,'input-group-prepend':!append},attrs:{id:props.id}}),props.isText?[h(BInputGroupText,children)]:children);}});var props$14=makePropsConfigurable(omit(props$15,['append']),NAME_INPUT_GROUP_APPEND);// --- Main component ---\n// @vue/component\nvar BInputGroupAppend=/*#__PURE__*/Vue__default['default'].extend({name:NAME_INPUT_GROUP_APPEND,functional:true,props:props$14,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;// Pass all our data down to child, and set `append` to `true`\nreturn h(BInputGroupAddon,a(data,{props:_objectSpread2$3(_objectSpread2$3({},props),{},{append:true})}),children);}});var props$13=makePropsConfigurable(omit(props$15,['append']),NAME_INPUT_GROUP_PREPEND);// --- Main component ---\n// @vue/component\nvar BInputGroupPrepend=/*#__PURE__*/Vue__default['default'].extend({name:NAME_INPUT_GROUP_PREPEND,functional:true,props:props$13,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;// Pass all our data down to child, and set `append` to `true`\nreturn h(BInputGroupAddon,a(data,{props:_objectSpread2$3(_objectSpread2$3({},props),{},{append:false})}),children);}});var props$12=makePropsConfigurable({append:makeProp(PROP_TYPE_STRING),appendHtml:makeProp(PROP_TYPE_STRING),id:makeProp(PROP_TYPE_STRING),prepend:makeProp(PROP_TYPE_STRING),prependHtml:makeProp(PROP_TYPE_STRING),size:makeProp(PROP_TYPE_STRING),tag:makeProp(PROP_TYPE_STRING,'div')},NAME_INPUT_GROUP);// --- Main component ---\n// @vue/component\nvar BInputGroup=/*#__PURE__*/Vue__default['default'].extend({name:NAME_INPUT_GROUP,functional:true,props:props$12,render:function render(h,_ref){var props=_ref.props,data=_ref.data,slots=_ref.slots,scopedSlots=_ref.scopedSlots;var prepend=props.prepend,prependHtml=props.prependHtml,append=props.append,appendHtml=props.appendHtml,size=props.size;var $scopedSlots=scopedSlots||{};var $slots=slots();var slotScope={};var $prepend=h();var hasPrependSlot=hasNormalizedSlot(SLOT_NAME_PREPEND,$scopedSlots,$slots);if(hasPrependSlot||prepend||prependHtml){$prepend=h(BInputGroupPrepend,[hasPrependSlot?normalizeSlot(SLOT_NAME_PREPEND,slotScope,$scopedSlots,$slots):h(BInputGroupText,{domProps:htmlOrText(prependHtml,prepend)})]);}var $append=h();var hasAppendSlot=hasNormalizedSlot(SLOT_NAME_APPEND,$scopedSlots,$slots);if(hasAppendSlot||append||appendHtml){$append=h(BInputGroupAppend,[hasAppendSlot?normalizeSlot(SLOT_NAME_APPEND,slotScope,$scopedSlots,$slots):h(BInputGroupText,{domProps:htmlOrText(appendHtml,append)})]);}return h(props.tag,a(data,{staticClass:'input-group',class:_defineProperty({},\"input-group-\".concat(size),size),attrs:{id:props.id||null,role:'group'}}),[$prepend,normalizeSlot(SLOT_NAME_DEFAULT,slotScope,$scopedSlots,$slots),$append]);}});var InputGroupPlugin=/*#__PURE__*/pluginFactory({components:{BInputGroup:BInputGroup,BInputGroupAddon:BInputGroupAddon,BInputGroupPrepend:BInputGroupPrepend,BInputGroupAppend:BInputGroupAppend,BInputGroupText:BInputGroupText}});var props$11=makePropsConfigurable({// String breakpoint name new in Bootstrap v4.4.x\nfluid:makeProp(PROP_TYPE_BOOLEAN_STRING,false),tag:makeProp(PROP_TYPE_STRING,'div')},NAME_CONTAINER);// --- Main component ---\n// @vue/component\nvar BContainer=/*#__PURE__*/Vue__default['default'].extend({name:NAME_CONTAINER,functional:true,props:props$11,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var fluid=props.fluid;return h(props.tag,a(data,{class:_defineProperty({container:!(fluid||fluid===''),'container-fluid':fluid===true||fluid===''},\"container-\".concat(fluid),fluid&&fluid!==true)}),children);}});var props$10=makePropsConfigurable({bgVariant:makeProp(PROP_TYPE_STRING),borderVariant:makeProp(PROP_TYPE_STRING),containerFluid:makeProp(PROP_TYPE_BOOLEAN_STRING,false),fluid:makeProp(PROP_TYPE_BOOLEAN,false),header:makeProp(PROP_TYPE_STRING),headerHtml:makeProp(PROP_TYPE_STRING),headerLevel:makeProp(PROP_TYPE_NUMBER_STRING,3),headerTag:makeProp(PROP_TYPE_STRING,'h1'),lead:makeProp(PROP_TYPE_STRING),leadHtml:makeProp(PROP_TYPE_STRING),leadTag:makeProp(PROP_TYPE_STRING,'p'),tag:makeProp(PROP_TYPE_STRING,'div'),textVariant:makeProp(PROP_TYPE_STRING)},NAME_JUMBOTRON);// --- Main component ---\n// @vue/component\nvar BJumbotron=/*#__PURE__*/Vue__default['default'].extend({name:NAME_JUMBOTRON,functional:true,props:props$10,render:function render(h,_ref){var _class2;var props=_ref.props,data=_ref.data,slots=_ref.slots,scopedSlots=_ref.scopedSlots;var header=props.header,headerHtml=props.headerHtml,lead=props.lead,leadHtml=props.leadHtml,textVariant=props.textVariant,bgVariant=props.bgVariant,borderVariant=props.borderVariant;var $scopedSlots=scopedSlots||{};var $slots=slots();var slotScope={};var $header=h();var hasHeaderSlot=hasNormalizedSlot(SLOT_NAME_HEADER,$scopedSlots,$slots);if(hasHeaderSlot||header||headerHtml){var headerLevel=props.headerLevel;$header=h(props.headerTag,{class:_defineProperty({},\"display-\".concat(headerLevel),headerLevel),domProps:hasHeaderSlot?{}:htmlOrText(headerHtml,header)},normalizeSlot(SLOT_NAME_HEADER,slotScope,$scopedSlots,$slots));}var $lead=h();var hasLeadSlot=hasNormalizedSlot(SLOT_NAME_LEAD,$scopedSlots,$slots);if(hasLeadSlot||lead||leadHtml){$lead=h(props.leadTag,{staticClass:'lead',domProps:hasLeadSlot?{}:htmlOrText(leadHtml,lead)},normalizeSlot(SLOT_NAME_LEAD,slotScope,$scopedSlots,$slots));}var $children=[$header,$lead,normalizeSlot(SLOT_NAME_DEFAULT,slotScope,$scopedSlots,$slots)];// If fluid, wrap content in a container\nif(props.fluid){$children=[h(BContainer,{props:{fluid:props.containerFluid}},$children)];}return h(props.tag,a(data,{staticClass:'jumbotron',class:(_class2={'jumbotron-fluid':props.fluid},_defineProperty(_class2,\"text-\".concat(textVariant),textVariant),_defineProperty(_class2,\"bg-\".concat(bgVariant),bgVariant),_defineProperty(_class2,\"border-\".concat(borderVariant),borderVariant),_defineProperty(_class2,\"border\",borderVariant),_class2)}),$children);}});var JumbotronPlugin=/*#__PURE__*/pluginFactory({components:{BJumbotron:BJumbotron}});var COMMON_ALIGNMENT=['start','end','center'];// --- Helper methods ---\n// Compute a `row-cols-{breakpoint}-{cols}` class name\n// Memoized function for better performance on generating class names\nvar computeRowColsClass=memoize(function(breakpoint,cols){cols=trim(toString(cols));return cols?lowerCase(['row-cols',breakpoint,cols].filter(identity).join('-')):null;});// Get the breakpoint name from the `rowCols` prop name\n// Memoized function for better performance on extracting breakpoint names\nvar computeRowColsBreakpoint=memoize(function(prop){return lowerCase(prop.replace('cols',''));});// Cached copy of the `row-cols` breakpoint prop names\n// Will be populated when the props are generated\nvar rowColsPropList=[];// --- Props ---\n// Prop generator for lazy generation of props\nvar generateProps=function generateProps(){// i.e. 'row-cols-2', 'row-cols-md-4', 'row-cols-xl-6', ...\nvar rowColsProps=getBreakpointsUpCached().reduce(function(props,breakpoint){props[suffixPropName(breakpoint,'cols')]=makeProp(PROP_TYPE_NUMBER_STRING);return props;},create(null));// Cache the row-cols prop names\nrowColsPropList=keys(rowColsProps);// Return the generated props\nreturn makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},rowColsProps),{},{alignContent:makeProp(PROP_TYPE_STRING,null,function(value){return arrayIncludes(concat(COMMON_ALIGNMENT,'between','around','stretch'),value);}),alignH:makeProp(PROP_TYPE_STRING,null,function(value){return arrayIncludes(concat(COMMON_ALIGNMENT,'between','around'),value);}),alignV:makeProp(PROP_TYPE_STRING,null,function(value){return arrayIncludes(concat(COMMON_ALIGNMENT,'baseline','stretch'),value);}),noGutters:makeProp(PROP_TYPE_BOOLEAN,false),tag:makeProp(PROP_TYPE_STRING,'div')})),NAME_ROW);};// --- Main component ---\n// We do not use `Vue.extend()` here as that would evaluate the props\n// immediately, which we do not want to happen\n// @vue/component\nvar BRow={name:NAME_ROW,functional:true,get props(){// Allow props to be lazy evaled on first access and\n// then they become a non-getter afterwards\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#Smart_self-overwriting_lazy_getters\ndelete this.props;this.props=generateProps();return this.props;},render:function render(h,_ref){var _classList$push;var props=_ref.props,data=_ref.data,children=_ref.children;var alignV=props.alignV,alignH=props.alignH,alignContent=props.alignContent;// Loop through row-cols breakpoint props and generate the classes\nvar classList=[];rowColsPropList.forEach(function(prop){var c=computeRowColsClass(computeRowColsBreakpoint(prop),props[prop]);// If a class is returned, push it onto the array\nif(c){classList.push(c);}});classList.push((_classList$push={'no-gutters':props.noGutters},_defineProperty(_classList$push,\"align-items-\".concat(alignV),alignV),_defineProperty(_classList$push,\"justify-content-\".concat(alignH),alignH),_defineProperty(_classList$push,\"align-content-\".concat(alignContent),alignContent),_classList$push));return h(props.tag,a(data,{staticClass:'row',class:classList}),children);}};var LayoutPlugin=/*#__PURE__*/pluginFactory({components:{BContainer:BContainer,BRow:BRow,BCol:BCol,BFormRow:BFormRow}});var LinkPlugin=/*#__PURE__*/pluginFactory({components:{BLink:BLink}});var props$$=makePropsConfigurable({flush:makeProp(PROP_TYPE_BOOLEAN,false),horizontal:makeProp(PROP_TYPE_BOOLEAN_STRING,false),tag:makeProp(PROP_TYPE_STRING,'div')},NAME_LIST_GROUP);// --- Main component ---\n// @vue/component\nvar BListGroup=/*#__PURE__*/Vue__default['default'].extend({name:NAME_LIST_GROUP,functional:true,props:props$$,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var horizontal=props.horizontal===''?true:props.horizontal;horizontal=props.flush?false:horizontal;var componentData={staticClass:'list-group',class:_defineProperty({'list-group-flush':props.flush,'list-group-horizontal':horizontal===true},\"list-group-horizontal-\".concat(horizontal),isString(horizontal))};return h(props.tag,a(data,componentData),children);}});var actionTags=['a','router-link','button','b-link'];// --- Props ---\nvar linkProps$3=omit(props$2f,['event','routerTag']);delete linkProps$3.href.default;delete linkProps$3.to.default;var props$_=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},linkProps$3),{},{action:makeProp(PROP_TYPE_BOOLEAN,false),button:makeProp(PROP_TYPE_BOOLEAN,false),tag:makeProp(PROP_TYPE_STRING,'div'),variant:makeProp(PROP_TYPE_STRING)})),NAME_LIST_GROUP_ITEM);// --- Main component ---\n// @vue/component\nvar BListGroupItem=/*#__PURE__*/Vue__default['default'].extend({name:NAME_LIST_GROUP_ITEM,functional:true,props:props$_,render:function render(h,_ref){var _class;var props=_ref.props,data=_ref.data,children=_ref.children;var button=props.button,variant=props.variant,active=props.active,disabled=props.disabled;var link=isLink$1(props);var tag=button?'button':!link?props.tag:BLink;var action=!!(props.action||link||button||arrayIncludes(actionTags,props.tag));var attrs={};var itemProps={};if(isTag(tag,'button')){if(!data.attrs||!data.attrs.type){// Add a type for button is one not provided in passed attributes\nattrs.type='button';}if(props.disabled){// Set disabled attribute if button and disabled\nattrs.disabled=true;}}else{itemProps=pluckProps(linkProps$3,props);}return h(tag,a(data,{attrs:attrs,props:itemProps,staticClass:'list-group-item',class:(_class={},_defineProperty(_class,\"list-group-item-\".concat(variant),variant),_defineProperty(_class,'list-group-item-action',action),_defineProperty(_class,\"active\",active),_defineProperty(_class,\"disabled\",disabled),_class)}),children);}});var ListGroupPlugin=/*#__PURE__*/pluginFactory({components:{BListGroup:BListGroup,BListGroupItem:BListGroupItem}});var props$Z=makePropsConfigurable({right:makeProp(PROP_TYPE_BOOLEAN,false),tag:makeProp(PROP_TYPE_STRING,'div'),verticalAlign:makeProp(PROP_TYPE_STRING,'top')},NAME_MEDIA_ASIDE);// --- Main component ---\n// @vue/component\nvar BMediaAside=/*#__PURE__*/Vue__default['default'].extend({name:NAME_MEDIA_ASIDE,functional:true,props:props$Z,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var verticalAlign=props.verticalAlign;var align=verticalAlign==='top'?'start':verticalAlign==='bottom'?'end':/* istanbul ignore next */verticalAlign;return h(props.tag,a(data,{staticClass:'media-aside',class:_defineProperty({'media-aside-right':props.right},\"align-self-\".concat(align),align)}),children);}});var props$Y=makePropsConfigurable({tag:makeProp(PROP_TYPE_STRING,'div')},NAME_MEDIA_BODY);// --- Main component ---\n// @vue/component\nvar BMediaBody=/*#__PURE__*/Vue__default['default'].extend({name:NAME_MEDIA_BODY,functional:true,props:props$Y,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;return h(props.tag,a(data,{staticClass:'media-body'}),children);}});var props$X=makePropsConfigurable({noBody:makeProp(PROP_TYPE_BOOLEAN,false),rightAlign:makeProp(PROP_TYPE_BOOLEAN,false),tag:makeProp(PROP_TYPE_STRING,'div'),verticalAlign:makeProp(PROP_TYPE_STRING,'top')},NAME_MEDIA);// --- Main component ---\n// @vue/component\nvar BMedia=/*#__PURE__*/Vue__default['default'].extend({name:NAME_MEDIA,functional:true,props:props$X,render:function render(h,_ref){var props=_ref.props,data=_ref.data,slots=_ref.slots,scopedSlots=_ref.scopedSlots,children=_ref.children;var noBody=props.noBody,rightAlign=props.rightAlign,verticalAlign=props.verticalAlign;var $children=noBody?children:[];if(!noBody){var slotScope={};var $slots=slots();var $scopedSlots=scopedSlots||{};$children.push(h(BMediaBody,normalizeSlot(SLOT_NAME_DEFAULT,slotScope,$scopedSlots,$slots)));var $aside=normalizeSlot(SLOT_NAME_ASIDE,slotScope,$scopedSlots,$slots);if($aside){$children[rightAlign?'push':'unshift'](h(BMediaAside,{props:{right:rightAlign,verticalAlign:verticalAlign}},$aside));}}return h(props.tag,a(data,{staticClass:'media'}),$children);}});var MediaPlugin=/*#__PURE__*/pluginFactory({components:{BMedia:BMedia,BMediaAside:BMediaAside,BMediaBody:BMediaBody}});var PROP$1='$_documentListeners';// --- Mixin ---\n// @vue/component\nvar listenOnDocumentMixin=Vue__default['default'].extend({created:function created(){// Define non-reactive property\n// Object of arrays, keyed by event name,\n// where value is an array of callbacks\nthis[PROP$1]={};},beforeDestroy:function beforeDestroy(){var _this=this;// Unregister all registered listeners\nkeys(this[PROP$1]||{}).forEach(function(event){_this[PROP$1][event].forEach(function(callback){_this.listenOffDocument(event,callback);});});this[PROP$1]=null;},methods:{registerDocumentListener:function registerDocumentListener(event,callback){if(this[PROP$1]){this[PROP$1][event]=this[PROP$1][event]||[];if(!arrayIncludes(this[PROP$1][event],callback)){this[PROP$1][event].push(callback);}}},unregisterDocumentListener:function unregisterDocumentListener(event,callback){if(this[PROP$1]&&this[PROP$1][event]){this[PROP$1][event]=this[PROP$1][event].filter(function(cb){return cb!==callback;});}},listenDocument:function listenDocument(on,event,callback){on?this.listenOnDocument(event,callback):this.listenOffDocument(event,callback);},listenOnDocument:function listenOnDocument(event,callback){if(IS_BROWSER){eventOn(document,event,callback,EVENT_OPTIONS_NO_CAPTURE);this.registerDocumentListener(event,callback);}},listenOffDocument:function listenOffDocument(event,callback){if(IS_BROWSER){eventOff(document,event,callback,EVENT_OPTIONS_NO_CAPTURE);}this.unregisterDocumentListener(event,callback);}}});var PROP='$_windowListeners';// --- Mixin ---\n// @vue/component\nvar listenOnWindowMixin=Vue__default['default'].extend({created:function created(){// Define non-reactive property\n// Object of arrays, keyed by event name,\n// where value is an array of callbacks\nthis[PROP]={};},beforeDestroy:function beforeDestroy(){var _this=this;// Unregister all registered listeners\nkeys(this[PROP]||{}).forEach(function(event){_this[PROP][event].forEach(function(callback){_this.listenOffWindow(event,callback);});});this[PROP]=null;},methods:{registerWindowListener:function registerWindowListener(event,callback){if(this[PROP]){this[PROP][event]=this[PROP][event]||[];if(!arrayIncludes(this[PROP][event],callback)){this[PROP][event].push(callback);}}},unregisterWindowListener:function unregisterWindowListener(event,callback){if(this[PROP]&&this[PROP][event]){this[PROP][event]=this[PROP][event].filter(function(cb){return cb!==callback;});}},listenWindow:function listenWindow(on,event,callback){on?this.listenOnWindow(event,callback):this.listenOffWindow(event,callback);},listenOnWindow:function listenOnWindow(event,callback){if(IS_BROWSER){eventOn(window,event,callback,EVENT_OPTIONS_NO_CAPTURE);this.registerWindowListener(event,callback);}},listenOffWindow:function listenOffWindow(event,callback){if(IS_BROWSER){eventOff(window,event,callback,EVENT_OPTIONS_NO_CAPTURE);}this.unregisterWindowListener(event,callback);}}});// This method returns a component's scoped style attribute name: `data-v-xxxxxxx`\n// The `_scopeId` options property is added by vue-loader when using scoped styles\n// and will be `undefined` if no scoped styles are in use\nvar getScopeId=function getScopeId(vm){var defaultValue=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;return vm?vm.$options._scopeId||defaultValue:defaultValue;};var scopedStyleMixin=Vue__default['default'].extend({computed:{scopedStyleAttrs:function scopedStyleAttrs(){var scopeId=getScopeId(this.$parent);return scopeId?_defineProperty({},scopeId,''):{};}}});// BVTransporter/BVTransporterTarget:\n//\n// Single root node portaling of content, which retains parent/child hierarchy\n// Unlike Portal-Vue where portaled content is no longer a descendent of its\n// intended parent components\n//\n// Private components for use by Tooltips, Popovers and Modals\n//\n// Based on vue-simple-portal\n// https://github.com/LinusBorg/vue-simple-portal\n// Transporter target used by BVTransporter\n// Supports only a single root element\n// @vue/component\nvar BVTransporterTarget=/*#__PURE__*/Vue__default['default'].extend({// As an abstract component, it doesn't appear in the $parent chain of\n// components, which means the next parent of any component rendered inside\n// of this one will be the parent from which is was portal'd\nabstract:true,name:NAME_TRANSPORTER_TARGET,props:{// Even though we only support a single root element,\n// VNodes are always passed as an array\nnodes:makeProp(PROP_TYPE_ARRAY_FUNCTION)},data:function data(vm){return{updatedNodes:vm.nodes};},destroyed:function destroyed(){removeNode(this.$el);},render:function render(h){var updatedNodes=this.updatedNodes;var $nodes=isFunction$1(updatedNodes)?updatedNodes({}):updatedNodes;$nodes=concat($nodes).filter(identity);if($nodes&&$nodes.length>0&&!$nodes[0].text){return $nodes[0];}/* istanbul ignore next */return h();}});// --- Props ---\nvar props$W={// String: CSS selector,\n// HTMLElement: Element reference\n// Mainly needed for tooltips/popovers inside modals\ncontainer:makeProp([HTMLElement,PROP_TYPE_STRING],'body'),disabled:makeProp(PROP_TYPE_BOOLEAN,false),// This should be set to match the root element type\ntag:makeProp(PROP_TYPE_STRING,'div')};// --- Main component ---\n// @vue/component\nvar BVTransporter=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TRANSPORTER,mixins:[normalizeSlotMixin],props:props$W,watch:{disabled:{immediate:true,handler:function handler(disabled){disabled?this.unmountTarget():this.$nextTick(this.mountTarget);}}},created:function created(){// Create private non-reactive props\nthis.$_defaultFn=null;this.$_target=null;},beforeMount:function beforeMount(){this.mountTarget();},updated:function updated(){// We need to make sure that all children have completed updating\n// before rendering in the target\n// `vue-simple-portal` has the this in a `$nextTick()`,\n// while `portal-vue` doesn't\n// Just trying to see if the `$nextTick()` delay is required or not\n// Since all slots in Vue 2.6.x are always functions\nthis.updateTarget();},beforeDestroy:function beforeDestroy(){this.unmountTarget();this.$_defaultFn=null;},methods:{// Get the element which the target should be appended to\ngetContainer:function getContainer(){/* istanbul ignore else */if(IS_BROWSER){var container=this.container;return isString(container)?select(container):container;}else{return null;}},// Mount the target\nmountTarget:function mountTarget(){if(!this.$_target){var $container=this.getContainer();if($container){var $el=document.createElement('div');$container.appendChild($el);this.$_target=new BVTransporterTarget({el:$el,parent:this,propsData:{// Initial nodes to be rendered\nnodes:concat(this.normalizeSlot())}});}}},// Update the content of the target\nupdateTarget:function updateTarget(){if(IS_BROWSER&&this.$_target){var defaultFn=this.$scopedSlots.default;if(!this.disabled){/* istanbul ignore else: only applicable in Vue 2.5.x */if(defaultFn&&this.$_defaultFn!==defaultFn){// We only update the target component if the scoped slot\n// function is a fresh one. The new slot syntax (since Vue 2.6)\n// can cache unchanged slot functions and we want to respect that here\nthis.$_target.updatedNodes=defaultFn;}else if(!defaultFn){// We also need to be back compatible with non-scoped default slot (i.e. 2.5.x)\nthis.$_target.updatedNodes=this.$slots.default;}}// Update the scoped slot function cache\nthis.$_defaultFn=defaultFn;}},// Unmount the target\nunmountTarget:function unmountTarget(){this.$_target&&this.$_target.$destroy();this.$_target=null;}},render:function render(h){// This component has no root element, so only a single VNode is allowed\nif(this.disabled){var $nodes=concat(this.normalizeSlot()).filter(identity);if($nodes.length>0&&!$nodes[0].text){return $nodes[0];}}return h();}});var BvModalEvent=/*#__PURE__*/function(_BvEvent){_inherits(BvModalEvent,_BvEvent);var _super=_createSuper(BvModalEvent);function BvModalEvent(type){var _this;var eventInit=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,BvModalEvent);_this=_super.call(this,type,eventInit);// Freeze our new props as readonly, but leave them enumerable\ndefineProperties(_assertThisInitialized(_this),{trigger:readonlyDescriptor()});return _this;}_createClass(BvModalEvent,null,[{key:\"Defaults\",get:function get(){return _objectSpread2$3(_objectSpread2$3({},_get(_getPrototypeOf(BvModalEvent),\"Defaults\",this)),{},{trigger:null});}}]);return BvModalEvent;}(BvEvent);// Named exports\n/**\n   * Private ModalManager helper\n   * Handles controlling modal stacking zIndexes and body adjustments/classes\n   */ // Default modal backdrop z-index\nvar DEFAULT_ZINDEX=1040;// Selectors for padding/margin adjustments\nvar SELECTOR_FIXED_CONTENT='.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';var SELECTOR_STICKY_CONTENT='.sticky-top';var SELECTOR_NAVBAR_TOGGLER='.navbar-toggler';// --- Main component ---\n// @vue/component\nvar ModalManager=/*#__PURE__*/Vue__default['default'].extend({data:function data(){return{modals:[],baseZIndex:null,scrollbarWidth:null,isBodyOverflowing:false};},computed:{modalCount:function modalCount(){return this.modals.length;},modalsAreOpen:function modalsAreOpen(){return this.modalCount>0;}},watch:{modalCount:function modalCount(newCount,oldCount){if(IS_BROWSER){this.getScrollbarWidth();if(newCount>0&&oldCount===0){// Transitioning to modal(s) open\nthis.checkScrollbar();this.setScrollbar();addClass(document.body,'modal-open');}else if(newCount===0&&oldCount>0){// Transitioning to modal(s) closed\nthis.resetScrollbar();removeClass(document.body,'modal-open');}setAttr(document.body,'data-modal-open-count',String(newCount));}},modals:function modals(newValue){var _this=this;this.checkScrollbar();requestAF(function(){_this.updateModals(newValue||[]);});}},methods:{// Public methods\nregisterModal:function registerModal(modal){// Register the modal if not already registered\nif(modal&&this.modals.indexOf(modal)===-1){this.modals.push(modal);}},unregisterModal:function unregisterModal(modal){var index=this.modals.indexOf(modal);if(index>-1){// Remove modal from modals array\nthis.modals.splice(index,1);// Reset the modal's data\nif(!modal._isBeingDestroyed&&!modal._isDestroyed){this.resetModal(modal);}}},getBaseZIndex:function getBaseZIndex(){if(IS_BROWSER&&isNull(this.baseZIndex)){// Create a temporary `div.modal-backdrop` to get computed z-index\nvar div=document.createElement('div');addClass(div,'modal-backdrop');addClass(div,'d-none');setStyle(div,'display','none');document.body.appendChild(div);this.baseZIndex=toInteger(getCS(div).zIndex,DEFAULT_ZINDEX);document.body.removeChild(div);}return this.baseZIndex||DEFAULT_ZINDEX;},getScrollbarWidth:function getScrollbarWidth(){if(IS_BROWSER&&isNull(this.scrollbarWidth)){// Create a temporary `div.measure-scrollbar` to get computed z-index\nvar div=document.createElement('div');addClass(div,'modal-scrollbar-measure');document.body.appendChild(div);this.scrollbarWidth=getBCR(div).width-div.clientWidth;document.body.removeChild(div);}return this.scrollbarWidth||0;},// Private methods\nupdateModals:function updateModals(modals){var _this2=this;var baseZIndex=this.getBaseZIndex();var scrollbarWidth=this.getScrollbarWidth();modals.forEach(function(modal,index){// We update data values on each modal\nmodal.zIndex=baseZIndex+index;modal.scrollbarWidth=scrollbarWidth;modal.isTop=index===_this2.modals.length-1;modal.isBodyOverflowing=_this2.isBodyOverflowing;});},resetModal:function resetModal(modal){if(modal){modal.zIndex=this.getBaseZIndex();modal.isTop=true;modal.isBodyOverflowing=false;}},checkScrollbar:function checkScrollbar(){// Determine if the body element is overflowing\nvar _getBCR=getBCR(document.body),left=_getBCR.left,right=_getBCR.right;this.isBodyOverflowing=left+right<window.innerWidth;},setScrollbar:function setScrollbar(){var body=document.body;// Storage place to cache changes to margins and padding\n// Note: This assumes the following element types are not added to the\n// document after the modal has opened.\nbody._paddingChangedForModal=body._paddingChangedForModal||[];body._marginChangedForModal=body._marginChangedForModal||[];if(this.isBodyOverflowing){var scrollbarWidth=this.scrollbarWidth;// Adjust fixed content padding\n/* istanbul ignore next: difficult to test in JSDOM */selectAll(SELECTOR_FIXED_CONTENT).forEach(function(el){var actualPadding=getStyle(el,'paddingRight')||'';setAttr(el,'data-padding-right',actualPadding);setStyle(el,'paddingRight',\"\".concat(toFloat(getCS(el).paddingRight,0)+scrollbarWidth,\"px\"));body._paddingChangedForModal.push(el);});// Adjust sticky content margin\n/* istanbul ignore next: difficult to test in JSDOM */selectAll(SELECTOR_STICKY_CONTENT).forEach(function(el)/* istanbul ignore next */{var actualMargin=getStyle(el,'marginRight')||'';setAttr(el,'data-margin-right',actualMargin);setStyle(el,'marginRight',\"\".concat(toFloat(getCS(el).marginRight,0)-scrollbarWidth,\"px\"));body._marginChangedForModal.push(el);});// Adjust <b-navbar-toggler> margin\n/* istanbul ignore next: difficult to test in JSDOM */selectAll(SELECTOR_NAVBAR_TOGGLER).forEach(function(el)/* istanbul ignore next */{var actualMargin=getStyle(el,'marginRight')||'';setAttr(el,'data-margin-right',actualMargin);setStyle(el,'marginRight',\"\".concat(toFloat(getCS(el).marginRight,0)+scrollbarWidth,\"px\"));body._marginChangedForModal.push(el);});// Adjust body padding\nvar actualPadding=getStyle(body,'paddingRight')||'';setAttr(body,'data-padding-right',actualPadding);setStyle(body,'paddingRight',\"\".concat(toFloat(getCS(body).paddingRight,0)+scrollbarWidth,\"px\"));}},resetScrollbar:function resetScrollbar(){var body=document.body;if(body._paddingChangedForModal){// Restore fixed content padding\nbody._paddingChangedForModal.forEach(function(el){/* istanbul ignore next: difficult to test in JSDOM */if(hasAttr(el,'data-padding-right')){setStyle(el,'paddingRight',getAttr(el,'data-padding-right')||'');removeAttr(el,'data-padding-right');}});}if(body._marginChangedForModal){// Restore sticky content and navbar-toggler margin\nbody._marginChangedForModal.forEach(function(el){/* istanbul ignore next: difficult to test in JSDOM */if(hasAttr(el,'data-margin-right')){setStyle(el,'marginRight',getAttr(el,'data-margin-right')||'');removeAttr(el,'data-margin-right');}});}body._paddingChangedForModal=null;body._marginChangedForModal=null;// Restore body padding\nif(hasAttr(body,'data-padding-right')){setStyle(body,'paddingRight',getAttr(body,'data-padding-right')||'');removeAttr(body,'data-padding-right');}}}});// Create and export our modal manager instance\nvar modalManager=new ModalManager();var _makeModelMixin$5=makeModelMixin('visible',{type:PROP_TYPE_BOOLEAN,defaultValue:false,event:EVENT_NAME_CHANGE}),modelMixin$5=_makeModelMixin$5.mixin,modelProps$5=_makeModelMixin$5.props,MODEL_PROP_NAME$5=_makeModelMixin$5.prop,MODEL_EVENT_NAME$5=_makeModelMixin$5.event;var TRIGGER_BACKDROP='backdrop';var TRIGGER_ESC='esc';var TRIGGER_FORCE='FORCE';var TRIGGER_TOGGLE='toggle';var BUTTON_CANCEL='cancel';// TODO: This should be renamed to 'close'\nvar BUTTON_CLOSE='headerclose';var BUTTON_OK='ok';var BUTTONS=[BUTTON_CANCEL,BUTTON_CLOSE,BUTTON_OK];// `ObserveDom` config to detect changes in modal content\n// so that we can adjust the modal padding if needed\nvar OBSERVER_CONFIG={subtree:true,childList:true,characterData:true,attributes:true,attributeFilter:['style','class']};// --- Props ---\nvar props$V=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),modelProps$5),{},{ariaLabel:makeProp(PROP_TYPE_STRING),autoFocusButton:makeProp(PROP_TYPE_STRING,null,/* istanbul ignore next */function(value){return isUndefinedOrNull(value)||arrayIncludes(BUTTONS,value);}),bodyBgVariant:makeProp(PROP_TYPE_STRING),bodyClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),bodyTextVariant:makeProp(PROP_TYPE_STRING),busy:makeProp(PROP_TYPE_BOOLEAN,false),buttonSize:makeProp(PROP_TYPE_STRING),cancelDisabled:makeProp(PROP_TYPE_BOOLEAN,false),cancelTitle:makeProp(PROP_TYPE_STRING,'Cancel'),cancelTitleHtml:makeProp(PROP_TYPE_STRING),cancelVariant:makeProp(PROP_TYPE_STRING,'secondary'),centered:makeProp(PROP_TYPE_BOOLEAN,false),contentClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),dialogClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),footerBgVariant:makeProp(PROP_TYPE_STRING),footerBorderVariant:makeProp(PROP_TYPE_STRING),footerClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),footerTag:makeProp(PROP_TYPE_STRING,'footer'),footerTextVariant:makeProp(PROP_TYPE_STRING),headerBgVariant:makeProp(PROP_TYPE_STRING),headerBorderVariant:makeProp(PROP_TYPE_STRING),headerClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),headerCloseContent:makeProp(PROP_TYPE_STRING,'&times;'),headerCloseLabel:makeProp(PROP_TYPE_STRING,'Close'),headerCloseVariant:makeProp(PROP_TYPE_STRING),headerTag:makeProp(PROP_TYPE_STRING,'header'),headerTextVariant:makeProp(PROP_TYPE_STRING),// TODO: Rename to `noBackdrop` and deprecate `hideBackdrop`\nhideBackdrop:makeProp(PROP_TYPE_BOOLEAN,false),// TODO: Rename to `noFooter` and deprecate `hideFooter`\nhideFooter:makeProp(PROP_TYPE_BOOLEAN,false),// TODO: Rename to `noHeader` and deprecate `hideHeader`\nhideHeader:makeProp(PROP_TYPE_BOOLEAN,false),// TODO: Rename to `noHeaderClose` and deprecate `hideHeaderClose`\nhideHeaderClose:makeProp(PROP_TYPE_BOOLEAN,false),ignoreEnforceFocusSelector:makeProp(PROP_TYPE_ARRAY_STRING),lazy:makeProp(PROP_TYPE_BOOLEAN,false),modalClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),noCloseOnBackdrop:makeProp(PROP_TYPE_BOOLEAN,false),noCloseOnEsc:makeProp(PROP_TYPE_BOOLEAN,false),noEnforceFocus:makeProp(PROP_TYPE_BOOLEAN,false),noFade:makeProp(PROP_TYPE_BOOLEAN,false),noStacking:makeProp(PROP_TYPE_BOOLEAN,false),okDisabled:makeProp(PROP_TYPE_BOOLEAN,false),okOnly:makeProp(PROP_TYPE_BOOLEAN,false),okTitle:makeProp(PROP_TYPE_STRING,'OK'),okTitleHtml:makeProp(PROP_TYPE_STRING),okVariant:makeProp(PROP_TYPE_STRING,'primary'),// HTML Element, CSS selector string or Vue component instance\nreturnFocus:makeProp([HTMLElement,PROP_TYPE_OBJECT,PROP_TYPE_STRING]),scrollable:makeProp(PROP_TYPE_BOOLEAN,false),size:makeProp(PROP_TYPE_STRING,'md'),static:makeProp(PROP_TYPE_BOOLEAN,false),title:makeProp(PROP_TYPE_STRING),titleClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),titleHtml:makeProp(PROP_TYPE_STRING),titleSrOnly:makeProp(PROP_TYPE_BOOLEAN,false),titleTag:makeProp(PROP_TYPE_STRING,'h5')})),NAME_MODAL);// --- Main component ---\n// @vue/component\nvar BModal=/*#__PURE__*/Vue__default['default'].extend({name:NAME_MODAL,mixins:[attrsMixin,idMixin,modelMixin$5,listenOnDocumentMixin,listenOnRootMixin,listenOnWindowMixin,normalizeSlotMixin,scopedStyleMixin],inheritAttrs:false,props:props$V,data:function data(){return{isHidden:true,// If modal should not be in document\nisVisible:false,// Controls modal visible state\nisTransitioning:false,// Used for style control\nisShow:false,// Used for style control\nisBlock:false,// Used for style control\nisOpening:false,// To signal that the modal is in the process of opening\nisClosing:false,// To signal that the modal is in the process of closing\nignoreBackdropClick:false,// Used to signify if click out listener should ignore the click\nisModalOverflowing:false,// The following items are controlled by the modalManager instance\nscrollbarWidth:0,zIndex:modalManager.getBaseZIndex(),isTop:true,isBodyOverflowing:false};},computed:{modalId:function modalId(){return this.safeId();},modalOuterId:function modalOuterId(){return this.safeId('__BV_modal_outer_');},modalHeaderId:function modalHeaderId(){return this.safeId('__BV_modal_header_');},modalBodyId:function modalBodyId(){return this.safeId('__BV_modal_body_');},modalTitleId:function modalTitleId(){return this.safeId('__BV_modal_title_');},modalContentId:function modalContentId(){return this.safeId('__BV_modal_content_');},modalFooterId:function modalFooterId(){return this.safeId('__BV_modal_footer_');},modalBackdropId:function modalBackdropId(){return this.safeId('__BV_modal_backdrop_');},modalClasses:function modalClasses(){return[{fade:!this.noFade,show:this.isShow},this.modalClass];},modalStyles:function modalStyles(){var sbWidth=\"\".concat(this.scrollbarWidth,\"px\");return{paddingLeft:!this.isBodyOverflowing&&this.isModalOverflowing?sbWidth:'',paddingRight:this.isBodyOverflowing&&!this.isModalOverflowing?sbWidth:'',// Needed to fix issue https://github.com/bootstrap-vue/bootstrap-vue/issues/3457\n// Even though we are using v-show, we must ensure 'none' is restored in the styles\ndisplay:this.isBlock?'block':'none'};},dialogClasses:function dialogClasses(){var _ref;return[(_ref={},_defineProperty(_ref,\"modal-\".concat(this.size),this.size),_defineProperty(_ref,'modal-dialog-centered',this.centered),_defineProperty(_ref,'modal-dialog-scrollable',this.scrollable),_ref),this.dialogClass];},headerClasses:function headerClasses(){var _ref2;return[(_ref2={},_defineProperty(_ref2,\"bg-\".concat(this.headerBgVariant),this.headerBgVariant),_defineProperty(_ref2,\"text-\".concat(this.headerTextVariant),this.headerTextVariant),_defineProperty(_ref2,\"border-\".concat(this.headerBorderVariant),this.headerBorderVariant),_ref2),this.headerClass];},titleClasses:function titleClasses(){return[{'sr-only':this.titleSrOnly},this.titleClass];},bodyClasses:function bodyClasses(){var _ref3;return[(_ref3={},_defineProperty(_ref3,\"bg-\".concat(this.bodyBgVariant),this.bodyBgVariant),_defineProperty(_ref3,\"text-\".concat(this.bodyTextVariant),this.bodyTextVariant),_ref3),this.bodyClass];},footerClasses:function footerClasses(){var _ref4;return[(_ref4={},_defineProperty(_ref4,\"bg-\".concat(this.footerBgVariant),this.footerBgVariant),_defineProperty(_ref4,\"text-\".concat(this.footerTextVariant),this.footerTextVariant),_defineProperty(_ref4,\"border-\".concat(this.footerBorderVariant),this.footerBorderVariant),_ref4),this.footerClass];},modalOuterStyle:function modalOuterStyle(){// Styles needed for proper stacking of modals\nreturn{position:'absolute',zIndex:this.zIndex};},slotScope:function slotScope(){return{cancel:this.onCancel,close:this.onClose,hide:this.hide,ok:this.onOk,visible:this.isVisible};},computeIgnoreEnforceFocusSelector:function computeIgnoreEnforceFocusSelector(){// Normalize to an single selector with selectors separated by `,`\nreturn concat(this.ignoreEnforceFocusSelector).filter(identity).join(',').trim();},computedAttrs:function computedAttrs(){// If the parent has a scoped style attribute, and the modal\n// is portalled, add the scoped attribute to the modal wrapper\nvar scopedStyleAttrs=!this.static?this.scopedStyleAttrs:{};return _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},scopedStyleAttrs),this.bvAttrs),{},{id:this.modalOuterId});},computedModalAttrs:function computedModalAttrs(){var isVisible=this.isVisible,ariaLabel=this.ariaLabel;return{id:this.modalId,role:'dialog','aria-hidden':isVisible?null:'true','aria-modal':isVisible?'true':null,'aria-label':ariaLabel,'aria-labelledby':this.hideHeader||ariaLabel||// TODO: Rename slot to `title` and deprecate `modal-title`\n!(this.hasNormalizedSlot(SLOT_NAME_MODAL_TITLE)||this.titleHtml||this.title)?null:this.modalTitleId,'aria-describedby':this.modalBodyId};}},watch:_defineProperty({},MODEL_PROP_NAME$5,function(newValue,oldValue){if(newValue!==oldValue){this[newValue?'show':'hide']();}}),created:function created(){// Define non-reactive properties\nthis.$_observer=null;this.$_returnFocus=this.returnFocus||null;},mounted:function mounted(){// Set initial z-index as queried from the DOM\nthis.zIndex=modalManager.getBaseZIndex();// Listen for events from others to either open or close ourselves\n// and listen to all modals to enable/disable enforce focus\nthis.listenOnRoot(getRootActionEventName(NAME_MODAL,EVENT_NAME_SHOW),this.showHandler);this.listenOnRoot(getRootActionEventName(NAME_MODAL,EVENT_NAME_HIDE),this.hideHandler);this.listenOnRoot(getRootActionEventName(NAME_MODAL,EVENT_NAME_TOGGLE),this.toggleHandler);// Listen for `bv:modal::show events`, and close ourselves if the\n// opening modal not us\nthis.listenOnRoot(getRootEventName(NAME_MODAL,EVENT_NAME_SHOW),this.modalListener);// Initially show modal?\nif(this[MODEL_PROP_NAME$5]===true){this.$nextTick(this.show);}},beforeDestroy:function beforeDestroy(){// Ensure everything is back to normal\nmodalManager.unregisterModal(this);this.setObserver(false);if(this.isVisible){this.isVisible=false;this.isShow=false;this.isTransitioning=false;}},methods:{setObserver:function setObserver(){var on=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;this.$_observer&&this.$_observer.disconnect();this.$_observer=null;if(on){this.$_observer=observeDom(this.$refs.content,this.checkModalOverflow.bind(this),OBSERVER_CONFIG);}},// Private method to update the v-model\nupdateModel:function updateModel(value){if(value!==this[MODEL_PROP_NAME$5]){this.$emit(MODEL_EVENT_NAME$5,value);}},// Private method to create a BvModalEvent object\nbuildEvent:function buildEvent(type){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return new BvModalEvent(type,_objectSpread2$3(_objectSpread2$3({// Default options\ncancelable:false,target:this.$refs.modal||this.$el||null,relatedTarget:null,trigger:null},options),{},{// Options that can't be overridden\nvueTarget:this,componentId:this.modalId}));},// Public method to show modal\nshow:function show(){if(this.isVisible||this.isOpening){// If already open, or in the process of opening, do nothing\n/* istanbul ignore next */return;}/* istanbul ignore next */if(this.isClosing){// If we are in the process of closing, wait until hidden before re-opening\n/* istanbul ignore next */this.$once(EVENT_NAME_HIDDEN,this.show);/* istanbul ignore next */return;}this.isOpening=true;// Set the element to return focus to when closed\nthis.$_returnFocus=this.$_returnFocus||this.getActiveElement();var showEvent=this.buildEvent(EVENT_NAME_SHOW,{cancelable:true});this.emitEvent(showEvent);// Don't show if canceled\nif(showEvent.defaultPrevented||this.isVisible){this.isOpening=false;// Ensure the v-model reflects the current state\nthis.updateModel(false);return;}// Show the modal\nthis.doShow();},// Public method to hide modal\nhide:function hide(){var trigger=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'';if(!this.isVisible||this.isClosing){/* istanbul ignore next */return;}this.isClosing=true;var hideEvent=this.buildEvent(EVENT_NAME_HIDE,{cancelable:trigger!==TRIGGER_FORCE,trigger:trigger||null});// We emit specific event for one of the three built-in buttons\nif(trigger===BUTTON_OK){this.$emit(EVENT_NAME_OK,hideEvent);}else if(trigger===BUTTON_CANCEL){this.$emit(EVENT_NAME_CANCEL,hideEvent);}else if(trigger===BUTTON_CLOSE){this.$emit(EVENT_NAME_CLOSE,hideEvent);}this.emitEvent(hideEvent);// Hide if not canceled\nif(hideEvent.defaultPrevented||!this.isVisible){this.isClosing=false;// Ensure v-model reflects current state\nthis.updateModel(true);return;}// Stop observing for content changes\nthis.setObserver(false);// Trigger the hide transition\nthis.isVisible=false;// Update the v-model\nthis.updateModel(false);},// Public method to toggle modal visibility\ntoggle:function toggle(triggerEl){if(triggerEl){this.$_returnFocus=triggerEl;}if(this.isVisible){this.hide(TRIGGER_TOGGLE);}else{this.show();}},// Private method to get the current document active element\ngetActiveElement:function getActiveElement$1(){// Returning focus to `document.body` may cause unwanted scrolls,\n// so we exclude setting focus on body\nvar activeElement=getActiveElement(IS_BROWSER?[document.body]:[]);// Preset the fallback return focus value if it is not set\n// `document.activeElement` should be the trigger element that was clicked or\n// in the case of using the v-model, which ever element has current focus\n// Will be overridden by some commands such as toggle, etc.\n// Note: On IE 11, `document.activeElement` may be `null`\n// So we test it for truthiness first\n// https://github.com/bootstrap-vue/bootstrap-vue/issues/3206\nreturn activeElement&&activeElement.focus?activeElement:null;},// Private method to finish showing modal\ndoShow:function doShow(){var _this=this;/* istanbul ignore next: commenting out for now until we can test stacking */if(modalManager.modalsAreOpen&&this.noStacking){// If another modal(s) is already open, wait for it(them) to close\nthis.listenOnRootOnce(getRootEventName(NAME_MODAL,EVENT_NAME_HIDDEN),this.doShow);return;}modalManager.registerModal(this);// Place modal in DOM\nthis.isHidden=false;this.$nextTick(function(){// We do this in `$nextTick()` to ensure the modal is in DOM first\n// before we show it\n_this.isVisible=true;_this.isOpening=false;// Update the v-model\n_this.updateModel(true);_this.$nextTick(function(){// Observe changes in modal content and adjust if necessary\n// In a `$nextTick()` in case modal content is lazy\n_this.setObserver(true);});});},// Transition handlers\nonBeforeEnter:function onBeforeEnter(){this.isTransitioning=true;this.setResizeEvent(true);},onEnter:function onEnter(){var _this2=this;this.isBlock=true;// We add the `show` class 1 frame later\n// `requestAF()` runs the callback before the next repaint, so we need\n// two calls to guarantee the next frame has been rendered\nrequestAF(function(){requestAF(function(){_this2.isShow=true;});});},onAfterEnter:function onAfterEnter(){var _this3=this;this.checkModalOverflow();this.isTransitioning=false;// We use `requestAF()` to allow transition hooks to complete\n// before passing control over to the other handlers\n// This will allow users to not have to use `$nextTick()` or `requestAF()`\n// when trying to pre-focus an element\nrequestAF(function(){_this3.emitEvent(_this3.buildEvent(EVENT_NAME_SHOWN));_this3.setEnforceFocus(true);_this3.$nextTick(function(){// Delayed in a `$nextTick()` to allow users time to pre-focus\n// an element if the wish\n_this3.focusFirst();});});},onBeforeLeave:function onBeforeLeave(){this.isTransitioning=true;this.setResizeEvent(false);this.setEnforceFocus(false);},onLeave:function onLeave(){// Remove the 'show' class\nthis.isShow=false;},onAfterLeave:function onAfterLeave(){var _this4=this;this.isBlock=false;this.isTransitioning=false;this.isModalOverflowing=false;this.isHidden=true;this.$nextTick(function(){_this4.isClosing=false;modalManager.unregisterModal(_this4);_this4.returnFocusTo();// TODO: Need to find a way to pass the `trigger` property\n//       to the `hidden` event, not just only the `hide` event\n_this4.emitEvent(_this4.buildEvent(EVENT_NAME_HIDDEN));});},emitEvent:function emitEvent(bvEvent){var type=bvEvent.type;// We emit on `$root` first in case a global listener wants to cancel\n// the event first before the instance emits its event\nthis.emitOnRoot(getRootEventName(NAME_MODAL,type),bvEvent,bvEvent.componentId);this.$emit(type,bvEvent);},// UI event handlers\nonDialogMousedown:function onDialogMousedown(){var _this5=this;// Watch to see if the matching mouseup event occurs outside the dialog\n// And if it does, cancel the clickOut handler\nvar modal=this.$refs.modal;var onceModalMouseup=function onceModalMouseup(event){eventOff(modal,'mouseup',onceModalMouseup,EVENT_OPTIONS_NO_CAPTURE);if(event.target===modal){_this5.ignoreBackdropClick=true;}};eventOn(modal,'mouseup',onceModalMouseup,EVENT_OPTIONS_NO_CAPTURE);},onClickOut:function onClickOut(event){if(this.ignoreBackdropClick){// Click was initiated inside the modal content, but finished outside.\n// Set by the above onDialogMousedown handler\nthis.ignoreBackdropClick=false;return;}// Do nothing if not visible, backdrop click disabled, or element\n// that generated click event is no longer in document body\nif(!this.isVisible||this.noCloseOnBackdrop||!contains(document.body,event.target)){return;}// If backdrop clicked, hide modal\nif(!contains(this.$refs.content,event.target)){this.hide(TRIGGER_BACKDROP);}},onOk:function onOk(){this.hide(BUTTON_OK);},onCancel:function onCancel(){this.hide(BUTTON_CANCEL);},onClose:function onClose(){this.hide(BUTTON_CLOSE);},onEsc:function onEsc(event){// If ESC pressed, hide modal\nif(event.keyCode===CODE_ESC&&this.isVisible&&!this.noCloseOnEsc){this.hide(TRIGGER_ESC);}},// Document focusin listener\nfocusHandler:function focusHandler(event){// If focus leaves modal content, bring it back\nvar content=this.$refs.content;var target=event.target;if(this.noEnforceFocus||!this.isTop||!this.isVisible||!content||document===target||contains(content,target)||this.computeIgnoreEnforceFocusSelector&&closest(this.computeIgnoreEnforceFocusSelector,target,true)){return;}var tabables=getTabables(this.$refs.content);var bottomTrap=this.$refs['bottom-trap'];var topTrap=this.$refs['top-trap'];if(bottomTrap&&target===bottomTrap){// If user pressed TAB out of modal into our bottom trab trap element\n// Find the first tabable element in the modal content and focus it\nif(attemptFocus(tabables[0])){// Focus was successful\nreturn;}}else if(topTrap&&target===topTrap){// If user pressed CTRL-TAB out of modal and into our top tab trap element\n// Find the last tabable element in the modal content and focus it\nif(attemptFocus(tabables[tabables.length-1])){// Focus was successful\nreturn;}}// Otherwise focus the modal content container\nattemptFocus(content,{preventScroll:true});},// Turn on/off focusin listener\nsetEnforceFocus:function setEnforceFocus(on){this.listenDocument(on,'focusin',this.focusHandler);},// Resize listener\nsetResizeEvent:function setResizeEvent(on){this.listenWindow(on,'resize',this.checkModalOverflow);this.listenWindow(on,'orientationchange',this.checkModalOverflow);},// Root listener handlers\nshowHandler:function showHandler(id,triggerEl){if(id===this.modalId){this.$_returnFocus=triggerEl||this.getActiveElement();this.show();}},hideHandler:function hideHandler(id){if(id===this.modalId){this.hide('event');}},toggleHandler:function toggleHandler(id,triggerEl){if(id===this.modalId){this.toggle(triggerEl);}},modalListener:function modalListener(bvEvent){// If another modal opens, close this one if stacking not permitted\nif(this.noStacking&&bvEvent.vueTarget!==this){this.hide();}},// Focus control handlers\nfocusFirst:function focusFirst(){var _this6=this;// Don't try and focus if we are SSR\nif(IS_BROWSER){requestAF(function(){var modal=_this6.$refs.modal;var content=_this6.$refs.content;var activeElement=_this6.getActiveElement();// If the modal contains the activeElement, we don't do anything\nif(modal&&content&&!(activeElement&&contains(content,activeElement))){var ok=_this6.$refs['ok-button'];var cancel=_this6.$refs['cancel-button'];var close=_this6.$refs['close-button'];// Focus the appropriate button or modal content wrapper\nvar autoFocus=_this6.autoFocusButton;/* istanbul ignore next */var el=autoFocus===BUTTON_OK&&ok?ok.$el||ok:autoFocus===BUTTON_CANCEL&&cancel?cancel.$el||cancel:autoFocus===BUTTON_CLOSE&&close?close.$el||close:content;// Focus the element\nattemptFocus(el);if(el===content){// Make sure top of modal is showing (if longer than the viewport)\n_this6.$nextTick(function(){modal.scrollTop=0;});}}});}},returnFocusTo:function returnFocusTo(){// Prefer `returnFocus` prop over event specified\n// `return_focus` value\nvar el=this.returnFocus||this.$_returnFocus||null;this.$_returnFocus=null;this.$nextTick(function(){// Is el a string CSS selector?\nel=isString(el)?select(el):el;if(el){// Possibly could be a component reference\nel=el.$el||el;attemptFocus(el);}});},checkModalOverflow:function checkModalOverflow(){if(this.isVisible){var modal=this.$refs.modal;this.isModalOverflowing=modal.scrollHeight>document.documentElement.clientHeight;}},makeModal:function makeModal(h){// Modal header\nvar $header=h();if(!this.hideHeader){// TODO: Rename slot to `header` and deprecate `modal-header`\nvar $modalHeader=this.normalizeSlot(SLOT_NAME_MODAL_HEADER,this.slotScope);if(!$modalHeader){var $closeButton=h();if(!this.hideHeaderClose){$closeButton=h(BButtonClose,{props:{content:this.headerCloseContent,disabled:this.isTransitioning,ariaLabel:this.headerCloseLabel,textVariant:this.headerCloseVariant||this.headerTextVariant},on:{click:this.onClose},ref:'close-button'},// TODO: Rename slot to `header-close` and deprecate `modal-header-close`\n[this.normalizeSlot(SLOT_NAME_MODAL_HEADER_CLOSE)]);}$modalHeader=[h(this.titleTag,{staticClass:'modal-title',class:this.titleClasses,attrs:{id:this.modalTitleId},// TODO: Rename slot to `title` and deprecate `modal-title`\ndomProps:this.hasNormalizedSlot(SLOT_NAME_MODAL_TITLE)?{}:htmlOrText(this.titleHtml,this.title)},// TODO: Rename slot to `title` and deprecate `modal-title`\nthis.normalizeSlot(SLOT_NAME_MODAL_TITLE,this.slotScope)),$closeButton];}$header=h(this.headerTag,{staticClass:'modal-header',class:this.headerClasses,attrs:{id:this.modalHeaderId},ref:'header'},[$modalHeader]);}// Modal body\nvar $body=h('div',{staticClass:'modal-body',class:this.bodyClasses,attrs:{id:this.modalBodyId},ref:'body'},this.normalizeSlot(SLOT_NAME_DEFAULT,this.slotScope));// Modal footer\nvar $footer=h();if(!this.hideFooter){// TODO: Rename slot to `footer` and deprecate `modal-footer`\nvar $modalFooter=this.normalizeSlot(SLOT_NAME_MODAL_FOOTER,this.slotScope);if(!$modalFooter){var $cancelButton=h();if(!this.okOnly){$cancelButton=h(BButton,{props:{variant:this.cancelVariant,size:this.buttonSize,disabled:this.cancelDisabled||this.busy||this.isTransitioning},// TODO: Rename slot to `cancel-button` and deprecate `modal-cancel`\ndomProps:this.hasNormalizedSlot(SLOT_NAME_MODAL_CANCEL)?{}:htmlOrText(this.cancelTitleHtml,this.cancelTitle),on:{click:this.onCancel},ref:'cancel-button'},// TODO: Rename slot to `cancel-button` and deprecate `modal-cancel`\nthis.normalizeSlot(SLOT_NAME_MODAL_CANCEL));}var $okButton=h(BButton,{props:{variant:this.okVariant,size:this.buttonSize,disabled:this.okDisabled||this.busy||this.isTransitioning},// TODO: Rename slot to `ok-button` and deprecate `modal-ok`\ndomProps:this.hasNormalizedSlot(SLOT_NAME_MODAL_OK)?{}:htmlOrText(this.okTitleHtml,this.okTitle),on:{click:this.onOk},ref:'ok-button'},// TODO: Rename slot to `ok-button` and deprecate `modal-ok`\nthis.normalizeSlot(SLOT_NAME_MODAL_OK));$modalFooter=[$cancelButton,$okButton];}$footer=h(this.footerTag,{staticClass:'modal-footer',class:this.footerClasses,attrs:{id:this.modalFooterId},ref:'footer'},[$modalFooter]);}// Assemble modal content\nvar $modalContent=h('div',{staticClass:'modal-content',class:this.contentClass,attrs:{id:this.modalContentId,tabindex:'-1'},ref:'content'},[$header,$body,$footer]);// Tab traps to prevent page from scrolling to next element in\n// tab index during enforce-focus tab cycle\nvar $tabTrapTop=h();var $tabTrapBottom=h();if(this.isVisible&&!this.noEnforceFocus){$tabTrapTop=h('span',{attrs:{tabindex:'0'},ref:'top-trap'});$tabTrapBottom=h('span',{attrs:{tabindex:'0'},ref:'bottom-trap'});}// Modal dialog wrapper\nvar $modalDialog=h('div',{staticClass:'modal-dialog',class:this.dialogClasses,on:{mousedown:this.onDialogMousedown},ref:'dialog'},[$tabTrapTop,$modalContent,$tabTrapBottom]);// Modal\nvar $modal=h('div',{staticClass:'modal',class:this.modalClasses,style:this.modalStyles,attrs:this.computedModalAttrs,on:{keydown:this.onEsc,click:this.onClickOut},directives:[{name:'show',value:this.isVisible}],ref:'modal'},[$modalDialog]);// Wrap modal in transition\n// Sadly, we can't use `BVTransition` here due to the differences in\n// transition durations for `.modal` and `.modal-dialog`\n// At least until https://github.com/vuejs/vue/issues/9986 is resolved\n$modal=h('transition',{props:{enterClass:'',enterToClass:'',enterActiveClass:'',leaveClass:'',leaveActiveClass:'',leaveToClass:''},on:{beforeEnter:this.onBeforeEnter,enter:this.onEnter,afterEnter:this.onAfterEnter,beforeLeave:this.onBeforeLeave,leave:this.onLeave,afterLeave:this.onAfterLeave}},[$modal]);// Modal backdrop\nvar $backdrop=h();if(!this.hideBackdrop&&this.isVisible){$backdrop=h('div',{staticClass:'modal-backdrop',attrs:{id:this.modalBackdropId}},// TODO: Rename slot to `backdrop` and deprecate `modal-backdrop`\nthis.normalizeSlot(SLOT_NAME_MODAL_BACKDROP));}$backdrop=h(BVTransition,{props:{noFade:this.noFade}},[$backdrop]);// Assemble modal and backdrop in an outer <div>\nreturn h('div',{style:this.modalOuterStyle,attrs:this.computedAttrs,key:\"modal-outer-\".concat(this[COMPONENT_UID_KEY])},[$modal,$backdrop]);}},render:function render(h){if(this.static){return this.lazy&&this.isHidden?h():this.makeModal(h);}else{return this.isHidden?h():h(BVTransporter,[this.makeModal(h)]);}}});var ROOT_ACTION_EVENT_NAME_SHOW=getRootActionEventName(NAME_MODAL,EVENT_NAME_SHOW);// Prop name we use to store info on root element\nvar PROPERTY='__bv_modal_directive__';var getTarget=function getTarget(_ref){var _ref$modifiers=_ref.modifiers,modifiers=_ref$modifiers===void 0?{}:_ref$modifiers,arg=_ref.arg,value=_ref.value;// Try value, then arg, otherwise pick last modifier\nreturn isString(value)?value:isString(arg)?arg:keys(modifiers).reverse()[0];};var getTriggerElement=function getTriggerElement(el){// If root element is a dropdown-item or nav-item, we\n// need to target the inner link or button instead\nreturn el&&matches(el,'.dropdown-menu > li, li.nav-item')?select('a, button',el)||el:el;};var setRole=function setRole(trigger){// Ensure accessibility on non button elements\nif(trigger&&trigger.tagName!=='BUTTON'){// Only set a role if the trigger element doesn't have one\nif(!hasAttr(trigger,'role')){setAttr(trigger,'role','button');}// Add a tabindex is not a button or link, and tabindex is not provided\nif(trigger.tagName!=='A'&&!hasAttr(trigger,'tabindex')){setAttr(trigger,'tabindex','0');}}};var bind=function bind(el,binding,vnode){var target=getTarget(binding);var trigger=getTriggerElement(el);if(target&&trigger){var handler=function handler(event){// `currentTarget` is the element with the listener on it\nvar currentTarget=event.currentTarget;if(!isDisabled(currentTarget)){var type=event.type;var key=event.keyCode;// Open modal only if trigger is not disabled\nif(type==='click'||type==='keydown'&&(key===CODE_ENTER||key===CODE_SPACE)){vnode.context.$root.$emit(ROOT_ACTION_EVENT_NAME_SHOW,target,currentTarget);}}};el[PROPERTY]={handler:handler,target:target,trigger:trigger};// If element is not a button, we add `role=\"button\"` for accessibility\nsetRole(trigger);// Listen for click events\neventOn(trigger,'click',handler,EVENT_OPTIONS_PASSIVE);if(trigger.tagName!=='BUTTON'&&getAttr(trigger,'role')==='button'){// If trigger isn't a button but has role button,\n// we also listen for `keydown.space` && `keydown.enter`\neventOn(trigger,'keydown',handler,EVENT_OPTIONS_PASSIVE);}}};var unbind=function unbind(el){var oldProp=el[PROPERTY]||{};var trigger=oldProp.trigger;var handler=oldProp.handler;if(trigger&&handler){eventOff(trigger,'click',handler,EVENT_OPTIONS_PASSIVE);eventOff(trigger,'keydown',handler,EVENT_OPTIONS_PASSIVE);eventOff(el,'click',handler,EVENT_OPTIONS_PASSIVE);eventOff(el,'keydown',handler,EVENT_OPTIONS_PASSIVE);}delete el[PROPERTY];};var componentUpdated=function componentUpdated(el,binding,vnode){var oldProp=el[PROPERTY]||{};var target=getTarget(binding);var trigger=getTriggerElement(el);if(target!==oldProp.target||trigger!==oldProp.trigger){// We bind and rebind if the target or trigger changes\nunbind(el);bind(el,binding,vnode);}// If trigger element is not a button, ensure `role=\"button\"`\n// is still set for accessibility\nsetRole(trigger);};var updated=function updated(){};/*\n   * Export our directive\n   */var VBModal={inserted:componentUpdated,updated:updated,componentUpdated:componentUpdated,unbind:unbind};var PROP_NAME$1='$bvModal';var PROP_NAME_PRIV$1='_bv__modal';// Base modal props that are allowed\n// Some may be ignored or overridden on some message boxes\n// Prop ID is allowed, but really only should be used for testing\n// We need to add it in explicitly as it comes from the `idMixin`\nvar BASE_PROPS$1=['id'].concat(_toConsumableArray$1(keys(omit(props$V,['busy','lazy','noStacking','static','visible']))));// Fallback event resolver (returns undefined)\nvar defaultResolver=function defaultResolver(){};// Map prop names to modal slot names\nvar propsToSlots$1={msgBoxContent:'default',title:'modal-title',okTitle:'modal-ok',cancelTitle:'modal-cancel'};// --- Helper methods ---\n// Method to filter only recognized props that are not undefined\nvar filterOptions$1=function filterOptions(options){return BASE_PROPS$1.reduce(function(memo,key){if(!isUndefined(options[key])){memo[key]=options[key];}return memo;},{});};// Method to install `$bvModal` VM injection\nvar plugin$1=function plugin(Vue){// Create a private sub-component that extends BModal\n// which self-destructs after hidden\n// @vue/component\nvar BMsgBox=Vue.extend({name:NAME_MSG_BOX,extends:BModal,destroyed:function destroyed(){// Make sure we not in document any more\nif(this.$el&&this.$el.parentNode){this.$el.parentNode.removeChild(this.$el);}},mounted:function mounted(){var _this=this;// Self destruct handler\nvar handleDestroy=function handleDestroy(){_this.$nextTick(function(){// In a `requestAF()` to release control back to application\nrequestAF(function(){_this.$destroy();});});};// Self destruct if parent destroyed\nthis.$parent.$once(HOOK_EVENT_NAME_DESTROYED,handleDestroy);// Self destruct after hidden\nthis.$once(EVENT_NAME_HIDDEN,handleDestroy);// Self destruct on route change\n/* istanbul ignore if */if(this.$router&&this.$route){// Destroy ourselves if route changes\n/* istanbul ignore next */this.$once(HOOK_EVENT_NAME_BEFORE_DESTROY,this.$watch('$router',handleDestroy));}// Show the `BMsgBox`\nthis.show();}});// Method to generate the on-demand modal message box\n// Returns a promise that resolves to a value returned by the resolve\nvar asyncMsgBox=function asyncMsgBox($parent,props){var resolver=arguments.length>2&&arguments[2]!==undefined?arguments[2]:defaultResolver;if(warnNotClient(PROP_NAME$1)||warnNoPromiseSupport(PROP_NAME$1)){/* istanbul ignore next */return;}// Create an instance of `BMsgBox` component\nvar msgBox=new BMsgBox({// We set parent as the local VM so these modals can emit events on\n// the app `$root`, as needed by things like tooltips and popovers\n// And it helps to ensure `BMsgBox` is destroyed when parent is destroyed\nparent:$parent,// Preset the prop values\npropsData:_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},filterOptions$1(getComponentConfig(NAME_MODAL))),{},{// Defaults that user can override\nhideHeaderClose:true,hideHeader:!(props.title||props.titleHtml)},omit(props,keys(propsToSlots$1))),{},{// Props that can't be overridden\nlazy:false,busy:false,visible:false,noStacking:false,noEnforceFocus:false})});// Convert certain props to scoped slots\nkeys(propsToSlots$1).forEach(function(prop){if(!isUndefined(props[prop])){// Can be a string, or array of VNodes.\n// Alternatively, user can use HTML version of prop to pass an HTML string.\nmsgBox.$slots[propsToSlots$1[prop]]=concat(props[prop]);}});// Return a promise that resolves when hidden, or rejects on destroyed\nreturn new Promise(function(resolve,reject){var resolved=false;msgBox.$once(HOOK_EVENT_NAME_DESTROYED,function(){if(!resolved){/* istanbul ignore next */reject(new Error('BootstrapVue MsgBox destroyed before resolve'));}});msgBox.$on(EVENT_NAME_HIDE,function(bvModalEvent){if(!bvModalEvent.defaultPrevented){var result=resolver(bvModalEvent);// If resolver didn't cancel hide, we resolve\nif(!bvModalEvent.defaultPrevented){resolved=true;resolve(result);}}});// Create a mount point (a DIV) and mount the msgBo which will trigger it to show\nvar div=document.createElement('div');document.body.appendChild(div);msgBox.$mount(div);});};// Private utility method to open a user defined message box and returns a promise.\n// Not to be used directly by consumers, as this method may change calling syntax\nvar makeMsgBox=function makeMsgBox($parent,content){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var resolver=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;if(!content||warnNoPromiseSupport(PROP_NAME$1)||warnNotClient(PROP_NAME$1)||!isFunction$1(resolver)){/* istanbul ignore next */return;}return asyncMsgBox($parent,_objectSpread2$3(_objectSpread2$3({},filterOptions$1(options)),{},{msgBoxContent:content}),resolver);};// BvModal instance class\nvar BvModal=/*#__PURE__*/function(){function BvModal(vm){_classCallCheck(this,BvModal);// Assign the new properties to this instance\nassign(this,{_vm:vm,_root:vm.$root});// Set these properties as read-only and non-enumerable\ndefineProperties(this,{_vm:readonlyDescriptor(),_root:readonlyDescriptor()});}// --- Instance methods ---\n// Show modal with the specified ID args are for future use\n_createClass(BvModal,[{key:\"show\",value:function show(id){if(id&&this._root){var _this$_root;for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}(_this$_root=this._root).$emit.apply(_this$_root,[getRootActionEventName(NAME_MODAL,'show'),id].concat(args));}}// Hide modal with the specified ID args are for future use\n},{key:\"hide\",value:function hide(id){if(id&&this._root){var _this$_root2;for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}(_this$_root2=this._root).$emit.apply(_this$_root2,[getRootActionEventName(NAME_MODAL,'hide'),id].concat(args));}}// The following methods require Promise support!\n// IE 11 and others do not support Promise natively, so users\n// should have a Polyfill loaded (which they need anyways for IE 11 support)\n// Open a message box with OK button only and returns a promise\n},{key:\"msgBoxOk\",value:function msgBoxOk(message){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};// Pick the modal props we support from options\nvar props=_objectSpread2$3(_objectSpread2$3({},options),{},{// Add in overrides and our content prop\nokOnly:true,okDisabled:false,hideFooter:false,msgBoxContent:message});return makeMsgBox(this._vm,message,props,function(){// Always resolve to true for OK\nreturn true;});}// Open a message box modal with OK and CANCEL buttons\n// and returns a promise\n},{key:\"msgBoxConfirm\",value:function msgBoxConfirm(message){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};// Set the modal props we support from options\nvar props=_objectSpread2$3(_objectSpread2$3({},options),{},{// Add in overrides and our content prop\nokOnly:false,okDisabled:false,cancelDisabled:false,hideFooter:false});return makeMsgBox(this._vm,message,props,function(bvModalEvent){var trigger=bvModalEvent.trigger;return trigger==='ok'?true:trigger==='cancel'?false:null;});}}]);return BvModal;}();// Add our instance mixin\nVue.mixin({beforeCreate:function beforeCreate(){// Because we need access to `$root` for `$emits`, and VM for parenting,\n// we have to create a fresh instance of `BvModal` for each VM\nthis[PROP_NAME_PRIV$1]=new BvModal(this);}});// Define our read-only `$bvModal` instance property\n// Placed in an if just in case in HMR mode\nif(!hasOwnProperty(Vue.prototype,PROP_NAME$1)){defineProperty$1(Vue.prototype,PROP_NAME$1,{get:function get(){/* istanbul ignore next */if(!this||!this[PROP_NAME_PRIV$1]){warn(\"\\\"\".concat(PROP_NAME$1,\"\\\" must be accessed from a Vue instance \\\"this\\\" context.\"),NAME_MODAL);}return this[PROP_NAME_PRIV$1];}});}};var BVModalPlugin=/*#__PURE__*/pluginFactory({plugins:{plugin:plugin$1}});var ModalPlugin=/*#__PURE__*/pluginFactory({components:{BModal:BModal},directives:{VBModal:VBModal},// $bvModal injection\nplugins:{BVModalPlugin:BVModalPlugin}});var computeJustifyContent$1=function computeJustifyContent(value){value=value==='left'?'start':value==='right'?'end':value;return\"justify-content-\".concat(value);};// --- Props ---\nvar props$U=makePropsConfigurable({align:makeProp(PROP_TYPE_STRING),// Set to `true` if placing in a card header\ncardHeader:makeProp(PROP_TYPE_BOOLEAN,false),fill:makeProp(PROP_TYPE_BOOLEAN,false),justified:makeProp(PROP_TYPE_BOOLEAN,false),pills:makeProp(PROP_TYPE_BOOLEAN,false),small:makeProp(PROP_TYPE_BOOLEAN,false),tabs:makeProp(PROP_TYPE_BOOLEAN,false),tag:makeProp(PROP_TYPE_STRING,'ul'),vertical:makeProp(PROP_TYPE_BOOLEAN,false)},NAME_NAV);// --- Main component ---\n// @vue/component\nvar BNav=/*#__PURE__*/Vue__default['default'].extend({name:NAME_NAV,functional:true,props:props$U,render:function render(h,_ref){var _class;var props=_ref.props,data=_ref.data,children=_ref.children;var tabs=props.tabs,pills=props.pills,vertical=props.vertical,align=props.align,cardHeader=props.cardHeader;return h(props.tag,a(data,{staticClass:'nav',class:(_class={'nav-tabs':tabs,'nav-pills':pills&&!tabs,'card-header-tabs':!vertical&&cardHeader&&tabs,'card-header-pills':!vertical&&cardHeader&&pills&&!tabs,'flex-column':vertical,'nav-fill':!vertical&&props.fill,'nav-justified':!vertical&&props.justified},_defineProperty(_class,computeJustifyContent$1(align),!vertical&&align),_defineProperty(_class,\"small\",props.small),_class)}),children);}});var linkProps$2=omit(props$2f,['event','routerTag']);var props$T=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},linkProps$2),{},{linkAttrs:makeProp(PROP_TYPE_OBJECT,{}),linkClasses:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)})),NAME_NAV_ITEM);// --- Main component ---\n// @vue/component\nvar BNavItem=/*#__PURE__*/Vue__default['default'].extend({name:NAME_NAV_ITEM,functional:true,props:props$T,render:function render(h,_ref){var props=_ref.props,data=_ref.data,listeners=_ref.listeners,children=_ref.children;return h('li',a(omit(data,['on']),{staticClass:'nav-item'}),[h(BLink,{staticClass:'nav-link',class:props.linkClasses,attrs:props.linkAttrs,props:pluckProps(linkProps$2,props),on:listeners},children)]);}});var props$S={};// --- Main component ---\n// @vue/component\nvar BNavText=/*#__PURE__*/Vue__default['default'].extend({name:NAME_NAV_TEXT,functional:true,props:props$S,render:function render(h,_ref){var data=_ref.data,children=_ref.children;return h('li',a(data,{staticClass:'navbar-text'}),children);}});var formProps=omit(props$1I,['inline']);var props$R=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},formProps),{},{formClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)})),NAME_NAV_FORM);// --- Main component ---\n// @vue/component\nvar BNavForm=/*#__PURE__*/Vue__default['default'].extend({name:NAME_NAV_FORM,functional:true,props:props$R,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children,listeners=_ref.listeners;var $form=h(BForm,{class:props.formClass,props:_objectSpread2$3(_objectSpread2$3({},pluckProps(formProps,props)),{},{inline:true}),attrs:data.attrs,on:listeners},children);return h('li',a(omit(data,['attrs','on']),{staticClass:'form-inline'}),[$form]);}});var props$Q=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},props$25),pick$1(props$1N,[].concat(_toConsumableArray$1(keys(props$1O)),['html','lazy','menuClass','noCaret','role','text','toggleClass'])))),NAME_NAV_ITEM_DROPDOWN);// --- Main component ---\n// @vue/component\nvar BNavItemDropdown=/*#__PURE__*/Vue__default['default'].extend({name:NAME_NAV_ITEM_DROPDOWN,mixins:[idMixin,dropdownMixin,normalizeSlotMixin],props:props$Q,computed:{toggleId:function toggleId(){return this.safeId('_BV_toggle_');},menuId:function menuId(){return this.safeId('_BV_toggle_menu_');},dropdownClasses:function dropdownClasses(){return[this.directionClass,this.boundaryClass,{show:this.visible}];},menuClasses:function menuClasses(){return[this.menuClass,{'dropdown-menu-right':this.right,show:this.visible}];},toggleClasses:function toggleClasses(){return[this.toggleClass,{'dropdown-toggle-no-caret':this.noCaret}];}},render:function render(h){var toggleId=this.toggleId,menuId=this.menuId,visible=this.visible,hide=this.hide;var $toggle=h(BLink,{staticClass:'nav-link dropdown-toggle',class:this.toggleClasses,props:{href:\"#\".concat(this.id||''),disabled:this.disabled},attrs:{id:toggleId,role:'button','aria-haspopup':'true','aria-expanded':visible?'true':'false','aria-controls':menuId},on:{mousedown:this.onMousedown,click:this.toggle,keydown:this.toggle// Handle ENTER, SPACE and DOWN\n},ref:'toggle'},[// TODO: The `text` slot is deprecated in favor of the `button-content` slot\nthis.normalizeSlot([SLOT_NAME_BUTTON_CONTENT,SLOT_NAME_TEXT])||h('span',{domProps:htmlOrText(this.html,this.text)})]);var $menu=h('ul',{staticClass:'dropdown-menu',class:this.menuClasses,attrs:{tabindex:'-1','aria-labelledby':toggleId,id:menuId},on:{keydown:this.onKeydown// Handle UP, DOWN and ESC\n},ref:'menu'},!this.lazy||visible?this.normalizeSlot(SLOT_NAME_DEFAULT,{hide:hide}):[h()]);return h('li',{staticClass:'nav-item b-nav-dropdown dropdown',class:this.dropdownClasses,attrs:{id:this.safeId()}},[$toggle,$menu]);}});var NavPlugin=/*#__PURE__*/pluginFactory({components:{BNav:BNav,BNavItem:BNavItem,BNavText:BNavText,BNavForm:BNavForm,BNavItemDropdown:BNavItemDropdown,BNavItemDd:BNavItemDropdown,BNavDropdown:BNavItemDropdown,BNavDd:BNavItemDropdown},plugins:{DropdownPlugin:DropdownPlugin}});var props$P=makePropsConfigurable({fixed:makeProp(PROP_TYPE_STRING),print:makeProp(PROP_TYPE_BOOLEAN,false),sticky:makeProp(PROP_TYPE_BOOLEAN,false),tag:makeProp(PROP_TYPE_STRING,'nav'),toggleable:makeProp(PROP_TYPE_BOOLEAN_STRING,false),type:makeProp(PROP_TYPE_STRING,'light'),variant:makeProp(PROP_TYPE_STRING)},NAME_NAVBAR);// --- Main component ---\n// @vue/component\nvar BNavbar=/*#__PURE__*/Vue__default['default'].extend({name:NAME_NAVBAR,mixins:[normalizeSlotMixin],provide:function provide(){return{bvNavbar:this};},props:props$P,computed:{breakpointClass:function breakpointClass(){var toggleable=this.toggleable;var xs=getBreakpoints()[0];var breakpoint=null;if(toggleable&&isString(toggleable)&&toggleable!==xs){breakpoint=\"navbar-expand-\".concat(toggleable);}else if(toggleable===false){breakpoint='navbar-expand';}return breakpoint;}},render:function render(h){var _ref;var tag=this.tag,type=this.type,variant=this.variant,fixed=this.fixed;return h(tag,{staticClass:'navbar',class:[(_ref={'d-print':this.print,'sticky-top':this.sticky},_defineProperty(_ref,\"navbar-\".concat(type),type),_defineProperty(_ref,\"bg-\".concat(variant),variant),_defineProperty(_ref,\"fixed-\".concat(fixed),fixed),_ref),this.breakpointClass],attrs:{role:isTag(tag,'nav')?null:'navigation'}},[this.normalizeSlot()]);}});var computeJustifyContent=function computeJustifyContent(value){value=value==='left'?'start':value==='right'?'end':value;return\"justify-content-\".concat(value);};// --- Props ---\nvar props$O=makePropsConfigurable(pick$1(props$U,['tag','fill','justified','align','small']),NAME_NAVBAR_NAV);// --- Main component ---\n// @vue/component\nvar BNavbarNav=/*#__PURE__*/Vue__default['default'].extend({name:NAME_NAVBAR_NAV,functional:true,props:props$O,render:function render(h,_ref){var _class;var props=_ref.props,data=_ref.data,children=_ref.children;var align=props.align;return h(props.tag,a(data,{staticClass:'navbar-nav',class:(_class={'nav-fill':props.fill,'nav-justified':props.justified},_defineProperty(_class,computeJustifyContent(align),align),_defineProperty(_class,\"small\",props.small),_class)}),children);}});var linkProps$1=omit(props$2f,['event','routerTag']);linkProps$1.href.default=undefined;linkProps$1.to.default=undefined;var props$N=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},linkProps$1),{},{tag:makeProp(PROP_TYPE_STRING,'div')})),NAME_NAVBAR_BRAND);// --- Main component ---\n// @vue/component\nvar BNavbarBrand=/*#__PURE__*/Vue__default['default'].extend({name:NAME_NAVBAR_BRAND,functional:true,props:props$N,render:function render(h,_ref){var props=_ref.props,data=_ref.data,children=_ref.children;var isLink=props.to||props.href;var tag=isLink?BLink:props.tag;return h(tag,a(data,{staticClass:'navbar-brand',props:isLink?pluckProps(linkProps$1,props):{}}),children);}});var CLASS_NAME$1='navbar-toggler';var ROOT_EVENT_NAME_STATE$1=getRootEventName(NAME_COLLAPSE,'state');var ROOT_EVENT_NAME_SYNC_STATE$1=getRootEventName(NAME_COLLAPSE,'sync-state');// --- Props ---\nvar props$M=makePropsConfigurable({disabled:makeProp(PROP_TYPE_BOOLEAN,false),label:makeProp(PROP_TYPE_STRING,'Toggle navigation'),target:makeProp(PROP_TYPE_ARRAY_STRING,undefined,true)// Required\n},NAME_NAVBAR_TOGGLE);// --- Main component ---\n// @vue/component\nvar BNavbarToggle=/*#__PURE__*/Vue__default['default'].extend({name:NAME_NAVBAR_TOGGLE,directives:{VBToggle:VBToggle},mixins:[listenOnRootMixin,normalizeSlotMixin],props:props$M,data:function data(){return{toggleState:false};},created:function created(){this.listenOnRoot(ROOT_EVENT_NAME_STATE$1,this.handleStateEvent);this.listenOnRoot(ROOT_EVENT_NAME_SYNC_STATE$1,this.handleStateEvent);},methods:{onClick:function onClick(event){if(!this.disabled){// Emit courtesy `click` event\nthis.$emit(EVENT_NAME_CLICK,event);}},handleStateEvent:function handleStateEvent(id,state){// We listen for state events so that we can pass the\n// boolean expanded state to the default scoped slot\nif(id===this.target){this.toggleState=state;}}},render:function render(h){var disabled=this.disabled;return h('button',{staticClass:CLASS_NAME$1,class:{disabled:disabled},directives:[{name:'VBToggle',value:this.target}],attrs:{type:'button',disabled:disabled,'aria-label':this.label},on:{click:this.onClick}},[this.normalizeSlot(SLOT_NAME_DEFAULT,{expanded:this.toggleState})||h('span',{staticClass:\"\".concat(CLASS_NAME$1,\"-icon\")})]);}});var NavbarPlugin=/*#__PURE__*/pluginFactory({components:{BNavbar:BNavbar,BNavbarNav:BNavbarNav,BNavbarBrand:BNavbarBrand,BNavbarToggle:BNavbarToggle,BNavToggle:BNavbarToggle},plugins:{NavPlugin:NavPlugin,CollapsePlugin:CollapsePlugin,DropdownPlugin:DropdownPlugin}});var props$L=makePropsConfigurable({label:makeProp(PROP_TYPE_STRING),role:makeProp(PROP_TYPE_STRING,'status'),small:makeProp(PROP_TYPE_BOOLEAN,false),tag:makeProp(PROP_TYPE_STRING,'span'),type:makeProp(PROP_TYPE_STRING,'border'),variant:makeProp(PROP_TYPE_STRING)},NAME_SPINNER);// --- Main component ---\n// @vue/component\nvar BSpinner=/*#__PURE__*/Vue__default['default'].extend({name:NAME_SPINNER,functional:true,props:props$L,render:function render(h,_ref){var _class;var props=_ref.props,data=_ref.data,slots=_ref.slots,scopedSlots=_ref.scopedSlots;var $slots=slots();var $scopedSlots=scopedSlots||{};var $label=normalizeSlot(SLOT_NAME_LABEL,{},$scopedSlots,$slots)||props.label;if($label){$label=h('span',{staticClass:'sr-only'},$label);}return h(props.tag,a(data,{attrs:{role:$label?props.role||'status':null,'aria-hidden':$label?null:'true'},class:(_class={},_defineProperty(_class,\"spinner-\".concat(props.type),props.type),_defineProperty(_class,\"spinner-\".concat(props.type,\"-sm\"),props.small),_defineProperty(_class,\"text-\".concat(props.variant),props.variant),_class)}),[$label||h()]);}});var POSITION_COVER={top:0,left:0,bottom:0,right:0};// --- Props ---\nvar props$K=makePropsConfigurable({// Alternative to variant, allowing a specific\n// CSS color to be applied to the overlay\nbgColor:makeProp(PROP_TYPE_STRING),blur:makeProp(PROP_TYPE_STRING,'2px'),fixed:makeProp(PROP_TYPE_BOOLEAN,false),noCenter:makeProp(PROP_TYPE_BOOLEAN,false),noFade:makeProp(PROP_TYPE_BOOLEAN,false),// If `true, does not render the default slot\n// and switches to absolute positioning\nnoWrap:makeProp(PROP_TYPE_BOOLEAN,false),opacity:makeProp(PROP_TYPE_NUMBER_STRING,0.85,function(value){var number=toFloat(value,0);return number>=0&&number<=1;}),overlayTag:makeProp(PROP_TYPE_STRING,'div'),rounded:makeProp(PROP_TYPE_BOOLEAN_STRING,false),show:makeProp(PROP_TYPE_BOOLEAN,false),spinnerSmall:makeProp(PROP_TYPE_BOOLEAN,false),spinnerType:makeProp(PROP_TYPE_STRING,'border'),spinnerVariant:makeProp(PROP_TYPE_STRING),variant:makeProp(PROP_TYPE_STRING,'light'),wrapTag:makeProp(PROP_TYPE_STRING,'div'),zIndex:makeProp(PROP_TYPE_NUMBER_STRING,10)},NAME_OVERLAY);// --- Main component ---\n// @vue/component\nvar BOverlay=/*#__PURE__*/Vue__default['default'].extend({name:NAME_OVERLAY,mixins:[normalizeSlotMixin],props:props$K,computed:{computedRounded:function computedRounded(){var rounded=this.rounded;return rounded===true||rounded===''?'rounded':!rounded?'':\"rounded-\".concat(rounded);},computedVariant:function computedVariant(){var variant=this.variant;return variant&&!this.bgColor?\"bg-\".concat(variant):'';},slotScope:function slotScope(){return{spinnerType:this.spinnerType||null,spinnerVariant:this.spinnerVariant||null,spinnerSmall:this.spinnerSmall};}},methods:{defaultOverlayFn:function defaultOverlayFn(_ref){var spinnerType=_ref.spinnerType,spinnerVariant=_ref.spinnerVariant,spinnerSmall=_ref.spinnerSmall;return this.$createElement(BSpinner,{props:{type:spinnerType,variant:spinnerVariant,small:spinnerSmall}});}},render:function render(h){var _this=this;var show=this.show,fixed=this.fixed,noFade=this.noFade,noWrap=this.noWrap,slotScope=this.slotScope;var $overlay=h();if(show){var $background=h('div',{staticClass:'position-absolute',class:[this.computedVariant,this.computedRounded],style:_objectSpread2$3(_objectSpread2$3({},POSITION_COVER),{},{opacity:this.opacity,backgroundColor:this.bgColor||null,backdropFilter:this.blur?\"blur(\".concat(this.blur,\")\"):null})});var $content=h('div',{staticClass:'position-absolute',style:this.noCenter?/* istanbul ignore next */_objectSpread2$3({},POSITION_COVER):{top:'50%',left:'50%',transform:'translateX(-50%) translateY(-50%)'}},[this.normalizeSlot(SLOT_NAME_OVERLAY,slotScope)||this.defaultOverlayFn(slotScope)]);$overlay=h(this.overlayTag,{staticClass:'b-overlay',class:{'position-absolute':!noWrap||noWrap&&!fixed,'position-fixed':noWrap&&fixed},style:_objectSpread2$3(_objectSpread2$3({},POSITION_COVER),{},{zIndex:this.zIndex||10}),on:{click:function click(event){return _this.$emit(EVENT_NAME_CLICK,event);}},key:'overlay'},[$background,$content]);}// Wrap in a fade transition\n$overlay=h(BVTransition,{props:{noFade:noFade,appear:true},on:{'after-enter':function afterEnter(){return _this.$emit(EVENT_NAME_SHOWN);},'after-leave':function afterLeave(){return _this.$emit(EVENT_NAME_HIDDEN);}}},[$overlay]);if(noWrap){return $overlay;}return h(this.wrapTag,{staticClass:'b-overlay-wrap position-relative',attrs:{'aria-busy':show?'true':null}},noWrap?[$overlay]:[this.normalizeSlot(),$overlay]);}});var OverlayPlugin=/*#__PURE__*/pluginFactory({components:{BOverlay:BOverlay}});var _watch$6;// for `<b-pagination>` and `<b-pagination-nav>`\n// --- Constants ---\nvar _makeModelMixin$4=makeModelMixin('value',{type:PROP_TYPE_BOOLEAN_NUMBER_STRING,defaultValue:null,/* istanbul ignore next */validator:function validator(value){if(!isNull(value)&&toInteger(value,0)<1){warn('\"v-model\" value must be a number greater than \"0\"',NAME_PAGINATION);return false;}return true;}}),modelMixin$4=_makeModelMixin$4.mixin,modelProps$4=_makeModelMixin$4.props,MODEL_PROP_NAME$4=_makeModelMixin$4.prop,MODEL_EVENT_NAME$4=_makeModelMixin$4.event;var ELLIPSIS_THRESHOLD=3;// Default # of buttons limit\nvar DEFAULT_LIMIT=5;// --- Helper methods ---\n// Make an array of N to N+X\nvar makePageArray=function makePageArray(startNumber,numberOfPages){return createArray(numberOfPages,function(_,i){return{number:startNumber+i,classes:null};});};// Sanitize the provided limit value (converting to a number)\nvar sanitizeLimit=function sanitizeLimit(value){var limit=toInteger(value)||1;return limit<1?DEFAULT_LIMIT:limit;};// Sanitize the provided current page number (converting to a number)\nvar sanitizeCurrentPage=function sanitizeCurrentPage(val,numberOfPages){var page=toInteger(val)||1;return page>numberOfPages?numberOfPages:page<1?1:page;};// Links don't normally respond to SPACE, so we add that\n// functionality via this handler\nvar onSpaceKey=function onSpaceKey(event){if(event.keyCode===CODE_SPACE){// Stop page from scrolling\nstopEvent(event,{immediatePropagation:true});// Trigger the click event on the link\nevent.currentTarget.click();return false;}};// --- Props ---\nvar props$J=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},modelProps$4),{},{align:makeProp(PROP_TYPE_STRING,'left'),ariaLabel:makeProp(PROP_TYPE_STRING,'Pagination'),disabled:makeProp(PROP_TYPE_BOOLEAN,false),ellipsisClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),ellipsisText:makeProp(PROP_TYPE_STRING,\"\\u2026\"),// ''\nfirstClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),firstNumber:makeProp(PROP_TYPE_BOOLEAN,false),firstText:makeProp(PROP_TYPE_STRING,\"\\xAB\"),// ''\nhideEllipsis:makeProp(PROP_TYPE_BOOLEAN,false),hideGotoEndButtons:makeProp(PROP_TYPE_BOOLEAN,false),labelFirstPage:makeProp(PROP_TYPE_STRING,'Go to first page'),labelLastPage:makeProp(PROP_TYPE_STRING,'Go to last page'),labelNextPage:makeProp(PROP_TYPE_STRING,'Go to next page'),labelPage:makeProp(PROP_TYPE_FUNCTION_STRING,'Go to page'),labelPrevPage:makeProp(PROP_TYPE_STRING,'Go to previous page'),lastClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),lastNumber:makeProp(PROP_TYPE_BOOLEAN,false),lastText:makeProp(PROP_TYPE_STRING,\"\\xBB\"),// ''\nlimit:makeProp(PROP_TYPE_NUMBER_STRING,DEFAULT_LIMIT,/* istanbul ignore next */function(value){if(toInteger(value,0)<1){warn('Prop \"limit\" must be a number greater than \"0\"',NAME_PAGINATION);return false;}return true;}),nextClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),nextText:makeProp(PROP_TYPE_STRING,\"\\u203A\"),// ''\npageClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),pills:makeProp(PROP_TYPE_BOOLEAN,false),prevClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),prevText:makeProp(PROP_TYPE_STRING,\"\\u2039\"),// ''\nsize:makeProp(PROP_TYPE_STRING)})),'pagination');// --- Mixin ---\n// @vue/component\nvar paginationMixin$1=Vue__default['default'].extend({mixins:[modelMixin$4,normalizeSlotMixin],props:props$J,data:function data(){// `-1` signifies no page initially selected\nvar currentPage=toInteger(this[MODEL_PROP_NAME$4],0);currentPage=currentPage>0?currentPage:-1;return{currentPage:currentPage,localNumberOfPages:1,localLimit:DEFAULT_LIMIT};},computed:{btnSize:function btnSize(){var size=this.size;return size?\"pagination-\".concat(size):'';},alignment:function alignment(){var align=this.align;if(align==='center'){return'justify-content-center';}else if(align==='end'||align==='right'){return'justify-content-end';}else if(align==='fill'){// The page-items will also have 'flex-fill' added\n// We add text centering to make the button appearance better in fill mode\nreturn'text-center';}return'';},styleClass:function styleClass(){return this.pills?'b-pagination-pills':'';},computedCurrentPage:function computedCurrentPage(){return sanitizeCurrentPage(this.currentPage,this.localNumberOfPages);},paginationParams:function paginationParams(){// Determine if we should show the the ellipsis\nvar limit=this.localLimit,numberOfPages=this.localNumberOfPages,currentPage=this.computedCurrentPage,hideEllipsis=this.hideEllipsis,firstNumber=this.firstNumber,lastNumber=this.lastNumber;var showFirstDots=false;var showLastDots=false;var numberOfLinks=limit;var startNumber=1;if(numberOfPages<=limit){// Special case: Less pages available than the limit of displayed pages\nnumberOfLinks=numberOfPages;}else if(currentPage<limit-1&&limit>ELLIPSIS_THRESHOLD){if(!hideEllipsis||lastNumber){showLastDots=true;numberOfLinks=limit-(firstNumber?0:1);}numberOfLinks=mathMin(numberOfLinks,limit);}else if(numberOfPages-currentPage+2<limit&&limit>ELLIPSIS_THRESHOLD){if(!hideEllipsis||firstNumber){showFirstDots=true;numberOfLinks=limit-(lastNumber?0:1);}startNumber=numberOfPages-numberOfLinks+1;}else{// We are somewhere in the middle of the page list\nif(limit>ELLIPSIS_THRESHOLD){numberOfLinks=limit-(hideEllipsis?0:2);showFirstDots=!!(!hideEllipsis||firstNumber);showLastDots=!!(!hideEllipsis||lastNumber);}startNumber=currentPage-mathFloor(numberOfLinks/2);}// Sanity checks\n/* istanbul ignore if */if(startNumber<1){startNumber=1;showFirstDots=false;}else if(startNumber>numberOfPages-numberOfLinks){startNumber=numberOfPages-numberOfLinks+1;showLastDots=false;}if(showFirstDots&&firstNumber&&startNumber<4){numberOfLinks=numberOfLinks+2;startNumber=1;showFirstDots=false;}var lastPageNumber=startNumber+numberOfLinks-1;if(showLastDots&&lastNumber&&lastPageNumber>numberOfPages-3){numberOfLinks=numberOfLinks+(lastPageNumber===numberOfPages-2?2:3);showLastDots=false;}// Special handling for lower limits (where ellipsis are never shown)\nif(limit<=ELLIPSIS_THRESHOLD){if(firstNumber&&startNumber===1){numberOfLinks=mathMin(numberOfLinks+1,numberOfPages,limit+1);}else if(lastNumber&&numberOfPages===startNumber+numberOfLinks-1){startNumber=mathMax(startNumber-1,1);numberOfLinks=mathMin(numberOfPages-startNumber+1,numberOfPages,limit+1);}}numberOfLinks=mathMin(numberOfLinks,numberOfPages-startNumber+1);return{showFirstDots:showFirstDots,showLastDots:showLastDots,numberOfLinks:numberOfLinks,startNumber:startNumber};},pageList:function pageList(){// Generates the pageList array\nvar _this$paginationParam=this.paginationParams,numberOfLinks=_this$paginationParam.numberOfLinks,startNumber=_this$paginationParam.startNumber;var currentPage=this.computedCurrentPage;// Generate list of page numbers\nvar pages=makePageArray(startNumber,numberOfLinks);// We limit to a total of 3 page buttons on XS screens\n// So add classes to page links to hide them for XS breakpoint\n// Note: Ellipsis will also be hidden on XS screens\n// TODO: Make this visual limit configurable based on breakpoint(s)\nif(pages.length>3){var idx=currentPage-startNumber;// THe following is a bootstrap-vue custom utility class\nvar classes='bv-d-xs-down-none';if(idx===0){// Keep leftmost 3 buttons visible when current page is first page\nfor(var i=3;i<pages.length;i++){pages[i].classes=classes;}}else if(idx===pages.length-1){// Keep rightmost 3 buttons visible when current page is last page\nfor(var _i=0;_i<pages.length-3;_i++){pages[_i].classes=classes;}}else{// Hide all except current page, current page - 1 and current page + 1\nfor(var _i2=0;_i2<idx-1;_i2++){// hide some left button(s)\npages[_i2].classes=classes;}for(var _i3=pages.length-1;_i3>idx+1;_i3--){// hide some right button(s)\npages[_i3].classes=classes;}}}return pages;}},watch:(_watch$6={},_defineProperty(_watch$6,MODEL_PROP_NAME$4,function(newValue,oldValue){if(newValue!==oldValue){this.currentPage=sanitizeCurrentPage(newValue,this.localNumberOfPages);}}),_defineProperty(_watch$6,\"currentPage\",function currentPage(newValue,oldValue){if(newValue!==oldValue){// Emit `null` if no page selected\nthis.$emit(MODEL_EVENT_NAME$4,newValue>0?newValue:null);}}),_defineProperty(_watch$6,\"limit\",function limit(newValue,oldValue){if(newValue!==oldValue){this.localLimit=sanitizeLimit(newValue);}}),_watch$6),created:function created(){var _this=this;// Set our default values in data\nthis.localLimit=sanitizeLimit(this.limit);this.$nextTick(function(){// Sanity check\n_this.currentPage=_this.currentPage>_this.localNumberOfPages?_this.localNumberOfPages:_this.currentPage;});},methods:{handleKeyNav:function handleKeyNav(event){var keyCode=event.keyCode,shiftKey=event.shiftKey;/* istanbul ignore if */if(this.isNav){// We disable left/right keyboard navigation in `<b-pagination-nav>`\nreturn;}if(keyCode===CODE_LEFT||keyCode===CODE_UP){stopEvent(event,{propagation:false});shiftKey?this.focusFirst():this.focusPrev();}else if(keyCode===CODE_RIGHT||keyCode===CODE_DOWN){stopEvent(event,{propagation:false});shiftKey?this.focusLast():this.focusNext();}},getButtons:function getButtons(){// Return only buttons that are visible\nreturn selectAll('button.page-link, a.page-link',this.$el).filter(function(btn){return isVisible(btn);});},focusCurrent:function focusCurrent(){var _this2=this;// We do this in `$nextTick()` to ensure buttons have finished rendering\nthis.$nextTick(function(){var btn=_this2.getButtons().find(function(el){return toInteger(getAttr(el,'aria-posinset'),0)===_this2.computedCurrentPage;});if(!attemptFocus(btn)){// Fallback if current page is not in button list\n_this2.focusFirst();}});},focusFirst:function focusFirst(){var _this3=this;// We do this in `$nextTick()` to ensure buttons have finished rendering\nthis.$nextTick(function(){var btn=_this3.getButtons().find(function(el){return!isDisabled(el);});attemptFocus(btn);});},focusLast:function focusLast(){var _this4=this;// We do this in `$nextTick()` to ensure buttons have finished rendering\nthis.$nextTick(function(){var btn=_this4.getButtons().reverse().find(function(el){return!isDisabled(el);});attemptFocus(btn);});},focusPrev:function focusPrev(){var _this5=this;// We do this in `$nextTick()` to ensure buttons have finished rendering\nthis.$nextTick(function(){var buttons=_this5.getButtons();var index=buttons.indexOf(getActiveElement());if(index>0&&!isDisabled(buttons[index-1])){attemptFocus(buttons[index-1]);}});},focusNext:function focusNext(){var _this6=this;// We do this in `$nextTick()` to ensure buttons have finished rendering\nthis.$nextTick(function(){var buttons=_this6.getButtons();var index=buttons.indexOf(getActiveElement());if(index<buttons.length-1&&!isDisabled(buttons[index+1])){attemptFocus(buttons[index+1]);}});}},render:function render(h){var _this7=this;var disabled=this.disabled,labelPage=this.labelPage,ariaLabel=this.ariaLabel,isNav=this.isNav,numberOfPages=this.localNumberOfPages,currentPage=this.computedCurrentPage;var pageNumbers=this.pageList.map(function(p){return p.number;});var _this$paginationParam2=this.paginationParams,showFirstDots=_this$paginationParam2.showFirstDots,showLastDots=_this$paginationParam2.showLastDots;var fill=this.align==='fill';var $buttons=[];// Helper function and flag\nvar isActivePage=function isActivePage(pageNumber){return pageNumber===currentPage;};var noCurrentPage=this.currentPage<1;// Factory function for prev/next/first/last buttons\nvar makeEndBtn=function makeEndBtn(linkTo,ariaLabel,btnSlot,btnText,btnClass,pageTest,key){var isDisabled=disabled||isActivePage(pageTest)||noCurrentPage||linkTo<1||linkTo>numberOfPages;var pageNumber=linkTo<1?1:linkTo>numberOfPages?numberOfPages:linkTo;var scope={disabled:isDisabled,page:pageNumber,index:pageNumber-1};var $btnContent=_this7.normalizeSlot(btnSlot,scope)||toString(btnText)||h();var $inner=h(isDisabled?'span':isNav?BLink:'button',{staticClass:'page-link',class:{'flex-grow-1':!isNav&&!isDisabled&&fill},props:isDisabled||!isNav?{}:_this7.linkProps(linkTo),attrs:{role:isNav?null:'menuitem',type:isNav||isDisabled?null:'button',tabindex:isDisabled||isNav?null:'-1','aria-label':ariaLabel,'aria-controls':_this7.ariaControls||null,'aria-disabled':isDisabled?'true':null},on:isDisabled?{}:{'!click':function click(event){_this7.onClick(event,linkTo);},keydown:onSpaceKey}},[$btnContent]);return h('li',{key:key,staticClass:'page-item',class:[{disabled:isDisabled,'flex-fill':fill,'d-flex':fill&&!isNav&&!isDisabled},btnClass],attrs:{role:isNav?null:'presentation','aria-hidden':isDisabled?'true':null}},[$inner]);};// Ellipsis factory\nvar makeEllipsis=function makeEllipsis(isLast){return h('li',{staticClass:'page-item',class:['disabled','bv-d-xs-down-none',fill?'flex-fill':'',_this7.ellipsisClass],attrs:{role:'separator'},key:\"ellipsis-\".concat(isLast?'last':'first')},[h('span',{staticClass:'page-link'},[_this7.normalizeSlot(SLOT_NAME_ELLIPSIS_TEXT)||toString(_this7.ellipsisText)||h()])]);};// Page button factory\nvar makePageButton=function makePageButton(page,idx){var pageNumber=page.number;var active=isActivePage(pageNumber)&&!noCurrentPage;// Active page will have tabindex of 0, or if no current page and first page button\nvar tabIndex=disabled?null:active||noCurrentPage&&idx===0?'0':'-1';var attrs={role:isNav?null:'menuitemradio',type:isNav||disabled?null:'button','aria-disabled':disabled?'true':null,'aria-controls':_this7.ariaControls||null,'aria-label':hasPropFunction(labelPage)?/* istanbul ignore next */labelPage(pageNumber):\"\".concat(isFunction$1(labelPage)?labelPage():labelPage,\" \").concat(pageNumber),'aria-checked':isNav?null:active?'true':'false','aria-current':isNav&&active?'page':null,'aria-posinset':isNav?null:pageNumber,'aria-setsize':isNav?null:numberOfPages,// ARIA \"roving tabindex\" method (except in `isNav` mode)\ntabindex:isNav?null:tabIndex};var btnContent=toString(_this7.makePage(pageNumber));var scope={page:pageNumber,index:pageNumber-1,content:btnContent,active:active,disabled:disabled};var $inner=h(disabled?'span':isNav?BLink:'button',{props:disabled||!isNav?{}:_this7.linkProps(pageNumber),staticClass:'page-link',class:{'flex-grow-1':!isNav&&!disabled&&fill},attrs:attrs,on:disabled?{}:{'!click':function click(event){_this7.onClick(event,pageNumber);},keydown:onSpaceKey}},[_this7.normalizeSlot(SLOT_NAME_PAGE,scope)||btnContent]);return h('li',{staticClass:'page-item',class:[{disabled:disabled,active:active,'flex-fill':fill,'d-flex':fill&&!isNav&&!disabled},page.classes,_this7.pageClass],attrs:{role:isNav?null:'presentation'},key:\"page-\".concat(pageNumber)},[$inner]);};// Goto first page button\n// Don't render button when `hideGotoEndButtons` or `firstNumber` is set\nvar $firstPageBtn=h();if(!this.firstNumber&&!this.hideGotoEndButtons){$firstPageBtn=makeEndBtn(1,this.labelFirstPage,SLOT_NAME_FIRST_TEXT,this.firstText,this.firstClass,1,'pagination-goto-first');}$buttons.push($firstPageBtn);// Goto previous page button\n$buttons.push(makeEndBtn(currentPage-1,this.labelPrevPage,SLOT_NAME_PREV_TEXT,this.prevText,this.prevClass,1,'pagination-goto-prev'));// Show first (1) button?\n$buttons.push(this.firstNumber&&pageNumbers[0]!==1?makePageButton({number:1},0):h());// First ellipsis\n$buttons.push(showFirstDots?makeEllipsis(false):h());// Individual page links\nthis.pageList.forEach(function(page,idx){var offset=showFirstDots&&_this7.firstNumber&&pageNumbers[0]!==1?1:0;$buttons.push(makePageButton(page,idx+offset));});// Last ellipsis\n$buttons.push(showLastDots?makeEllipsis(true):h());// Show last page button?\n$buttons.push(this.lastNumber&&pageNumbers[pageNumbers.length-1]!==numberOfPages?makePageButton({number:numberOfPages},-1):h());// Goto next page button\n$buttons.push(makeEndBtn(currentPage+1,this.labelNextPage,SLOT_NAME_NEXT_TEXT,this.nextText,this.nextClass,numberOfPages,'pagination-goto-next'));// Goto last page button\n// Don't render button when `hideGotoEndButtons` or `lastNumber` is set\nvar $lastPageBtn=h();if(!this.lastNumber&&!this.hideGotoEndButtons){$lastPageBtn=makeEndBtn(numberOfPages,this.labelLastPage,SLOT_NAME_LAST_TEXT,this.lastText,this.lastClass,numberOfPages,'pagination-goto-last');}$buttons.push($lastPageBtn);// Assemble the pagination buttons\nvar $pagination=h('ul',{staticClass:'pagination',class:['b-pagination',this.btnSize,this.alignment,this.styleClass],attrs:{role:isNav?null:'menubar','aria-disabled':disabled?'true':'false','aria-label':isNav?null:ariaLabel||null},// We disable keyboard left/right nav when `<b-pagination-nav>`\non:isNav?{}:{keydown:this.handleKeyNav},ref:'ul'},$buttons);// If we are `<b-pagination-nav>`, wrap in `<nav>` wrapper\nif(isNav){return h('nav',{attrs:{'aria-disabled':disabled?'true':null,'aria-hidden':disabled?'true':'false','aria-label':isNav?ariaLabel||null:null}},[$pagination]);}return $pagination;}});var DEFAULT_PER_PAGE=20;var DEFAULT_TOTAL_ROWS=0;// --- Helper methods ---\n// Sanitize the provided per page number (converting to a number)\nvar sanitizePerPage=function sanitizePerPage(value){return mathMax(toInteger(value)||DEFAULT_PER_PAGE,1);};// Sanitize the provided total rows number (converting to a number)\nvar sanitizeTotalRows=function sanitizeTotalRows(value){return mathMax(toInteger(value)||DEFAULT_TOTAL_ROWS,0);};// --- Props ---\nvar props$I=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},props$J),{},{ariaControls:makeProp(PROP_TYPE_STRING),perPage:makeProp(PROP_TYPE_NUMBER_STRING,DEFAULT_PER_PAGE),totalRows:makeProp(PROP_TYPE_NUMBER_STRING,DEFAULT_TOTAL_ROWS)})),NAME_PAGINATION);// --- Main component ---\n// @vue/component\nvar BPagination=/*#__PURE__*/Vue__default['default'].extend({name:NAME_PAGINATION,// The render function is brought in via the `paginationMixin`\nmixins:[paginationMixin$1],props:props$I,computed:{numberOfPages:function numberOfPages(){var result=mathCeil(sanitizeTotalRows(this.totalRows)/sanitizePerPage(this.perPage));return result<1?1:result;},// Used for watching changes to `perPage` and `numberOfPages`\npageSizeNumberOfPages:function pageSizeNumberOfPages(){return{perPage:sanitizePerPage(this.perPage),totalRows:sanitizeTotalRows(this.totalRows),numberOfPages:this.numberOfPages};}},watch:{pageSizeNumberOfPages:function pageSizeNumberOfPages(newValue,oldValue){if(!isUndefinedOrNull(oldValue)){if(newValue.perPage!==oldValue.perPage&&newValue.totalRows===oldValue.totalRows){// If the page size changes, reset to page 1\nthis.currentPage=1;}else if(newValue.numberOfPages!==oldValue.numberOfPages&&this.currentPage>newValue.numberOfPages){// If `numberOfPages` changes and is less than\n// the `currentPage` number, reset to page 1\nthis.currentPage=1;}}this.localNumberOfPages=newValue.numberOfPages;}},created:function created(){var _this=this;// Set the initial page count\nthis.localNumberOfPages=this.numberOfPages;// Set the initial page value\nvar currentPage=toInteger(this[MODEL_PROP_NAME$4],0);if(currentPage>0){this.currentPage=currentPage;}else{this.$nextTick(function(){// If this value parses to `NaN` or a value less than `1`\n// trigger an initial emit of `null` if no page specified\n_this.currentPage=0;});}},methods:{// These methods are used by the render function\nonClick:function onClick(event,pageNumber){var _this2=this;// Dont do anything if clicking the current active page\nif(pageNumber===this.currentPage){return;}var target=event.target;// Emit a user-cancelable `page-click` event\nvar clickEvent=new BvEvent(EVENT_NAME_PAGE_CLICK,{cancelable:true,vueTarget:this,target:target});this.$emit(clickEvent.type,clickEvent,pageNumber);if(clickEvent.defaultPrevented){return;}// Update the `v-model`\nthis.currentPage=pageNumber;// Emit event triggered by user interaction\nthis.$emit(EVENT_NAME_CHANGE,this.currentPage);// Keep the current button focused if possible\nthis.$nextTick(function(){if(isVisible(target)&&_this2.$el.contains(target)){attemptFocus(target);}else{_this2.focusCurrent();}});},makePage:function makePage(pageNum){return pageNum;},/* istanbul ignore next */linkProps:function linkProps(){// No props, since we render a plain button\nreturn{};}}});var PaginationPlugin=/*#__PURE__*/pluginFactory({components:{BPagination:BPagination}});// Sanitize the provided number of pages (converting to a number)\nvar sanitizeNumberOfPages=function sanitizeNumberOfPages(value){return mathMax(toInteger(value,0),1);};// --- Props ---\nvar _linkProps=omit(props$2f,['event','routerTag']);var props$H=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$J),_linkProps),{},{baseUrl:makeProp(PROP_TYPE_STRING,'/'),linkGen:makeProp(PROP_TYPE_FUNCTION),// Disable auto page number detection if `true`\nnoPageDetect:makeProp(PROP_TYPE_BOOLEAN,false),numberOfPages:makeProp(PROP_TYPE_NUMBER_STRING,1,/* istanbul ignore next */function(value){var number=toInteger(value,0);if(number<1){warn('Prop \"number-of-pages\" must be a number greater than \"0\"',NAME_PAGINATION_NAV);return false;}return true;}),pageGen:makeProp(PROP_TYPE_FUNCTION),// Optional array of page links\npages:makeProp(PROP_TYPE_ARRAY),useRouter:makeProp(PROP_TYPE_BOOLEAN,false)})),NAME_PAGINATION_NAV);// --- Main component ---\n// @vue/component\nvar BPaginationNav=/*#__PURE__*/Vue__default['default'].extend({name:NAME_PAGINATION_NAV,// The render function is brought in via the pagination mixin\nmixins:[paginationMixin$1],props:props$H,computed:{// Used by render function to trigger wrapping in '<nav>' element\nisNav:function isNav(){return true;},computedValue:function computedValue(){// Returns the value prop as a number or `null` if undefined or < 1\nvar value=toInteger(this.value,0);return value<1?null:value;}},watch:{numberOfPages:function numberOfPages(){var _this=this;this.$nextTick(function(){_this.setNumberOfPages();});},pages:function pages(){var _this2=this;this.$nextTick(function(){_this2.setNumberOfPages();});}},created:function created(){this.setNumberOfPages();},mounted:function mounted(){var _this3=this;if(this.$router){// We only add the watcher if vue router is detected\nthis.$watch('$route',function(){_this3.$nextTick(function(){requestAF(function(){_this3.guessCurrentPage();});});});}},methods:{setNumberOfPages:function setNumberOfPages(){var _this4=this;if(isArray(this.pages)&&this.pages.length>0){this.localNumberOfPages=this.pages.length;}else{this.localNumberOfPages=sanitizeNumberOfPages(this.numberOfPages);}this.$nextTick(function(){_this4.guessCurrentPage();});},onClick:function onClick(event,pageNumber){var _this5=this;// Dont do anything if clicking the current active page\nif(pageNumber===this.currentPage){return;}var target=event.currentTarget||event.target;// Emit a user-cancelable `page-click` event\nvar clickEvent=new BvEvent(EVENT_NAME_PAGE_CLICK,{cancelable:true,vueTarget:this,target:target});this.$emit(clickEvent.type,clickEvent,pageNumber);if(clickEvent.defaultPrevented){return;}// Update the `v-model`\n// Done in in requestAF() to allow browser to complete the\n// native browser click handling of a link\nrequestAF(function(){_this5.currentPage=pageNumber;_this5.$emit(EVENT_NAME_CHANGE,pageNumber);});// Emulate native link click page reloading behaviour by blurring the\n// paginator and returning focus to the document\n// Done in a `nextTick()` to ensure rendering complete\nthis.$nextTick(function(){attemptBlur(target);});},getPageInfo:function getPageInfo(pageNumber){if(!isArray(this.pages)||this.pages.length===0||isUndefined(this.pages[pageNumber-1])){var link=\"\".concat(this.baseUrl).concat(pageNumber);return{link:this.useRouter?{path:link}:link,text:toString(pageNumber)};}var info=this.pages[pageNumber-1];if(isObject(info)){var _link=info.link;return{// Normalize link for router use\nlink:isObject(_link)?_link:this.useRouter?{path:_link}:_link,// Make sure text has a value\ntext:toString(info.text||pageNumber)};}else{return{link:toString(info),text:toString(pageNumber)};}},makePage:function makePage(pageNumber){var pageGen=this.pageGen;var info=this.getPageInfo(pageNumber);if(hasPropFunction(pageGen)){return pageGen(pageNumber,info);}return info.text;},makeLink:function makeLink(pageNumber){var linkGen=this.linkGen;var info=this.getPageInfo(pageNumber);if(hasPropFunction(linkGen)){return linkGen(pageNumber,info);}return info.link;},linkProps:function linkProps(pageNumber){var props=pluckProps(_linkProps,this);var link=this.makeLink(pageNumber);if(this.useRouter||isObject(link)){props.to=link;}else{props.href=link;}return props;},resolveLink:function resolveLink(){var to=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'';// Given a to (or href string), convert to normalized route-like structure\n// Works only client side!\nvar link;try{// Convert the `to` to a HREF via a temporary `a` tag\nlink=document.createElement('a');link.href=computeHref({to:to},'a','/','/');// We need to add the anchor to the document to make sure the\n// `pathname` is correctly detected in any browser (i.e. IE)\ndocument.body.appendChild(link);// Once href is assigned, the link will be normalized to the full URL bits\nvar _link2=link,pathname=_link2.pathname,hash=_link2.hash,search=_link2.search;// Remove link from document\ndocument.body.removeChild(link);// Return the location in a route-like object\nreturn{path:pathname,hash:hash,query:parseQuery(search)};}catch(e){/* istanbul ignore next */try{link&&link.parentNode&&link.parentNode.removeChild(link);}catch(_unused){}/* istanbul ignore next */return{};}},resolveRoute:function resolveRoute(){var to=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'';// Given a to (or href string), convert to normalized route location structure\n// Works only when router available!\ntry{var route=this.$router.resolve(to,this.$route).route;return{path:route.path,hash:route.hash,query:route.query};}catch(e){/* istanbul ignore next */return{};}},guessCurrentPage:function guessCurrentPage(){var $router=this.$router,$route=this.$route;var guess=this.computedValue;// This section only occurs if we are client side, or server-side with `$router`\nif(!this.noPageDetect&&!guess&&(IS_BROWSER||!IS_BROWSER&&$router)){// Current route (if router available)\nvar currentRoute=$router&&$route?{path:$route.path,hash:$route.hash,query:$route.query}:{};// Current page full HREF (if client side)\n// Can't be done as a computed prop!\nvar loc=IS_BROWSER?window.location||document.location:null;var currentLink=loc?{path:loc.pathname,hash:loc.hash,query:parseQuery(loc.search)}:/* istanbul ignore next */{};// Loop through the possible pages looking for a match until found\nfor(var pageNumber=1;!guess&&pageNumber<=this.localNumberOfPages;pageNumber++){var to=this.makeLink(pageNumber);if($router&&(isObject(to)||this.useRouter)){// Resolve the page via the `$router`\nguess=looseEqual(this.resolveRoute(to),currentRoute)?pageNumber:null;}else if(IS_BROWSER){// If no `$router` available (or `!this.useRouter` when `to` is a string)\n// we compare using parsed URIs\nguess=looseEqual(this.resolveLink(to),currentLink)?pageNumber:null;}else{// Probably SSR, but no `$router` so we can't guess,\n// so lets break out of the loop early\n/* istanbul ignore next */guess=-1;}}}// We set `currentPage` to `0` to trigger an `$emit('input', null)`\n// As the default for `currentPage` is `-1` when no value is specified\n// Valid page numbers are greater than `0`\nthis.currentPage=guess>0?guess:0;}}});var PaginationNavPlugin=/*#__PURE__*/pluginFactory({components:{BPaginationNav:BPaginationNav}});// Base on-demand component for tooltip / popover templates\nvar AttachmentMap={AUTO:'auto',TOP:'top',RIGHT:'right',BOTTOM:'bottom',LEFT:'left',TOPLEFT:'top',TOPRIGHT:'top',RIGHTTOP:'right',RIGHTBOTTOM:'right',BOTTOMLEFT:'bottom',BOTTOMRIGHT:'bottom',LEFTTOP:'left',LEFTBOTTOM:'left'};var OffsetMap={AUTO:0,TOPLEFT:-1,TOP:0,TOPRIGHT:+1,RIGHTTOP:-1,RIGHT:0,RIGHTBOTTOM:+1,BOTTOMLEFT:-1,BOTTOM:0,BOTTOMRIGHT:+1,LEFTTOP:-1,LEFT:0,LEFTBOTTOM:+1};// --- Props ---\nvar props$G={// The minimum distance (in `px`) from the edge of the\n// tooltip/popover that the arrow can be positioned\narrowPadding:makeProp(PROP_TYPE_NUMBER_STRING,6),// 'scrollParent', 'viewport', 'window', or `Element`\nboundary:makeProp([HTMLElement,PROP_TYPE_STRING],'scrollParent'),// Tooltip/popover will try and stay away from\n// boundary edge by this many pixels\nboundaryPadding:makeProp(PROP_TYPE_NUMBER_STRING,5),fallbackPlacement:makeProp(PROP_TYPE_ARRAY_STRING,'flip'),offset:makeProp(PROP_TYPE_NUMBER_STRING,0),placement:makeProp(PROP_TYPE_STRING,'top'),// Element that the tooltip/popover is positioned relative to\ntarget:makeProp([HTMLElement,SVGElement])};// --- Main component ---\n// @vue/component\nvar BVPopper=/*#__PURE__*/Vue__default['default'].extend({name:NAME_POPPER,props:props$G,data:function data(){return{// reactive props set by parent\nnoFade:false,// State related data\nlocalShow:true,attachment:this.getAttachment(this.placement)};},computed:{/* istanbul ignore next */templateType:function templateType(){// Overridden by template component\nreturn'unknown';},popperConfig:function popperConfig(){var _this=this;var placement=this.placement;return{placement:this.getAttachment(placement),modifiers:{offset:{offset:this.getOffset(placement)},flip:{behavior:this.fallbackPlacement},// `arrow.element` can also be a reference to an HTML Element\n// maybe we should make this a `$ref` in the templates?\narrow:{element:'.arrow'},preventOverflow:{padding:this.boundaryPadding,boundariesElement:this.boundary}},onCreate:function onCreate(data){// Handle flipping arrow classes\nif(data.originalPlacement!==data.placement){/* istanbul ignore next: can't test in JSDOM */_this.popperPlacementChange(data);}},onUpdate:function onUpdate(data){// Handle flipping arrow classes\n_this.popperPlacementChange(data);}};}},created:function created(){var _this2=this;// Note: We are created on-demand, and should be guaranteed that\n// DOM is rendered/ready by the time the created hook runs\nthis.$_popper=null;// Ensure we show as we mount\nthis.localShow=true;// Create popper instance before shown\nthis.$on(EVENT_NAME_SHOW,function(el){_this2.popperCreate(el);});// Self destruct handler\nvar handleDestroy=function handleDestroy(){_this2.$nextTick(function(){// In a `requestAF()` to release control back to application\nrequestAF(function(){_this2.$destroy();});});};// Self destruct if parent destroyed\nthis.$parent.$once(HOOK_EVENT_NAME_DESTROYED,handleDestroy);// Self destruct after hidden\nthis.$once(EVENT_NAME_HIDDEN,handleDestroy);},beforeMount:function beforeMount(){// Ensure that the attachment position is correct before mounting\n// as our propsData is added after `new Template({...})`\nthis.attachment=this.getAttachment(this.placement);},updated:function updated(){// Update popper if needed\n// TODO: Should this be a watcher on `this.popperConfig` instead?\nthis.updatePopper();},beforeDestroy:function beforeDestroy(){this.destroyPopper();},destroyed:function destroyed(){// Make sure template is removed from DOM\nvar el=this.$el;el&&el.parentNode&&el.parentNode.removeChild(el);},methods:{// \"Public\" method to trigger hide template\nhide:function hide(){this.localShow=false;},// Private\ngetAttachment:function getAttachment(placement){return AttachmentMap[String(placement).toUpperCase()]||'auto';},getOffset:function getOffset(placement){if(!this.offset){// Could set a ref for the arrow element\nvar arrow=this.$refs.arrow||select('.arrow',this.$el);var arrowOffset=toFloat(getCS(arrow).width,0)+toFloat(this.arrowPadding,0);switch(OffsetMap[String(placement).toUpperCase()]||0){/* istanbul ignore next: can't test in JSDOM */case+1:/* istanbul ignore next: can't test in JSDOM */return\"+50%p - \".concat(arrowOffset,\"px\");/* istanbul ignore next: can't test in JSDOM */case-1:/* istanbul ignore next: can't test in JSDOM */return\"-50%p + \".concat(arrowOffset,\"px\");default:return 0;}}/* istanbul ignore next */return this.offset;},popperCreate:function popperCreate(el){this.destroyPopper();// We use `el` rather than `this.$el` just in case the original\n// mountpoint root element type was changed by the template\nthis.$_popper=new Popper(this.target,el,this.popperConfig);},destroyPopper:function destroyPopper(){this.$_popper&&this.$_popper.destroy();this.$_popper=null;},updatePopper:function updatePopper(){this.$_popper&&this.$_popper.scheduleUpdate();},popperPlacementChange:function popperPlacementChange(data){// Callback used by popper to adjust the arrow placement\nthis.attachment=this.getAttachment(data.placement);},/* istanbul ignore next */renderTemplate:function renderTemplate(h){// Will be overridden by templates\nreturn h('div');}},render:function render(h){var _this3=this;var noFade=this.noFade;// Note: 'show' and 'fade' classes are only appled during transition\nreturn h(BVTransition,{// Transitions as soon as mounted\nprops:{appear:true,noFade:noFade},on:{// Events used by parent component/instance\nbeforeEnter:function beforeEnter(el){return _this3.$emit(EVENT_NAME_SHOW,el);},afterEnter:function afterEnter(el){return _this3.$emit(EVENT_NAME_SHOWN,el);},beforeLeave:function beforeLeave(el){return _this3.$emit(EVENT_NAME_HIDE,el);},afterLeave:function afterLeave(el){return _this3.$emit(EVENT_NAME_HIDDEN,el);}}},[this.localShow?this.renderTemplate(h):h()]);}});var props$F={// Used only by the directive versions\nhtml:makeProp(PROP_TYPE_BOOLEAN,false),// Other non-reactive (while open) props are pulled in from BVPopper\nid:makeProp(PROP_TYPE_STRING)};// --- Main component ---\n// @vue/component\nvar BVTooltipTemplate=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TOOLTIP_TEMPLATE,extends:BVPopper,mixins:[scopedStyleMixin],props:props$F,data:function data(){// We use data, rather than props to ensure reactivity\n// Parent component will directly set this data\nreturn{title:'',content:'',variant:null,customClass:null,interactive:true};},computed:{templateType:function templateType(){return'tooltip';},templateClasses:function templateClasses(){var _ref;var variant=this.variant,attachment=this.attachment,templateType=this.templateType;return[(_ref={// Disables pointer events to hide the tooltip when the user\n// hovers over its content\nnoninteractive:!this.interactive},_defineProperty(_ref,\"b-\".concat(templateType,\"-\").concat(variant),variant),_defineProperty(_ref,\"bs-\".concat(templateType,\"-\").concat(attachment),attachment),_ref),this.customClass];},templateAttributes:function templateAttributes(){var id=this.id;return _objectSpread2$3(_objectSpread2$3({},this.$parent.$parent.$attrs),{},{id:id,role:'tooltip',tabindex:'-1'},this.scopedStyleAttrs);},templateListeners:function templateListeners(){var _this=this;// Used for hover/focus trigger listeners\nreturn{mouseenter:/* istanbul ignore next */function mouseenter(event){_this.$emit(EVENT_NAME_MOUSEENTER,event);},mouseleave:/* istanbul ignore next */function mouseleave(event){_this.$emit(EVENT_NAME_MOUSELEAVE,event);},focusin:/* istanbul ignore next */function focusin(event){_this.$emit(EVENT_NAME_FOCUSIN,event);},focusout:/* istanbul ignore next */function focusout(event){_this.$emit(EVENT_NAME_FOCUSOUT,event);}};}},methods:{renderTemplate:function renderTemplate(h){var title=this.title;// Title can be a scoped slot function\nvar $title=isFunction$1(title)?title({}):title;// Directive versions only\nvar domProps=this.html&&!isFunction$1(title)?{innerHTML:title}:{};return h('div',{staticClass:'tooltip b-tooltip',class:this.templateClasses,attrs:this.templateAttributes,on:this.templateListeners},[h('div',{staticClass:'arrow',ref:'arrow'}),h('div',{staticClass:'tooltip-inner',domProps:domProps},[$title])]);}}});// Modal container selector for appending tooltip/popover\nvar MODAL_SELECTOR='.modal-content';// Modal `$root` hidden event\nvar ROOT_EVENT_NAME_MODAL_HIDDEN=getRootEventName(NAME_MODAL,EVENT_NAME_HIDDEN);// Sidebar container selector for appending tooltip/popover\nvar SIDEBAR_SELECTOR='.b-sidebar';// For finding the container to append to\nvar CONTAINER_SELECTOR=[MODAL_SELECTOR,SIDEBAR_SELECTOR].join(', ');// For dropdown sniffing\nvar DROPDOWN_CLASS='dropdown';var DROPDOWN_OPEN_SELECTOR='.dropdown-menu.show';// Data attribute to temporary store the `title` attribute's value\nvar DATA_TITLE_ATTR='data-original-title';// Data specific to popper and template\n// We don't use props, as we need reactivity (we can't pass reactive props)\nvar templateData={// Text string or Scoped slot function\ntitle:'',// Text string or Scoped slot function\ncontent:'',// String\nvariant:null,// String, Array, Object\ncustomClass:null,// String or array of Strings (overwritten by BVPopper)\ntriggers:'',// String (overwritten by BVPopper)\nplacement:'auto',// String or array of strings\nfallbackPlacement:'flip',// Element or Component reference (or function that returns element) of\n// the element that will have the trigger events bound, and is also\n// default element for positioning\ntarget:null,// HTML ID, Element or Component reference\ncontainer:null,// 'body'\n// Boolean\nnoFade:false,// 'scrollParent', 'viewport', 'window', Element, or Component reference\nboundary:'scrollParent',// Tooltip/popover will try and stay away from\n// boundary edge by this many pixels (Number)\nboundaryPadding:5,// Arrow offset (Number)\noffset:0,// Hover/focus delay (Number or Object)\ndelay:0,// Arrow of Tooltip/popover will try and stay away from\n// the edge of tooltip/popover edge by this many pixels\narrowPadding:6,// Interactive state (Boolean)\ninteractive:true,// Disabled state (Boolean)\ndisabled:false,// ID to use for tooltip/popover\nid:null,// Flag used by directives only, for HTML content\nhtml:false};// --- Main component ---\n// @vue/component\nvar BVTooltip=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TOOLTIP_HELPER,mixins:[listenOnRootMixin],data:function data(){return _objectSpread2$3(_objectSpread2$3({},templateData),{},{// State management data\nactiveTrigger:{// manual: false,\nhover:false,click:false,focus:false},localShow:false});},computed:{templateType:function templateType(){// Overwritten by BVPopover\nreturn'tooltip';},computedId:function computedId(){return this.id||\"__bv_\".concat(this.templateType,\"_\").concat(this[COMPONENT_UID_KEY],\"__\");},computedDelay:function computedDelay(){// Normalizes delay into object form\nvar delay={show:0,hide:0};if(isPlainObject(this.delay)){delay.show=mathMax(toInteger(this.delay.show,0),0);delay.hide=mathMax(toInteger(this.delay.hide,0),0);}else if(isNumber(this.delay)||isString(this.delay)){delay.show=delay.hide=mathMax(toInteger(this.delay,0),0);}return delay;},computedTriggers:function computedTriggers(){// Returns the triggers in sorted array form\n// TODO: Switch this to object form for easier lookup\nreturn concat(this.triggers).filter(identity).join(' ').trim().toLowerCase().split(/\\s+/).sort();},isWithActiveTrigger:function isWithActiveTrigger(){for(var trigger in this.activeTrigger){if(this.activeTrigger[trigger]){return true;}}return false;},computedTemplateData:function computedTemplateData(){var title=this.title,content=this.content,variant=this.variant,customClass=this.customClass,noFade=this.noFade,interactive=this.interactive;return{title:title,content:content,variant:variant,customClass:customClass,noFade:noFade,interactive:interactive};}},watch:{computedTriggers:function computedTriggers(newTriggers,oldTriggers){var _this=this;// Triggers have changed, so re-register them\n/* istanbul ignore next */if(!looseEqual(newTriggers,oldTriggers)){this.$nextTick(function(){// Disable trigger listeners\n_this.unListen();// Clear any active triggers that are no longer in the list of triggers\noldTriggers.forEach(function(trigger){if(!arrayIncludes(newTriggers,trigger)){if(_this.activeTrigger[trigger]){_this.activeTrigger[trigger]=false;}}});// Re-enable the trigger listeners\n_this.listen();});}},computedTemplateData:function computedTemplateData(){// If any of the while open reactive \"props\" change,\n// ensure that the template updates accordingly\nthis.handleTemplateUpdate();},title:function title(newValue,oldValue){// Make sure to hide the tooltip when the title is set empty\nif(newValue!==oldValue&&!newValue){this.hide();}},disabled:function disabled(newValue){if(newValue){this.disable();}else{this.enable();}}},created:function created(){var _this2=this;// Create non-reactive properties\nthis.$_tip=null;this.$_hoverTimeout=null;this.$_hoverState='';this.$_visibleInterval=null;this.$_enabled=!this.disabled;this.$_noop=noop.bind(this);// Destroy ourselves when the parent is destroyed\nif(this.$parent){this.$parent.$once(HOOK_EVENT_NAME_BEFORE_DESTROY,function(){_this2.$nextTick(function(){// In a `requestAF()` to release control back to application\nrequestAF(function(){_this2.$destroy();});});});}this.$nextTick(function(){var target=_this2.getTarget();if(target&&contains(document.body,target)){// Copy the parent's scoped style attribute\n_this2.scopeId=getScopeId(_this2.$parent);// Set up all trigger handlers and listeners\n_this2.listen();}else{/* istanbul ignore next */warn(isString(_this2.target)?\"Unable to find target element by ID \\\"#\".concat(_this2.target,\"\\\" in document.\"):'The provided target is no valid HTML element.',_this2.templateType);}});},/* istanbul ignore next */updated:function updated(){// Usually called when the slots/data changes\nthis.$nextTick(this.handleTemplateUpdate);},/* istanbul ignore next */deactivated:function deactivated(){// In a keepalive that has been deactivated, so hide\n// the tooltip/popover if it is showing\nthis.forceHide();},beforeDestroy:function beforeDestroy(){// Remove all handler/listeners\nthis.unListen();this.setWhileOpenListeners(false);// Clear any timeouts/intervals\nthis.clearHoverTimeout();this.clearVisibilityInterval();// Destroy the template\nthis.destroyTemplate();// Remove any other private properties created during create\nthis.$_noop=null;},methods:{// --- Methods for creating and destroying the template ---\ngetTemplate:function getTemplate(){// Overridden by BVPopover\nreturn BVTooltipTemplate;},updateData:function updateData(){var _this3=this;var data=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};// Method for updating popper/template data\n// We only update data if it exists, and has not changed\nvar titleUpdated=false;keys(templateData).forEach(function(prop){if(!isUndefined(data[prop])&&_this3[prop]!==data[prop]){_this3[prop]=data[prop];if(prop==='title'){titleUpdated=true;}}});// If the title has updated, we may need to handle the `title`\n// attribute on the trigger target\n// We only do this while the template is open\nif(titleUpdated&&this.localShow){this.fixTitle();}},createTemplateAndShow:function createTemplateAndShow(){// Creates the template instance and show it\nvar container=this.getContainer();var Template=this.getTemplate();var $tip=this.$_tip=new Template({parent:this,// The following is not reactive to changes in the props data\npropsData:{// These values cannot be changed while template is showing\nid:this.computedId,html:this.html,placement:this.placement,fallbackPlacement:this.fallbackPlacement,target:this.getPlacementTarget(),boundary:this.getBoundary(),// Ensure the following are integers\noffset:toInteger(this.offset,0),arrowPadding:toInteger(this.arrowPadding,0),boundaryPadding:toInteger(this.boundaryPadding,0)}});// We set the initial reactive data (values that can be changed while open)\nthis.handleTemplateUpdate();// Template transition phase events (handled once only)\n// When the template has mounted, but not visibly shown yet\n$tip.$once(EVENT_NAME_SHOW,this.onTemplateShow);// When the template has completed showing\n$tip.$once(EVENT_NAME_SHOWN,this.onTemplateShown);// When the template has started to hide\n$tip.$once(EVENT_NAME_HIDE,this.onTemplateHide);// When the template has completed hiding\n$tip.$once(EVENT_NAME_HIDDEN,this.onTemplateHidden);// When the template gets destroyed for any reason\n$tip.$once(HOOK_EVENT_NAME_DESTROYED,this.destroyTemplate);// Convenience events from template\n// To save us from manually adding/removing DOM\n// listeners to tip element when it is open\n$tip.$on(EVENT_NAME_FOCUSIN,this.handleEvent);$tip.$on(EVENT_NAME_FOCUSOUT,this.handleEvent);$tip.$on(EVENT_NAME_MOUSEENTER,this.handleEvent);$tip.$on(EVENT_NAME_MOUSELEAVE,this.handleEvent);// Mount (which triggers the `show`)\n$tip.$mount(container.appendChild(document.createElement('div')));// Template will automatically remove its markup from DOM when hidden\n},hideTemplate:function hideTemplate(){// Trigger the template to start hiding\n// The template will emit the `hide` event after this and\n// then emit the `hidden` event once it is fully hidden\n// The `hook:destroyed` will also be called (safety measure)\nthis.$_tip&&this.$_tip.hide();// Clear out any stragging active triggers\nthis.clearActiveTriggers();// Reset the hover state\nthis.$_hoverState='';},// Destroy the template instance and reset state\ndestroyTemplate:function destroyTemplate(){this.setWhileOpenListeners(false);this.clearHoverTimeout();this.$_hoverState='';this.clearActiveTriggers();this.localPlacementTarget=null;try{this.$_tip.$destroy();}catch(_unused){}this.$_tip=null;this.removeAriaDescribedby();this.restoreTitle();this.localShow=false;},getTemplateElement:function getTemplateElement(){return this.$_tip?this.$_tip.$el:null;},handleTemplateUpdate:function handleTemplateUpdate(){var _this4=this;// Update our template title/content \"props\"\n// So that the template updates accordingly\nvar $tip=this.$_tip;if($tip){var props=['title','content','variant','customClass','noFade','interactive'];// Only update the values if they have changed\nprops.forEach(function(prop){if($tip[prop]!==_this4[prop]){$tip[prop]=_this4[prop];}});}},// --- Show/Hide handlers ---\n// Show the tooltip\nshow:function show(){var target=this.getTarget();if(!target||!contains(document.body,target)||!isVisible(target)||this.dropdownOpen()||(isUndefinedOrNull(this.title)||this.title==='')&&(isUndefinedOrNull(this.content)||this.content==='')){// If trigger element isn't in the DOM or is not visible, or\n// is on an open dropdown toggle, or has no content, then\n// we exit without showing\nreturn;}// If tip already exists, exit early\nif(this.$_tip||this.localShow){/* istanbul ignore next */return;}// In the process of showing\nthis.localShow=true;// Create a cancelable BvEvent\nvar showEvent=this.buildEvent(EVENT_NAME_SHOW,{cancelable:true});this.emitEvent(showEvent);// Don't show if event cancelled\n/* istanbul ignore if */if(showEvent.defaultPrevented){// Destroy the template (if for some reason it was created)\nthis.destroyTemplate();return;}// Fix the title attribute on target\nthis.fixTitle();// Set aria-describedby on target\nthis.addAriaDescribedby();// Create and show the tooltip\nthis.createTemplateAndShow();},hide:function hide(){var force=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;// Hide the tooltip\nvar tip=this.getTemplateElement();/* istanbul ignore if */if(!tip||!this.localShow){this.restoreTitle();return;}// Emit cancelable BvEvent 'hide'\n// We disable cancelling if `force` is true\nvar hideEvent=this.buildEvent(EVENT_NAME_HIDE,{cancelable:!force});this.emitEvent(hideEvent);/* istanbul ignore if: ignore for now */if(hideEvent.defaultPrevented){// Don't hide if event cancelled\nreturn;}// Tell the template to hide\nthis.hideTemplate();},forceHide:function forceHide(){// Forcefully hides/destroys the template, regardless of any active triggers\nvar tip=this.getTemplateElement();if(!tip||!this.localShow){/* istanbul ignore next */return;}// Disable while open listeners/watchers\n// This is also done in the template `hide` event handler\nthis.setWhileOpenListeners(false);// Clear any hover enter/leave event\nthis.clearHoverTimeout();this.$_hoverState='';this.clearActiveTriggers();// Disable the fade animation on the template\nif(this.$_tip){this.$_tip.noFade=true;}// Hide the tip (with force = true)\nthis.hide(true);},enable:function enable(){this.$_enabled=true;// Create a non-cancelable BvEvent\nthis.emitEvent(this.buildEvent(EVENT_NAME_ENABLED));},disable:function disable(){this.$_enabled=false;// Create a non-cancelable BvEvent\nthis.emitEvent(this.buildEvent(EVENT_NAME_DISABLED));},// --- Handlers for template events ---\n// When template is inserted into DOM, but not yet shown\nonTemplateShow:function onTemplateShow(){// Enable while open listeners/watchers\nthis.setWhileOpenListeners(true);},// When template show transition completes\nonTemplateShown:function onTemplateShown(){var prevHoverState=this.$_hoverState;this.$_hoverState='';/* istanbul ignore next: occasional Node 10 coverage error */if(prevHoverState==='out'){this.leave(null);}// Emit a non-cancelable BvEvent 'shown'\nthis.emitEvent(this.buildEvent(EVENT_NAME_SHOWN));},// When template is starting to hide\nonTemplateHide:function onTemplateHide(){// Disable while open listeners/watchers\nthis.setWhileOpenListeners(false);},// When template has completed closing (just before it self destructs)\nonTemplateHidden:function onTemplateHidden(){// Destroy the template\nthis.destroyTemplate();// Emit a non-cancelable BvEvent 'shown'\nthis.emitEvent(this.buildEvent(EVENT_NAME_HIDDEN));},// --- Helper methods ---\ngetTarget:function getTarget(){var target=this.target;if(isString(target)){target=getById(target.replace(/^#/,''));}else if(isFunction$1(target)){target=target();}else if(target){target=target.$el||target;}return isElement(target)?target:null;},getPlacementTarget:function getPlacementTarget(){// This is the target that the tooltip will be placed on, which may not\n// necessarily be the same element that has the trigger event listeners\n// For now, this is the same as target\n// TODO:\n//   Add in child selector support\n//   Add in visibility checks for this element\n//   Fallback to target if not found\nreturn this.getTarget();},getTargetId:function getTargetId(){// Returns the ID of the trigger element\nvar target=this.getTarget();return target&&target.id?target.id:null;},getContainer:function getContainer(){// Handle case where container may be a component ref\nvar container=this.container?this.container.$el||this.container:false;var body=document.body;var target=this.getTarget();// If we are in a modal, we append to the modal, If we\n// are in a sidebar, we append to the sidebar, else append\n// to body, unless a container is specified\n// TODO:\n//   Template should periodically check to see if it is in dom\n//   And if not, self destruct (if container got v-if'ed out of DOM)\n//   Or this could possibly be part of the visibility check\nreturn container===false?closest(CONTAINER_SELECTOR,target)||body:/*istanbul ignore next */isString(container)?/*istanbul ignore next */getById(container.replace(/^#/,''))||body:/*istanbul ignore next */body;},getBoundary:function getBoundary(){return this.boundary?this.boundary.$el||this.boundary:'scrollParent';},isInModal:function isInModal(){var target=this.getTarget();return target&&closest(MODAL_SELECTOR,target);},isDropdown:function isDropdown(){// Returns true if trigger is a dropdown\nvar target=this.getTarget();return target&&hasClass(target,DROPDOWN_CLASS);},dropdownOpen:function dropdownOpen(){// Returns true if trigger is a dropdown and the dropdown menu is open\nvar target=this.getTarget();return this.isDropdown()&&target&&select(DROPDOWN_OPEN_SELECTOR,target);},clearHoverTimeout:function clearHoverTimeout(){clearTimeout(this.$_hoverTimeout);this.$_hoverTimeout=null;},clearVisibilityInterval:function clearVisibilityInterval(){clearInterval(this.$_visibleInterval);this.$_visibleInterval=null;},clearActiveTriggers:function clearActiveTriggers(){for(var trigger in this.activeTrigger){this.activeTrigger[trigger]=false;}},addAriaDescribedby:function addAriaDescribedby(){// Add aria-describedby on trigger element, without removing any other IDs\nvar target=this.getTarget();var desc=getAttr(target,'aria-describedby')||'';desc=desc.split(/\\s+/).concat(this.computedId).join(' ').trim();// Update/add aria-described by\nsetAttr(target,'aria-describedby',desc);},removeAriaDescribedby:function removeAriaDescribedby(){var _this5=this;// Remove aria-describedby on trigger element, without removing any other IDs\nvar target=this.getTarget();var desc=getAttr(target,'aria-describedby')||'';desc=desc.split(/\\s+/).filter(function(d){return d!==_this5.computedId;}).join(' ').trim();// Update or remove aria-describedby\nif(desc){/* istanbul ignore next */setAttr(target,'aria-describedby',desc);}else{removeAttr(target,'aria-describedby');}},fixTitle:function fixTitle(){// If the target has a `title` attribute,\n// remove it and store it on a data attribute\nvar target=this.getTarget();if(hasAttr(target,'title')){// Get `title` attribute value and remove it from target\nvar title=getAttr(target,'title');setAttr(target,'title','');// Only set the data attribute when the value is truthy\nif(title){setAttr(target,DATA_TITLE_ATTR,title);}}},restoreTitle:function restoreTitle(){// If the target had a `title` attribute,\n// restore it and remove the data attribute\nvar target=this.getTarget();if(hasAttr(target,DATA_TITLE_ATTR)){// Get data attribute value and remove it from target\nvar title=getAttr(target,DATA_TITLE_ATTR);removeAttr(target,DATA_TITLE_ATTR);// Only restore the `title` attribute when the value is truthy\nif(title){setAttr(target,'title',title);}}},// --- BvEvent helpers ---\nbuildEvent:function buildEvent(type){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};// Defaults to a non-cancellable event\nreturn new BvEvent(type,_objectSpread2$3({cancelable:false,target:this.getTarget(),relatedTarget:this.getTemplateElement()||null,componentId:this.computedId,vueTarget:this},options));},emitEvent:function emitEvent(bvEvent){var type=bvEvent.type;this.emitOnRoot(getRootEventName(this.templateType,type),bvEvent);this.$emit(type,bvEvent);},// --- Event handler setup methods ---\nlisten:function listen(){var _this6=this;// Enable trigger event handlers\nvar el=this.getTarget();if(!el){/* istanbul ignore next */return;}// Listen for global show/hide events\nthis.setRootListener(true);// Set up our listeners on the target trigger element\nthis.computedTriggers.forEach(function(trigger){if(trigger==='click'){eventOn(el,'click',_this6.handleEvent,EVENT_OPTIONS_NO_CAPTURE);}else if(trigger==='focus'){eventOn(el,'focusin',_this6.handleEvent,EVENT_OPTIONS_NO_CAPTURE);eventOn(el,'focusout',_this6.handleEvent,EVENT_OPTIONS_NO_CAPTURE);}else if(trigger==='blur'){// Used to close $tip when element loses focus\n/* istanbul ignore next */eventOn(el,'focusout',_this6.handleEvent,EVENT_OPTIONS_NO_CAPTURE);}else if(trigger==='hover'){eventOn(el,'mouseenter',_this6.handleEvent,EVENT_OPTIONS_NO_CAPTURE);eventOn(el,'mouseleave',_this6.handleEvent,EVENT_OPTIONS_NO_CAPTURE);}},this);},/* istanbul ignore next */unListen:function unListen(){var _this7=this;// Remove trigger event handlers\nvar events=['click','focusin','focusout','mouseenter','mouseleave'];var target=this.getTarget();// Stop listening for global show/hide/enable/disable events\nthis.setRootListener(false);// Clear out any active target listeners\nevents.forEach(function(event){target&&eventOff(target,event,_this7.handleEvent,EVENT_OPTIONS_NO_CAPTURE);},this);},setRootListener:function setRootListener(on){// Listen for global `bv::{hide|show}::{tooltip|popover}` hide request event\nvar $root=this.$root;if($root){var method=on?'$on':'$off';var type=this.templateType;$root[method](getRootActionEventName(type,EVENT_NAME_HIDE),this.doHide);$root[method](getRootActionEventName(type,EVENT_NAME_SHOW),this.doShow);$root[method](getRootActionEventName(type,EVENT_NAME_DISABLE),this.doDisable);$root[method](getRootActionEventName(type,EVENT_NAME_ENABLE),this.doEnable);}},setWhileOpenListeners:function setWhileOpenListeners(on){// Events that are only registered when the template is showing\n// Modal close events\nthis.setModalListener(on);// Dropdown open events (if we are attached to a dropdown)\nthis.setDropdownListener(on);// Periodic $element visibility check\n// For handling when tip target is in <keepalive>, tabs, carousel, etc\nthis.visibleCheck(on);// On-touch start listeners\nthis.setOnTouchStartListener(on);},// Handler for periodic visibility check\nvisibleCheck:function visibleCheck(on){var _this8=this;this.clearVisibilityInterval();var target=this.getTarget();if(on){this.$_visibleInterval=setInterval(function(){var tip=_this8.getTemplateElement();if(tip&&_this8.localShow&&(!target.parentNode||!isVisible(target))){// Target element is no longer visible or not in DOM, so force-hide the tooltip\n_this8.forceHide();}},100);}},setModalListener:function setModalListener(on){// Handle case where tooltip/target is in a modal\nif(this.isInModal()){// We can listen for modal hidden events on `$root`\nthis.$root[on?'$on':'$off'](ROOT_EVENT_NAME_MODAL_HIDDEN,this.forceHide);}},/* istanbul ignore next: JSDOM doesn't support `ontouchstart` */setOnTouchStartListener:function setOnTouchStartListener(on){var _this9=this;// If this is a touch-enabled device we add extra empty\n// `mouseover` listeners to the body's immediate children\n// Only needed because of broken event delegation on iOS\n// https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\nif('ontouchstart'in document.documentElement){from(document.body.children).forEach(function(el){eventOnOff(on,el,'mouseover',_this9.$_noop);});}},setDropdownListener:function setDropdownListener(on){var target=this.getTarget();if(!target||!this.$root||!this.isDropdown){return;}// We can listen for dropdown shown events on its instance\n// TODO:\n//   We could grab the ID from the dropdown, and listen for\n//   $root events for that particular dropdown id\n//   Dropdown shown and hidden events will need to emit\n//   Note: Dropdown auto-ID happens in a `$nextTick()` after mount\n//         So the ID lookup would need to be done in a `$nextTick()`\nif(target.__vue__){target.__vue__[on?'$on':'$off'](EVENT_NAME_SHOWN,this.forceHide);}},// --- Event handlers ---\nhandleEvent:function handleEvent(event){// General trigger event handler\n// target is the trigger element\nvar target=this.getTarget();if(!target||isDisabled(target)||!this.$_enabled||this.dropdownOpen()){// If disabled or not enabled, or if a dropdown that is open, don't do anything\n// If tip is shown before element gets disabled, then tip will not\n// close until no longer disabled or forcefully closed\nreturn;}var type=event.type;var triggers=this.computedTriggers;if(type==='click'&&arrayIncludes(triggers,'click')){this.click(event);}else if(type==='mouseenter'&&arrayIncludes(triggers,'hover')){// `mouseenter` is a non-bubbling event\nthis.enter(event);}else if(type==='focusin'&&arrayIncludes(triggers,'focus')){// `focusin` is a bubbling event\n// `event` includes `relatedTarget` (element losing focus)\nthis.enter(event);}else if(type==='focusout'&&(arrayIncludes(triggers,'focus')||arrayIncludes(triggers,'blur'))||type==='mouseleave'&&arrayIncludes(triggers,'hover')){// `focusout` is a bubbling event\n// `mouseleave` is a non-bubbling event\n// `tip` is the template (will be null if not open)\nvar tip=this.getTemplateElement();// `eventTarget` is the element which is losing focus/hover and\nvar eventTarget=event.target;// `relatedTarget` is the element gaining focus/hover\nvar relatedTarget=event.relatedTarget;/* istanbul ignore next */if(// From tip to target\ntip&&contains(tip,eventTarget)&&contains(target,relatedTarget)||// From target to tip\ntip&&contains(target,eventTarget)&&contains(tip,relatedTarget)||// Within tip\ntip&&contains(tip,eventTarget)&&contains(tip,relatedTarget)||// Within target\ncontains(target,eventTarget)&&contains(target,relatedTarget)){// If focus/hover moves within `tip` and `target`, don't trigger a leave\nreturn;}// Otherwise trigger a leave\nthis.leave(event);}},doHide:function doHide(id){// Programmatically hide tooltip or popover\nif(!id||this.getTargetId()===id||this.computedId===id){// Close all tooltips or popovers, or this specific tip (with ID)\nthis.forceHide();}},doShow:function doShow(id){// Programmatically show tooltip or popover\nif(!id||this.getTargetId()===id||this.computedId===id){// Open all tooltips or popovers, or this specific tip (with ID)\nthis.show();}},/*istanbul ignore next: ignore for now */doDisable:function doDisable(id)/*istanbul ignore next: ignore for now */{// Programmatically disable tooltip or popover\nif(!id||this.getTargetId()===id||this.computedId===id){// Disable all tooltips or popovers (no ID), or this specific tip (with ID)\nthis.disable();}},/*istanbul ignore next: ignore for now */doEnable:function doEnable(id)/*istanbul ignore next: ignore for now */{// Programmatically enable tooltip or popover\nif(!id||this.getTargetId()===id||this.computedId===id){// Enable all tooltips or popovers (no ID), or this specific tip (with ID)\nthis.enable();}},click:function click(event){if(!this.$_enabled||this.dropdownOpen()){/* istanbul ignore next */return;}// Get around a WebKit bug where `click` does not trigger focus events\n// On most browsers, `click` triggers a `focusin`/`focus` event first\n// Needed so that trigger 'click blur' works on iOS\n// https://github.com/bootstrap-vue/bootstrap-vue/issues/5099\n// We use `currentTarget` rather than `target` to trigger on the\n// element, not the inner content\nattemptFocus(event.currentTarget);this.activeTrigger.click=!this.activeTrigger.click;if(this.isWithActiveTrigger){this.enter(null);}else{/* istanbul ignore next */this.leave(null);}},/* istanbul ignore next */toggle:function toggle(){// Manual toggle handler\nif(!this.$_enabled||this.dropdownOpen()){/* istanbul ignore next */return;}// Should we register as an active trigger?\n// this.activeTrigger.manual = !this.activeTrigger.manual\nif(this.localShow){this.leave(null);}else{this.enter(null);}},enter:function enter(){var _this10=this;var event=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;// Opening trigger handler\n// Note: Click events are sent with event === null\nif(event){this.activeTrigger[event.type==='focusin'?'focus':'hover']=true;}/* istanbul ignore next */if(this.localShow||this.$_hoverState==='in'){this.$_hoverState='in';return;}this.clearHoverTimeout();this.$_hoverState='in';if(!this.computedDelay.show){this.show();}else{// Hide any title attribute while enter delay is active\nthis.fixTitle();this.$_hoverTimeout=setTimeout(function(){/* istanbul ignore else */if(_this10.$_hoverState==='in'){_this10.show();}else if(!_this10.localShow){_this10.restoreTitle();}},this.computedDelay.show);}},leave:function leave(){var _this11=this;var event=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;// Closing trigger handler\n// Note: Click events are sent with event === null\nif(event){this.activeTrigger[event.type==='focusout'?'focus':'hover']=false;/* istanbul ignore next */if(event.type==='focusout'&&arrayIncludes(this.computedTriggers,'blur')){// Special case for `blur`: we clear out the other triggers\nthis.activeTrigger.click=false;this.activeTrigger.hover=false;}}/* istanbul ignore next: ignore for now */if(this.isWithActiveTrigger){return;}this.clearHoverTimeout();this.$_hoverState='out';if(!this.computedDelay.hide){this.hide();}else{this.$_hoverTimeout=setTimeout(function(){if(_this11.$_hoverState==='out'){_this11.hide();}},this.computedDelay.hide);}}}});var _makePropsConfigurabl,_watch$5;var MODEL_PROP_NAME_ENABLED='disabled';var MODEL_EVENT_NAME_ENABLED=MODEL_EVENT_NAME_PREFIX+MODEL_PROP_NAME_ENABLED;var MODEL_PROP_NAME_SHOW='show';var MODEL_EVENT_NAME_SHOW=MODEL_EVENT_NAME_PREFIX+MODEL_PROP_NAME_SHOW;// --- Props ---\nvar props$E=makePropsConfigurable((_makePropsConfigurabl={// String: scrollParent, window, or viewport\n// Element: element reference\n// Object: Vue component\nboundary:makeProp([HTMLElement,PROP_TYPE_OBJECT,PROP_TYPE_STRING],'scrollParent'),boundaryPadding:makeProp(PROP_TYPE_NUMBER_STRING,50),// String: HTML ID of container, if null body is used (default)\n// HTMLElement: element reference reference\n// Object: Vue Component\ncontainer:makeProp([HTMLElement,PROP_TYPE_OBJECT,PROP_TYPE_STRING]),customClass:makeProp(PROP_TYPE_STRING),delay:makeProp(PROP_TYPE_NUMBER_OBJECT_STRING,50)},_defineProperty(_makePropsConfigurabl,MODEL_PROP_NAME_ENABLED,makeProp(PROP_TYPE_BOOLEAN,false)),_defineProperty(_makePropsConfigurabl,\"fallbackPlacement\",makeProp(PROP_TYPE_ARRAY_STRING,'flip')),_defineProperty(_makePropsConfigurabl,\"id\",makeProp(PROP_TYPE_STRING)),_defineProperty(_makePropsConfigurabl,\"noFade\",makeProp(PROP_TYPE_BOOLEAN,false)),_defineProperty(_makePropsConfigurabl,\"noninteractive\",makeProp(PROP_TYPE_BOOLEAN,false)),_defineProperty(_makePropsConfigurabl,\"offset\",makeProp(PROP_TYPE_NUMBER_STRING,0)),_defineProperty(_makePropsConfigurabl,\"placement\",makeProp(PROP_TYPE_STRING,'top')),_defineProperty(_makePropsConfigurabl,MODEL_PROP_NAME_SHOW,makeProp(PROP_TYPE_BOOLEAN,false)),_defineProperty(_makePropsConfigurabl,\"target\",makeProp([HTMLElement,SVGElement,PROP_TYPE_FUNCTION,PROP_TYPE_OBJECT,PROP_TYPE_STRING],undefined,true)),_defineProperty(_makePropsConfigurabl,\"title\",makeProp(PROP_TYPE_STRING)),_defineProperty(_makePropsConfigurabl,\"triggers\",makeProp(PROP_TYPE_ARRAY_STRING,'hover focus')),_defineProperty(_makePropsConfigurabl,\"variant\",makeProp(PROP_TYPE_STRING)),_makePropsConfigurabl),NAME_TOOLTIP);// --- Main component ---\n// @vue/component\nvar BTooltip=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TOOLTIP,mixins:[normalizeSlotMixin],inheritAttrs:false,props:props$E,data:function data(){return{localShow:this[MODEL_PROP_NAME_SHOW],localTitle:'',localContent:''};},computed:{// Data that will be passed to the template and popper\ntemplateData:function templateData(){return _objectSpread2$3({title:this.localTitle,content:this.localContent,interactive:!this.noninteractive},pick$1(this.$props,['boundary','boundaryPadding','container','customClass','delay','fallbackPlacement','id','noFade','offset','placement','target','target','triggers','variant',MODEL_PROP_NAME_ENABLED]));},// Used to watch for changes to the title and content props\ntemplateTitleContent:function templateTitleContent(){var title=this.title,content=this.content;return{title:title,content:content};}},watch:(_watch$5={},_defineProperty(_watch$5,MODEL_PROP_NAME_SHOW,function(newValue,oldValue){if(newValue!==oldValue&&newValue!==this.localShow&&this.$_toolpop){if(newValue){this.$_toolpop.show();}else{// We use `forceHide()` to override any active triggers\nthis.$_toolpop.forceHide();}}}),_defineProperty(_watch$5,MODEL_PROP_NAME_ENABLED,function(newValue){if(newValue){this.doDisable();}else{this.doEnable();}}),_defineProperty(_watch$5,\"localShow\",function localShow(newValue){// TODO: May need to be done in a `$nextTick()`\nthis.$emit(MODEL_EVENT_NAME_SHOW,newValue);}),_defineProperty(_watch$5,\"templateData\",function templateData(){var _this=this;this.$nextTick(function(){if(_this.$_toolpop){_this.$_toolpop.updateData(_this.templateData);}});}),_defineProperty(_watch$5,\"templateTitleContent\",function templateTitleContent(){this.$nextTick(this.updateContent);}),_watch$5),created:function created(){// Create private non-reactive props\nthis.$_toolpop=null;},updated:function updated(){// Update the `propData` object\n// Done in a `$nextTick()` to ensure slot(s) have updated\nthis.$nextTick(this.updateContent);},beforeDestroy:function beforeDestroy(){// Shutdown our local event listeners\nthis.$off(EVENT_NAME_OPEN,this.doOpen);this.$off(EVENT_NAME_CLOSE,this.doClose);this.$off(EVENT_NAME_DISABLE,this.doDisable);this.$off(EVENT_NAME_ENABLE,this.doEnable);// Destroy the tip instance\nif(this.$_toolpop){this.$_toolpop.$destroy();this.$_toolpop=null;}},mounted:function mounted(){var _this2=this;// Instantiate a new BVTooltip instance\n// Done in a `$nextTick()` to ensure DOM has completed rendering\n// so that target can be found\nthis.$nextTick(function(){// Load the on demand child instance\nvar Component=_this2.getComponent();// Ensure we have initial content\n_this2.updateContent();// Pass down the scoped style attribute if available\nvar scopeId=getScopeId(_this2)||getScopeId(_this2.$parent);// Create the instance\nvar $toolpop=_this2.$_toolpop=new Component({parent:_this2,// Pass down the scoped style ID\n_scopeId:scopeId||undefined});// Set the initial data\n$toolpop.updateData(_this2.templateData);// Set listeners\n$toolpop.$on(EVENT_NAME_SHOW,_this2.onShow);$toolpop.$on(EVENT_NAME_SHOWN,_this2.onShown);$toolpop.$on(EVENT_NAME_HIDE,_this2.onHide);$toolpop.$on(EVENT_NAME_HIDDEN,_this2.onHidden);$toolpop.$on(EVENT_NAME_DISABLED,_this2.onDisabled);$toolpop.$on(EVENT_NAME_ENABLED,_this2.onEnabled);// Initially disabled?\nif(_this2[MODEL_PROP_NAME_ENABLED]){// Initially disabled\n_this2.doDisable();}// Listen to open signals from others\n_this2.$on(EVENT_NAME_OPEN,_this2.doOpen);// Listen to close signals from others\n_this2.$on(EVENT_NAME_CLOSE,_this2.doClose);// Listen to disable signals from others\n_this2.$on(EVENT_NAME_DISABLE,_this2.doDisable);// Listen to enable signals from others\n_this2.$on(EVENT_NAME_ENABLE,_this2.doEnable);// Initially show tooltip?\nif(_this2.localShow){$toolpop.show();}});},methods:{getComponent:function getComponent(){// Overridden by BPopover\nreturn BVTooltip;},updateContent:function updateContent(){// Overridden by BPopover\n// Tooltip: Default slot is `title`\n// Popover: Default slot is `content`, `title` slot is title\n// We pass a scoped slot function reference by default (Vue v2.6x)\n// And pass the title prop as a fallback\nthis.setTitle(this.normalizeSlot()||this.title);},// Helper methods for `updateContent()`\nsetTitle:function setTitle(value){value=isUndefinedOrNull(value)?'':value;// We only update the value if it has changed\nif(this.localTitle!==value){this.localTitle=value;}},setContent:function setContent(value){value=isUndefinedOrNull(value)?'':value;// We only update the value if it has changed\nif(this.localContent!==value){this.localContent=value;}},// --- Template event handlers ---\nonShow:function onShow(bvEvent){// Placeholder\nthis.$emit(EVENT_NAME_SHOW,bvEvent);if(bvEvent){this.localShow=!bvEvent.defaultPrevented;}},onShown:function onShown(bvEvent){// Tip is now showing\nthis.localShow=true;this.$emit(EVENT_NAME_SHOWN,bvEvent);},onHide:function onHide(bvEvent){this.$emit(EVENT_NAME_HIDE,bvEvent);},onHidden:function onHidden(bvEvent){// Tip is no longer showing\nthis.$emit(EVENT_NAME_HIDDEN,bvEvent);this.localShow=false;},onDisabled:function onDisabled(bvEvent){// Prevent possible endless loop if user mistakenly\n// fires `disabled` instead of `disable`\nif(bvEvent&&bvEvent.type===EVENT_NAME_DISABLED){this.$emit(MODEL_EVENT_NAME_ENABLED,true);this.$emit(EVENT_NAME_DISABLED,bvEvent);}},onEnabled:function onEnabled(bvEvent){// Prevent possible endless loop if user mistakenly\n// fires `enabled` instead of `enable`\nif(bvEvent&&bvEvent.type===EVENT_NAME_ENABLED){this.$emit(MODEL_EVENT_NAME_ENABLED,false);this.$emit(EVENT_NAME_ENABLED,bvEvent);}},// --- Local event listeners ---\ndoOpen:function doOpen(){!this.localShow&&this.$_toolpop&&this.$_toolpop.show();},doClose:function doClose(){this.localShow&&this.$_toolpop&&this.$_toolpop.hide();},doDisable:function doDisable(){this.$_toolpop&&this.$_toolpop.disable();},doEnable:function doEnable(){this.$_toolpop&&this.$_toolpop.enable();}},render:function render(h){// Always renders a comment node\n// TODO:\n//   Future: Possibly render a target slot (single root element)\n//   which we can apply the listeners to (pass `this.$el` to BVTooltip)\nreturn h();}});var BVPopoverTemplate=/*#__PURE__*/Vue__default['default'].extend({name:NAME_POPOVER_TEMPLATE,extends:BVTooltipTemplate,computed:{templateType:function templateType(){return'popover';}},methods:{renderTemplate:function renderTemplate(h){var title=this.title,content=this.content;// Title and content could be a scoped slot function\nvar $title=isFunction$1(title)?title({}):title;var $content=isFunction$1(content)?content({}):content;// Directive usage only\nvar titleDomProps=this.html&&!isFunction$1(title)?{innerHTML:title}:{};var contentDomProps=this.html&&!isFunction$1(content)?{innerHTML:content}:{};return h('div',{staticClass:'popover b-popover',class:this.templateClasses,attrs:this.templateAttributes,on:this.templateListeners},[h('div',{staticClass:'arrow',ref:'arrow'}),isUndefinedOrNull($title)||$title===''?/* istanbul ignore next */h():h('h3',{staticClass:'popover-header',domProps:titleDomProps},[$title]),isUndefinedOrNull($content)||$content===''?/* istanbul ignore next */h():h('div',{staticClass:'popover-body',domProps:contentDomProps},[$content])]);}}});// Popover \"Class\" (Built as a renderless Vue instance)\nvar BVPopover=/*#__PURE__*/Vue__default['default'].extend({name:NAME_POPOVER_HELPER,extends:BVTooltip,computed:{// Overwrites BVTooltip\ntemplateType:function templateType(){return'popover';}},methods:{getTemplate:function getTemplate(){// Overwrites BVTooltip\nreturn BVPopoverTemplate;}}});var props$D=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},props$E),{},{content:makeProp(PROP_TYPE_STRING),placement:makeProp(PROP_TYPE_STRING,'right'),triggers:makeProp(PROP_TYPE_ARRAY_STRING,EVENT_NAME_CLICK)})),NAME_POPOVER);// --- Main component ---\n// @vue/component\nvar BPopover=/*#__PURE__*/Vue__default['default'].extend({name:NAME_POPOVER,extends:BTooltip,inheritAttrs:false,props:props$D,methods:{getComponent:function getComponent(){// Overridden by BPopover\nreturn BVPopover;},updateContent:function updateContent(){// Tooltip: Default slot is `title`\n// Popover: Default slot is `content`, `title` slot is title\n// We pass a scoped slot function references by default (Vue v2.6x)\n// And pass the title prop as a fallback\nthis.setContent(this.normalizeSlot()||this.content);this.setTitle(this.normalizeSlot(SLOT_NAME_TITLE)||this.title);}}// Render function provided by BTooltip\n});var BV_POPOVER='__BV_Popover__';// Default trigger\nvar DefaultTrigger$1='click';// Valid event triggers\nvar validTriggers$1={focus:true,hover:true,click:true,blur:true,manual:true};// Directive modifier test regular expressions. Pre-compile for performance\nvar htmlRE$1=/^html$/i;var noFadeRE$1=/^nofade$/i;var placementRE$1=/^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/i;var boundaryRE$1=/^(window|viewport|scrollParent)$/i;var delayRE$1=/^d\\d+$/i;var delayShowRE$1=/^ds\\d+$/i;var delayHideRE$1=/^dh\\d+$/i;var offsetRE$2=/^o-?\\d+$/i;var variantRE$1=/^v-.+$/i;var spacesRE$1=/\\s+/;// Build a Popover config based on bindings (if any)\n// Arguments and modifiers take precedence over passed value config object\nvar parseBindings$2=function parseBindings(bindings,vnode)/* istanbul ignore next: not easy to test */{// We start out with a basic config\nvar config={title:undefined,content:undefined,trigger:'',// Default set below if needed\nplacement:'right',fallbackPlacement:'flip',container:false,// Default of body\nanimation:true,offset:0,disabled:false,id:null,html:false,delay:getComponentConfig(NAME_POPOVER,'delay',50),boundary:String(getComponentConfig(NAME_POPOVER,'boundary','scrollParent')),boundaryPadding:toInteger(getComponentConfig(NAME_POPOVER,'boundaryPadding',5),0),variant:getComponentConfig(NAME_POPOVER,'variant'),customClass:getComponentConfig(NAME_POPOVER,'customClass')};// Process `bindings.value`\nif(isString(bindings.value)||isNumber(bindings.value)){// Value is popover content (html optionally supported)\nconfig.content=bindings.value;}else if(isFunction$1(bindings.value)){// Content generator function\nconfig.content=bindings.value;}else if(isPlainObject(bindings.value)){// Value is config object, so merge\nconfig=_objectSpread2$3(_objectSpread2$3({},config),bindings.value);}// If argument, assume element ID of container element\nif(bindings.arg){// Element ID specified as arg\n// We must prepend '#' to become a CSS selector\nconfig.container=\"#\".concat(bindings.arg);}// If title is not provided, try title attribute\nif(isUndefined(config.title)){// Try attribute\nvar data=vnode.data||{};config.title=data.attrs&&!isUndefinedOrNull(data.attrs.title)?data.attrs.title:undefined;}// Normalize delay\nif(!isPlainObject(config.delay)){config.delay={show:toInteger(config.delay,0),hide:toInteger(config.delay,0)};}// Process modifiers\nkeys(bindings.modifiers).forEach(function(mod){if(htmlRE$1.test(mod)){// Title/content allows HTML\nconfig.html=true;}else if(noFadeRE$1.test(mod)){// No animation\nconfig.animation=false;}else if(placementRE$1.test(mod)){// Placement of popover\nconfig.placement=mod;}else if(boundaryRE$1.test(mod)){// Boundary of popover\nmod=mod==='scrollparent'?'scrollParent':mod;config.boundary=mod;}else if(delayRE$1.test(mod)){// Delay value\nvar delay=toInteger(mod.slice(1),0);config.delay.show=delay;config.delay.hide=delay;}else if(delayShowRE$1.test(mod)){// Delay show value\nconfig.delay.show=toInteger(mod.slice(2),0);}else if(delayHideRE$1.test(mod)){// Delay hide value\nconfig.delay.hide=toInteger(mod.slice(2),0);}else if(offsetRE$2.test(mod)){// Offset value, negative allowed\nconfig.offset=toInteger(mod.slice(1),0);}else if(variantRE$1.test(mod)){// Variant\nconfig.variant=mod.slice(2)||null;}});// Special handling of event trigger modifiers trigger is\n// a space separated list\nvar selectedTriggers={};// Parse current config object trigger\nconcat(config.trigger||'').filter(identity).join(' ').trim().toLowerCase().split(spacesRE$1).forEach(function(trigger){if(validTriggers$1[trigger]){selectedTriggers[trigger]=true;}});// Parse modifiers for triggers\nkeys(bindings.modifiers).forEach(function(mod){mod=mod.toLowerCase();if(validTriggers$1[mod]){// If modifier is a valid trigger\nselectedTriggers[mod]=true;}});// Sanitize triggers\nconfig.trigger=keys(selectedTriggers).join(' ');if(config.trigger==='blur'){// Blur by itself is useless, so convert it to 'focus'\nconfig.trigger='focus';}if(!config.trigger){// Use default trigger\nconfig.trigger=DefaultTrigger$1;}return config;};// Add or update Popover on our element\nvar applyPopover=function applyPopover(el,bindings,vnode){if(!IS_BROWSER){/* istanbul ignore next */return;}var config=parseBindings$2(bindings,vnode);if(!el[BV_POPOVER]){var $parent=vnode.context;el[BV_POPOVER]=new BVPopover({parent:$parent,// Add the parent's scoped style attribute data\n_scopeId:getScopeId($parent,undefined)});el[BV_POPOVER].__bv_prev_data__={};el[BV_POPOVER].$on(EVENT_NAME_SHOW,function()/* istanbul ignore next: for now */{// Before showing the popover, we update the title\n// and content if they are functions\nvar data={};if(isFunction$1(config.title)){data.title=config.title(el);}if(isFunction$1(config.content)){data.content=config.content(el);}if(keys(data).length>0){el[BV_POPOVER].updateData(data);}});}var data={title:config.title,content:config.content,triggers:config.trigger,placement:config.placement,fallbackPlacement:config.fallbackPlacement,variant:config.variant,customClass:config.customClass,container:config.container,boundary:config.boundary,delay:config.delay,offset:config.offset,noFade:!config.animation,id:config.id,disabled:config.disabled,html:config.html};var oldData=el[BV_POPOVER].__bv_prev_data__;el[BV_POPOVER].__bv_prev_data__=data;if(!looseEqual(data,oldData)){// We only update the instance if data has changed\nvar newData={target:el};keys(data).forEach(function(prop){// We only pass data properties that have changed\nif(data[prop]!==oldData[prop]){// If title/content is a function, we execute it here\nnewData[prop]=(prop==='title'||prop==='content')&&isFunction$1(data[prop])?/* istanbul ignore next */data[prop](el):data[prop];}});el[BV_POPOVER].updateData(newData);}};// Remove Popover from our element\nvar removePopover=function removePopover(el){if(el[BV_POPOVER]){el[BV_POPOVER].$destroy();el[BV_POPOVER]=null;}delete el[BV_POPOVER];};// Export our directive\nvar VBPopover={bind:function bind(el,bindings,vnode){applyPopover(el,bindings,vnode);},// We use `componentUpdated` here instead of `update`, as the former\n// waits until the containing component and children have finished updating\ncomponentUpdated:function componentUpdated(el,bindings,vnode){// Performed in a `$nextTick()` to prevent endless render/update loops\nvnode.context.$nextTick(function(){applyPopover(el,bindings,vnode);});},unbind:function unbind(el){removePopover(el);}};var VBPopoverPlugin=/*#__PURE__*/pluginFactory({directives:{VBPopover:VBPopover}});var PopoverPlugin=/*#__PURE__*/pluginFactory({components:{BPopover:BPopover},plugins:{VBPopoverPlugin:VBPopoverPlugin}});var props$C=makePropsConfigurable({animated:makeProp(PROP_TYPE_BOOLEAN,null),label:makeProp(PROP_TYPE_STRING),labelHtml:makeProp(PROP_TYPE_STRING),max:makeProp(PROP_TYPE_NUMBER_STRING,null),precision:makeProp(PROP_TYPE_NUMBER_STRING,null),showProgress:makeProp(PROP_TYPE_BOOLEAN,null),showValue:makeProp(PROP_TYPE_BOOLEAN,null),striped:makeProp(PROP_TYPE_BOOLEAN,null),value:makeProp(PROP_TYPE_NUMBER_STRING,0),variant:makeProp(PROP_TYPE_STRING)},NAME_PROGRESS_BAR);// --- Main component ---\n// @vue/component\nvar BProgressBar=/*#__PURE__*/Vue__default['default'].extend({name:NAME_PROGRESS_BAR,mixins:[normalizeSlotMixin],inject:{bvProgress:{default:/* istanbul ignore next */function _default(){return{};}}},props:props$C,computed:{progressBarClasses:function progressBarClasses(){var computedAnimated=this.computedAnimated,computedVariant=this.computedVariant;return[computedVariant?\"bg-\".concat(computedVariant):'',this.computedStriped||computedAnimated?'progress-bar-striped':'',computedAnimated?'progress-bar-animated':''];},progressBarStyles:function progressBarStyles(){return{width:100*(this.computedValue/this.computedMax)+'%'};},computedValue:function computedValue(){return toFloat(this.value,0);},computedMax:function computedMax(){// Prefer our max over parent setting\n// Default to `100` for invalid values (`-x`, `0`, `NaN`)\nvar max=toFloat(this.max)||toFloat(this.bvProgress.max,0);return max>0?max:100;},computedPrecision:function computedPrecision(){// Prefer our precision over parent setting\n// Default to `0` for invalid values (`-x`, `NaN`)\nreturn mathMax(toInteger(this.precision,toInteger(this.bvProgress.precision,0)),0);},computedProgress:function computedProgress(){var precision=this.computedPrecision;var p=mathPow(10,precision);return toFixed(100*p*this.computedValue/this.computedMax/p,precision);},computedVariant:function computedVariant(){// Prefer our variant over parent setting\nreturn this.variant||this.bvProgress.variant;},computedStriped:function computedStriped(){// Prefer our striped over parent setting\nreturn isBoolean(this.striped)?this.striped:this.bvProgress.striped||false;},computedAnimated:function computedAnimated(){// Prefer our animated over parent setting\nreturn isBoolean(this.animated)?this.animated:this.bvProgress.animated||false;},computedShowProgress:function computedShowProgress(){// Prefer our showProgress over parent setting\nreturn isBoolean(this.showProgress)?this.showProgress:this.bvProgress.showProgress||false;},computedShowValue:function computedShowValue(){// Prefer our showValue over parent setting\nreturn isBoolean(this.showValue)?this.showValue:this.bvProgress.showValue||false;}},render:function render(h){var label=this.label,labelHtml=this.labelHtml,computedValue=this.computedValue,computedPrecision=this.computedPrecision;var $children;var domProps={};if(this.hasNormalizedSlot()){$children=this.normalizeSlot();}else if(label||labelHtml){domProps=htmlOrText(labelHtml,label);}else if(this.computedShowProgress){$children=this.computedProgress;}else if(this.computedShowValue){$children=toFixed(computedValue,computedPrecision);}return h('div',{staticClass:'progress-bar',class:this.progressBarClasses,style:this.progressBarStyles,attrs:{role:'progressbar','aria-valuemin':'0','aria-valuemax':toString(this.computedMax),'aria-valuenow':toFixed(computedValue,computedPrecision)},domProps:domProps},$children);}});var progressBarProps=omit(props$C,['label','labelHtml']);var props$B=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},progressBarProps),{},{animated:makeProp(PROP_TYPE_BOOLEAN,false),height:makeProp(PROP_TYPE_STRING),max:makeProp(PROP_TYPE_NUMBER_STRING,100),precision:makeProp(PROP_TYPE_NUMBER_STRING,0),showProgress:makeProp(PROP_TYPE_BOOLEAN,false),showValue:makeProp(PROP_TYPE_BOOLEAN,false),striped:makeProp(PROP_TYPE_BOOLEAN,false)})),NAME_PROGRESS);// --- Main component ---\n// @vue/component\nvar BProgress=/*#__PURE__*/Vue__default['default'].extend({name:NAME_PROGRESS,mixins:[normalizeSlotMixin],provide:function provide(){return{bvProgress:this};},props:props$B,computed:{progressHeight:function progressHeight(){return{height:this.height||null};}},render:function render(h){var $childNodes=this.normalizeSlot();if(!$childNodes){$childNodes=h(BProgressBar,{props:pluckProps(progressBarProps,this.$props)});}return h('div',{staticClass:'progress',style:this.progressHeight},[$childNodes]);}});var ProgressPlugin=/*#__PURE__*/pluginFactory({components:{BProgress:BProgress,BProgressBar:BProgressBar}});var _watch$4;var CLASS_NAME='b-sidebar';var ROOT_ACTION_EVENT_NAME_REQUEST_STATE=getRootActionEventName(NAME_COLLAPSE,'request-state');var ROOT_ACTION_EVENT_NAME_TOGGLE=getRootActionEventName(NAME_COLLAPSE,'toggle');var ROOT_EVENT_NAME_STATE=getRootEventName(NAME_COLLAPSE,'state');var ROOT_EVENT_NAME_SYNC_STATE=getRootEventName(NAME_COLLAPSE,'sync-state');var _makeModelMixin$3=makeModelMixin('visible',{type:PROP_TYPE_BOOLEAN,defaultValue:false,event:EVENT_NAME_CHANGE}),modelMixin$3=_makeModelMixin$3.mixin,modelProps$3=_makeModelMixin$3.props,MODEL_PROP_NAME$3=_makeModelMixin$3.prop,MODEL_EVENT_NAME$3=_makeModelMixin$3.event;// --- Props ---\nvar props$A=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),modelProps$3),{},{ariaLabel:makeProp(PROP_TYPE_STRING),ariaLabelledby:makeProp(PROP_TYPE_STRING),// If `true`, shows a basic backdrop\nbackdrop:makeProp(PROP_TYPE_BOOLEAN,false),backdropVariant:makeProp(PROP_TYPE_STRING,'dark'),bgVariant:makeProp(PROP_TYPE_STRING,'light'),bodyClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),// `aria-label` for close button\ncloseLabel:makeProp(PROP_TYPE_STRING),footerClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),footerTag:makeProp(PROP_TYPE_STRING,'footer'),headerClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),headerTag:makeProp(PROP_TYPE_STRING,'header'),lazy:makeProp(PROP_TYPE_BOOLEAN,false),noCloseOnBackdrop:makeProp(PROP_TYPE_BOOLEAN,false),noCloseOnEsc:makeProp(PROP_TYPE_BOOLEAN,false),noCloseOnRouteChange:makeProp(PROP_TYPE_BOOLEAN,false),noEnforceFocus:makeProp(PROP_TYPE_BOOLEAN,false),noHeader:makeProp(PROP_TYPE_BOOLEAN,false),noHeaderClose:makeProp(PROP_TYPE_BOOLEAN,false),noSlide:makeProp(PROP_TYPE_BOOLEAN,false),right:makeProp(PROP_TYPE_BOOLEAN,false),shadow:makeProp(PROP_TYPE_BOOLEAN_STRING,false),sidebarClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),tag:makeProp(PROP_TYPE_STRING,'div'),textVariant:makeProp(PROP_TYPE_STRING,'dark'),title:makeProp(PROP_TYPE_STRING),width:makeProp(PROP_TYPE_STRING),zIndex:makeProp(PROP_TYPE_NUMBER_STRING)})),NAME_SIDEBAR);// --- Render methods ---\nvar renderHeaderTitle=function renderHeaderTitle(h,ctx){// Render a empty `<span>` when to title was provided\nvar title=ctx.normalizeSlot(SLOT_NAME_TITLE,ctx.slotScope)||ctx.title;if(!title){return h('span');}return h('strong',{attrs:{id:ctx.safeId('__title__')}},[title]);};var renderHeaderClose=function renderHeaderClose(h,ctx){if(ctx.noHeaderClose){return h();}var closeLabel=ctx.closeLabel,textVariant=ctx.textVariant,hide=ctx.hide;return h(BButtonClose,{props:{ariaLabel:closeLabel,textVariant:textVariant},on:{click:hide},ref:'close-button'},[ctx.normalizeSlot(SLOT_NAME_HEADER_CLOSE)||h(BIconX)]);};var renderHeader=function renderHeader(h,ctx){if(ctx.noHeader){return h();}var $content=ctx.normalizeSlot(SLOT_NAME_HEADER,ctx.slotScope);if(!$content){var $title=renderHeaderTitle(h,ctx);var $close=renderHeaderClose(h,ctx);$content=ctx.right?[$close,$title]:[$title,$close];}return h(ctx.headerTag,{staticClass:\"\".concat(CLASS_NAME,\"-header\"),class:ctx.headerClass,key:'header'},$content);};var renderBody=function renderBody(h,ctx){return h('div',{staticClass:\"\".concat(CLASS_NAME,\"-body\"),class:ctx.bodyClass,key:'body'},[ctx.normalizeSlot(SLOT_NAME_DEFAULT,ctx.slotScope)]);};var renderFooter=function renderFooter(h,ctx){var $footer=ctx.normalizeSlot(SLOT_NAME_FOOTER,ctx.slotScope);if(!$footer){return h();}return h(ctx.footerTag,{staticClass:\"\".concat(CLASS_NAME,\"-footer\"),class:ctx.footerClass,key:'footer'},[$footer]);};var renderContent=function renderContent(h,ctx){// We render the header even if `lazy` is enabled as it\n// acts as the accessible label for the sidebar\nvar $header=renderHeader(h,ctx);if(ctx.lazy&&!ctx.isOpen){return $header;}return[$header,renderBody(h,ctx),renderFooter(h,ctx)];};var renderBackdrop=function renderBackdrop(h,ctx){if(!ctx.backdrop){return h();}var backdropVariant=ctx.backdropVariant;return h('div',{directives:[{name:'show',value:ctx.localShow}],staticClass:'b-sidebar-backdrop',class:_defineProperty({},\"bg-\".concat(backdropVariant),backdropVariant),on:{click:ctx.onBackdropClick}});};// --- Main component ---\n// @vue/component\nvar BSidebar=/*#__PURE__*/Vue__default['default'].extend({name:NAME_SIDEBAR,mixins:[attrsMixin,idMixin,modelMixin$3,listenOnRootMixin,normalizeSlotMixin],inheritAttrs:false,props:props$A,data:function data(){var visible=!!this[MODEL_PROP_NAME$3];return{// Internal `v-model` state\nlocalShow:visible,// For lazy render triggering\nisOpen:visible};},computed:{transitionProps:function transitionProps(){return this.noSlide?/* istanbul ignore next */{css:true}:{css:true,enterClass:'',enterActiveClass:'slide',enterToClass:'show',leaveClass:'show',leaveActiveClass:'slide',leaveToClass:''};},slotScope:function slotScope(){var hide=this.hide,right=this.right,visible=this.localShow;return{hide:hide,right:right,visible:visible};},hasTitle:function hasTitle(){var $scopedSlots=this.$scopedSlots,$slots=this.$slots;return!this.noHeader&&!this.hasNormalizedSlot(SLOT_NAME_HEADER)&&!!(this.normalizeSlot(SLOT_NAME_TITLE,this.slotScope,$scopedSlots,$slots)||this.title);},titleId:function titleId(){return this.hasTitle?this.safeId('__title__'):null;},computedAttrs:function computedAttrs(){return _objectSpread2$3(_objectSpread2$3({},this.bvAttrs),{},{id:this.safeId(),tabindex:'-1',role:'dialog','aria-modal':this.backdrop?'true':'false','aria-hidden':this.localShow?null:'true','aria-label':this.ariaLabel||null,'aria-labelledby':this.ariaLabelledby||this.titleId||null});}},watch:(_watch$4={},_defineProperty(_watch$4,MODEL_PROP_NAME$3,function(newValue,oldValue){if(newValue!==oldValue){this.localShow=newValue;}}),_defineProperty(_watch$4,\"localShow\",function localShow(newValue,oldValue){if(newValue!==oldValue){this.emitState(newValue);this.$emit(MODEL_EVENT_NAME$3,newValue);}}),_defineProperty(_watch$4,\"$route\",function $route(){var newValue=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var oldValue=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(!this.noCloseOnRouteChange&&newValue.fullPath!==oldValue.fullPath){this.hide();}}),_watch$4),created:function created(){// Define non-reactive properties\nthis.$_returnFocusEl=null;},mounted:function mounted(){var _this=this;// Add `$root` listeners\nthis.listenOnRoot(ROOT_ACTION_EVENT_NAME_TOGGLE,this.handleToggle);this.listenOnRoot(ROOT_ACTION_EVENT_NAME_REQUEST_STATE,this.handleSync);// Send out a gratuitous state event to ensure toggle button is synced\nthis.$nextTick(function(){_this.emitState(_this.localShow);});},/* istanbul ignore next */activated:function activated(){this.emitSync();},beforeDestroy:function beforeDestroy(){this.localShow=false;this.$_returnFocusEl=null;},methods:{hide:function hide(){this.localShow=false;},emitState:function emitState(){var state=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.localShow;this.emitOnRoot(ROOT_EVENT_NAME_STATE,this.safeId(),state);},emitSync:function emitSync(){var state=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.localShow;this.emitOnRoot(ROOT_EVENT_NAME_SYNC_STATE,this.safeId(),state);},handleToggle:function handleToggle(id){// Note `safeId()` can be null until after mount\nif(id&&id===this.safeId()){this.localShow=!this.localShow;}},handleSync:function handleSync(id){var _this2=this;// Note `safeId()` can be null until after mount\nif(id&&id===this.safeId()){this.$nextTick(function(){_this2.emitSync(_this2.localShow);});}},onKeydown:function onKeydown(event){var keyCode=event.keyCode;if(!this.noCloseOnEsc&&keyCode===CODE_ESC&&this.localShow){this.hide();}},onBackdropClick:function onBackdropClick(){if(this.localShow&&!this.noCloseOnBackdrop){this.hide();}},/* istanbul ignore next */onTopTrapFocus:function onTopTrapFocus(){var tabables=getTabables(this.$refs.content);this.enforceFocus(tabables.reverse()[0]);},/* istanbul ignore next */onBottomTrapFocus:function onBottomTrapFocus(){var tabables=getTabables(this.$refs.content);this.enforceFocus(tabables[0]);},onBeforeEnter:function onBeforeEnter(){// Returning focus to `document.body` may cause unwanted scrolls,\n// so we exclude setting focus on body\nthis.$_returnFocusEl=getActiveElement(IS_BROWSER?[document.body]:[]);// Trigger lazy render\nthis.isOpen=true;},onAfterEnter:function onAfterEnter(el){if(!contains(el,getActiveElement())){this.enforceFocus(el);}this.$emit(EVENT_NAME_SHOWN);},onAfterLeave:function onAfterLeave(){this.enforceFocus(this.$_returnFocusEl);this.$_returnFocusEl=null;// Trigger lazy render\nthis.isOpen=false;this.$emit(EVENT_NAME_HIDDEN);},enforceFocus:function enforceFocus(el){if(!this.noEnforceFocus){attemptFocus(el);}}},render:function render(h){var _ref;var bgVariant=this.bgVariant,width=this.width,textVariant=this.textVariant,localShow=this.localShow;var shadow=this.shadow===''?true:this.shadow;var $sidebar=h(this.tag,{staticClass:CLASS_NAME,class:[(_ref={shadow:shadow===true},_defineProperty(_ref,\"shadow-\".concat(shadow),shadow&&shadow!==true),_defineProperty(_ref,\"\".concat(CLASS_NAME,\"-right\"),this.right),_defineProperty(_ref,\"bg-\".concat(bgVariant),bgVariant),_defineProperty(_ref,\"text-\".concat(textVariant),textVariant),_ref),this.sidebarClass],style:{width:width},attrs:this.computedAttrs,directives:[{name:'show',value:localShow}],ref:'content'},[renderContent(h,this)]);$sidebar=h('transition',{props:this.transitionProps,on:{beforeEnter:this.onBeforeEnter,afterEnter:this.onAfterEnter,afterLeave:this.onAfterLeave}},[$sidebar]);var $backdrop=h(BVTransition,{props:{noFade:this.noSlide}},[renderBackdrop(h,this)]);var $tabTrapTop=h();var $tabTrapBottom=h();if(this.backdrop&&localShow){$tabTrapTop=h('div',{attrs:{tabindex:'0'},on:{focus:this.onTopTrapFocus}});$tabTrapBottom=h('div',{attrs:{tabindex:'0'},on:{focus:this.onBottomTrapFocus}});}return h('div',{staticClass:'b-sidebar-outer',style:{zIndex:this.zIndex},attrs:{tabindex:'-1'},on:{keydown:this.onKeydown}},[$tabTrapTop,$sidebar,$tabTrapBottom,$backdrop]);}});var SidebarPlugin=/*#__PURE__*/pluginFactory({components:{BSidebar:BSidebar},plugins:{VBTogglePlugin:VBTogglePlugin}});var props$z=makePropsConfigurable({animation:makeProp(PROP_TYPE_STRING,'wave'),height:makeProp(PROP_TYPE_STRING),size:makeProp(PROP_TYPE_STRING),type:makeProp(PROP_TYPE_STRING,'text'),variant:makeProp(PROP_TYPE_STRING),width:makeProp(PROP_TYPE_STRING)},NAME_SKELETON);// --- Main component ---\n// @vue/component\nvar BSkeleton=/*#__PURE__*/Vue__default['default'].extend({name:NAME_SKELETON,functional:true,props:props$z,render:function render(h,_ref){var _class;var data=_ref.data,props=_ref.props;var size=props.size,animation=props.animation,variant=props.variant;return h('div',a(data,{staticClass:'b-skeleton',style:{width:size||props.width,height:size||props.height},class:(_class={},_defineProperty(_class,\"b-skeleton-\".concat(props.type),true),_defineProperty(_class,\"b-skeleton-animate-\".concat(animation),animation),_defineProperty(_class,\"bg-\".concat(variant),variant),_class)}));}});makePropsConfigurable(omit(props$2h,['content','stacked']),NAME_ICONSTACK);// --- Main component ---\nvar props$y=makePropsConfigurable({animation:makeProp(PROP_TYPE_STRING,'wave'),icon:makeProp(PROP_TYPE_STRING),iconProps:makeProp(PROP_TYPE_OBJECT,{})},NAME_SKELETON_ICON);// --- Main component ---\n// @vue/component\nvar BSkeletonIcon=/*#__PURE__*/Vue__default['default'].extend({name:NAME_SKELETON_ICON,functional:true,props:props$y,render:function render(h,_ref){var data=_ref.data,props=_ref.props;var icon=props.icon,animation=props.animation;var $icon=h(BIcon,{staticClass:'b-skeleton-icon',props:_objectSpread2$3(_objectSpread2$3({},props.iconProps),{},{icon:icon})});return h('div',a(data,{staticClass:'b-skeleton-icon-wrapper position-relative d-inline-block overflow-hidden',class:_defineProperty({},\"b-skeleton-animate-\".concat(animation),animation)}),[$icon]);}});var props$x=makePropsConfigurable({animation:makeProp(PROP_TYPE_STRING),aspect:makeProp(PROP_TYPE_STRING,'16:9'),cardImg:makeProp(PROP_TYPE_STRING),height:makeProp(PROP_TYPE_STRING),noAspect:makeProp(PROP_TYPE_BOOLEAN,false),variant:makeProp(PROP_TYPE_STRING),width:makeProp(PROP_TYPE_STRING)},NAME_SKELETON_IMG);// --- Main component ---\n// @vue/component\nvar BSkeletonImg=/*#__PURE__*/Vue__default['default'].extend({name:NAME_SKELETON_IMG,functional:true,props:props$x,render:function render(h,_ref){var data=_ref.data,props=_ref.props;var aspect=props.aspect,width=props.width,height=props.height,animation=props.animation,variant=props.variant,cardImg=props.cardImg;var $img=h(BSkeleton,a(data,{props:{type:'img',width:width,height:height,animation:animation,variant:variant},class:_defineProperty({},\"card-img-\".concat(cardImg),cardImg)}));return props.noAspect?$img:h(BAspect,{props:{aspect:aspect}},[$img]);}});// Mixin to determine if an event listener has been registered\nvar hasListenerMixin=Vue__default['default'].extend({methods:{hasListener:function hasListener(name){// Only includes listeners registered via `v-on:name`\nvar $listeners=this.$listeners||{};// Includes `v-on:name` and `this.$on('name')` registered listeners\n// Note this property is not part of the public Vue API, but it is\n// the only way to determine if a listener was added via `vm.$on`\nvar $events=this._events||{};// Registered listeners in `this._events` are always an array,\n// but might be zero length\nreturn!isUndefined($listeners[name])||isArray($events[name])&&$events[name].length>0;}}});var LIGHT='light';var DARK='dark';// --- Props ---\nvar props$w=makePropsConfigurable({variant:makeProp(PROP_TYPE_STRING)},NAME_TR);// --- Main component ---\n// TODO:\n//   In Bootstrap v5, we won't need \"sniffing\" as table element variants properly inherit\n//   to the child elements, so this can be converted to a functional component\n// @vue/component\nvar BTr=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TR,mixins:[attrsMixin,listenersMixin,normalizeSlotMixin],provide:function provide(){return{bvTableTr:this};},inject:{bvTableRowGroup:{default:/* istanbul ignore next */function _default(){return{};}}},inheritAttrs:false,props:props$w,computed:{// Sniffed by `<b-td>` / `<b-th>`\ninTbody:function inTbody(){return this.bvTableRowGroup.isTbody;},// Sniffed by `<b-td>` / `<b-th>`\ninThead:function inThead(){return this.bvTableRowGroup.isThead;},// Sniffed by `<b-td>` / `<b-th>`\ninTfoot:function inTfoot(){return this.bvTableRowGroup.isTfoot;},// Sniffed by `<b-td>` / `<b-th>`\nisDark:function isDark(){return this.bvTableRowGroup.isDark;},// Sniffed by `<b-td>` / `<b-th>`\nisStacked:function isStacked(){return this.bvTableRowGroup.isStacked;},// Sniffed by `<b-td>` / `<b-th>`\nisResponsive:function isResponsive(){return this.bvTableRowGroup.isResponsive;},// Sniffed by `<b-td>` / `<b-th>`\n// Sticky headers are only supported in thead\nisStickyHeader:function isStickyHeader(){return this.bvTableRowGroup.isStickyHeader;},// Sniffed by <b-tr> / `<b-td>` / `<b-th>`\n// Needed to handle header background classes, due to lack of\n// background color inheritance with Bootstrap v4 table CSS\nhasStickyHeader:function hasStickyHeader(){return!this.isStacked&&this.bvTableRowGroup.hasStickyHeader;},// Sniffed by `<b-td>` / `<b-th>`\ntableVariant:function tableVariant(){return this.bvTableRowGroup.tableVariant;},// Sniffed by `<b-td>` / `<b-th>`\nheadVariant:function headVariant(){return this.inThead?this.bvTableRowGroup.headVariant:null;},// Sniffed by `<b-td>` / `<b-th>`\nfootVariant:function footVariant(){return this.inTfoot?this.bvTableRowGroup.footVariant:null;},isRowDark:function isRowDark(){return this.headVariant===LIGHT||this.footVariant===LIGHT?/* istanbul ignore next */false:this.headVariant===DARK||this.footVariant===DARK?/* istanbul ignore next */true:this.isDark;},trClasses:function trClasses(){var variant=this.variant;return[variant?\"\".concat(this.isRowDark?'bg':'table',\"-\").concat(variant):null];},trAttrs:function trAttrs(){return _objectSpread2$3({role:'row'},this.bvAttrs);}},render:function render(h){return h('tr',{class:this.trClasses,attrs:this.trAttrs,// Pass native listeners to child\non:this.bvListeners},this.normalizeSlot());}});var props$v={};// --- Mixin ---\n// @vue/component\nvar bottomRowMixin=Vue__default['default'].extend({props:props$v,methods:{renderBottomRow:function renderBottomRow(){var fields=this.computedFields,stacked=this.stacked,tbodyTrClass=this.tbodyTrClass,tbodyTrAttr=this.tbodyTrAttr;var h=this.$createElement;// Static bottom row slot (hidden in visibly stacked mode as we can't control the data-label)\n// If in *always* stacked mode, we don't bother rendering the row\nif(!this.hasNormalizedSlot(SLOT_NAME_BOTTOM_ROW)||stacked===true||stacked===''){return h();}return h(BTr,{staticClass:'b-table-bottom-row',class:[isFunction$1(tbodyTrClass)?/* istanbul ignore next */tbodyTrClass(null,'row-bottom'):tbodyTrClass],attrs:isFunction$1(tbodyTrAttr)?/* istanbul ignore next */tbodyTrAttr(null,'row-bottom'):tbodyTrAttr,key:'b-bottom-row'},this.normalizeSlot(SLOT_NAME_BOTTOM_ROW,{columns:fields.length,fields:fields}));}}});// Parse a rowspan or colspan into a digit (or `null` if < `1` )\nvar parseSpan=function parseSpan(value){value=toInteger(value,0);return value>0?value:null;};/* istanbul ignore next */var spanValidator=function spanValidator(value){return isUndefinedOrNull(value)||parseSpan(value)>0;};// --- Props ---\nvar props$u=makePropsConfigurable({colspan:makeProp(PROP_TYPE_NUMBER_STRING,null,spanValidator),rowspan:makeProp(PROP_TYPE_NUMBER_STRING,null,spanValidator),stackedHeading:makeProp(PROP_TYPE_STRING),stickyColumn:makeProp(PROP_TYPE_BOOLEAN,false),variant:makeProp(PROP_TYPE_STRING)},NAME_TABLE_CELL);// --- Main component ---\n// TODO:\n//   In Bootstrap v5, we won't need \"sniffing\" as table element variants properly inherit\n//   to the child elements, so this can be converted to a functional component\n// @vue/component\nvar BTd=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TABLE_CELL,// Mixin order is important!\nmixins:[attrsMixin,listenersMixin,normalizeSlotMixin],inject:{bvTableTr:{default:/* istanbul ignore next */function _default(){return{};}}},inheritAttrs:false,props:props$u,computed:{// Overridden by `<b-th>`\ntag:function tag(){return'td';},inTbody:function inTbody(){return this.bvTableTr.inTbody;},inThead:function inThead(){return this.bvTableTr.inThead;},inTfoot:function inTfoot(){return this.bvTableTr.inTfoot;},isDark:function isDark(){return this.bvTableTr.isDark;},isStacked:function isStacked(){return this.bvTableTr.isStacked;},// We only support stacked-heading in tbody in stacked mode\nisStackedCell:function isStackedCell(){return this.inTbody&&this.isStacked;},isResponsive:function isResponsive(){return this.bvTableTr.isResponsive;},// Needed to handle header background classes, due to lack of\n// background color inheritance with Bootstrap v4 table CSS\n// Sticky headers only apply to cells in table `thead`\nisStickyHeader:function isStickyHeader(){return this.bvTableTr.isStickyHeader;},// Needed to handle header background classes, due to lack of\n// background color inheritance with Bootstrap v4 table CSS\nhasStickyHeader:function hasStickyHeader(){return this.bvTableTr.hasStickyHeader;},// Needed to handle background classes, due to lack of\n// background color inheritance with Bootstrap v4 table CSS\n// Sticky column cells are only available in responsive\n// mode (horizontal scrolling) or when sticky header mode\n// Applies to cells in `thead`, `tbody` and `tfoot`\nisStickyColumn:function isStickyColumn(){return!this.isStacked&&(this.isResponsive||this.hasStickyHeader)&&this.stickyColumn;},rowVariant:function rowVariant(){return this.bvTableTr.variant;},headVariant:function headVariant(){return this.bvTableTr.headVariant;},footVariant:function footVariant(){return this.bvTableTr.footVariant;},tableVariant:function tableVariant(){return this.bvTableTr.tableVariant;},computedColspan:function computedColspan(){return parseSpan(this.colspan);},computedRowspan:function computedRowspan(){return parseSpan(this.rowspan);},// We use computed props here for improved performance by caching\n// the results of the string interpolation\ncellClasses:function cellClasses(){var variant=this.variant,headVariant=this.headVariant,isStickyColumn=this.isStickyColumn;if(!variant&&this.isStickyHeader&&!headVariant||!variant&&isStickyColumn&&this.inTfoot&&!this.footVariant||!variant&&isStickyColumn&&this.inThead&&!headVariant||!variant&&isStickyColumn&&this.inTbody){// Needed for sticky-header mode as Bootstrap v4 table cells do\n// not inherit parent's `background-color`\nvariant=this.rowVariant||this.tableVariant||'b-table-default';}return[variant?\"\".concat(this.isDark?'bg':'table',\"-\").concat(variant):null,isStickyColumn?'b-table-sticky-column':null];},cellAttrs:function cellAttrs(){var stackedHeading=this.stackedHeading;// We use computed props here for improved performance by caching\n// the results of the object spread (Object.assign)\nvar headOrFoot=this.inThead||this.inTfoot;// Make sure col/rowspan's are > 0 or null\nvar colspan=this.computedColspan;var rowspan=this.computedRowspan;// Default role and scope\nvar role='cell';var scope=null;// Compute role and scope\n// We only add scopes with an explicit span of 1 or greater\nif(headOrFoot){// Header or footer cells\nrole='columnheader';scope=colspan>0?'colspan':'col';}else if(isTag(this.tag,'th')){// th's in tbody\nrole='rowheader';scope=rowspan>0?'rowgroup':'row';}return _objectSpread2$3(_objectSpread2$3({colspan:colspan,rowspan:rowspan,role:role,scope:scope},this.bvAttrs),{},{// Add in the stacked cell label data-attribute if in\n// stacked mode (if a stacked heading label is provided)\n'data-label':this.isStackedCell&&!isUndefinedOrNull(stackedHeading)?/* istanbul ignore next */toString(stackedHeading):null});}},render:function render(h){var $content=[this.normalizeSlot()];return h(this.tag,{class:this.cellClasses,attrs:this.cellAttrs,// Transfer any native listeners\non:this.bvListeners},[this.isStackedCell?h('div',[$content]):$content]);}});var MODEL_PROP_NAME_BUSY='busy';var MODEL_EVENT_NAME_BUSY=MODEL_EVENT_NAME_PREFIX+MODEL_PROP_NAME_BUSY;// --- Props ---\nvar props$t=_defineProperty({},MODEL_PROP_NAME_BUSY,makeProp(PROP_TYPE_BOOLEAN,false));// --- Mixin ---\n// @vue/component\nvar busyMixin=Vue__default['default'].extend({props:props$t,data:function data(){return{localBusy:false};},computed:{computedBusy:function computedBusy(){return this[MODEL_PROP_NAME_BUSY]||this.localBusy;}},watch:{localBusy:function localBusy(newValue,oldValue){if(newValue!==oldValue){this.$emit(MODEL_EVENT_NAME_BUSY,newValue);}}},methods:{// Event handler helper\nstopIfBusy:function stopIfBusy(event){// If table is busy (via provider) then don't propagate\nif(this.computedBusy){stopEvent(event);return true;}return false;},// Render the busy indicator or return `null` if not busy\nrenderBusy:function renderBusy(){var tbodyTrClass=this.tbodyTrClass,tbodyTrAttr=this.tbodyTrAttr;var h=this.$createElement;// Return a busy indicator row, or `null` if not busy\nif(this.computedBusy&&this.hasNormalizedSlot(SLOT_NAME_TABLE_BUSY)){return h(BTr,{staticClass:'b-table-busy-slot',class:[isFunction$1(tbodyTrClass)?/* istanbul ignore next */tbodyTrClass(null,SLOT_NAME_TABLE_BUSY):tbodyTrClass],attrs:isFunction$1(tbodyTrAttr)?/* istanbul ignore next */tbodyTrAttr(null,SLOT_NAME_TABLE_BUSY):tbodyTrAttr,key:'table-busy-slot'},[h(BTd,{props:{colspan:this.computedFields.length||null}},[this.normalizeSlot(SLOT_NAME_TABLE_BUSY)])]);}// We return `null` here so that we can determine if we need to\n// render the table items rows or not\nreturn null;}}});var props$s={caption:makeProp(PROP_TYPE_STRING),captionHtml:makeProp(PROP_TYPE_STRING)// `caption-top` is part of table-render mixin (styling)\n// captionTop: makeProp(PROP_TYPE_BOOLEAN, false)\n};// --- Mixin ---\n// @vue/component\nvar captionMixin=Vue__default['default'].extend({props:props$s,computed:{captionId:function captionId(){return this.isStacked?this.safeId('_caption_'):null;}},methods:{renderCaption:function renderCaption(){var caption=this.caption,captionHtml=this.captionHtml;var h=this.$createElement;var $caption=h();var hasCaptionSlot=this.hasNormalizedSlot(SLOT_NAME_TABLE_CAPTION);if(hasCaptionSlot||caption||captionHtml){$caption=h('caption',{attrs:{id:this.captionId},domProps:hasCaptionSlot?{}:htmlOrText(captionHtml,caption),key:'caption',ref:'caption'},this.normalizeSlot(SLOT_NAME_TABLE_CAPTION));}return $caption;}}});var props$r={};// --- Mixin ---\n// @vue/component\nvar colgroupMixin=Vue__default['default'].extend({methods:{renderColgroup:function renderColgroup(){var fields=this.computedFields;var h=this.$createElement;var $colgroup=h();if(this.hasNormalizedSlot(SLOT_NAME_TABLE_COLGROUP)){$colgroup=h('colgroup',{key:'colgroup'},[this.normalizeSlot(SLOT_NAME_TABLE_COLGROUP,{columns:fields.length,fields:fields})]);}return $colgroup;}}});var props$q={emptyFilteredHtml:makeProp(PROP_TYPE_STRING),emptyFilteredText:makeProp(PROP_TYPE_STRING,'There are no records matching your request'),emptyHtml:makeProp(PROP_TYPE_STRING),emptyText:makeProp(PROP_TYPE_STRING,'There are no records to show'),showEmpty:makeProp(PROP_TYPE_BOOLEAN,false)};// --- Mixin ---\n// @vue/component\nvar emptyMixin=Vue__default['default'].extend({props:props$q,methods:{renderEmpty:function renderEmpty(){var items=this.computedItems;var h=this.$createElement;var $empty=h();if(this.showEmpty&&(!items||items.length===0)&&!(this.computedBusy&&this.hasNormalizedSlot(SLOT_NAME_TABLE_BUSY))){var fields=this.computedFields,isFiltered=this.isFiltered,emptyText=this.emptyText,emptyHtml=this.emptyHtml,emptyFilteredText=this.emptyFilteredText,emptyFilteredHtml=this.emptyFilteredHtml,tbodyTrClass=this.tbodyTrClass,tbodyTrAttr=this.tbodyTrAttr;$empty=this.normalizeSlot(isFiltered?SLOT_NAME_EMPTYFILTERED:SLOT_NAME_EMPTY,{emptyFilteredHtml:emptyFilteredHtml,emptyFilteredText:emptyFilteredText,emptyHtml:emptyHtml,emptyText:emptyText,fields:fields,// Not sure why this is included, as it will always be an empty array\nitems:items});if(!$empty){$empty=h('div',{class:['text-center','my-2'],domProps:isFiltered?htmlOrText(emptyFilteredHtml,emptyFilteredText):htmlOrText(emptyHtml,emptyText)});}$empty=h(BTd,{props:{colspan:fields.length||null}},[h('div',{attrs:{role:'alert','aria-live':'polite'}},[$empty])]);$empty=h(BTr,{staticClass:'b-table-empty-row',class:[isFunction$1(tbodyTrClass)?/* istanbul ignore next */tbodyTrClass(null,'row-empty'):tbodyTrClass],attrs:isFunction$1(tbodyTrAttr)?/* istanbul ignore next */tbodyTrAttr(null,'row-empty'):tbodyTrAttr,key:isFiltered?'b-empty-filtered-row':'b-empty-row'},[$empty]);}return $empty;}}});// SSR safe deterministic way (keys are sorted before stringification)\n//\n//   ex:\n//     { b: 3, c: { z: 'zzz', d: null, e: 2 }, d: [10, 12, 11], a: 'one' }\n//   becomes\n//     'one 3 2 zzz 10 12 11'\n//\n// Strings are returned as-is\n// Numbers get converted to string\n// `null` and `undefined` values are filtered out\n// Dates are converted to their native string format\nvar stringifyObjectValues=function stringifyObjectValues(value){if(isUndefinedOrNull(value)){return'';}// Arrays are also object, and keys just returns the array indexes\n// Date objects we convert to strings\nif(isObject(value)&&!isDate(value)){return keys(value).sort()// Sort to prevent SSR issues on pre-rendered sorted tables\n.map(function(k){return stringifyObjectValues(value[k]);}).filter(function(v){return!!v;})// Ignore empty strings\n.join(' ');}return toString(value);};// Constants used by table helpers\nvar FIELD_KEY_CELL_VARIANT='_cellVariants';var FIELD_KEY_ROW_VARIANT='_rowVariant';var FIELD_KEY_SHOW_DETAILS='_showDetails';// Object of item keys that should be ignored for headers and\n// stringification and filter events\nvar IGNORED_FIELD_KEYS=[FIELD_KEY_CELL_VARIANT,FIELD_KEY_ROW_VARIANT,FIELD_KEY_SHOW_DETAILS].reduce(function(result,key){return _objectSpread2$3(_objectSpread2$3({},result),{},_defineProperty({},key,true));},{});// Filter CSS selector for click/dblclick/etc. events\n// If any of these selectors match the clicked element, we ignore the event\nvar EVENT_FILTER=['a','a *',// Include content inside links\n'button','button *',// Include content inside buttons\n'input:not(.disabled):not([disabled])','select:not(.disabled):not([disabled])','textarea:not(.disabled):not([disabled])','[role=\"link\"]','[role=\"link\"] *','[role=\"button\"]','[role=\"button\"] *','[tabindex]:not(.disabled):not([disabled])'].join(',');var sanitizeRow=function sanitizeRow(row,ignoreFields,includeFields){var fieldsObj=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};// We first need to format the row based on the field configurations\n// This ensures that we add formatted values for keys that may not\n// exist in the row itself\nvar formattedRow=keys(fieldsObj).reduce(function(result,key){var field=fieldsObj[key];var filterByFormatted=field.filterByFormatted;var formatter=isFunction$1(filterByFormatted)?/* istanbul ignore next */filterByFormatted:filterByFormatted?/* istanbul ignore next */field.formatter:null;if(isFunction$1(formatter)){result[key]=formatter(row[key],key,row);}return result;},clone(row));// Determine the allowed keys:\n//   - Ignore special fields that start with `_`\n//   - Ignore fields in the `ignoreFields` array\n//   - Include only fields in the `includeFields` array\nvar allowedKeys=keys(formattedRow).filter(function(key){return!IGNORED_FIELD_KEYS[key]&&!(isArray(ignoreFields)&&ignoreFields.length>0&&arrayIncludes(ignoreFields,key))&&!(isArray(includeFields)&&includeFields.length>0&&!arrayIncludes(includeFields,key));});return pick$1(formattedRow,allowedKeys);};// TODO: Add option to stringify `scopedSlot` items\nvar stringifyRecordValues=function stringifyRecordValues(row,ignoreFields,includeFields,fieldsObj){return isObject(row)?stringifyObjectValues(sanitizeRow(row,ignoreFields,includeFields,fieldsObj)):/* istanbul ignore next */'';};var DEBOUNCE_DEPRECATED_MSG='Prop \"filter-debounce\" is deprecated. Use the debounce feature of \"<b-form-input>\" instead.';// --- Props ---\nvar props$p={filter:makeProp([].concat(_toConsumableArray$1(PROP_TYPE_ARRAY_OBJECT_STRING),[PROP_TYPE_REG_EXP])),filterDebounce:makeProp(PROP_TYPE_NUMBER_STRING,0,function(value){return RX_DIGITS.test(String(value));}),filterFunction:makeProp(PROP_TYPE_FUNCTION),filterIgnoredFields:makeProp(PROP_TYPE_ARRAY,[]),filterIncludedFields:makeProp(PROP_TYPE_ARRAY,[])};// --- Mixin ---\n// @vue/component\nvar filteringMixin=Vue__default['default'].extend({props:props$p,data:function data(){return{// Flag for displaying which empty slot to show and some event triggering\nisFiltered:false,// Where we store the copy of the filter criteria after debouncing\n// We pre-set it with the sanitized filter value\nlocalFilter:this.filterSanitize(this.filter)};},computed:{computedFilterIgnored:function computedFilterIgnored(){return concat(this.filterIgnoredFields||[]).filter(identity);},computedFilterIncluded:function computedFilterIncluded(){return concat(this.filterIncludedFields||[]).filter(identity);},computedFilterDebounce:function computedFilterDebounce(){var ms=toInteger(this.filterDebounce,0);/* istanbul ignore next */if(ms>0){warn(DEBOUNCE_DEPRECATED_MSG,NAME_TABLE);}return ms;},localFiltering:function localFiltering(){return this.hasProvider?!!this.noProviderFiltering:true;},// For watching changes to `filteredItems` vs `localItems`\nfilteredCheck:function filteredCheck(){var filteredItems=this.filteredItems,localItems=this.localItems,localFilter=this.localFilter;return{filteredItems:filteredItems,localItems:localItems,localFilter:localFilter};},// Sanitized/normalize filter-function prop\nlocalFilterFn:function localFilterFn(){// Return `null` to signal to use internal filter function\nvar filterFunction=this.filterFunction;return hasPropFunction(filterFunction)?filterFunction:null;},// Returns the records in `localItems` that match the filter criteria\n// Returns the original `localItems` array if not sorting\nfilteredItems:function filteredItems(){// Note the criteria is debounced and sanitized\nvar items=this.localItems,criteria=this.localFilter;// Resolve the filtering function, when requested\n// We prefer the provided filtering function and fallback to the internal one\n// When no filtering criteria is specified the filtering factories will return `null`\nvar filterFn=this.localFiltering?this.filterFnFactory(this.localFilterFn,criteria)||this.defaultFilterFnFactory(criteria):null;// We only do local filtering when requested and there are records to filter\nreturn filterFn&&items.length>0?items.filter(filterFn):items;}},watch:{// Watch for debounce being set to 0\ncomputedFilterDebounce:function computedFilterDebounce(newValue){if(!newValue&&this.$_filterTimer){this.clearFilterTimer();this.localFilter=this.filterSanitize(this.filter);}},// Watch for changes to the filter criteria, and debounce if necessary\nfilter:{// We need a deep watcher in case the user passes\n// an object when using `filter-function`\ndeep:true,handler:function handler(newCriteria){var _this=this;var timeout=this.computedFilterDebounce;this.clearFilterTimer();if(timeout&&timeout>0){// If we have a debounce time, delay the update of `localFilter`\nthis.$_filterTimer=setTimeout(function(){_this.localFilter=_this.filterSanitize(newCriteria);},timeout);}else{// Otherwise, immediately update `localFilter` with `newFilter` value\nthis.localFilter=this.filterSanitize(newCriteria);}}},// Watch for changes to the filter criteria and filtered items vs `localItems`\n// Set visual state and emit events as required\nfilteredCheck:function filteredCheck(_ref){var filteredItems=_ref.filteredItems,localFilter=_ref.localFilter;// Determine if the dataset is filtered or not\nvar isFiltered=false;if(!localFilter){// If filter criteria is falsey\nisFiltered=false;}else if(looseEqual(localFilter,[])||looseEqual(localFilter,{})){// If filter criteria is an empty array or object\nisFiltered=false;}else if(localFilter){// If filter criteria is truthy\nisFiltered=true;}if(isFiltered){this.$emit(EVENT_NAME_FILTERED,filteredItems,filteredItems.length);}this.isFiltered=isFiltered;},isFiltered:function isFiltered(newValue,oldValue){if(newValue===false&&oldValue===true){// We need to emit a filtered event if `isFiltered` transitions from `true` to\n// `false` so that users can update their pagination controls\nvar localItems=this.localItems;this.$emit(EVENT_NAME_FILTERED,localItems,localItems.length);}}},created:function created(){var _this2=this;// Create private non-reactive props\nthis.$_filterTimer=null;// If filter is \"pre-set\", set the criteria\n// This will trigger any watchers/dependents\n// this.localFilter = this.filterSanitize(this.filter)\n// Set the initial filtered state in a `$nextTick()` so that\n// we trigger a filtered event if needed\nthis.$nextTick(function(){_this2.isFiltered=Boolean(_this2.localFilter);});},beforeDestroy:function beforeDestroy(){this.clearFilterTimer();},methods:{clearFilterTimer:function clearFilterTimer(){clearTimeout(this.$_filterTimer);this.$_filterTimer=null;},filterSanitize:function filterSanitize(criteria){// Sanitizes filter criteria based on internal or external filtering\nif(this.localFiltering&&!this.localFilterFn&&!(isString(criteria)||isRegExp(criteria))){// If using internal filter function, which only accepts string or RegExp,\n// return '' to signify no filter\nreturn'';}// Could be a string, object or array, as needed by external filter function\n// We use `cloneDeep` to ensure we have a new copy of an object or array\n// without Vue's reactive observers\nreturn cloneDeep(criteria);},// Filter Function factories\nfilterFnFactory:function filterFnFactory(filterFn,criteria){// Wrapper factory for external filter functions\n// Wrap the provided filter-function and return a new function\n// Returns `null` if no filter-function defined or if criteria is falsey\n// Rather than directly grabbing `this.computedLocalFilterFn` or `this.filterFunction`\n// we have it passed, so that the caller computed prop will be reactive to changes\n// in the original filter-function (as this routine is a method)\nif(!filterFn||!isFunction$1(filterFn)||!criteria||looseEqual(criteria,[])||looseEqual(criteria,{})){return null;}// Build the wrapped filter test function, passing the criteria to the provided function\nvar fn=function fn(item){// Generated function returns true if the criteria matches part\n// of the serialized data, otherwise false\nreturn filterFn(item,criteria);};// Return the wrapped function\nreturn fn;},defaultFilterFnFactory:function defaultFilterFnFactory(criteria){var _this3=this;// Generates the default filter function, using the given filter criteria\n// Returns `null` if no criteria or criteria format not supported\nif(!criteria||!(isString(criteria)||isRegExp(criteria))){// Built in filter can only support strings or RegExp criteria (at the moment)\nreturn null;}// Build the RegExp needed for filtering\nvar regExp=criteria;if(isString(regExp)){// Escape special RegExp characters in the string and convert contiguous\n// whitespace to \\s+ matches\nvar pattern=escapeRegExp(criteria).replace(RX_SPACES,'\\\\s+');// Build the RegExp (no need for global flag, as we only need\n// to find the value once in the string)\nregExp=new RegExp(\".*\".concat(pattern,\".*\"),'i');}// Generate the wrapped filter test function to use\nvar fn=function fn(item){// This searches all row values (and sub property values) in the entire (excluding\n// special `_` prefixed keys), because we convert the record to a space-separated\n// string containing all the value properties (recursively), even ones that are\n// not visible (not specified in this.fields)\n// Users can ignore filtering on specific fields, or on only certain fields,\n// and can optionall specify searching results of fields with formatter\n//\n// TODO: Enable searching on scoped slots (optional, as it will be SLOW)\n//\n// Generated function returns true if the criteria matches part of\n// the serialized data, otherwise false\n//\n// We set `lastIndex = 0` on the `RegExp` in case someone specifies the `/g` global flag\nregExp.lastIndex=0;return regExp.test(stringifyRecordValues(item,_this3.computedFilterIgnored,_this3.computedFilterIncluded,_this3.computedFieldsObj));};// Return the generated function\nreturn fn;}}});var processField=function processField(key,value){var field=null;if(isString(value)){// Label shortcut\nfield={key:key,label:value};}else if(isFunction$1(value)){// Formatter shortcut\nfield={key:key,formatter:value};}else if(isObject(value)){field=clone(value);field.key=field.key||key;}else if(value!==false){// Fallback to just key\n/* istanbul ignore next */field={key:key};}return field;};// We normalize fields into an array of objects\n// [ { key:..., label:..., ...}, {...}, ..., {..}]\nvar normalizeFields=function normalizeFields(origFields,items){var fields=[];if(isArray(origFields)){// Normalize array Form\norigFields.filter(identity).forEach(function(f){if(isString(f)){fields.push({key:f,label:startCase(f)});}else if(isObject(f)&&f.key&&isString(f.key)){// Full object definition. We use assign so that we don't mutate the original\nfields.push(clone(f));}else if(isObject(f)&&keys(f).length===1){// Shortcut object (i.e. { 'foo_bar': 'This is Foo Bar' }\nvar key=keys(f)[0];var field=processField(key,f[key]);if(field){fields.push(field);}}});}// If no field provided, take a sample from first record (if exits)\nif(fields.length===0&&isArray(items)&&items.length>0){var sample=items[0];keys(sample).forEach(function(k){if(!IGNORED_FIELD_KEYS[k]){fields.push({key:k,label:startCase(k)});}});}// Ensure we have a unique array of fields and that they have String labels\nvar memo={};return fields.filter(function(f){if(!memo[f.key]){memo[f.key]=true;f.label=isString(f.label)?f.label:startCase(f.key);return true;}return false;});};var _makeModelMixin$2=makeModelMixin('value',{type:PROP_TYPE_ARRAY,defaultValue:[]}),modelMixin$2=_makeModelMixin$2.mixin,modelProps$2=_makeModelMixin$2.props,MODEL_PROP_NAME$2=_makeModelMixin$2.prop,MODEL_EVENT_NAME$2=_makeModelMixin$2.event;var props$o=sortKeys(_objectSpread2$3(_objectSpread2$3({},modelProps$2),{},_defineProperty({fields:makeProp(PROP_TYPE_ARRAY,null),// Provider mixin adds in `Function` type\nitems:makeProp(PROP_TYPE_ARRAY,[]),// Primary key for record\n// If provided the value in each row must be unique!\nprimaryKey:makeProp(PROP_TYPE_STRING)},MODEL_PROP_NAME$2,makeProp(PROP_TYPE_ARRAY,[]))));// --- Mixin ---\n// @vue/component\nvar itemsMixin=Vue__default['default'].extend({mixins:[modelMixin$2],props:props$o,data:function data(){var items=this.items;return{// Our local copy of the items\n// Must be an array\nlocalItems:isArray(items)?items.slice():[]};},computed:{computedFields:function computedFields(){// We normalize fields into an array of objects\n// `[ { key:..., label:..., ...}, {...}, ..., {..}]`\nreturn normalizeFields(this.fields,this.localItems);},computedFieldsObj:function computedFieldsObj(){// Fields as a simple lookup hash object\n// Mainly for formatter lookup and use in `scopedSlots` for convenience\n// If the field has a formatter, it normalizes formatter to a\n// function ref or `undefined` if no formatter\nvar $parent=this.$parent;return this.computedFields.reduce(function(obj,f){// We use object spread here so we don't mutate the original field object\nobj[f.key]=clone(f);if(f.formatter){// Normalize formatter to a function ref or `undefined`\nvar formatter=f.formatter;if(isString(formatter)&&isFunction$1($parent[formatter])){formatter=$parent[formatter];}else if(!isFunction$1(formatter)){/* istanbul ignore next */formatter=undefined;}// Return formatter function or `undefined` if none\nobj[f.key].formatter=formatter;}return obj;},{});},computedItems:function computedItems(){// Fallback if various mixins not provided\nreturn(this.paginatedItems||this.sortedItems||this.filteredItems||this.localItems||/* istanbul ignore next */[]).slice();},context:function context(){// Current state of sorting, filtering and pagination props/values\nreturn{filter:this.localFilter,sortBy:this.localSortBy,sortDesc:this.localSortDesc,perPage:mathMax(toInteger(this.perPage,0),0),currentPage:mathMax(toInteger(this.currentPage,0),1),apiUrl:this.apiUrl};}},watch:{items:function items(newValue){// Set `localItems`/`filteredItems` to a copy of the provided array\nthis.localItems=isArray(newValue)?newValue.slice():[];},// Watch for changes on `computedItems` and update the `v-model`\ncomputedItems:function computedItems(newValue,oldValue){if(!looseEqual(newValue,oldValue)){this.$emit(MODEL_EVENT_NAME$2,newValue);}},// Watch for context changes\ncontext:function context(newValue,oldValue){// Emit context information for external paging/filtering/sorting handling\nif(!looseEqual(newValue,oldValue)){this.$emit(EVENT_NAME_CONTEXT_CHANGED,newValue);}}},mounted:function mounted(){// Initially update the `v-model` of displayed items\nthis.$emit(MODEL_EVENT_NAME$2,this.computedItems);},methods:{// Method to get the formatter method for a given field key\ngetFieldFormatter:function getFieldFormatter(key){var field=this.computedFieldsObj[key];// `this.computedFieldsObj` has pre-normalized the formatter to a\n// function ref if present, otherwise `undefined`\nreturn field?field.formatter:undefined;}}});var props$n={currentPage:makeProp(PROP_TYPE_NUMBER_STRING,1),perPage:makeProp(PROP_TYPE_NUMBER_STRING,0)};// --- Mixin ---\n// @vue/component\nvar paginationMixin=Vue__default['default'].extend({props:props$n,computed:{localPaging:function localPaging(){return this.hasProvider?!!this.noProviderPaging:true;},paginatedItems:function paginatedItems(){var items=this.sortedItems||this.filteredItems||this.localItems||[];var currentPage=mathMax(toInteger(this.currentPage,1),1);var perPage=mathMax(toInteger(this.perPage,0),0);// Apply local pagination\nif(this.localPaging&&perPage){// Grab the current page of data (which may be past filtered items limit)\nitems=items.slice((currentPage-1)*perPage,currentPage*perPage);}// Return the items to display in the table\nreturn items;}}});var ROOT_EVENT_NAME_REFRESHED=getRootEventName(NAME_TABLE,EVENT_NAME_REFRESHED);var ROOT_ACTION_EVENT_NAME_REFRESH=getRootActionEventName(NAME_TABLE,EVENT_NAME_REFRESH);// --- Props ---\nvar props$m={// Passed to the context object\n// Not used by `<b-table>` directly\napiUrl:makeProp(PROP_TYPE_STRING),// Adds in 'Function' support\nitems:makeProp(PROP_TYPE_ARRAY_FUNCTION,[]),noProviderFiltering:makeProp(PROP_TYPE_BOOLEAN,false),noProviderPaging:makeProp(PROP_TYPE_BOOLEAN,false),noProviderSorting:makeProp(PROP_TYPE_BOOLEAN,false)};// --- Mixin ---\n// @vue/component\nvar providerMixin=Vue__default['default'].extend({mixins:[listenOnRootMixin],props:props$m,computed:{hasProvider:function hasProvider(){return isFunction$1(this.items);},providerTriggerContext:function providerTriggerContext(){// Used to trigger the provider function via a watcher. Only the fields that\n// are needed for triggering a provider update are included. Note that the\n// regular this.context is sent to the provider during fetches though, as they\n// may need all the prop info.\nvar ctx={apiUrl:this.apiUrl,filter:null,sortBy:null,sortDesc:null,perPage:null,currentPage:null};if(!this.noProviderFiltering){// Either a string, or could be an object or array.\nctx.filter=this.localFilter;}if(!this.noProviderSorting){ctx.sortBy=this.localSortBy;ctx.sortDesc=this.localSortDesc;}if(!this.noProviderPaging){ctx.perPage=this.perPage;ctx.currentPage=this.currentPage;}return clone(ctx);}},watch:{// Provider update triggering\nitems:function items(newValue){// If a new provider has been specified, trigger an update\nif(this.hasProvider||isFunction$1(newValue)){this.$nextTick(this._providerUpdate);}},providerTriggerContext:function providerTriggerContext(newValue,oldValue){// Trigger the provider to update as the relevant context values have changed.\nif(!looseEqual(newValue,oldValue)){this.$nextTick(this._providerUpdate);}}},mounted:function mounted(){var _this=this;// Call the items provider if necessary\nif(this.hasProvider&&(!this.localItems||this.localItems.length===0)){// Fetch on mount if localItems is empty\nthis._providerUpdate();}// Listen for global messages to tell us to force refresh the table\nthis.listenOnRoot(ROOT_ACTION_EVENT_NAME_REFRESH,function(id){if(id===_this.id||id===_this){_this.refresh();}});},methods:{refresh:function refresh(){var items=this.items,refresh=this.refresh;// Public Method: Force a refresh of the provider function\nthis.$off(EVENT_NAME_REFRESHED,refresh);if(this.computedBusy){// Can't force an update when forced busy by user (busy prop === true)\nif(this.localBusy&&this.hasProvider){// But if provider running (localBusy), re-schedule refresh once `refreshed` emitted\nthis.$on(EVENT_NAME_REFRESHED,refresh);}}else{this.clearSelected();if(this.hasProvider){this.$nextTick(this._providerUpdate);}else{/* istanbul ignore next */this.localItems=isArray(items)?items.slice():[];}}},// Provider related methods\n_providerSetLocal:function _providerSetLocal(items){this.localItems=isArray(items)?items.slice():[];this.localBusy=false;this.$emit(EVENT_NAME_REFRESHED);// New root emit\nif(this.id){this.emitOnRoot(ROOT_EVENT_NAME_REFRESHED,this.id);}},_providerUpdate:function _providerUpdate(){var _this2=this;// Refresh the provider function items.\nif(!this.hasProvider){// Do nothing if no provider\nreturn;}// If table is busy, wait until refreshed before calling again\nif(this.computedBusy){// Schedule a new refresh once `refreshed` is emitted\nthis.$nextTick(this.refresh);return;}// Set internal busy state\nthis.localBusy=true;// Call provider function with context and optional callback after DOM is fully updated\nthis.$nextTick(function(){try{// Call provider function passing it the context and optional callback\nvar data=_this2.items(_this2.context,_this2._providerSetLocal);if(isPromise(data)){// Provider returned Promise\ndata.then(function(items){// Provider resolved with items\n_this2._providerSetLocal(items);});}else if(isArray(data)){// Provider returned Array data\n_this2._providerSetLocal(data);}else{/* istanbul ignore if */if(_this2.items.length!==2){// Check number of arguments provider function requested\n// Provider not using callback (didn't request second argument), so we clear\n// busy state as most likely there was an error in the provider function\n/* istanbul ignore next */warn(\"Provider function didn't request callback and did not return a promise or data.\",NAME_TABLE);_this2.localBusy=false;}}}catch(e)/* istanbul ignore next */{// Provider function borked on us, so we spew out a warning\n// and clear the busy state\nwarn(\"Provider function error [\".concat(e.name,\"] \").concat(e.message,\".\"),NAME_TABLE);_this2.localBusy=false;_this2.$off(EVENT_NAME_REFRESHED,_this2.refresh);}});}}});var SELECT_MODES=['range','multi','single'];var ROLE_GRID='grid';// --- Props ---\nvar props$l={// Disable use of click handlers for row selection\nnoSelectOnClick:makeProp(PROP_TYPE_BOOLEAN,false),selectMode:makeProp(PROP_TYPE_STRING,'multi',function(value){return arrayIncludes(SELECT_MODES,value);}),selectable:makeProp(PROP_TYPE_BOOLEAN,false),selectedVariant:makeProp(PROP_TYPE_STRING,'active')};// --- Mixin ---\n// @vue/component\nvar selectableMixin=Vue__default['default'].extend({props:props$l,data:function data(){return{selectedRows:[],selectedLastRow:-1};},computed:{isSelectable:function isSelectable(){return this.selectable&&this.selectMode;},hasSelectableRowClick:function hasSelectableRowClick(){return this.isSelectable&&!this.noSelectOnClick;},supportsSelectableRows:function supportsSelectableRows(){return true;},selectableHasSelection:function selectableHasSelection(){var selectedRows=this.selectedRows;return this.isSelectable&&selectedRows&&selectedRows.length>0&&selectedRows.some(identity);},selectableIsMultiSelect:function selectableIsMultiSelect(){return this.isSelectable&&arrayIncludes(['range','multi'],this.selectMode);},selectableTableClasses:function selectableTableClasses(){var _ref;var isSelectable=this.isSelectable;return _ref={'b-table-selectable':isSelectable},_defineProperty(_ref,\"b-table-select-\".concat(this.selectMode),isSelectable),_defineProperty(_ref,'b-table-selecting',this.selectableHasSelection),_defineProperty(_ref,'b-table-selectable-no-click',isSelectable&&!this.hasSelectableRowClick),_ref;},selectableTableAttrs:function selectableTableAttrs(){if(!this.isSelectable){return{};}var role=this.bvAttrs.role||ROLE_GRID;return{role:role,// TODO:\n//   Should this attribute not be included when `no-select-on-click` is set\n//   since this attribute implies keyboard navigation?\n'aria-multiselectable':role===ROLE_GRID?toString(this.selectableIsMultiSelect):null};}},watch:{computedItems:function computedItems(newValue,oldValue){// Reset for selectable\nvar equal=false;if(this.isSelectable&&this.selectedRows.length>0){// Quick check against array length\nequal=isArray(newValue)&&isArray(oldValue)&&newValue.length===oldValue.length;for(var i=0;equal&&i<newValue.length;i++){// Look for the first non-loosely equal row, after ignoring reserved fields\nequal=looseEqual(sanitizeRow(newValue[i]),sanitizeRow(oldValue[i]));}}if(!equal){this.clearSelected();}},selectable:function selectable(newValue){this.clearSelected();this.setSelectionHandlers(newValue);},selectMode:function selectMode(){this.clearSelected();},hasSelectableRowClick:function hasSelectableRowClick(newValue){this.clearSelected();this.setSelectionHandlers(!newValue);},selectedRows:function selectedRows(_selectedRows,oldValue){var _this=this;if(this.isSelectable&&!looseEqual(_selectedRows,oldValue)){var items=[];// `.forEach()` skips over non-existent indices (on sparse arrays)\n_selectedRows.forEach(function(v,idx){if(v){items.push(_this.computedItems[idx]);}});this.$emit(EVENT_NAME_ROW_SELECTED,items);}}},beforeMount:function beforeMount(){// Set up handlers if needed\nif(this.isSelectable){this.setSelectionHandlers(true);}},methods:{// Public methods\nselectRow:function selectRow(index){// Select a particular row (indexed based on computedItems)\nif(this.isSelectable&&isNumber(index)&&index>=0&&index<this.computedItems.length&&!this.isRowSelected(index)){var selectedRows=this.selectableIsMultiSelect?this.selectedRows.slice():[];selectedRows[index]=true;this.selectedLastClicked=-1;this.selectedRows=selectedRows;}},unselectRow:function unselectRow(index){// Un-select a particular row (indexed based on `computedItems`)\nif(this.isSelectable&&isNumber(index)&&this.isRowSelected(index)){var selectedRows=this.selectedRows.slice();selectedRows[index]=false;this.selectedLastClicked=-1;this.selectedRows=selectedRows;}},selectAllRows:function selectAllRows(){var length=this.computedItems.length;if(this.isSelectable&&length>0){this.selectedLastClicked=-1;this.selectedRows=this.selectableIsMultiSelect?createArray(length,true):[true];}},isRowSelected:function isRowSelected(index){// Determine if a row is selected (indexed based on `computedItems`)\nreturn!!(isNumber(index)&&this.selectedRows[index]);},clearSelected:function clearSelected(){// Clear any active selected row(s)\nthis.selectedLastClicked=-1;this.selectedRows=[];},// Internal private methods\nselectableRowClasses:function selectableRowClasses(index){if(this.isSelectable&&this.isRowSelected(index)){var variant=this.selectedVariant;return _defineProperty({'b-table-row-selected':true},\"\".concat(this.dark?'bg':'table',\"-\").concat(variant),variant);}return{};},selectableRowAttrs:function selectableRowAttrs(index){return{'aria-selected':!this.isSelectable?null:this.isRowSelected(index)?'true':'false'};},setSelectionHandlers:function setSelectionHandlers(on){var method=on&&!this.noSelectOnClick?'$on':'$off';// Handle row-clicked event\nthis[method](EVENT_NAME_ROW_CLICKED,this.selectionHandler);// Clear selection on filter, pagination, and sort changes\nthis[method](EVENT_NAME_FILTERED,this.clearSelected);this[method](EVENT_NAME_CONTEXT_CHANGED,this.clearSelected);},selectionHandler:function selectionHandler(item,index,event){/* istanbul ignore if: should never happen */if(!this.isSelectable||this.noSelectOnClick){// Don't do anything if table is not in selectable mode\nthis.clearSelected();return;}var selectMode=this.selectMode,selectedLastRow=this.selectedLastRow;var selectedRows=this.selectedRows.slice();var selected=!selectedRows[index];// Note 'multi' mode needs no special event handling\nif(selectMode==='single'){selectedRows=[];}else if(selectMode==='range'){if(selectedLastRow>-1&&event.shiftKey){// range\nfor(var idx=mathMin(selectedLastRow,index);idx<=mathMax(selectedLastRow,index);idx++){selectedRows[idx]=true;}selected=true;}else{if(!(event.ctrlKey||event.metaKey)){// Clear range selection if any\nselectedRows=[];selected=true;}if(selected)this.selectedLastRow=index;}}selectedRows[index]=selected;this.selectedRows=selectedRows;}}});/*\n   * Consistent and stable sort function across JavaScript platforms\n   *\n   * Inconsistent sorts can cause SSR problems between client and server\n   * such as in <b-table> if sortBy is applied to the data on server side render.\n   * Chrome and V8 native sorts are inconsistent/unstable\n   *\n   * This function uses native sort with fallback to index compare when the a and b\n   * compare returns 0\n   *\n   * Algorithm based on:\n   * https://stackoverflow.com/questions/1427608/fast-stable-sorting-algorithm-implementation-in-javascript/45422645#45422645\n   *\n   * @param {array} array to sort\n   * @param {function} sort compare function\n   * @return {array}\n   */var stableSort$1=function stableSort(array,compareFn){// Using `.bind(compareFn)` on the wrapped anonymous function improves\n// performance by avoiding the function call setup. We don't use an arrow\n// function here as it binds `this` to the `stableSort` context rather than\n// the `compareFn` context, which wouldn't give us the performance increase.\nreturn array.map(function(a,index){return[index,a];}).sort(function(a,b){return this(a[1],b[1])||a[0]-b[0];}.bind(compareFn)).map(function(e){return e[1];});};var normalizeValue=function normalizeValue(value){if(isUndefinedOrNull(value)){return'';}if(isNumeric$1(value)){return toFloat(value,value);}return value;};// Default sort compare routine\n//\n// TODO:\n//   Add option to sort by multiple columns (tri-state per column,\n//   plus order of columns in sort) where `sortBy` could be an array\n//   of objects `[ {key: 'foo', sortDir: 'asc'}, {key:'bar', sortDir: 'desc'} ...]`\n//   or an array of arrays `[ ['foo','asc'], ['bar','desc'] ]`\n//   Multisort will most likely be handled in `mixin-sort.js` by\n//   calling this method for each sortBy\nvar defaultSortCompare=function defaultSortCompare(a,b){var _ref=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{},_ref$sortBy=_ref.sortBy,sortBy=_ref$sortBy===void 0?null:_ref$sortBy,_ref$formatter=_ref.formatter,formatter=_ref$formatter===void 0?null:_ref$formatter,_ref$locale=_ref.locale,locale=_ref$locale===void 0?undefined:_ref$locale,_ref$localeOptions=_ref.localeOptions,localeOptions=_ref$localeOptions===void 0?{}:_ref$localeOptions,_ref$nullLast=_ref.nullLast,nullLast=_ref$nullLast===void 0?false:_ref$nullLast;// Get the value by `sortBy`\nvar aa=get(a,sortBy,null);var bb=get(b,sortBy,null);// Apply user-provided formatter\nif(isFunction$1(formatter)){aa=formatter(aa,sortBy,a);bb=formatter(bb,sortBy,b);}// Internally normalize value\n// `null` / `undefined` => ''\n// `'0'` => `0`\naa=normalizeValue(aa);bb=normalizeValue(bb);if(isDate(aa)&&isDate(bb)||isNumber(aa)&&isNumber(bb)){// Special case for comparing dates and numbers\n// Internally dates are compared via their epoch number values\nreturn aa<bb?-1:aa>bb?1:0;}else if(nullLast&&aa===''&&bb!==''){// Special case when sorting `null` / `undefined` / '' last\nreturn 1;}else if(nullLast&&aa!==''&&bb===''){// Special case when sorting `null` / `undefined` / '' last\nreturn-1;}// Do localized string comparison\nreturn stringifyObjectValues(aa).localeCompare(stringifyObjectValues(bb),locale,localeOptions);};var _props,_watch$3;var MODEL_PROP_NAME_SORT_BY='sortBy';var MODEL_EVENT_NAME_SORT_BY=MODEL_EVENT_NAME_PREFIX+MODEL_PROP_NAME_SORT_BY;var MODEL_PROP_NAME_SORT_DESC='sortDesc';var MODEL_EVENT_NAME_SORT_DESC=MODEL_EVENT_NAME_PREFIX+MODEL_PROP_NAME_SORT_DESC;var SORT_DIRECTION_ASC='asc';var SORT_DIRECTION_DESC='desc';var SORT_DIRECTION_LAST='last';var SORT_DIRECTIONS=[SORT_DIRECTION_ASC,SORT_DIRECTION_DESC,SORT_DIRECTION_LAST];// --- Props ---\nvar props$k=(_props={labelSortAsc:makeProp(PROP_TYPE_STRING,'Click to sort ascending'),labelSortClear:makeProp(PROP_TYPE_STRING,'Click to clear sorting'),labelSortDesc:makeProp(PROP_TYPE_STRING,'Click to sort descending'),noFooterSorting:makeProp(PROP_TYPE_BOOLEAN,false),noLocalSorting:makeProp(PROP_TYPE_BOOLEAN,false),// Another prop that should have had a better name\n// It should be `noSortClear` (on non-sortable headers)\n// We will need to make sure the documentation is clear on what\n// this prop does (as well as in the code for future reference)\nnoSortReset:makeProp(PROP_TYPE_BOOLEAN,false)},_defineProperty(_props,MODEL_PROP_NAME_SORT_BY,makeProp(PROP_TYPE_STRING)),_defineProperty(_props,\"sortCompare\",makeProp(PROP_TYPE_FUNCTION)),_defineProperty(_props,\"sortCompareLocale\",makeProp(PROP_TYPE_ARRAY_STRING)),_defineProperty(_props,\"sortCompareOptions\",makeProp(PROP_TYPE_OBJECT,{numeric:true})),_defineProperty(_props,MODEL_PROP_NAME_SORT_DESC,makeProp(PROP_TYPE_BOOLEAN,false)),_defineProperty(_props,\"sortDirection\",makeProp(PROP_TYPE_STRING,SORT_DIRECTION_ASC,function(value){return arrayIncludes(SORT_DIRECTIONS,value);})),_defineProperty(_props,\"sortIconLeft\",makeProp(PROP_TYPE_BOOLEAN,false)),_defineProperty(_props,\"sortNullLast\",makeProp(PROP_TYPE_BOOLEAN,false)),_props);// --- Mixin ---\n// @vue/component\nvar sortingMixin=Vue__default['default'].extend({props:props$k,data:function data(){return{localSortBy:this[MODEL_PROP_NAME_SORT_BY]||'',localSortDesc:this[MODEL_PROP_NAME_SORT_DESC]||false};},computed:{localSorting:function localSorting(){return this.hasProvider?!!this.noProviderSorting:!this.noLocalSorting;},isSortable:function isSortable(){return this.computedFields.some(function(f){return f.sortable;});},// Sorts the filtered items and returns a new array of the sorted items\n// When not sorted, the original items array will be returned\nsortedItems:function sortedItems(){var sortBy=this.localSortBy,sortDesc=this.localSortDesc,locale=this.sortCompareLocale,nullLast=this.sortNullLast,sortCompare=this.sortCompare,localSorting=this.localSorting;var items=(this.filteredItems||this.localItems||[]).slice();var localeOptions=_objectSpread2$3(_objectSpread2$3({},this.sortCompareOptions),{},{usage:'sort'});if(sortBy&&localSorting){var field=this.computedFieldsObj[sortBy]||{};var sortByFormatted=field.sortByFormatted;var formatter=isFunction$1(sortByFormatted)?/* istanbul ignore next */sortByFormatted:sortByFormatted?this.getFieldFormatter(sortBy):undefined;// `stableSort` returns a new array, and leaves the original array intact\nreturn stableSort$1(items,function(a,b){var result=null;// Call user provided `sortCompare` routine first\nif(isFunction$1(sortCompare)){// TODO:\n//   Change the `sortCompare` signature to the one of `defaultSortCompare`\n//   with the next major version bump\nresult=sortCompare(a,b,sortBy,sortDesc,formatter,localeOptions,locale);}// Fallback to built-in `defaultSortCompare` if `sortCompare`\n// is not defined or returns `null`/`false`\nif(isUndefinedOrNull(result)||result===false){result=defaultSortCompare(a,b,{sortBy:sortBy,formatter:formatter,locale:locale,localeOptions:localeOptions,nullLast:nullLast});}// Negate result if sorting in descending order\nreturn(result||0)*(sortDesc?-1:1);});}return items;}},watch:(_watch$3={/* istanbul ignore next: pain in the butt to test */isSortable:function isSortable(newValue){if(newValue){if(this.isSortable){this.$on(EVENT_NAME_HEAD_CLICKED,this.handleSort);}}else{this.$off(EVENT_NAME_HEAD_CLICKED,this.handleSort);}}},_defineProperty(_watch$3,MODEL_PROP_NAME_SORT_DESC,function(newValue){/* istanbul ignore next */if(newValue===this.localSortDesc){return;}this.localSortDesc=newValue||false;}),_defineProperty(_watch$3,MODEL_PROP_NAME_SORT_BY,function(newValue){/* istanbul ignore next */if(newValue===this.localSortBy){return;}this.localSortBy=newValue||'';}),_defineProperty(_watch$3,\"localSortDesc\",function localSortDesc(newValue,oldValue){// Emit update to sort-desc.sync\nif(newValue!==oldValue){this.$emit(MODEL_EVENT_NAME_SORT_DESC,newValue);}}),_defineProperty(_watch$3,\"localSortBy\",function localSortBy(newValue,oldValue){if(newValue!==oldValue){this.$emit(MODEL_EVENT_NAME_SORT_BY,newValue);}}),_watch$3),created:function created(){if(this.isSortable){this.$on(EVENT_NAME_HEAD_CLICKED,this.handleSort);}},methods:{// Handlers\n// Need to move from thead-mixin\nhandleSort:function handleSort(key,field,event,isFoot){var _this=this;if(!this.isSortable){/* istanbul ignore next */return;}if(isFoot&&this.noFooterSorting){return;}// TODO: make this tri-state sorting\n// cycle desc => asc => none => desc => ...\nvar sortChanged=false;var toggleLocalSortDesc=function toggleLocalSortDesc(){var sortDirection=field.sortDirection||_this.sortDirection;if(sortDirection===SORT_DIRECTION_ASC){_this.localSortDesc=false;}else if(sortDirection===SORT_DIRECTION_DESC){_this.localSortDesc=true;}else;};if(field.sortable){var sortKey=!this.localSorting&&field.sortKey?field.sortKey:key;if(this.localSortBy===sortKey){// Change sorting direction on current column\nthis.localSortDesc=!this.localSortDesc;}else{// Start sorting this column ascending\nthis.localSortBy=sortKey;// this.localSortDesc = false\ntoggleLocalSortDesc();}sortChanged=true;}else if(this.localSortBy&&!this.noSortReset){this.localSortBy='';toggleLocalSortDesc();sortChanged=true;}if(sortChanged){// Sorting parameters changed\nthis.$emit(EVENT_NAME_SORT_CHANGED,this.context);}},// methods to compute classes and attrs for thead>th cells\nsortTheadThClasses:function sortTheadThClasses(key,field,isFoot){return{// If sortable and sortIconLeft are true, then place sort icon on the left\n'b-table-sort-icon-left':field.sortable&&this.sortIconLeft&&!(isFoot&&this.noFooterSorting)};},sortTheadThAttrs:function sortTheadThAttrs(key,field,isFoot){var _field$sortKey;var isSortable=this.isSortable,noFooterSorting=this.noFooterSorting,localSortDesc=this.localSortDesc,localSortBy=this.localSortBy,localSorting=this.localSorting;if(!isSortable||isFoot&&noFooterSorting){// No attributes if not a sortable table\nreturn{};}var sortable=field.sortable;var sortKey=!localSorting?(_field$sortKey=field.sortKey)!==null&&_field$sortKey!==void 0?_field$sortKey:key:key;// Assemble the aria-sort attribute value\nvar ariaSort=sortable&&localSortBy===sortKey?localSortDesc?'descending':'ascending':sortable?'none':null;// Return the attribute\nreturn{'aria-sort':ariaSort};},// A label to be placed in an `.sr-only` element in the header cell\nsortTheadThLabel:function sortTheadThLabel(key,field,isFoot){// No label if not a sortable table\nif(!this.isSortable||isFoot&&this.noFooterSorting){return null;}var localSortBy=this.localSortBy,localSortDesc=this.localSortDesc,labelSortAsc=this.labelSortAsc,labelSortDesc=this.labelSortDesc;var sortable=field.sortable;// The correctness of these labels is very important for screen reader users\nvar labelSorting='';if(sortable){if(localSortBy===key){// Currently sorted sortable column\nlabelSorting=localSortDesc?labelSortAsc:labelSortDesc;}else{// Not currently sorted sortable column\n// Not using nested ternary's here for clarity/readability\n// Default for `aria-label`\nlabelSorting=localSortDesc?labelSortDesc:labelSortAsc;// Handle `sortDirection` setting\nvar sortDirection=this.sortDirection||field.sortDirection;if(sortDirection===SORT_DIRECTION_ASC){labelSorting=labelSortAsc;}else if(sortDirection===SORT_DIRECTION_DESC){labelSorting=labelSortDesc;}}}else if(!this.noSortReset){// Non sortable column\nlabelSorting=localSortBy?this.labelSortClear:'';}// Return the `.sr-only` sort label or `null` if no label\nreturn trim(labelSorting)||null;}}});var props$j={stacked:makeProp(PROP_TYPE_BOOLEAN_STRING,false)};// --- Mixin ---\n// @vue/component\nvar stackedMixin=Vue__default['default'].extend({props:props$j,computed:{isStacked:function isStacked(){var stacked=this.stacked;// `true` when always stacked, or returns breakpoint specified\nreturn stacked===''?true:stacked;},isStackedAlways:function isStackedAlways(){return this.isStacked===true;},stackedTableClasses:function stackedTableClasses(){var isStackedAlways=this.isStackedAlways;return _defineProperty({'b-table-stacked':isStackedAlways},\"b-table-stacked-\".concat(this.stacked),!isStackedAlways&&this.isStacked);}}});// Includes all main table styling options\n// --- Props ---\nvar props$i={bordered:makeProp(PROP_TYPE_BOOLEAN,false),borderless:makeProp(PROP_TYPE_BOOLEAN,false),captionTop:makeProp(PROP_TYPE_BOOLEAN,false),dark:makeProp(PROP_TYPE_BOOLEAN,false),fixed:makeProp(PROP_TYPE_BOOLEAN,false),hover:makeProp(PROP_TYPE_BOOLEAN,false),noBorderCollapse:makeProp(PROP_TYPE_BOOLEAN,false),outlined:makeProp(PROP_TYPE_BOOLEAN,false),responsive:makeProp(PROP_TYPE_BOOLEAN_STRING,false),small:makeProp(PROP_TYPE_BOOLEAN,false),// If a string, it is assumed to be the table `max-height` value\nstickyHeader:makeProp(PROP_TYPE_BOOLEAN_STRING,false),striped:makeProp(PROP_TYPE_BOOLEAN,false),tableClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),tableVariant:makeProp(PROP_TYPE_STRING)};// --- Mixin ---\n// @vue/component\nvar tableRendererMixin=Vue__default['default'].extend({mixins:[attrsMixin],provide:function provide(){return{bvTable:this};},// Don't place attributes on root element automatically,\n// as table could be wrapped in responsive `<div>`\ninheritAttrs:false,props:props$i,computed:{// Layout related computed props\nisResponsive:function isResponsive(){var responsive=this.responsive;return responsive===''?true:responsive;},isStickyHeader:function isStickyHeader(){var stickyHeader=this.stickyHeader;stickyHeader=stickyHeader===''?true:stickyHeader;return this.isStacked?false:stickyHeader;},wrapperClasses:function wrapperClasses(){var isResponsive=this.isResponsive;return[this.isStickyHeader?'b-table-sticky-header':'',isResponsive===true?'table-responsive':isResponsive?\"table-responsive-\".concat(this.responsive):''].filter(identity);},wrapperStyles:function wrapperStyles(){var isStickyHeader=this.isStickyHeader;return isStickyHeader&&!isBoolean(isStickyHeader)?{maxHeight:isStickyHeader}:{};},tableClasses:function tableClasses(){var hover=this.hover,tableVariant=this.tableVariant;hover=this.isTableSimple?hover:hover&&this.computedItems.length>0&&!this.computedBusy;return[// User supplied classes\nthis.tableClass,// Styling classes\n{'table-striped':this.striped,'table-hover':hover,'table-dark':this.dark,'table-bordered':this.bordered,'table-borderless':this.borderless,'table-sm':this.small,// The following are b-table custom styles\nborder:this.outlined,'b-table-fixed':this.fixed,'b-table-caption-top':this.captionTop,'b-table-no-border-collapse':this.noBorderCollapse},tableVariant?\"\".concat(this.dark?'bg':'table',\"-\").concat(tableVariant):'',// Stacked table classes\nthis.stackedTableClasses,// Selectable classes\nthis.selectableTableClasses];},tableAttrs:function tableAttrs(){var items=this.computedItems,filteredItems=this.filteredItems,fields=this.computedFields,selectableTableAttrs=this.selectableTableAttrs;var ariaAttrs=this.isTableSimple?{}:{'aria-busy':toString(this.computedBusy),'aria-colcount':toString(fields.length),// Preserve user supplied `aria-describedby`, if provided\n'aria-describedby':this.bvAttrs['aria-describedby']||this.$refs.caption?this.captionId:null};var rowCount=items&&filteredItems&&filteredItems.length>items.length?toString(filteredItems.length):null;return _objectSpread2$3(_objectSpread2$3(_objectSpread2$3({// We set `aria-rowcount` before merging in `$attrs`,\n// in case user has supplied their own\n'aria-rowcount':rowCount},this.bvAttrs),{},{// Now we can override any `$attrs` here\nid:this.safeId(),role:this.bvAttrs.role||'table'},ariaAttrs),selectableTableAttrs);}},render:function render(h){var wrapperClasses=this.wrapperClasses,renderCaption=this.renderCaption,renderColgroup=this.renderColgroup,renderThead=this.renderThead,renderTbody=this.renderTbody,renderTfoot=this.renderTfoot;var $content=[];if(this.isTableSimple){$content.push(this.normalizeSlot());}else{// Build the `<caption>` (from caption mixin)\n$content.push(renderCaption?renderCaption():null);// Build the `<colgroup>`\n$content.push(renderColgroup?renderColgroup():null);// Build the `<thead>`\n$content.push(renderThead?renderThead():null);// Build the `<tbody>`\n$content.push(renderTbody?renderTbody():null);// Build the `<tfoot>`\n$content.push(renderTfoot?renderTfoot():null);}// Assemble `<table>`\nvar $table=h('table',{staticClass:'table b-table',class:this.tableClasses,attrs:this.tableAttrs,key:'b-table'},$content.filter(identity));// Add responsive/sticky wrapper if needed and return table\nreturn wrapperClasses.length>0?h('div',{class:wrapperClasses,style:this.wrapperStyles,key:'wrap'},[$table]):$table;}});var props$h=makePropsConfigurable({tbodyTransitionHandlers:makeProp(PROP_TYPE_OBJECT),tbodyTransitionProps:makeProp(PROP_TYPE_OBJECT)},NAME_TBODY);// --- Main component ---\n// TODO:\n//   In Bootstrap v5, we won't need \"sniffing\" as table element variants properly inherit\n//   to the child elements, so this can be converted to a functional component\n// @vue/component\nvar BTbody=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TBODY,mixins:[attrsMixin,listenersMixin,normalizeSlotMixin],provide:function provide(){return{bvTableRowGroup:this};},inject:{// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\nbvTable:{default:/* istanbul ignore next */function _default(){return{};}}},inheritAttrs:false,props:props$h,computed:{// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\nisTbody:function isTbody(){return true;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\nisDark:function isDark(){return this.bvTable.dark;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\nisStacked:function isStacked(){return this.bvTable.isStacked;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\nisResponsive:function isResponsive(){return this.bvTable.isResponsive;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\n// Sticky headers are only supported in thead\nisStickyHeader:function isStickyHeader(){return false;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\n// Needed to handle header background classes, due to lack of\n// background color inheritance with Bootstrap v4 table CSS\nhasStickyHeader:function hasStickyHeader(){return!this.isStacked&&this.bvTable.stickyHeader;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\ntableVariant:function tableVariant(){return this.bvTable.tableVariant;},isTransitionGroup:function isTransitionGroup(){return this.tbodyTransitionProps||this.tbodyTransitionHandlers;},tbodyAttrs:function tbodyAttrs(){return _objectSpread2$3({role:'rowgroup'},this.bvAttrs);},tbodyProps:function tbodyProps(){var tbodyTransitionProps=this.tbodyTransitionProps;return tbodyTransitionProps?_objectSpread2$3(_objectSpread2$3({},tbodyTransitionProps),{},{tag:'tbody'}):{};}},render:function render(h){var data={props:this.tbodyProps,attrs:this.tbodyAttrs};if(this.isTransitionGroup){// We use native listeners if a transition group for any delegated events\ndata.on=this.tbodyTransitionHandlers||{};data.nativeOn=this.bvListeners;}else{// Otherwise we place any listeners on the tbody element\ndata.on=this.bvListeners;}return h(this.isTransitionGroup?'transition-group':'tbody',data,this.normalizeSlot());}});var TABLE_TAG_NAMES=['TD','TH','TR'];// Returns `true` if we should ignore the click/double-click/keypress event\n// Avoids having the user need to use `@click.stop` on the form control\nvar filterEvent=function filterEvent(event){// Exit early when we don't have a target element\nif(!event||!event.target){/* istanbul ignore next */return false;}var el=event.target;// Exit early when element is disabled or a table element\nif(el.disabled||TABLE_TAG_NAMES.indexOf(el.tagName)!==-1){return false;}// Ignore the click when it was inside a dropdown menu\nif(closest('.dropdown-menu',el)){return true;}var label=el.tagName==='LABEL'?el:closest('label',el);// If the label's form control is not disabled then we don't propagate event\n// Modern browsers have `label.control` that references the associated input, but IE 11\n// does not have this property on the label element, so we resort to DOM lookups\nif(label){var labelFor=getAttr(label,'for');var input=labelFor?getById(labelFor):select('input, select, textarea',label);if(input&&!input.disabled){return true;}}// Otherwise check if the event target matches one of the selectors in the\n// event filter (i.e. anchors, non disabled inputs, etc.)\n// Return `true` if we should ignore the event\nreturn matches(el,EVENT_FILTER);};// Used to filter out click events caused by the mouse up at end of selection\n//\n// Accepts an element as only argument to test to see if selection overlaps or is\n// contained within the element\nvar textSelectionActive=function textSelectionActive(){var el=arguments.length>0&&arguments[0]!==undefined?arguments[0]:document;var sel=getSel();return sel&&sel.toString().trim()!==''&&sel.containsNode&&isElement(el)?/* istanbul ignore next */sel.containsNode(el,true):false;};var props$g=makePropsConfigurable(props$u,NAME_TH);// --- Main component ---\n// TODO:\n//   In Bootstrap v5, we won't need \"sniffing\" as table element variants properly inherit\n//   to the child elements, so this can be converted to a functional component\n// @vue/component\nvar BTh=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TH,extends:BTd,props:props$g,computed:{tag:function tag(){return'th';}}});var props$f={detailsTdClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),tbodyTrAttr:makeProp(PROP_TYPE_OBJECT_FUNCTION),tbodyTrClass:makeProp([].concat(_toConsumableArray$1(PROP_TYPE_ARRAY_OBJECT_STRING),[PROP_TYPE_FUNCTION]))};// --- Mixin ---\n// @vue/component\nvar tbodyRowMixin=Vue__default['default'].extend({props:props$f,methods:{// Methods for computing classes, attributes and styles for table cells\ngetTdValues:function getTdValues(item,key,tdValue,defaultValue){var $parent=this.$parent;if(tdValue){var value=get(item,key,'');if(isFunction$1(tdValue)){return tdValue(value,key,item);}else if(isString(tdValue)&&isFunction$1($parent[tdValue])){return $parent[tdValue](value,key,item);}return tdValue;}return defaultValue;},getThValues:function getThValues(item,key,thValue,type,defaultValue){var $parent=this.$parent;if(thValue){var value=get(item,key,'');if(isFunction$1(thValue)){return thValue(value,key,item,type);}else if(isString(thValue)&&isFunction$1($parent[thValue])){return $parent[thValue](value,key,item,type);}return thValue;}return defaultValue;},// Method to get the value for a field\ngetFormattedValue:function getFormattedValue(item,field){var key=field.key;var formatter=this.getFieldFormatter(key);var value=get(item,key,null);if(isFunction$1(formatter)){value=formatter(value,key,item);}return isUndefinedOrNull(value)?'':value;},// Factory function methods\ntoggleDetailsFactory:function toggleDetailsFactory(hasDetailsSlot,item){var _this=this;// Returns a function to toggle a row's details slot\nreturn function(){if(hasDetailsSlot){_this.$set(item,FIELD_KEY_SHOW_DETAILS,!item[FIELD_KEY_SHOW_DETAILS]);}};},// Row event handlers\nrowHovered:function rowHovered(event){// `mouseenter` handler (non-bubbling)\n// `this.tbodyRowEventStopped` from tbody mixin\nif(!this.tbodyRowEventStopped(event)){// `this.emitTbodyRowEvent` from tbody mixin\nthis.emitTbodyRowEvent(EVENT_NAME_ROW_HOVERED,event);}},rowUnhovered:function rowUnhovered(event){// `mouseleave` handler (non-bubbling)\n// `this.tbodyRowEventStopped` from tbody mixin\nif(!this.tbodyRowEventStopped(event)){// `this.emitTbodyRowEvent` from tbody mixin\nthis.emitTbodyRowEvent(EVENT_NAME_ROW_UNHOVERED,event);}},// Renders a TD or TH for a row's field\nrenderTbodyRowCell:function renderTbodyRowCell(field,colIndex,item,rowIndex){var _this2=this;var isStacked=this.isStacked;var key=field.key,label=field.label,isRowHeader=field.isRowHeader;var h=this.$createElement;var hasDetailsSlot=this.hasNormalizedSlot(SLOT_NAME_ROW_DETAILS);var formatted=this.getFormattedValue(item,field);var stickyColumn=!isStacked&&(this.isResponsive||this.stickyHeader)&&field.stickyColumn;// We only uses the helper components for sticky columns to\n// improve performance of BTable/BTableLite by reducing the\n// total number of vue instances created during render\nvar cellTag=stickyColumn?isRowHeader?BTh:BTd:isRowHeader?'th':'td';var cellVariant=item[FIELD_KEY_CELL_VARIANT]&&item[FIELD_KEY_CELL_VARIANT][key]?item[FIELD_KEY_CELL_VARIANT][key]:field.variant||null;var data={// For the Vue key, we concatenate the column index and\n// field key (as field keys could be duplicated)\n// TODO: Although we do prevent duplicate field keys...\n//   So we could change this to: `row-${rowIndex}-cell-${key}`\nclass:[field.class?field.class:'',this.getTdValues(item,key,field.tdClass,'')],props:{},attrs:_objectSpread2$3({'aria-colindex':String(colIndex+1)},isRowHeader?this.getThValues(item,key,field.thAttr,'row',{}):this.getTdValues(item,key,field.tdAttr,{})),key:\"row-\".concat(rowIndex,\"-cell-\").concat(colIndex,\"-\").concat(key)};if(stickyColumn){// We are using the helper BTd or BTh\ndata.props={stackedHeading:isStacked?label:null,stickyColumn:true,variant:cellVariant};}else{// Using native TD or TH element, so we need to\n// add in the attributes and variant class\ndata.attrs['data-label']=isStacked&&!isUndefinedOrNull(label)?toString(label):null;data.attrs.role=isRowHeader?'rowheader':'cell';data.attrs.scope=isRowHeader?'row':null;// Add in the variant class\nif(cellVariant){data.class.push(\"\".concat(this.dark?'bg':'table',\"-\").concat(cellVariant));}}var slotScope={item:item,index:rowIndex,field:field,unformatted:get(item,key,''),value:formatted,toggleDetails:this.toggleDetailsFactory(hasDetailsSlot,item),detailsShowing:Boolean(item[FIELD_KEY_SHOW_DETAILS])};// If table supports selectable mode, then add in the following scope\n// this.supportsSelectableRows will be undefined if mixin isn't loaded\nif(this.supportsSelectableRows){slotScope.rowSelected=this.isRowSelected(rowIndex);slotScope.selectRow=function(){return _this2.selectRow(rowIndex);};slotScope.unselectRow=function(){return _this2.unselectRow(rowIndex);};}// The new `v-slot` syntax doesn't like a slot name starting with\n// a square bracket and if using in-document HTML templates, the\n// v-slot attributes are lower-cased by the browser.\n// Switched to round bracket syntax to prevent confusion with\n// dynamic slot name syntax.\n// We look for slots in this order: `cell(${key})`, `cell(${key.toLowerCase()})`, 'cell()'\n// Slot names are now cached by mixin tbody in `this.$_bodyFieldSlotNameCache`\n// Will be `null` if no slot (or fallback slot) exists\nvar slotName=this.$_bodyFieldSlotNameCache[key];var $childNodes=slotName?this.normalizeSlot(slotName,slotScope):toString(formatted);if(this.isStacked){// We wrap in a DIV to ensure rendered as a single cell when visually stacked!\n$childNodes=[h('div',[$childNodes])];}// Render either a td or th cell\nreturn h(cellTag,data,[$childNodes]);},// Renders an item's row (or rows if details supported)\nrenderTbodyRow:function renderTbodyRow(item,rowIndex){var _this3=this;var fields=this.computedFields,striped=this.striped,primaryKey=this.primaryKey,currentPage=this.currentPage,perPage=this.perPage,tbodyTrClass=this.tbodyTrClass,tbodyTrAttr=this.tbodyTrAttr;var h=this.$createElement;var hasDetailsSlot=this.hasNormalizedSlot(SLOT_NAME_ROW_DETAILS);var rowShowDetails=item[FIELD_KEY_SHOW_DETAILS]&&hasDetailsSlot;var hasRowClickHandler=this.$listeners[EVENT_NAME_ROW_CLICKED]||this.hasSelectableRowClick;// We can return more than one TR if rowDetails enabled\nvar $rows=[];// Details ID needed for `aria-details` when details showing\n// We set it to `null` when not showing so that attribute\n// does not appear on the element\nvar detailsId=rowShowDetails?this.safeId(\"_details_\".concat(rowIndex,\"_\")):null;// For each item data field in row\nvar $tds=fields.map(function(field,colIndex){return _this3.renderTbodyRowCell(field,colIndex,item,rowIndex);});// Calculate the row number in the dataset (indexed from 1)\nvar ariaRowIndex=null;if(currentPage&&perPage&&perPage>0){ariaRowIndex=String((currentPage-1)*perPage+rowIndex+1);}// Create a unique :key to help ensure that sub components are re-rendered rather than\n// re-used, which can cause issues. If a primary key is not provided we use the rendered\n// rows index within the tbody.\n// See: https://github.com/bootstrap-vue/bootstrap-vue/issues/2410\nvar primaryKeyValue=toString(get(item,primaryKey))||null;var rowKey=primaryKeyValue||toString(rowIndex);// If primary key is provided, use it to generate a unique ID on each tbody > tr\n// In the format of '{tableId}__row_{primaryKeyValue}'\nvar rowId=primaryKeyValue?this.safeId(\"_row_\".concat(primaryKeyValue)):null;// Selectable classes and attributes\nvar selectableClasses=this.selectableRowClasses?this.selectableRowClasses(rowIndex):{};var selectableAttrs=this.selectableRowAttrs?this.selectableRowAttrs(rowIndex):{};// Additional classes and attributes\nvar userTrClasses=isFunction$1(tbodyTrClass)?tbodyTrClass(item,'row'):tbodyTrClass;var userTrAttrs=isFunction$1(tbodyTrAttr)?/* istanbul ignore next */tbodyTrAttr(item,'row'):tbodyTrAttr;// Add the item row\n$rows.push(h(BTr,{class:[userTrClasses,selectableClasses,rowShowDetails?'b-table-has-details':''],props:{variant:item[FIELD_KEY_ROW_VARIANT]||null},attrs:_objectSpread2$3(_objectSpread2$3({id:rowId},userTrAttrs),{},{// Users cannot override the following attributes\ntabindex:hasRowClickHandler?'0':null,'data-pk':primaryKeyValue||null,'aria-details':detailsId,'aria-owns':detailsId,'aria-rowindex':ariaRowIndex},selectableAttrs),on:{// Note: These events are not A11Y friendly!\nmouseenter:this.rowHovered,mouseleave:this.rowUnhovered},key:\"__b-table-row-\".concat(rowKey,\"__\"),ref:'item-rows',refInFor:true},$tds));// Row Details slot\nif(rowShowDetails){var detailsScope={item:item,index:rowIndex,fields:fields,toggleDetails:this.toggleDetailsFactory(hasDetailsSlot,item)};// If table supports selectable mode, then add in the following scope\n// this.supportsSelectableRows will be undefined if mixin isn't loaded\nif(this.supportsSelectableRows){detailsScope.rowSelected=this.isRowSelected(rowIndex);detailsScope.selectRow=function(){return _this3.selectRow(rowIndex);};detailsScope.unselectRow=function(){return _this3.unselectRow(rowIndex);};}// Render the details slot in a TD\nvar $details=h(BTd,{props:{colspan:fields.length},class:this.detailsTdClass},[this.normalizeSlot(SLOT_NAME_ROW_DETAILS,detailsScope)]);// Add a hidden row to keep table row striping consistent when details showing\n// Only added if the table is striped\nif(striped){$rows.push(// We don't use `BTr` here as we don't need the extra functionality\nh('tr',{staticClass:'d-none',attrs:{'aria-hidden':'true',role:'presentation'},key:\"__b-table-details-stripe__\".concat(rowKey)}));}// Add the actual details row\nvar userDetailsTrClasses=isFunction$1(this.tbodyTrClass)?/* istanbul ignore next */this.tbodyTrClass(item,SLOT_NAME_ROW_DETAILS):this.tbodyTrClass;var userDetailsTrAttrs=isFunction$1(this.tbodyTrAttr)?/* istanbul ignore next */this.tbodyTrAttr(item,SLOT_NAME_ROW_DETAILS):this.tbodyTrAttr;$rows.push(h(BTr,{staticClass:'b-table-details',class:[userDetailsTrClasses],props:{variant:item[FIELD_KEY_ROW_VARIANT]||null},attrs:_objectSpread2$3(_objectSpread2$3({},userDetailsTrAttrs),{},{// Users cannot override the following attributes\nid:detailsId,tabindex:'-1'}),key:\"__b-table-details__\".concat(rowKey)},[$details]));}else if(hasDetailsSlot){// Only add the placeholder if a the table has a row-details slot defined (but not shown)\n$rows.push(h());if(striped){// Add extra placeholder if table is striped\n$rows.push(h());}}// Return the row(s)\nreturn $rows;}}});var getCellSlotName=function getCellSlotName(value){return\"cell(\".concat(value||'',\")\");};// --- Props ---\nvar props$e=sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$h),props$f),{},{tbodyClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)}));// --- Mixin ---\n// @vue/component\nvar tbodyMixin=Vue__default['default'].extend({mixins:[tbodyRowMixin],props:props$e,beforeDestroy:function beforeDestroy(){this.$_bodyFieldSlotNameCache=null;},methods:{// Returns all the item TR elements (excludes detail and spacer rows)\n// `this.$refs['item-rows']` is an array of item TR components/elements\n// Rows should all be `<b-tr>` components, but we map to TR elements\n// Also note that `this.$refs['item-rows']` may not always be in document order\ngetTbodyTrs:function getTbodyTrs(){var $refs=this.$refs;var tbody=$refs.tbody?$refs.tbody.$el||$refs.tbody:null;var trs=($refs['item-rows']||[]).map(function(tr){return tr.$el||tr;});return tbody&&tbody.children&&tbody.children.length>0&&trs&&trs.length>0?from(tbody.children).filter(function(tr){return arrayIncludes(trs,tr);}):/* istanbul ignore next */[];},// Returns index of a particular TBODY item TR\n// We set `true` on closest to include self in result\ngetTbodyTrIndex:function getTbodyTrIndex(el){/* istanbul ignore next: should not normally happen */if(!isElement(el)){return-1;}var tr=el.tagName==='TR'?el:closest('tr',el,true);return tr?this.getTbodyTrs().indexOf(tr):-1;},// Emits a row event, with the item object, row index and original event\nemitTbodyRowEvent:function emitTbodyRowEvent(type,event){if(type&&this.hasListener(type)&&event&&event.target){var rowIndex=this.getTbodyTrIndex(event.target);if(rowIndex>-1){// The array of TRs correlate to the `computedItems` array\nvar item=this.computedItems[rowIndex];this.$emit(type,item,rowIndex,event);}}},tbodyRowEventStopped:function tbodyRowEventStopped(event){return this.stopIfBusy&&this.stopIfBusy(event);},// Delegated row event handlers\nonTbodyRowKeydown:function onTbodyRowKeydown(event){// Keyboard navigation and row click emulation\nvar target=event.target,keyCode=event.keyCode;if(this.tbodyRowEventStopped(event)||target.tagName!=='TR'||!isActiveElement(target)||target.tabIndex!==0){// Early exit if not an item row TR\nreturn;}if(arrayIncludes([CODE_ENTER,CODE_SPACE],keyCode)){// Emulated click for keyboard users, transfer to click handler\nstopEvent(event);this.onTBodyRowClicked(event);}else if(arrayIncludes([CODE_UP,CODE_DOWN,CODE_HOME,CODE_END],keyCode)){// Keyboard navigation\nvar rowIndex=this.getTbodyTrIndex(target);if(rowIndex>-1){stopEvent(event);var trs=this.getTbodyTrs();var shift=event.shiftKey;if(keyCode===CODE_HOME||shift&&keyCode===CODE_UP){// Focus first row\nattemptFocus(trs[0]);}else if(keyCode===CODE_END||shift&&keyCode===CODE_DOWN){// Focus last row\nattemptFocus(trs[trs.length-1]);}else if(keyCode===CODE_UP&&rowIndex>0){// Focus previous row\nattemptFocus(trs[rowIndex-1]);}else if(keyCode===CODE_DOWN&&rowIndex<trs.length-1){// Focus next row\nattemptFocus(trs[rowIndex+1]);}}}},onTBodyRowClicked:function onTBodyRowClicked(event){var $refs=this.$refs;var tbody=$refs.tbody?$refs.tbody.$el||$refs.tbody:null;// Don't emit event when the table is busy, the user clicked\n// on a non-disabled control or is selecting text\nif(this.tbodyRowEventStopped(event)||filterEvent(event)||textSelectionActive(tbody||this.$el)){return;}this.emitTbodyRowEvent(EVENT_NAME_ROW_CLICKED,event);},onTbodyRowMiddleMouseRowClicked:function onTbodyRowMiddleMouseRowClicked(event){if(!this.tbodyRowEventStopped(event)&&event.which===2){this.emitTbodyRowEvent(EVENT_NAME_ROW_MIDDLE_CLICKED,event);}},onTbodyRowContextmenu:function onTbodyRowContextmenu(event){if(!this.tbodyRowEventStopped(event)){this.emitTbodyRowEvent(EVENT_NAME_ROW_CONTEXTMENU,event);}},onTbodyRowDblClicked:function onTbodyRowDblClicked(event){if(!this.tbodyRowEventStopped(event)&&!filterEvent(event)){this.emitTbodyRowEvent(EVENT_NAME_ROW_DBLCLICKED,event);}},// Render the tbody element and children\n// Note:\n//   Row hover handlers are handled by the tbody-row mixin\n//   As mouseenter/mouseleave events do not bubble\nrenderTbody:function renderTbody(){var _this=this;var items=this.computedItems,renderBusy=this.renderBusy,renderTopRow=this.renderTopRow,renderEmpty=this.renderEmpty,renderBottomRow=this.renderBottomRow;var h=this.$createElement;var hasRowClickHandler=this.hasListener(EVENT_NAME_ROW_CLICKED)||this.hasSelectableRowClick;// Prepare the tbody rows\nvar $rows=[];// Add the item data rows or the busy slot\nvar $busy=renderBusy?renderBusy():null;if($busy){// If table is busy and a busy slot, then return only the busy \"row\" indicator\n$rows.push($busy);}else{// Table isn't busy, or we don't have a busy slot\n// Create a slot cache for improved performance when looking up cell slot names\n// Values will be keyed by the field's `key` and will store the slot's name\n// Slots could be dynamic (i.e. `v-if`), so we must compute on each render\n// Used by tbody-row mixin render helper\nvar cache={};var defaultSlotName=getCellSlotName();defaultSlotName=this.hasNormalizedSlot(defaultSlotName)?defaultSlotName:null;this.computedFields.forEach(function(field){var key=field.key;var slotName=getCellSlotName(key);var lowercaseSlotName=getCellSlotName(key.toLowerCase());cache[key]=_this.hasNormalizedSlot(slotName)?slotName:_this.hasNormalizedSlot(lowercaseSlotName)?/* istanbul ignore next */lowercaseSlotName:defaultSlotName;});// Created as a non-reactive property so to not trigger component updates\n// Must be a fresh object each render\nthis.$_bodyFieldSlotNameCache=cache;// Add static top row slot (hidden in visibly stacked mode\n// as we can't control `data-label` attr)\n$rows.push(renderTopRow?renderTopRow():h());// Render the rows\nitems.forEach(function(item,rowIndex){// Render the individual item row (rows if details slot)\n$rows.push(_this.renderTbodyRow(item,rowIndex));});// Empty items / empty filtered row slot (only shows if `items.length < 1`)\n$rows.push(renderEmpty?renderEmpty():h());// Static bottom row slot (hidden in visibly stacked mode\n// as we can't control `data-label` attr)\n$rows.push(renderBottomRow?renderBottomRow():h());}// Note: these events will only emit if a listener is registered\nvar handlers={auxclick:this.onTbodyRowMiddleMouseRowClicked,// TODO:\n//   Perhaps we do want to automatically prevent the\n//   default context menu from showing if there is a\n//   `row-contextmenu` listener registered\ncontextmenu:this.onTbodyRowContextmenu,// The following event(s) is not considered A11Y friendly\ndblclick:this.onTbodyRowDblClicked// Hover events (`mouseenter`/`mouseleave`) are handled by `tbody-row` mixin\n};// Add in click/keydown listeners if needed\nif(hasRowClickHandler){handlers.click=this.onTBodyRowClicked;handlers.keydown=this.onTbodyRowKeydown;}// Assemble rows into the tbody\nvar $tbody=h(BTbody,{class:this.tbodyClass||null,props:pluckProps(props$h,this.$props),// BTbody transfers all native event listeners to the root element\n// TODO: Only set the handlers if the table is not busy\non:handlers,ref:'tbody'},$rows);// Return the assembled tbody\nreturn $tbody;}}});var props$d=makePropsConfigurable({// Supported values: 'lite', 'dark', or null\nfootVariant:makeProp(PROP_TYPE_STRING)},NAME_TFOOT);// --- Main component ---\n// TODO:\n//   In Bootstrap v5, we won't need \"sniffing\" as table element variants properly inherit\n//   to the child elements, so this can be converted to a functional component\n// @vue/component\nvar BTfoot=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TFOOT,mixins:[attrsMixin,listenersMixin,normalizeSlotMixin],provide:function provide(){return{bvTableRowGroup:this};},inject:{// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\nbvTable:{default:/* istanbul ignore next */function _default(){return{};}}},inheritAttrs:false,props:props$d,computed:{// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\nisTfoot:function isTfoot(){return true;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\nisDark:function isDark(){return this.bvTable.dark;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\nisStacked:function isStacked(){return this.bvTable.isStacked;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\nisResponsive:function isResponsive(){return this.bvTable.isResponsive;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\n// Sticky headers are only supported in thead\nisStickyHeader:function isStickyHeader(){return false;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\n// Needed to handle header background classes, due to lack of\n// background color inheritance with Bootstrap v4 table CSS\nhasStickyHeader:function hasStickyHeader(){return!this.isStacked&&this.bvTable.stickyHeader;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\ntableVariant:function tableVariant(){return this.bvTable.tableVariant;},tfootClasses:function tfootClasses(){return[this.footVariant?\"thead-\".concat(this.footVariant):null];},tfootAttrs:function tfootAttrs(){return _objectSpread2$3(_objectSpread2$3({},this.bvAttrs),{},{role:'rowgroup'});}},render:function render(h){return h('tfoot',{class:this.tfootClasses,attrs:this.tfootAttrs,// Pass down any native listeners\non:this.bvListeners},this.normalizeSlot());}});var props$c={footClone:makeProp(PROP_TYPE_BOOLEAN,false),// Any Bootstrap theme variant (or custom)\n// Falls back to `headRowVariant`\nfootRowVariant:makeProp(PROP_TYPE_STRING),// 'dark', 'light', or `null` (or custom)\nfootVariant:makeProp(PROP_TYPE_STRING),tfootClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),tfootTrClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)};// --- Mixin ---\n// @vue/component\nvar tfootMixin=Vue__default['default'].extend({props:props$c,methods:{renderTFootCustom:function renderTFootCustom(){var h=this.$createElement;if(this.hasNormalizedSlot(SLOT_NAME_CUSTOM_FOOT)){return h(BTfoot,{class:this.tfootClass||null,props:{footVariant:this.footVariant||this.headVariant||null},key:'bv-tfoot-custom'},this.normalizeSlot(SLOT_NAME_CUSTOM_FOOT,{items:this.computedItems.slice(),fields:this.computedFields.slice(),columns:this.computedFields.length}));}return h();},renderTfoot:function renderTfoot(){// Passing true to renderThead will make it render a tfoot\nreturn this.footClone?this.renderThead(true):this.renderTFootCustom();}}});var props$b=makePropsConfigurable({// Also sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\n// Supported values: 'lite', 'dark', or `null`\nheadVariant:makeProp(PROP_TYPE_STRING)},NAME_THEAD);// --- Main component ---\n// TODO:\n//   In Bootstrap v5, we won't need \"sniffing\" as table element variants properly inherit\n//   to the child elements, so this can be converted to a functional component\n// @vue/component\nvar BThead=/*#__PURE__*/Vue__default['default'].extend({name:NAME_THEAD,mixins:[attrsMixin,listenersMixin,normalizeSlotMixin],provide:function provide(){return{bvTableRowGroup:this};},inject:{// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\nbvTable:{default:/* istanbul ignore next */function _default(){return{};}}},inheritAttrs:false,props:props$b,computed:{// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\nisThead:function isThead(){return true;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\nisDark:function isDark(){return this.bvTable.dark;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\nisStacked:function isStacked(){return this.bvTable.isStacked;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\nisResponsive:function isResponsive(){return this.bvTable.isResponsive;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\n// Needed to handle header background classes, due to lack of\n// background color inheritance with Bootstrap v4 table CSS\n// Sticky headers only apply to cells in table `thead`\nisStickyHeader:function isStickyHeader(){return!this.isStacked&&this.bvTable.stickyHeader;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\n// Needed to handle header background classes, due to lack of\n// background color inheritance with Bootstrap v4 table CSS\nhasStickyHeader:function hasStickyHeader(){return!this.isStacked&&this.bvTable.stickyHeader;},// Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`\ntableVariant:function tableVariant(){return this.bvTable.tableVariant;},theadClasses:function theadClasses(){return[this.headVariant?\"thead-\".concat(this.headVariant):null];},theadAttrs:function theadAttrs(){return _objectSpread2$3({role:'rowgroup'},this.bvAttrs);}},render:function render(h){return h('thead',{class:this.theadClasses,attrs:this.theadAttrs,// Pass down any native listeners\non:this.bvListeners},this.normalizeSlot());}});var getHeadSlotName=function getHeadSlotName(value){return\"head(\".concat(value||'',\")\");};var getFootSlotName=function getFootSlotName(value){return\"foot(\".concat(value||'',\")\");};// --- Props ---\nvar props$a={// Any Bootstrap theme variant (or custom)\nheadRowVariant:makeProp(PROP_TYPE_STRING),// 'light', 'dark' or `null` (or custom)\nheadVariant:makeProp(PROP_TYPE_STRING),theadClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),theadTrClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)};// --- Mixin ---\n// @vue/component\nvar theadMixin=Vue__default['default'].extend({props:props$a,methods:{fieldClasses:function fieldClasses(field){// Header field (<th>) classes\nreturn[field.class?field.class:'',field.thClass?field.thClass:''];},headClicked:function headClicked(event,field,isFoot){if(this.stopIfBusy&&this.stopIfBusy(event)){// If table is busy (via provider) then don't propagate\nreturn;}else if(filterEvent(event)){// Clicked on a non-disabled control so ignore\nreturn;}else if(textSelectionActive(this.$el)){// User is selecting text, so ignore\n/* istanbul ignore next: JSDOM doesn't support getSelection() */return;}stopEvent(event);this.$emit(EVENT_NAME_HEAD_CLICKED,field.key,field,event,isFoot);},renderThead:function renderThead(){var _this=this;var isFoot=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;var fields=this.computedFields,isSortable=this.isSortable,isSelectable=this.isSelectable,headVariant=this.headVariant,footVariant=this.footVariant,headRowVariant=this.headRowVariant,footRowVariant=this.footRowVariant;var h=this.$createElement;// In always stacked mode, we don't bother rendering the head/foot\n// Or if no field headings (empty table)\nif(this.isStackedAlways||fields.length===0){return h();}var hasHeadClickListener=isSortable||this.hasListener(EVENT_NAME_HEAD_CLICKED);// Reference to `selectAllRows` and `clearSelected()`, if table is selectable\nvar selectAllRows=isSelectable?this.selectAllRows:noop;var clearSelected=isSelectable?this.clearSelected:noop;// Helper function to generate a field <th> cell\nvar makeCell=function makeCell(field,colIndex){var label=field.label,labelHtml=field.labelHtml,variant=field.variant,stickyColumn=field.stickyColumn,key=field.key;var ariaLabel=null;if(!field.label.trim()&&!field.headerTitle){// In case field's label and title are empty/blank\n// We need to add a hint about what the column is about for non-sighted users\n/* istanbul ignore next */ariaLabel=startCase(field.key);}var on={};if(hasHeadClickListener){on.click=function(event){_this.headClicked(event,field,isFoot);};on.keydown=function(event){var keyCode=event.keyCode;if(keyCode===CODE_ENTER||keyCode===CODE_SPACE){_this.headClicked(event,field,isFoot);}};}var sortAttrs=isSortable?_this.sortTheadThAttrs(key,field,isFoot):{};var sortClass=isSortable?_this.sortTheadThClasses(key,field,isFoot):null;var sortLabel=isSortable?_this.sortTheadThLabel(key,field,isFoot):null;var data={class:[{// We need to make the header cell relative when we have\n// a `.sr-only` sort label to work around overflow issues\n'position-relative':sortLabel},_this.fieldClasses(field),sortClass],props:{variant:variant,stickyColumn:stickyColumn},style:field.thStyle||{},attrs:_objectSpread2$3(_objectSpread2$3({// We only add a `tabindex` of `0` if there is a head-clicked listener\n// and the current field is sortable\ntabindex:hasHeadClickListener&&field.sortable?'0':null,abbr:field.headerAbbr||null,title:field.headerTitle||null,'aria-colindex':colIndex+1,'aria-label':ariaLabel},_this.getThValues(null,key,field.thAttr,isFoot?'foot':'head',{})),sortAttrs),on:on,key:key};// Handle edge case where in-document templates are used with new\n// `v-slot:name` syntax where the browser lower-cases the v-slot's\n// name (attributes become lower cased when parsed by the browser)\n// We have replaced the square bracket syntax with round brackets\n// to prevent confusion with dynamic slot names\nvar slotNames=[getHeadSlotName(key),getHeadSlotName(key.toLowerCase()),getHeadSlotName()];// Footer will fallback to header slot names\nif(isFoot){slotNames=[getFootSlotName(key),getFootSlotName(key.toLowerCase()),getFootSlotName()].concat(_toConsumableArray$1(slotNames));}var scope={label:label,column:key,field:field,isFoot:isFoot,// Add in row select methods\nselectAllRows:selectAllRows,clearSelected:clearSelected};var $content=_this.normalizeSlot(slotNames,scope)||h('div',{domProps:htmlOrText(labelHtml,label)});var $srLabel=sortLabel?h('span',{staticClass:'sr-only'},\" (\".concat(sortLabel,\")\")):null;// Return the header cell\nreturn h(BTh,data,[$content,$srLabel].filter(identity));};// Generate the array of <th> cells\nvar $cells=fields.map(makeCell).filter(identity);// Generate the row(s)\nvar $trs=[];if(isFoot){$trs.push(h(BTr,{class:this.tfootTrClass,props:{variant:isUndefinedOrNull(footRowVariant)?headRowVariant:/* istanbul ignore next */footRowVariant}},$cells));}else{var scope={columns:fields.length,fields:fields,// Add in row select methods\nselectAllRows:selectAllRows,clearSelected:clearSelected};$trs.push(this.normalizeSlot(SLOT_NAME_THEAD_TOP,scope)||h());$trs.push(h(BTr,{class:this.theadTrClass,props:{variant:headRowVariant}},$cells));}return h(isFoot?BTfoot:BThead,{class:(isFoot?this.tfootClass:this.theadClass)||null,props:isFoot?{footVariant:footVariant||headVariant||null}:{headVariant:headVariant||null},key:isFoot?'bv-tfoot':'bv-thead'},$trs);}}});var props$9={};// --- Mixin ---\n// @vue/component\nvar topRowMixin=Vue__default['default'].extend({methods:{renderTopRow:function renderTopRow(){var fields=this.computedFields,stacked=this.stacked,tbodyTrClass=this.tbodyTrClass,tbodyTrAttr=this.tbodyTrAttr;var h=this.$createElement;// Add static Top Row slot (hidden in visibly stacked mode as we can't control the data-label)\n// If in *always* stacked mode, we don't bother rendering the row\nif(!this.hasNormalizedSlot(SLOT_NAME_TOP_ROW)||stacked===true||stacked===''){return h();}return h(BTr,{staticClass:'b-table-top-row',class:[isFunction$1(tbodyTrClass)?tbodyTrClass(null,'row-top'):tbodyTrClass],attrs:isFunction$1(tbodyTrAttr)?tbodyTrAttr(null,'row-top'):tbodyTrAttr,key:'b-top-row'},[this.normalizeSlot(SLOT_NAME_TOP_ROW,{columns:fields.length,fields:fields})]);}}});var props$8=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),props$v),props$t),props$s),props$r),props$q),props$p),props$o),props$n),props$m),props$l),props$k),props$j),props$i),props$e),props$c),props$a),props$9)),NAME_TABLE);// --- Main component ---\n// @vue/component\nvar BTable=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TABLE,// Order of mixins is important!\n// They are merged from first to last, followed by this component\nmixins:[// General mixins\nattrsMixin,hasListenerMixin,idMixin,normalizeSlotMixin,// Required table mixins\nitemsMixin,tableRendererMixin,stackedMixin,theadMixin,tfootMixin,tbodyMixin,// Table features mixins\nstackedMixin,filteringMixin,sortingMixin,paginationMixin,captionMixin,colgroupMixin,selectableMixin,emptyMixin,topRowMixin,bottomRowMixin,busyMixin,providerMixin],props:props$8// Render function is provided by `tableRendererMixin`\n});var props$7=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),props$s),props$r),props$o),props$j),props$i),props$e),props$c),props$a)),NAME_TABLE_LITE);// --- Main component ---\n// @vue/component\nvar BTableLite=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TABLE_LITE,// Order of mixins is important!\n// They are merged from first to last, followed by this component\nmixins:[// General mixins\nattrsMixin,hasListenerMixin,idMixin,normalizeSlotMixin,// Required table mixins\nitemsMixin,tableRendererMixin,stackedMixin,theadMixin,tfootMixin,tbodyMixin,// Table features mixins\n// These are pretty lightweight, and are useful for lightweight tables\ncaptionMixin,colgroupMixin],props:props$7// Render function is provided by `tableRendererMixin`\n});var props$6=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),props$j),props$i)),NAME_TABLE_SIMPLE);// --- Main component ---\n// @vue/component\nvar BTableSimple=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TABLE_SIMPLE,// Order of mixins is important!\n// They are merged from first to last, followed by this component\nmixins:[// General mixins\nattrsMixin,hasListenerMixin,idMixin,normalizeSlotMixin,// Required table mixins\ntableRendererMixin,// Table features mixins\n// Stacked requires extra handling by users via\n// the table cell `stacked-heading` prop\nstackedMixin],props:props$6,computed:{isTableSimple:function isTableSimple(){return true;}}// Render function is provided by `tableRendererMixin`\n});var TableLitePlugin=/*#__PURE__*/pluginFactory({components:{BTableLite:BTableLite}});var TableSimplePlugin=/*#__PURE__*/pluginFactory({components:{BTableSimple:BTableSimple,BTbody:BTbody,BThead:BThead,BTfoot:BTfoot,BTr:BTr,BTd:BTd,BTh:BTh}});var TablePlugin=/*#__PURE__*/pluginFactory({components:{BTable:BTable},plugins:{TableLitePlugin:TableLitePlugin,TableSimplePlugin:TableSimplePlugin}});var isPositiveNumber=function isPositiveNumber(value){return value>0;};// --- Props ---\nvar props$5=makePropsConfigurable({animation:makeProp(PROP_TYPE_STRING),columns:makeProp(PROP_TYPE_NUMBER,5,isPositiveNumber),hideHeader:makeProp(PROP_TYPE_BOOLEAN,false),rows:makeProp(PROP_TYPE_NUMBER,3,isPositiveNumber),showFooter:makeProp(PROP_TYPE_BOOLEAN,false),tableProps:makeProp(PROP_TYPE_OBJECT,{})},NAME_SKELETON_TABLE);// --- Main component ---\n// @vue/component\nvar BSkeletonTable=/*#__PURE__*/Vue__default['default'].extend({name:NAME_SKELETON_TABLE,functional:true,props:props$5,render:function render(h,_ref){var data=_ref.data,props=_ref.props;var animation=props.animation,columns=props.columns;var $th=h('th',[h(BSkeleton,{props:{animation:animation}})]);var $thTr=h('tr',createArray(columns,$th));var $td=h('td',[h(BSkeleton,{props:{width:'75%',animation:animation}})]);var $tdTr=h('tr',createArray(columns,$td));var $tbody=h('tbody',createArray(props.rows,$tdTr));var $thead=!props.hideHeader?h('thead',[$thTr]):h();var $tfoot=props.showFooter?h('tfoot',[$thTr]):h();return h(BTableSimple,a(data,{props:_objectSpread2$3({},props.tableProps)}),[$thead,$tbody,$tfoot]);}});var props$4=makePropsConfigurable({loading:makeProp(PROP_TYPE_BOOLEAN,false)},NAME_SKELETON_WRAPPER);// --- Main component ---\n// @vue/component\nvar BSkeletonWrapper=/*#__PURE__*/Vue__default['default'].extend({name:NAME_SKELETON_WRAPPER,functional:true,props:props$4,render:function render(h,_ref){var data=_ref.data,props=_ref.props,slots=_ref.slots,scopedSlots=_ref.scopedSlots;var $slots=slots();var $scopedSlots=scopedSlots||{};var slotScope={};if(props.loading){return h('div',a(data,{attrs:{role:'alert','aria-live':'polite','aria-busy':true},staticClass:'b-skeleton-wrapper',key:'loading'}),normalizeSlot(SLOT_NAME_LOADING,slotScope,$scopedSlots,$slots));}return normalizeSlot(SLOT_NAME_DEFAULT,slotScope,$scopedSlots,$slots);}});var SkeletonPlugin=/*#__PURE__*/pluginFactory({components:{BSkeleton:BSkeleton,BSkeletonIcon:BSkeletonIcon,BSkeletonImg:BSkeletonImg,BSkeletonTable:BSkeletonTable,BSkeletonWrapper:BSkeletonWrapper}});var SpinnerPlugin=/*#__PURE__*/pluginFactory({components:{BSpinner:BSpinner}});var _watch$2;var _makeModelMixin$1=makeModelMixin('value',{type:PROP_TYPE_NUMBER}),modelMixin$1=_makeModelMixin$1.mixin,modelProps$1=_makeModelMixin$1.props,MODEL_PROP_NAME$1=_makeModelMixin$1.prop,MODEL_EVENT_NAME$1=_makeModelMixin$1.event;// --- Helper methods ---\n// Filter function to filter out disabled tabs\nvar notDisabled=function notDisabled(tab){return!tab.disabled;};// --- Helper components ---\n// @vue/component\nvar BVTabButton=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TAB_BUTTON_HELPER,inject:{bvTabs:{default:/* istanbul ignore next */function _default(){return{};}}},props:{controls:makeProp(PROP_TYPE_STRING),id:makeProp(PROP_TYPE_STRING),noKeyNav:makeProp(PROP_TYPE_BOOLEAN,false),posInSet:makeProp(PROP_TYPE_NUMBER),setSize:makeProp(PROP_TYPE_NUMBER),// Reference to the child <b-tab> instance\ntab:makeProp(),tabIndex:makeProp(PROP_TYPE_NUMBER)},methods:{focus:function focus(){attemptFocus(this.$refs.link);},handleEvent:function handleEvent(event){/* istanbul ignore next */if(this.tab.disabled){return;}var type=event.type,keyCode=event.keyCode,shiftKey=event.shiftKey;if(type==='click'){stopEvent(event);this.$emit(EVENT_NAME_CLICK,event);}else if(type==='keydown'&&keyCode===CODE_SPACE){// For ARIA tabs the SPACE key will also trigger a click/select\n// Even with keyboard navigation disabled, SPACE should \"click\" the button\n// See: https://github.com/bootstrap-vue/bootstrap-vue/issues/4323\nstopEvent(event);this.$emit(EVENT_NAME_CLICK,event);}else if(type==='keydown'&&!this.noKeyNav){// For keyboard navigation\nif([CODE_UP,CODE_LEFT,CODE_HOME].indexOf(keyCode)!==-1){stopEvent(event);if(shiftKey||keyCode===CODE_HOME){this.$emit(EVENT_NAME_FIRST,event);}else{this.$emit(EVENT_NAME_PREV,event);}}else if([CODE_DOWN,CODE_RIGHT,CODE_END].indexOf(keyCode)!==-1){stopEvent(event);if(shiftKey||keyCode===CODE_END){this.$emit(EVENT_NAME_LAST,event);}else{this.$emit(EVENT_NAME_NEXT,event);}}}}},render:function render(h){var id=this.id,tabIndex=this.tabIndex,setSize=this.setSize,posInSet=this.posInSet,controls=this.controls,handleEvent=this.handleEvent;var _this$tab=this.tab,title=_this$tab.title,localActive=_this$tab.localActive,disabled=_this$tab.disabled,titleItemClass=_this$tab.titleItemClass,titleLinkClass=_this$tab.titleLinkClass,titleLinkAttributes=_this$tab.titleLinkAttributes;var $link=h(BLink,{staticClass:'nav-link',class:[{active:localActive&&!disabled,disabled:disabled},titleLinkClass,// Apply <b-tabs> `activeNavItemClass` styles when the tab is active\nlocalActive?this.bvTabs.activeNavItemClass:null],props:{disabled:disabled},attrs:_objectSpread2$3(_objectSpread2$3({},titleLinkAttributes),{},{id:id,role:'tab',// Roving tab index when keynav enabled\ntabindex:tabIndex,'aria-selected':localActive&&!disabled?'true':'false','aria-setsize':setSize,'aria-posinset':posInSet,'aria-controls':controls}),on:{click:handleEvent,keydown:handleEvent},ref:'link'},[this.tab.normalizeSlot(SLOT_NAME_TITLE)||title]);return h('li',{staticClass:'nav-item',class:[titleItemClass],attrs:{role:'presentation'}},[$link]);}});// --- Props ---\nvar navProps=omit(props$U,['tabs','isNavBar','cardHeader']);var props$3=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),modelProps$1),navProps),{},{// Only applied to the currently active `<b-nav-item>`\nactiveNavItemClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),// Only applied to the currently active `<b-tab>`\n// This prop is sniffed by the `<b-tab>` child\nactiveTabClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),card:makeProp(PROP_TYPE_BOOLEAN,false),contentClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),// Synonym for 'bottom'\nend:makeProp(PROP_TYPE_BOOLEAN,false),// This prop is sniffed by the `<b-tab>` child\nlazy:makeProp(PROP_TYPE_BOOLEAN,false),navClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),navWrapperClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),noFade:makeProp(PROP_TYPE_BOOLEAN,false),noKeyNav:makeProp(PROP_TYPE_BOOLEAN,false),noNavStyle:makeProp(PROP_TYPE_BOOLEAN,false),tag:makeProp(PROP_TYPE_STRING,'div')})),NAME_TABS);// --- Main component ---\n// @vue/component\nvar BTabs=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TABS,mixins:[idMixin,modelMixin$1,normalizeSlotMixin],provide:function provide(){return{bvTabs:this};},props:props$3,data:function data(){return{// Index of current tab\ncurrentTab:toInteger(this[MODEL_PROP_NAME$1],-1),// Array of direct child `<b-tab>` instances, in DOM order\ntabs:[],// Array of child instances registered (for triggering reactive updates)\nregisteredTabs:[]};},computed:{fade:function fade(){// This computed prop is sniffed by the tab child\nreturn!this.noFade;},localNavClass:function localNavClass(){var classes=[];if(this.card&&this.vertical){classes.push('card-header','h-100','border-bottom-0','rounded-0');}return[].concat(classes,[this.navClass]);}},watch:(_watch$2={},_defineProperty(_watch$2,MODEL_PROP_NAME$1,function(newValue,oldValue){if(newValue!==oldValue){newValue=toInteger(newValue,-1);oldValue=toInteger(oldValue,0);var $tab=this.tabs[newValue];if($tab&&!$tab.disabled){this.activateTab($tab);}else{// Try next or prev tabs\nif(newValue<oldValue){this.previousTab();}else{this.nextTab();}}}}),_defineProperty(_watch$2,\"currentTab\",function currentTab(newValue){var index=-1;// Ensure only one tab is active at most\nthis.tabs.forEach(function($tab,i){if(i===newValue&&!$tab.disabled){$tab.localActive=true;index=i;}else{$tab.localActive=false;}});// Update the v-model\nthis.$emit(MODEL_EVENT_NAME$1,index);}),_defineProperty(_watch$2,\"tabs\",function tabs(newValue,oldValue){var _this=this;// We use `_uid` instead of `safeId()`, as the later is changed in a `$nextTick()`\n// if no explicit ID is provided, causing duplicate emits\nif(!looseEqual(newValue.map(function($tab){return $tab[COMPONENT_UID_KEY];}),oldValue.map(function($tab){return $tab[COMPONENT_UID_KEY];}))){// In a `$nextTick()` to ensure `currentTab` has been set first\nthis.$nextTick(function(){// We emit shallow copies of the new and old arrays of tabs,\n// to prevent users from potentially mutating the internal arrays\n_this.$emit(EVENT_NAME_CHANGED,newValue.slice(),oldValue.slice());});}}),_defineProperty(_watch$2,\"registeredTabs\",function registeredTabs(){this.updateTabs();}),_watch$2),created:function created(){// Create private non-reactive props\nthis.$_observer=null;},mounted:function mounted(){this.setObserver(true);},beforeDestroy:function beforeDestroy(){this.setObserver(false);// Ensure no references to child instances exist\nthis.tabs=[];},methods:{registerTab:function registerTab($tab){if(!arrayIncludes(this.registeredTabs,$tab)){this.registeredTabs.push($tab);}},unregisterTab:function unregisterTab($tab){this.registeredTabs=this.registeredTabs.slice().filter(function($t){return $t!==$tab;});},// DOM observer is needed to detect changes in order of tabs\nsetObserver:function setObserver(){var _this2=this;var on=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;this.$_observer&&this.$_observer.disconnect();this.$_observer=null;if(on){/* istanbul ignore next: difficult to test mutation observer in JSDOM */var handler=function handler(){_this2.$nextTick(function(){requestAF(function(){_this2.updateTabs();});});};// Watch for changes to `<b-tab>` sub components\nthis.$_observer=observeDom(this.$refs.content,handler,{childList:true,subtree:false,attributes:true,attributeFilter:['id']});}},getTabs:function getTabs(){var $tabs=this.registeredTabs.filter(function($tab){return $tab.$children.filter(function($t){return $t._isTab;}).length===0;});// DOM Order of Tabs\nvar order=[];/* istanbul ignore next: too difficult to test */if(IS_BROWSER&&$tabs.length>0){// We rely on the DOM when mounted to get the \"true\" order of the `<b-tab>` children\n// `querySelectorAll()` always returns elements in document order, regardless of\n// order specified in the selector\nvar selector=$tabs.map(function($tab){return\"#\".concat($tab.safeId());}).join(', ');order=selectAll(selector,this.$el).map(function($el){return $el.id;}).filter(identity);}// Stable sort keeps the original order if not found in the `order` array,\n// which will be an empty array before mount\nreturn stableSort$1($tabs,function(a,b){return order.indexOf(a.safeId())-order.indexOf(b.safeId());});},updateTabs:function updateTabs(){var $tabs=this.getTabs();// Find last active non-disabled tab in current tabs\n// We trust tab state over `currentTab`, in case tabs were added/removed/re-ordered\nvar tabIndex=$tabs.indexOf($tabs.slice().reverse().find(function($tab){return $tab.localActive&&!$tab.disabled;}));// Else try setting to `currentTab`\nif(tabIndex<0){var currentTab=this.currentTab;if(currentTab>=$tabs.length){// Handle last tab being removed, so find the last non-disabled tab\ntabIndex=$tabs.indexOf($tabs.slice().reverse().find(notDisabled));}else if($tabs[currentTab]&&!$tabs[currentTab].disabled){// Current tab is not disabled\ntabIndex=currentTab;}}// Else find first non-disabled tab in current tabs\nif(tabIndex<0){tabIndex=$tabs.indexOf($tabs.find(notDisabled));}// Ensure only one tab is active at a time\n$tabs.forEach(function($tab,index){$tab.localActive=index===tabIndex;});this.tabs=$tabs;this.currentTab=tabIndex;},// Find a button that controls a tab, given the tab reference\n// Returns the button vm instance\ngetButtonForTab:function getButtonForTab($tab){return(this.$refs.buttons||[]).find(function($btn){return $btn.tab===$tab;});},// Force a button to re-render its content, given a `<b-tab>` instance\n// Called by `<b-tab>` on `update()`\nupdateButton:function updateButton($tab){var $button=this.getButtonForTab($tab);if($button&&$button.$forceUpdate){$button.$forceUpdate();}},// Activate a tab given a `<b-tab>` instance\n// Also accessed by `<b-tab>`\nactivateTab:function activateTab($tab){var currentTab=this.currentTab,$tabs=this.tabs;var result=false;if($tab){var index=$tabs.indexOf($tab);if(index!==currentTab&&index>-1&&!$tab.disabled){var tabEvent=new BvEvent(EVENT_NAME_ACTIVATE_TAB,{cancelable:true,vueTarget:this,componentId:this.safeId()});this.$emit(tabEvent.type,index,currentTab,tabEvent);if(!tabEvent.defaultPrevented){this.currentTab=index;result=true;}}}// Couldn't set tab, so ensure v-model is up to date\n/* istanbul ignore next: should rarely happen */if(!result&&this[MODEL_PROP_NAME$1]!==currentTab){this.$emit(MODEL_EVENT_NAME$1,currentTab);}return result;},// Deactivate a tab given a `<b-tab>` instance\n// Accessed by `<b-tab>`\ndeactivateTab:function deactivateTab($tab){if($tab){// Find first non-disabled tab that isn't the one being deactivated\n// If no tabs are available, then don't deactivate current tab\nreturn this.activateTab(this.tabs.filter(function($t){return $t!==$tab;}).find(notDisabled));}/* istanbul ignore next: should never/rarely happen */return false;},// Focus a tab button given its `<b-tab>` instance\nfocusButton:function focusButton($tab){var _this3=this;// Wrap in `$nextTick()` to ensure DOM has completed rendering\nthis.$nextTick(function(){attemptFocus(_this3.getButtonForTab($tab));});},// Emit a click event on a specified `<b-tab>` component instance\nemitTabClick:function emitTabClick(tab,event){if(isEvent(event)&&tab&&tab.$emit&&!tab.disabled){tab.$emit(EVENT_NAME_CLICK,event);}},// Click handler\nclickTab:function clickTab($tab,event){this.activateTab($tab);this.emitTabClick($tab,event);},// Move to first non-disabled tab\nfirstTab:function firstTab(focus){var $tab=this.tabs.find(notDisabled);if(this.activateTab($tab)&&focus){this.focusButton($tab);this.emitTabClick($tab,focus);}},// Move to previous non-disabled tab\npreviousTab:function previousTab(focus){var currentIndex=mathMax(this.currentTab,0);var $tab=this.tabs.slice(0,currentIndex).reverse().find(notDisabled);if(this.activateTab($tab)&&focus){this.focusButton($tab);this.emitTabClick($tab,focus);}},// Move to next non-disabled tab\nnextTab:function nextTab(focus){var currentIndex=mathMax(this.currentTab,-1);var $tab=this.tabs.slice(currentIndex+1).find(notDisabled);if(this.activateTab($tab)&&focus){this.focusButton($tab);this.emitTabClick($tab,focus);}},// Move to last non-disabled tab\nlastTab:function lastTab(focus){var $tab=this.tabs.slice().reverse().find(notDisabled);if(this.activateTab($tab)&&focus){this.focusButton($tab);this.emitTabClick($tab,focus);}}},render:function render(h){var _this4=this;var align=this.align,card=this.card,end=this.end,fill=this.fill,firstTab=this.firstTab,justified=this.justified,lastTab=this.lastTab,nextTab=this.nextTab,noKeyNav=this.noKeyNav,noNavStyle=this.noNavStyle,pills=this.pills,previousTab=this.previousTab,small=this.small,$tabs=this.tabs,vertical=this.vertical;// Currently active tab\nvar $activeTab=$tabs.find(function($tab){return $tab.localActive&&!$tab.disabled;});// Tab button to allow focusing when no active tab found (keynav only)\nvar $fallbackTab=$tabs.find(function($tab){return!$tab.disabled;});// For each `<b-tab>` found create the tab buttons\nvar $buttons=$tabs.map(function($tab,index){var _on;var safeId=$tab.safeId;// Ensure at least one tab button is focusable when keynav enabled (if possible)\nvar tabIndex=null;if(!noKeyNav){// Buttons are not in tab index unless active, or a fallback tab\ntabIndex=-1;if($tab===$activeTab||!$activeTab&&$tab===$fallbackTab){// Place tab button in tab sequence\ntabIndex=null;}}return h(BVTabButton,{props:{controls:safeId?safeId():null,id:$tab.controlledBy||(safeId?safeId(\"_BV_tab_button_\"):null),noKeyNav:noKeyNav,posInSet:index+1,setSize:$tabs.length,tab:$tab,tabIndex:tabIndex},on:(_on={},_defineProperty(_on,EVENT_NAME_CLICK,function(event){_this4.clickTab($tab,event);}),_defineProperty(_on,EVENT_NAME_FIRST,firstTab),_defineProperty(_on,EVENT_NAME_PREV,previousTab),_defineProperty(_on,EVENT_NAME_NEXT,nextTab),_defineProperty(_on,EVENT_NAME_LAST,lastTab),_on),key:$tab[COMPONENT_UID_KEY]||index,ref:'buttons',// Needed to make `this.$refs.buttons` an array\nrefInFor:true});});var $nav=h(BNav,{class:this.localNavClass,attrs:{role:'tablist',id:this.safeId('_BV_tab_controls_')},props:{fill:fill,justified:justified,align:align,tabs:!noNavStyle&&!pills,pills:!noNavStyle&&pills,vertical:vertical,small:small,cardHeader:card&&!vertical},ref:'nav'},[this.normalizeSlot(SLOT_NAME_TABS_START)||h(),$buttons,this.normalizeSlot(SLOT_NAME_TABS_END)||h()]);$nav=h('div',{class:[{'card-header':card&&!vertical&&!end,'card-footer':card&&!vertical&&end,'col-auto':vertical},this.navWrapperClass],key:'bv-tabs-nav'},[$nav]);var $children=this.normalizeSlot()||[];var $empty=h();if($children.length===0){$empty=h('div',{class:['tab-pane','active',{'card-body':card}],key:'bv-empty-tab'},this.normalizeSlot(SLOT_NAME_EMPTY));}var $content=h('div',{staticClass:'tab-content',class:[{col:vertical},this.contentClass],attrs:{id:this.safeId('_BV_tab_container_')},key:'bv-content',ref:'content'},[$children,$empty]);// Render final output\nreturn h(this.tag,{staticClass:'tabs',class:{row:vertical,'no-gutters':vertical&&card},attrs:{id:this.safeId()}},[end?$content:h(),$nav,end?h():$content]);}});var _objectSpread2,_watch$1;var MODEL_PROP_NAME_ACTIVE='active';var MODEL_EVENT_NAME_ACTIVE=MODEL_EVENT_NAME_PREFIX+MODEL_PROP_NAME_ACTIVE;// --- Props ---\nvar props$2=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3({},props$25),{},(_objectSpread2={},_defineProperty(_objectSpread2,MODEL_PROP_NAME_ACTIVE,makeProp(PROP_TYPE_BOOLEAN,false)),_defineProperty(_objectSpread2,\"buttonId\",makeProp(PROP_TYPE_STRING)),_defineProperty(_objectSpread2,\"disabled\",makeProp(PROP_TYPE_BOOLEAN,false)),_defineProperty(_objectSpread2,\"lazy\",makeProp(PROP_TYPE_BOOLEAN,false)),_defineProperty(_objectSpread2,\"noBody\",makeProp(PROP_TYPE_BOOLEAN,false)),_defineProperty(_objectSpread2,\"tag\",makeProp(PROP_TYPE_STRING,'div')),_defineProperty(_objectSpread2,\"title\",makeProp(PROP_TYPE_STRING)),_defineProperty(_objectSpread2,\"titleItemClass\",makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)),_defineProperty(_objectSpread2,\"titleLinkAttributes\",makeProp(PROP_TYPE_OBJECT)),_defineProperty(_objectSpread2,\"titleLinkClass\",makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)),_objectSpread2))),NAME_TAB);// --- Main component ---\n// @vue/component\nvar BTab=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TAB,mixins:[idMixin,normalizeSlotMixin],inject:{bvTabs:{default:function _default(){return{};}}},props:props$2,data:function data(){return{localActive:this[MODEL_PROP_NAME_ACTIVE]&&!this.disabled};},computed:{// For parent sniffing of child\n_isTab:function _isTab(){return true;},tabClasses:function tabClasses(){var active=this.localActive,disabled=this.disabled;return[{active:active,disabled:disabled,'card-body':this.bvTabs.card&&!this.noBody},// Apply <b-tabs> `activeTabClass` styles when this tab is active\nactive?this.bvTabs.activeTabClass:null];},controlledBy:function controlledBy(){return this.buttonId||this.safeId('__BV_tab_button__');},computedNoFade:function computedNoFade(){return!(this.bvTabs.fade||false);},computedLazy:function computedLazy(){return this.bvTabs.lazy||this.lazy;}},watch:(_watch$1={},_defineProperty(_watch$1,MODEL_PROP_NAME_ACTIVE,function(newValue,oldValue){if(newValue!==oldValue){if(newValue){// If activated post mount\nthis.activate();}else{/* istanbul ignore next */if(!this.deactivate()){// Tab couldn't be deactivated, so we reset the synced active prop\n// Deactivation will fail if no other tabs to activate\nthis.$emit(MODEL_EVENT_NAME_ACTIVE,this.localActive);}}}}),_defineProperty(_watch$1,\"disabled\",function disabled(newValue,oldValue){if(newValue!==oldValue){var firstTab=this.bvTabs.firstTab;if(newValue&&this.localActive&&firstTab){this.localActive=false;firstTab();}}}),_defineProperty(_watch$1,\"localActive\",function localActive(newValue){// Make `active` prop work with `.sync` modifier\nthis.$emit(MODEL_EVENT_NAME_ACTIVE,newValue);}),_watch$1),mounted:function mounted(){// Inform `<b-tabs>` of our presence\nthis.registerTab();},updated:function updated(){// Force the tab button content to update (since slots are not reactive)\n// Only done if we have a title slot, as the title prop is reactive\nvar updateButton=this.bvTabs.updateButton;if(updateButton&&this.hasNormalizedSlot(SLOT_NAME_TITLE)){updateButton(this);}},beforeDestroy:function beforeDestroy(){// Inform `<b-tabs>` of our departure\nthis.unregisterTab();},methods:{// Private methods\nregisterTab:function registerTab(){// Inform `<b-tabs>` of our presence\nvar registerTab=this.bvTabs.registerTab;if(registerTab){registerTab(this);}},unregisterTab:function unregisterTab(){// Inform `<b-tabs>` of our departure\nvar unregisterTab=this.bvTabs.unregisterTab;if(unregisterTab){unregisterTab(this);}},// Public methods\nactivate:function activate(){// Not inside a `<b-tabs>` component or tab is disabled\nvar activateTab=this.bvTabs.activateTab;return activateTab&&!this.disabled?activateTab(this):false;},deactivate:function deactivate(){// Not inside a `<b-tabs>` component or not active to begin with\nvar deactivateTab=this.bvTabs.deactivateTab;return deactivateTab&&this.localActive?deactivateTab(this):false;}},render:function render(h){var localActive=this.localActive;var $content=h(this.tag,{staticClass:'tab-pane',class:this.tabClasses,directives:[{name:'show',value:localActive}],attrs:{role:'tabpanel',id:this.safeId(),'aria-hidden':localActive?'false':'true','aria-labelledby':this.controlledBy||null},ref:'panel'},// Render content lazily if requested\n[localActive||!this.computedLazy?this.normalizeSlot():h()]);return h(BVTransition,{props:{mode:'out-in',noFade:this.computedNoFade}},[$content]);}});var TabsPlugin=/*#__PURE__*/pluginFactory({components:{BTabs:BTabs,BTab:BTab}});var TimePlugin=/*#__PURE__*/pluginFactory({components:{BTime:BTime}});function _typeof(obj){if(typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"){_typeof=function(obj){return typeof obj;};}else{_typeof=function(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};}return _typeof(obj);}function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_nonIterableSpread();}function _arrayWithoutHoles(arr){if(Array.isArray(arr)){for(var i=0,arr2=new Array(arr.length);i<arr.length;i++)arr2[i]=arr[i];return arr2;}}function _iterableToArray(iter){if(Symbol.iterator in Object(iter)||Object.prototype.toString.call(iter)===\"[object Arguments]\")return Array.from(iter);}function _nonIterableSpread(){throw new TypeError(\"Invalid attempt to spread non-iterable instance\");}var inBrowser=typeof window!=='undefined';function freeze(item){if(Array.isArray(item)||_typeof(item)==='object'){return Object.freeze(item);}return item;}function combinePassengers(transports){var slotProps=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return transports.reduce(function(passengers,transport){var temp=transport.passengers[0];var newPassengers=typeof temp==='function'?temp(slotProps):transport.passengers;return passengers.concat(newPassengers);},[]);}function stableSort(array,compareFn){return array.map(function(v,idx){return[idx,v];}).sort(function(a,b){return compareFn(a[1],b[1])||a[0]-b[0];}).map(function(c){return c[1];});}function pick(obj,keys){return keys.reduce(function(acc,key){if(obj.hasOwnProperty(key)){acc[key]=obj[key];}return acc;},{});}var transports={};var targets={};var sources={};var Wormhole=Vue__default['default'].extend({data:function data(){return{transports:transports,targets:targets,sources:sources,trackInstances:inBrowser};},methods:{open:function open(transport){if(!inBrowser)return;var to=transport.to,from=transport.from,passengers=transport.passengers,_transport$order=transport.order,order=_transport$order===void 0?Infinity:_transport$order;if(!to||!from||!passengers)return;var newTransport={to:to,from:from,passengers:freeze(passengers),order:order};var keys=Object.keys(this.transports);if(keys.indexOf(to)===-1){Vue__default['default'].set(this.transports,to,[]);}var currentIndex=this.$_getTransportIndex(newTransport);// Copying the array here so that the PortalTarget change event will actually contain two distinct arrays\nvar newTransports=this.transports[to].slice(0);if(currentIndex===-1){newTransports.push(newTransport);}else{newTransports[currentIndex]=newTransport;}this.transports[to]=stableSort(newTransports,function(a,b){return a.order-b.order;});},close:function close(transport){var force=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var to=transport.to,from=transport.from;if(!to||!from&&force===false)return;if(!this.transports[to]){return;}if(force){this.transports[to]=[];}else{var index=this.$_getTransportIndex(transport);if(index>=0){// Copying the array here so that the PortalTarget change event will actually contain two distinct arrays\nvar newTransports=this.transports[to].slice(0);newTransports.splice(index,1);this.transports[to]=newTransports;}}},registerTarget:function registerTarget(target,vm,force){if(!inBrowser)return;if(this.trackInstances&&!force&&this.targets[target]){console.warn(\"[portal-vue]: Target \".concat(target,\" already exists\"));}this.$set(this.targets,target,Object.freeze([vm]));},unregisterTarget:function unregisterTarget(target){this.$delete(this.targets,target);},registerSource:function registerSource(source,vm,force){if(!inBrowser)return;if(this.trackInstances&&!force&&this.sources[source]){console.warn(\"[portal-vue]: source \".concat(source,\" already exists\"));}this.$set(this.sources,source,Object.freeze([vm]));},unregisterSource:function unregisterSource(source){this.$delete(this.sources,source);},hasTarget:function hasTarget(to){return!!(this.targets[to]&&this.targets[to][0]);},hasSource:function hasSource(to){return!!(this.sources[to]&&this.sources[to][0]);},hasContentFor:function hasContentFor(to){return!!this.transports[to]&&!!this.transports[to].length;},// Internal\n$_getTransportIndex:function $_getTransportIndex(_ref){var to=_ref.to,from=_ref.from;for(var i in this.transports[to]){if(this.transports[to][i].from===from){return+i;}}return-1;}}});var wormhole=new Wormhole(transports);var _id=1;var Portal=Vue__default['default'].extend({name:'portal',props:{disabled:{type:Boolean},name:{type:String,default:function _default(){return String(_id++);}},order:{type:Number,default:0},slim:{type:Boolean},slotProps:{type:Object,default:function _default(){return{};}},tag:{type:String,default:'DIV'},to:{type:String,default:function _default(){return String(Math.round(Math.random()*10000000));}}},created:function created(){var _this=this;this.$nextTick(function(){wormhole.registerSource(_this.name,_this);});},mounted:function mounted(){if(!this.disabled){this.sendUpdate();}},updated:function updated(){if(this.disabled){this.clear();}else{this.sendUpdate();}},beforeDestroy:function beforeDestroy(){wormhole.unregisterSource(this.name);this.clear();},watch:{to:function to(newValue,oldValue){oldValue&&oldValue!==newValue&&this.clear(oldValue);this.sendUpdate();}},methods:{clear:function clear(target){var closer={from:this.name,to:target||this.to};wormhole.close(closer);},normalizeSlots:function normalizeSlots(){return this.$scopedSlots.default?[this.$scopedSlots.default]:this.$slots.default;},normalizeOwnChildren:function normalizeOwnChildren(children){return typeof children==='function'?children(this.slotProps):children;},sendUpdate:function sendUpdate(){var slotContent=this.normalizeSlots();if(slotContent){var transport={from:this.name,to:this.to,passengers:_toConsumableArray(slotContent),order:this.order};wormhole.open(transport);}else{this.clear();}}},render:function render(h){var children=this.$slots.default||this.$scopedSlots.default||[];var Tag=this.tag;if(children&&this.disabled){return children.length<=1&&this.slim?this.normalizeOwnChildren(children)[0]:h(Tag,[this.normalizeOwnChildren(children)]);}else{return this.slim?h():h(Tag,{class:{'v-portal':true},style:{display:'none'},key:'v-portal-placeholder'});}}});var PortalTarget=Vue__default['default'].extend({name:'portalTarget',props:{multiple:{type:Boolean,default:false},name:{type:String,required:true},slim:{type:Boolean,default:false},slotProps:{type:Object,default:function _default(){return{};}},tag:{type:String,default:'div'},transition:{type:[String,Object,Function]}},data:function data(){return{transports:wormhole.transports,firstRender:true};},created:function created(){var _this=this;this.$nextTick(function(){wormhole.registerTarget(_this.name,_this);});},watch:{ownTransports:function ownTransports(){this.$emit('change',this.children().length>0);},name:function name(newVal,oldVal){/**\r\n         * TODO\r\n         * This should warn as well ...\r\n         */wormhole.unregisterTarget(oldVal);wormhole.registerTarget(newVal,this);}},mounted:function mounted(){var _this2=this;if(this.transition){this.$nextTick(function(){// only when we have a transition, because it causes a re-render\n_this2.firstRender=false;});}},beforeDestroy:function beforeDestroy(){wormhole.unregisterTarget(this.name);},computed:{ownTransports:function ownTransports(){var transports=this.transports[this.name]||[];if(this.multiple){return transports;}return transports.length===0?[]:[transports[transports.length-1]];},passengers:function passengers(){return combinePassengers(this.ownTransports,this.slotProps);}},methods:{// can't be a computed prop because it has to \"react\" to $slot changes.\nchildren:function children(){return this.passengers.length!==0?this.passengers:this.$scopedSlots.default?this.$scopedSlots.default(this.slotProps):this.$slots.default||[];},// can't be a computed prop because it has to \"react\" to this.children().\nnoWrapper:function noWrapper(){var noWrapper=this.slim&&!this.transition;if(noWrapper&&this.children().length>1){console.warn('[portal-vue]: PortalTarget with `slim` option received more than one child element.');}return noWrapper;}},render:function render(h){var noWrapper=this.noWrapper();var children=this.children();var Tag=this.transition||this.tag;return noWrapper?children[0]:this.slim&&!Tag?h():h(Tag,{props:{// if we have a transition component, pass the tag if it exists\ntag:this.transition&&this.tag?this.tag:undefined},class:{'vue-portal-target':true}},children);}});var _id$1=0;var portalProps=['disabled','name','order','slim','slotProps','tag','to'];var targetProps=['multiple','transition'];Vue__default['default'].extend({name:'MountingPortal',inheritAttrs:false,props:{append:{type:[Boolean,String]},bail:{type:Boolean},mountTo:{type:String,required:true},// Portal\ndisabled:{type:Boolean},// name for the portal\nname:{type:String,default:function _default(){return'mounted_'+String(_id$1++);}},order:{type:Number,default:0},slim:{type:Boolean},slotProps:{type:Object,default:function _default(){return{};}},tag:{type:String,default:'DIV'},// name for the target\nto:{type:String,default:function _default(){return String(Math.round(Math.random()*10000000));}},// Target\nmultiple:{type:Boolean,default:false},targetSlim:{type:Boolean},targetSlotProps:{type:Object,default:function _default(){return{};}},targetTag:{type:String,default:'div'},transition:{type:[String,Object,Function]}},created:function created(){if(typeof document==='undefined')return;var el=document.querySelector(this.mountTo);if(!el){console.error(\"[portal-vue]: Mount Point '\".concat(this.mountTo,\"' not found in document\"));return;}var props=this.$props;// Target already exists\nif(wormhole.targets[props.name]){if(props.bail){console.warn(\"[portal-vue]: Target \".concat(props.name,\" is already mounted.\\n        Aborting because 'bail: true' is set\"));}else{this.portalTarget=wormhole.targets[props.name];}return;}var append=props.append;if(append){var type=typeof append==='string'?append:'DIV';var mountEl=document.createElement(type);el.appendChild(mountEl);el=mountEl;}// get props for target from $props\n// we have to rename a few of them\nvar _props=pick(this.$props,targetProps);_props.slim=this.targetSlim;_props.tag=this.targetTag;_props.slotProps=this.targetSlotProps;_props.name=this.to;this.portalTarget=new PortalTarget({el:el,parent:this.$parent||this,propsData:_props});},beforeDestroy:function beforeDestroy(){var target=this.portalTarget;if(this.append){var el=target.$el;el.parentNode.removeChild(el);}target.$destroy();},render:function render(h){if(!this.portalTarget){console.warn(\"[portal-vue] Target wasn't mounted\");return h();}// if there's no \"manual\" scoped slot, so we create a <Portal> ourselves\nif(!this.$scopedSlots.manual){var props=pick(this.$props,portalProps);return h(Portal,{props:props,attrs:this.$attrs,on:this.$listeners,scopedSlots:this.$scopedSlots},this.$slots.default);}// else, we render the scoped slot\nvar content=this.$scopedSlots.manual({to:this.to});// if user used <template> for the scoped slot\n// content will be an array\nif(Array.isArray(content)){content=content[0];}if(!content)return h();return content;}});// @vue/component\nvar DefaultTransition=/*#__PURE__*/Vue__default['default'].extend({mixins:[normalizeSlotMixin],data:function data(){return{// Transition classes base name\nname:'b-toaster'};},methods:{onAfterEnter:function onAfterEnter(el){var _this=this;// Work around a Vue.js bug where `*-enter-to` class is not removed\n// See: https://github.com/vuejs/vue/pull/7901\n// The `*-move` class is also stuck on elements that moved,\n// but there are no JavaScript hooks to handle after move\n// See: https://github.com/vuejs/vue/pull/7906\nrequestAF(function(){removeClass(el,\"\".concat(_this.name,\"-enter-to\"));});}},render:function render(h){return h('transition-group',{props:{tag:'div',name:this.name},on:{afterEnter:this.onAfterEnter}},this.normalizeSlot());}});// --- Props ---\nvar props$1=makePropsConfigurable({// Allowed: 'true' or 'false' or `null`\nariaAtomic:makeProp(PROP_TYPE_STRING),ariaLive:makeProp(PROP_TYPE_STRING),name:makeProp(PROP_TYPE_STRING,undefined,true),// Required\n// Aria role\nrole:makeProp(PROP_TYPE_STRING)},NAME_TOASTER);// --- Main component ---\n// @vue/component\nvar BToaster=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TOASTER,mixins:[listenOnRootMixin],props:props$1,data:function data(){return{// We don't render on SSR or if a an existing target found\ndoRender:false,dead:false,// Toaster names cannot change once created\nstaticName:this.name};},beforeMount:function beforeMount(){var name=this.name;this.staticName=name;/* istanbul ignore if */if(wormhole.hasTarget(name)){warn(\"A \\\"<portal-target>\\\" with name \\\"\".concat(name,\"\\\" already exists in the document.\"),NAME_TOASTER);this.dead=true;}else{this.doRender=true;}},beforeDestroy:function beforeDestroy(){// Let toasts made with `this.$bvToast.toast()` know that this toaster\n// is being destroyed and should should also destroy/hide themselves\nif(this.doRender){this.emitOnRoot(getRootEventName(NAME_TOASTER,EVENT_NAME_DESTROYED),this.name);}},destroyed:function destroyed(){// Remove from DOM if needed\nvar $el=this.$el;/* istanbul ignore next: difficult to test */if($el&&$el.parentNode){$el.parentNode.removeChild($el);}},render:function render(h){var $toaster=h('div',{class:['d-none',{'b-dead-toaster':this.dead}]});if(this.doRender){var $target=h(PortalTarget,{staticClass:'b-toaster-slot',props:{name:this.staticName,multiple:true,tag:'div',slim:false,// transition: this.transition || DefaultTransition\ntransition:DefaultTransition}});$toaster=h('div',{staticClass:'b-toaster',class:[this.staticName],attrs:{id:this.staticName,// Fallback to null to make sure attribute doesn't exist\nrole:this.role||null,'aria-live':this.ariaLive,'aria-atomic':this.ariaAtomic}},[$target]);}return $toaster;}});var _watch;var _makeModelMixin=makeModelMixin('visible',{type:PROP_TYPE_BOOLEAN,defaultValue:false,event:EVENT_NAME_CHANGE}),modelMixin=_makeModelMixin.mixin,modelProps=_makeModelMixin.props,MODEL_PROP_NAME=_makeModelMixin.prop,MODEL_EVENT_NAME=_makeModelMixin.event;var MIN_DURATION=1000;// --- Props ---\nvar linkProps=pick$1(props$2f,['href','to']);var props=makePropsConfigurable(sortKeys(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},props$25),modelProps),linkProps),{},{appendToast:makeProp(PROP_TYPE_BOOLEAN,false),autoHideDelay:makeProp(PROP_TYPE_NUMBER_STRING,5000),bodyClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),headerClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),headerTag:makeProp(PROP_TYPE_STRING,'header'),// Switches role to 'status' and aria-live to 'polite'\nisStatus:makeProp(PROP_TYPE_BOOLEAN,false),noAutoHide:makeProp(PROP_TYPE_BOOLEAN,false),noCloseButton:makeProp(PROP_TYPE_BOOLEAN,false),noFade:makeProp(PROP_TYPE_BOOLEAN,false),noHoverPause:makeProp(PROP_TYPE_BOOLEAN,false),solid:makeProp(PROP_TYPE_BOOLEAN,false),// Render the toast in place, rather than in a portal-target\nstatic:makeProp(PROP_TYPE_BOOLEAN,false),title:makeProp(PROP_TYPE_STRING),toastClass:makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),toaster:makeProp(PROP_TYPE_STRING,'b-toaster-top-right'),variant:makeProp(PROP_TYPE_STRING)})),NAME_TOAST);// --- Main component ---\n// @vue/component\nvar BToast=/*#__PURE__*/Vue__default['default'].extend({name:NAME_TOAST,mixins:[attrsMixin,idMixin,modelMixin,listenOnRootMixin,normalizeSlotMixin,scopedStyleMixin],inheritAttrs:false,props:props,data:function data(){return{isMounted:false,doRender:false,localShow:false,isTransitioning:false,isHiding:false,order:0,dismissStarted:0,resumeDismiss:0};},computed:{toastClasses:function toastClasses(){var appendToast=this.appendToast,variant=this.variant;return _defineProperty({'b-toast-solid':this.solid,'b-toast-append':appendToast,'b-toast-prepend':!appendToast},\"b-toast-\".concat(variant),variant);},slotScope:function slotScope(){var hide=this.hide;return{hide:hide};},computedDuration:function computedDuration(){// Minimum supported duration is 1 second\nreturn mathMax(toInteger(this.autoHideDelay,0),MIN_DURATION);},computedToaster:function computedToaster(){return String(this.toaster);},transitionHandlers:function transitionHandlers(){return{beforeEnter:this.onBeforeEnter,afterEnter:this.onAfterEnter,beforeLeave:this.onBeforeLeave,afterLeave:this.onAfterLeave};},computedAttrs:function computedAttrs(){return _objectSpread2$3(_objectSpread2$3({},this.bvAttrs),{},{id:this.safeId(),tabindex:'0'});}},watch:(_watch={},_defineProperty(_watch,MODEL_PROP_NAME,function(newValue){this[newValue?'show':'hide']();}),_defineProperty(_watch,\"localShow\",function localShow(newValue){if(newValue!==this[MODEL_PROP_NAME]){this.$emit(MODEL_EVENT_NAME,newValue);}}),_defineProperty(_watch,\"toaster\",function toaster(){// If toaster target changed, make sure toaster exists\nthis.$nextTick(this.ensureToaster);}),_defineProperty(_watch,\"static\",function _static(newValue){// If static changes to true, and the toast is showing,\n// ensure the toaster target exists\nif(newValue&&this.localShow){this.ensureToaster();}}),_watch),created:function created(){// Create private non-reactive props\nthis.$_dismissTimer=null;},mounted:function mounted(){var _this=this;this.isMounted=true;this.$nextTick(function(){if(_this[MODEL_PROP_NAME]){requestAF(function(){_this.show();});}});// Listen for global $root show events\nthis.listenOnRoot(getRootActionEventName(NAME_TOAST,EVENT_NAME_SHOW),function(id){if(id===_this.safeId()){_this.show();}});// Listen for global $root hide events\nthis.listenOnRoot(getRootActionEventName(NAME_TOAST,EVENT_NAME_HIDE),function(id){if(!id||id===_this.safeId()){_this.hide();}});// Make sure we hide when toaster is destroyed\n/* istanbul ignore next: difficult to test */this.listenOnRoot(getRootEventName(NAME_TOASTER,EVENT_NAME_DESTROYED),function(toaster){/* istanbul ignore next */if(toaster===_this.computedToaster){_this.hide();}});},beforeDestroy:function beforeDestroy(){this.clearDismissTimer();},methods:{show:function show(){var _this2=this;if(!this.localShow){this.ensureToaster();var showEvent=this.buildEvent(EVENT_NAME_SHOW);this.emitEvent(showEvent);this.dismissStarted=this.resumeDismiss=0;this.order=Date.now()*(this.appendToast?1:-1);this.isHiding=false;this.doRender=true;this.$nextTick(function(){// We show the toast after we have rendered the portal and b-toast wrapper\n// so that screen readers will properly announce the toast\nrequestAF(function(){_this2.localShow=true;});});}},hide:function hide(){var _this3=this;if(this.localShow){var hideEvent=this.buildEvent(EVENT_NAME_HIDE);this.emitEvent(hideEvent);this.setHoverHandler(false);this.dismissStarted=this.resumeDismiss=0;this.clearDismissTimer();this.isHiding=true;requestAF(function(){_this3.localShow=false;});}},buildEvent:function buildEvent(type){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return new BvEvent(type,_objectSpread2$3(_objectSpread2$3({cancelable:false,target:this.$el||null,relatedTarget:null},options),{},{vueTarget:this,componentId:this.safeId()}));},emitEvent:function emitEvent(bvEvent){var type=bvEvent.type;this.emitOnRoot(getRootEventName(NAME_TOAST,type),bvEvent);this.$emit(type,bvEvent);},ensureToaster:function ensureToaster(){if(this.static){return;}var computedToaster=this.computedToaster;if(!wormhole.hasTarget(computedToaster)){var div=document.createElement('div');document.body.appendChild(div);var toaster=new BToaster({parent:this.$root,propsData:{name:computedToaster}});toaster.$mount(div);}},startDismissTimer:function startDismissTimer(){this.clearDismissTimer();if(!this.noAutoHide){this.$_dismissTimer=setTimeout(this.hide,this.resumeDismiss||this.computedDuration);this.dismissStarted=Date.now();this.resumeDismiss=0;}},clearDismissTimer:function clearDismissTimer(){clearTimeout(this.$_dismissTimer);this.$_dismissTimer=null;},setHoverHandler:function setHoverHandler(on){var el=this.$refs['b-toast'];eventOnOff(on,el,'mouseenter',this.onPause,EVENT_OPTIONS_NO_CAPTURE);eventOnOff(on,el,'mouseleave',this.onUnPause,EVENT_OPTIONS_NO_CAPTURE);},onPause:function onPause(){// Determine time remaining, and then pause timer\nif(this.noAutoHide||this.noHoverPause||!this.$_dismissTimer||this.resumeDismiss){return;}var passed=Date.now()-this.dismissStarted;if(passed>0){this.clearDismissTimer();this.resumeDismiss=mathMax(this.computedDuration-passed,MIN_DURATION);}},onUnPause:function onUnPause(){// Restart timer with max of time remaining or 1 second\nif(this.noAutoHide||this.noHoverPause||!this.resumeDismiss){this.resumeDismiss=this.dismissStarted=0;return;}this.startDismissTimer();},onLinkClick:function onLinkClick(){var _this4=this;// We delay the close to allow time for the\n// browser to process the link click\nthis.$nextTick(function(){requestAF(function(){_this4.hide();});});},onBeforeEnter:function onBeforeEnter(){this.isTransitioning=true;},onAfterEnter:function onAfterEnter(){this.isTransitioning=false;var hiddenEvent=this.buildEvent(EVENT_NAME_SHOWN);this.emitEvent(hiddenEvent);this.startDismissTimer();this.setHoverHandler(true);},onBeforeLeave:function onBeforeLeave(){this.isTransitioning=true;},onAfterLeave:function onAfterLeave(){this.isTransitioning=false;this.order=0;this.resumeDismiss=this.dismissStarted=0;var hiddenEvent=this.buildEvent(EVENT_NAME_HIDDEN);this.emitEvent(hiddenEvent);this.doRender=false;},// Render helper for generating the toast\nmakeToast:function makeToast(h){var _this5=this;var title=this.title,slotScope=this.slotScope;var link=isLink$1(this);var $headerContent=[];var $title=this.normalizeSlot(SLOT_NAME_TOAST_TITLE,slotScope);if($title){$headerContent.push($title);}else if(title){$headerContent.push(h('strong',{staticClass:'mr-2'},title));}if(!this.noCloseButton){$headerContent.push(h(BButtonClose,{staticClass:'ml-auto mb-1',on:{click:function click(){_this5.hide();}}}));}var $header=h();if($headerContent.length>0){$header=h(this.headerTag,{staticClass:'toast-header',class:this.headerClass},$headerContent);}var $body=h(link?BLink:'div',{staticClass:'toast-body',class:this.bodyClass,props:link?pluckProps(linkProps,this):{},on:link?{click:this.onLinkClick}:{}},this.normalizeSlot(SLOT_NAME_DEFAULT,slotScope));return h('div',{staticClass:'toast',class:this.toastClass,attrs:this.computedAttrs,key:\"toast-\".concat(this[COMPONENT_UID_KEY]),ref:'toast'},[$header,$body]);}},render:function render(h){if(!this.doRender||!this.isMounted){return h();}var order=this.order,isStatic=this.static,isHiding=this.isHiding,isStatus=this.isStatus;var name=\"b-toast-\".concat(this[COMPONENT_UID_KEY]);var $toast=h('div',{staticClass:'b-toast',class:this.toastClasses,attrs:_objectSpread2$3(_objectSpread2$3({},isStatic?{}:this.scopedStyleAttrs),{},{id:this.safeId('_toast_outer'),role:isHiding?null:isStatus?'status':'alert','aria-live':isHiding?null:isStatus?'polite':'assertive','aria-atomic':isHiding?null:'true'}),key:name,ref:'b-toast'},[h(BVTransition,{props:{noFade:this.noFade},on:this.transitionHandlers},[this.localShow?this.makeToast(h):h()])]);return h(Portal,{props:{name:name,to:this.computedToaster,order:order,slim:true,disabled:isStatic}},[$toast]);}});var PROP_NAME='$bvToast';var PROP_NAME_PRIV='_bv__toast';// Base toast props that are allowed\n// Some may be ignored or overridden on some message boxes\n// Prop ID is allowed, but really only should be used for testing\n// We need to add it in explicitly as it comes from the `idMixin`\nvar BASE_PROPS=['id'].concat(_toConsumableArray$1(keys(omit(props,['static','visible']))));// Map prop names to toast slot names\nvar propsToSlots={toastContent:'default',title:'toast-title'};// --- Helper methods ---\n// Method to filter only recognized props that are not undefined\nvar filterOptions=function filterOptions(options){return BASE_PROPS.reduce(function(memo,key){if(!isUndefined(options[key])){memo[key]=options[key];}return memo;},{});};// Method to install `$bvToast` VM injection\nvar plugin=function plugin(Vue){// Create a private sub-component constructor that\n// extends BToast and self-destructs after hidden\n// @vue/component\nvar BVToastPop=Vue.extend({name:NAME_TOAST_POP,extends:BToast,destroyed:function destroyed(){// Make sure we not in document any more\nvar $el=this.$el;if($el&&$el.parentNode){$el.parentNode.removeChild($el);}},mounted:function mounted(){var _this=this;// Self destruct handler\nvar handleDestroy=function handleDestroy(){// Ensure the toast has been force hidden\n_this.localShow=false;_this.doRender=false;_this.$nextTick(function(){_this.$nextTick(function(){// In a `requestAF()` to release control back to application\n// and to allow the portal-target time to remove the content\nrequestAF(function(){_this.$destroy();});});});};// Self destruct if parent destroyed\nthis.$parent.$once(HOOK_EVENT_NAME_DESTROYED,handleDestroy);// Self destruct after hidden\nthis.$once(EVENT_NAME_HIDDEN,handleDestroy);// Self destruct when toaster is destroyed\nthis.listenOnRoot(getRootEventName(NAME_TOASTER,EVENT_NAME_DESTROYED),function(toaster){/* istanbul ignore next: hard to test */if(toaster===_this.toaster){handleDestroy();}});}});// Private method to generate the on-demand toast\nvar makeToast=function makeToast(props,$parent){if(warnNotClient(PROP_NAME)){/* istanbul ignore next */return;}// Create an instance of `BVToastPop` component\nvar toast=new BVToastPop({// We set parent as the local VM so these toasts can emit events on the\n// app `$root`, and it ensures `BToast` is destroyed when parent is destroyed\nparent:$parent,propsData:_objectSpread2$3(_objectSpread2$3(_objectSpread2$3({},filterOptions(getComponentConfig(NAME_TOAST))),omit(props,keys(propsToSlots))),{},{// Props that can't be overridden\nstatic:false,visible:true})});// Convert certain props to slots\nkeys(propsToSlots).forEach(function(prop){var value=props[prop];if(!isUndefined(value)){// Can be a string, or array of VNodes\nif(prop==='title'&&isString(value)){// Special case for title if it is a string, we wrap in a <strong>\nvalue=[$parent.$createElement('strong',{class:'mr-2'},value)];}toast.$slots[propsToSlots[prop]]=concat(value);}});// Create a mount point (a DIV) and mount it (which triggers the show)\nvar div=document.createElement('div');document.body.appendChild(div);toast.$mount(div);};// Declare BvToast instance property class\nvar BvToast=/*#__PURE__*/function(){function BvToast(vm){_classCallCheck(this,BvToast);// Assign the new properties to this instance\nassign(this,{_vm:vm,_root:vm.$root});// Set these properties as read-only and non-enumerable\ndefineProperties(this,{_vm:readonlyDescriptor(),_root:readonlyDescriptor()});}// --- Public Instance methods ---\n// Opens a user defined toast and returns immediately\n_createClass(BvToast,[{key:\"toast\",value:function toast(content){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(!content||warnNotClient(PROP_NAME)){/* istanbul ignore next */return;}makeToast(_objectSpread2$3(_objectSpread2$3({},filterOptions(options)),{},{toastContent:content}),this._vm);}// shows a `<b-toast>` component with the specified ID\n},{key:\"show\",value:function show(id){if(id){this._root.$emit(getRootActionEventName(NAME_TOAST,EVENT_NAME_SHOW),id);}}// Hide a toast with specified ID, or if not ID all toasts\n},{key:\"hide\",value:function hide(){var id=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;this._root.$emit(getRootActionEventName(NAME_TOAST,EVENT_NAME_HIDE),id);}}]);return BvToast;}();// Add our instance mixin\nVue.mixin({beforeCreate:function beforeCreate(){// Because we need access to `$root` for `$emits`, and VM for parenting,\n// we have to create a fresh instance of `BvToast` for each VM\nthis[PROP_NAME_PRIV]=new BvToast(this);}});// Define our read-only `$bvToast` instance property\n// Placed in an if just in case in HMR mode\nif(!hasOwnProperty(Vue.prototype,PROP_NAME)){defineProperty$1(Vue.prototype,PROP_NAME,{get:function get(){/* istanbul ignore next */if(!this||!this[PROP_NAME_PRIV]){warn(\"\\\"\".concat(PROP_NAME,\"\\\" must be accessed from a Vue instance \\\"this\\\" context.\"),NAME_TOAST);}return this[PROP_NAME_PRIV];}});}};var BVToastPlugin=/*#__PURE__*/pluginFactory({plugins:{plugin:plugin}});var ToastPlugin=/*#__PURE__*/pluginFactory({components:{BToast:BToast,BToaster:BToaster},// $bvToast injection\nplugins:{BVToastPlugin:BVToastPlugin}});var BV_TOOLTIP='__BV_Tooltip__';// Default trigger\nvar DefaultTrigger='hover focus';// Valid event triggers\nvar validTriggers={focus:true,hover:true,click:true,blur:true,manual:true};// Directive modifier test regular expressions. Pre-compile for performance\nvar htmlRE=/^html$/i;var noninteractiveRE=/^noninteractive$/i;var noFadeRE=/^nofade$/i;var placementRE=/^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/i;var boundaryRE=/^(window|viewport|scrollParent)$/i;var delayRE=/^d\\d+$/i;var delayShowRE=/^ds\\d+$/i;var delayHideRE=/^dh\\d+$/i;var offsetRE$1=/^o-?\\d+$/i;var variantRE=/^v-.+$/i;var spacesRE=/\\s+/;// Build a Tooltip config based on bindings (if any)\n// Arguments and modifiers take precedence over passed value config object\nvar parseBindings$1=function parseBindings(bindings,vnode)/* istanbul ignore next: not easy to test */{// We start out with a basic config\nvar config={title:undefined,trigger:'',// Default set below if needed\nplacement:'top',fallbackPlacement:'flip',container:false,// Default of body\nanimation:true,offset:0,id:null,html:false,interactive:true,disabled:false,delay:getComponentConfig(NAME_TOOLTIP,'delay',50),boundary:String(getComponentConfig(NAME_TOOLTIP,'boundary','scrollParent')),boundaryPadding:toInteger(getComponentConfig(NAME_TOOLTIP,'boundaryPadding',5),0),variant:getComponentConfig(NAME_TOOLTIP,'variant'),customClass:getComponentConfig(NAME_TOOLTIP,'customClass')};// Process `bindings.value`\nif(isString(bindings.value)||isNumber(bindings.value)){// Value is tooltip content (HTML optionally supported)\nconfig.title=bindings.value;}else if(isFunction$1(bindings.value)){// Title generator function\nconfig.title=bindings.value;}else if(isPlainObject(bindings.value)){// Value is config object, so merge\nconfig=_objectSpread2$3(_objectSpread2$3({},config),bindings.value);}// If title is not provided, try title attribute\nif(isUndefined(config.title)){// Try attribute\nvar data=vnode.data||{};config.title=data.attrs&&!isUndefinedOrNull(data.attrs.title)?data.attrs.title:undefined;}// Normalize delay\nif(!isPlainObject(config.delay)){config.delay={show:toInteger(config.delay,0),hide:toInteger(config.delay,0)};}// If argument, assume element ID of container element\nif(bindings.arg){// Element ID specified as arg\n// We must prepend '#' to become a CSS selector\nconfig.container=\"#\".concat(bindings.arg);}// Process modifiers\nkeys(bindings.modifiers).forEach(function(mod){if(htmlRE.test(mod)){// Title allows HTML\nconfig.html=true;}else if(noninteractiveRE.test(mod)){// Noninteractive\nconfig.interactive=false;}else if(noFadeRE.test(mod)){// No animation\nconfig.animation=false;}else if(placementRE.test(mod)){// Placement of tooltip\nconfig.placement=mod;}else if(boundaryRE.test(mod)){// Boundary of tooltip\nmod=mod==='scrollparent'?'scrollParent':mod;config.boundary=mod;}else if(delayRE.test(mod)){// Delay value\nvar delay=toInteger(mod.slice(1),0);config.delay.show=delay;config.delay.hide=delay;}else if(delayShowRE.test(mod)){// Delay show value\nconfig.delay.show=toInteger(mod.slice(2),0);}else if(delayHideRE.test(mod)){// Delay hide value\nconfig.delay.hide=toInteger(mod.slice(2),0);}else if(offsetRE$1.test(mod)){// Offset value, negative allowed\nconfig.offset=toInteger(mod.slice(1),0);}else if(variantRE.test(mod)){// Variant\nconfig.variant=mod.slice(2)||null;}});// Special handling of event trigger modifiers trigger is\n// a space separated list\nvar selectedTriggers={};// Parse current config object trigger\nconcat(config.trigger||'').filter(identity).join(' ').trim().toLowerCase().split(spacesRE).forEach(function(trigger){if(validTriggers[trigger]){selectedTriggers[trigger]=true;}});// Parse modifiers for triggers\nkeys(bindings.modifiers).forEach(function(mod){mod=mod.toLowerCase();if(validTriggers[mod]){// If modifier is a valid trigger\nselectedTriggers[mod]=true;}});// Sanitize triggers\nconfig.trigger=keys(selectedTriggers).join(' ');if(config.trigger==='blur'){// Blur by itself is useless, so convert it to 'focus'\nconfig.trigger='focus';}if(!config.trigger){// Use default trigger\nconfig.trigger=DefaultTrigger;}// Return the config\nreturn config;};// Add/update Tooltip on our element\nvar applyTooltip=function applyTooltip(el,bindings,vnode){if(!IS_BROWSER){/* istanbul ignore next */return;}var config=parseBindings$1(bindings,vnode);if(!el[BV_TOOLTIP]){var $parent=vnode.context;el[BV_TOOLTIP]=new BVTooltip({parent:$parent,// Add the parent's scoped style attribute data\n_scopeId:getScopeId($parent,undefined)});el[BV_TOOLTIP].__bv_prev_data__={};el[BV_TOOLTIP].$on(EVENT_NAME_SHOW,function()/* istanbul ignore next: for now */{// Before showing the tooltip, we update the title if it is a function\nif(isFunction$1(config.title)){el[BV_TOOLTIP].updateData({title:config.title(el)});}});}var data={title:config.title,triggers:config.trigger,placement:config.placement,fallbackPlacement:config.fallbackPlacement,variant:config.variant,customClass:config.customClass,container:config.container,boundary:config.boundary,delay:config.delay,offset:config.offset,noFade:!config.animation,id:config.id,interactive:config.interactive,disabled:config.disabled,html:config.html};var oldData=el[BV_TOOLTIP].__bv_prev_data__;el[BV_TOOLTIP].__bv_prev_data__=data;if(!looseEqual(data,oldData)){// We only update the instance if data has changed\nvar newData={target:el};keys(data).forEach(function(prop){// We only pass data properties that have changed\nif(data[prop]!==oldData[prop]){// if title is a function, we execute it here\nnewData[prop]=prop==='title'&&isFunction$1(data[prop])?data[prop](el):data[prop];}});el[BV_TOOLTIP].updateData(newData);}};// Remove Tooltip on our element\nvar removeTooltip=function removeTooltip(el){if(el[BV_TOOLTIP]){el[BV_TOOLTIP].$destroy();el[BV_TOOLTIP]=null;}delete el[BV_TOOLTIP];};// Export our directive\nvar VBTooltip={bind:function bind(el,bindings,vnode){applyTooltip(el,bindings,vnode);},// We use `componentUpdated` here instead of `update`, as the former\n// waits until the containing component and children have finished updating\ncomponentUpdated:function componentUpdated(el,bindings,vnode){// Performed in a `$nextTick()` to prevent render update loops\nvnode.context.$nextTick(function(){applyTooltip(el,bindings,vnode);});},unbind:function unbind(el){removeTooltip(el);}};var VBTooltipPlugin=/*#__PURE__*/pluginFactory({directives:{VBTooltip:VBTooltip}});var TooltipPlugin=/*#__PURE__*/pluginFactory({components:{BTooltip:BTooltip},plugins:{VBTooltipPlugin:VBTooltipPlugin}});var componentsPlugin=/*#__PURE__*/pluginFactory({plugins:{AlertPlugin:AlertPlugin,AspectPlugin:AspectPlugin,AvatarPlugin:AvatarPlugin,BadgePlugin:BadgePlugin,BreadcrumbPlugin:BreadcrumbPlugin,ButtonPlugin:ButtonPlugin,ButtonGroupPlugin:ButtonGroupPlugin,ButtonToolbarPlugin:ButtonToolbarPlugin,CalendarPlugin:CalendarPlugin,CardPlugin:CardPlugin,CarouselPlugin:CarouselPlugin,CollapsePlugin:CollapsePlugin,DropdownPlugin:DropdownPlugin,EmbedPlugin:EmbedPlugin,FormPlugin:FormPlugin,FormCheckboxPlugin:FormCheckboxPlugin,FormDatepickerPlugin:FormDatepickerPlugin,FormFilePlugin:FormFilePlugin,FormGroupPlugin:FormGroupPlugin,FormInputPlugin:FormInputPlugin,FormRadioPlugin:FormRadioPlugin,FormRatingPlugin:FormRatingPlugin,FormSelectPlugin:FormSelectPlugin,FormSpinbuttonPlugin:FormSpinbuttonPlugin,FormTagsPlugin:FormTagsPlugin,FormTextareaPlugin:FormTextareaPlugin,FormTimepickerPlugin:FormTimepickerPlugin,ImagePlugin:ImagePlugin,InputGroupPlugin:InputGroupPlugin,JumbotronPlugin:JumbotronPlugin,LayoutPlugin:LayoutPlugin,LinkPlugin:LinkPlugin,ListGroupPlugin:ListGroupPlugin,MediaPlugin:MediaPlugin,ModalPlugin:ModalPlugin,NavPlugin:NavPlugin,NavbarPlugin:NavbarPlugin,OverlayPlugin:OverlayPlugin,PaginationPlugin:PaginationPlugin,PaginationNavPlugin:PaginationNavPlugin,PopoverPlugin:PopoverPlugin,ProgressPlugin:ProgressPlugin,SidebarPlugin:SidebarPlugin,SkeletonPlugin:SkeletonPlugin,SpinnerPlugin:SpinnerPlugin,TablePlugin:TablePlugin,TabsPlugin:TabsPlugin,TimePlugin:TimePlugin,ToastPlugin:ToastPlugin,TooltipPlugin:TooltipPlugin}});var VBHoverPlugin=/*#__PURE__*/pluginFactory({directives:{VBHover:VBHover}});var VBModalPlugin=/*#__PURE__*/pluginFactory({directives:{VBModal:VBModal}});/*\n   * Constants / Defaults\n   */var NAME$1='v-b-scrollspy';var CLASS_NAME_DROPDOWN_ITEM='dropdown-item';var CLASS_NAME_ACTIVE='active';var SELECTOR_NAV_LIST_GROUP='.nav, .list-group';var SELECTOR_NAV_LINKS='.nav-link';var SELECTOR_NAV_ITEMS='.nav-item';var SELECTOR_LIST_ITEMS='.list-group-item';var SELECTOR_DROPDOWN='.dropdown, .dropup';var SELECTOR_DROPDOWN_ITEMS='.dropdown-item';var SELECTOR_DROPDOWN_TOGGLE='.dropdown-toggle';var ROOT_EVENT_NAME_ACTIVATE=getRootEventName('BVScrollspy','activate');var METHOD_OFFSET='offset';var METHOD_POSITION='position';var Default={element:'body',offset:10,method:'auto',throttle:75};var DefaultType={element:'(string|element|component)',offset:'number',method:'string',throttle:'number'};// Transition Events\nvar TransitionEndEvents=['webkitTransitionEnd','transitionend','otransitionend','oTransitionEnd'];/*\n   * Utility Methods\n   */ // Better var type detection\nvar toType=function toType(obj)/* istanbul ignore next: not easy to test */{return toString$1(obj).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();};// Check config properties for expected types\n/* istanbul ignore next */var typeCheckConfig=function typeCheckConfig(componentName,config,configTypes)/* istanbul ignore next: not easy to test */{for(var property in configTypes){if(hasOwnProperty(configTypes,property)){var expectedTypes=configTypes[property];var value=config[property];var valueType=value&&isElement(value)?'element':toType(value);// handle Vue instances\nvalueType=value&&value._isVue?'component':valueType;if(!new RegExp(expectedTypes).test(valueType)){/* istanbul ignore next */warn(\"\".concat(componentName,\": Option \\\"\").concat(property,\"\\\" provided type \\\"\").concat(valueType,\"\\\" but expected type \\\"\").concat(expectedTypes,\"\\\"\"));}}}};/*\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */ /* istanbul ignore next: not easy to test */var BVScrollspy/* istanbul ignore next: not easy to test */=/*#__PURE__*/function(){function BVScrollspy(element,config,$root){_classCallCheck(this,BVScrollspy);// The element we activate links in\nthis.$el=element;this.$scroller=null;this.$selector=[SELECTOR_NAV_LINKS,SELECTOR_LIST_ITEMS,SELECTOR_DROPDOWN_ITEMS].join(',');this.$offsets=[];this.$targets=[];this.$activeTarget=null;this.$scrollHeight=0;this.$resizeTimeout=null;this.$scrollerObserver=null;this.$targetsObserver=null;this.$root=$root||null;this.$config=null;this.updateConfig(config);}_createClass(BVScrollspy,[{key:\"updateConfig\",value:function updateConfig(config,$root){if(this.$scroller){// Just in case out scroll element has changed\nthis.unlisten();this.$scroller=null;}var cfg=_objectSpread2$3(_objectSpread2$3({},this.constructor.Default),config);if($root){this.$root=$root;}typeCheckConfig(this.constructor.Name,cfg,this.constructor.DefaultType);this.$config=cfg;if(this.$root){var self=this;this.$root.$nextTick(function(){self.listen();});}else{this.listen();}}},{key:\"dispose\",value:function dispose(){this.unlisten();clearTimeout(this.$resizeTimeout);this.$resizeTimeout=null;this.$el=null;this.$config=null;this.$scroller=null;this.$selector=null;this.$offsets=null;this.$targets=null;this.$activeTarget=null;this.$scrollHeight=null;}},{key:\"listen\",value:function listen(){var _this=this;var scroller=this.getScroller();if(scroller&&scroller.tagName!=='BODY'){eventOn(scroller,'scroll',this,EVENT_OPTIONS_NO_CAPTURE);}eventOn(window,'scroll',this,EVENT_OPTIONS_NO_CAPTURE);eventOn(window,'resize',this,EVENT_OPTIONS_NO_CAPTURE);eventOn(window,'orientationchange',this,EVENT_OPTIONS_NO_CAPTURE);TransitionEndEvents.forEach(function(eventName){eventOn(window,eventName,_this,EVENT_OPTIONS_NO_CAPTURE);});this.setObservers(true);// Schedule a refresh\nthis.handleEvent('refresh');}},{key:\"unlisten\",value:function unlisten(){var _this2=this;var scroller=this.getScroller();this.setObservers(false);if(scroller&&scroller.tagName!=='BODY'){eventOff(scroller,'scroll',this,EVENT_OPTIONS_NO_CAPTURE);}eventOff(window,'scroll',this,EVENT_OPTIONS_NO_CAPTURE);eventOff(window,'resize',this,EVENT_OPTIONS_NO_CAPTURE);eventOff(window,'orientationchange',this,EVENT_OPTIONS_NO_CAPTURE);TransitionEndEvents.forEach(function(eventName){eventOff(window,eventName,_this2,EVENT_OPTIONS_NO_CAPTURE);});}},{key:\"setObservers\",value:function setObservers(on){var _this3=this;// We observe both the scroller for content changes, and the target links\nthis.$scrollerObserver&&this.$scrollerObserver.disconnect();this.$targetsObserver&&this.$targetsObserver.disconnect();this.$scrollerObserver=null;this.$targetsObserver=null;if(on){this.$targetsObserver=observeDom(this.$el,function(){_this3.handleEvent('mutation');},{subtree:true,childList:true,attributes:true,attributeFilter:['href']});this.$scrollerObserver=observeDom(this.getScroller(),function(){_this3.handleEvent('mutation');},{subtree:true,childList:true,characterData:true,attributes:true,attributeFilter:['id','style','class']});}}// General event handler\n},{key:\"handleEvent\",value:function handleEvent(event){var type=isString(event)?event:event.type;var self=this;var resizeThrottle=function resizeThrottle(){if(!self.$resizeTimeout){self.$resizeTimeout=setTimeout(function(){self.refresh();self.process();self.$resizeTimeout=null;},self.$config.throttle);}};if(type==='scroll'){if(!this.$scrollerObserver){// Just in case we are added to the DOM before the scroll target is\n// We re-instantiate our listeners, just in case\nthis.listen();}this.process();}else if(/(resize|orientationchange|mutation|refresh)/.test(type)){// Postpone these events by throttle time\nresizeThrottle();}}// Refresh the list of target links on the element we are applied to\n},{key:\"refresh\",value:function refresh(){var _this4=this;var scroller=this.getScroller();if(!scroller){return;}var autoMethod=scroller!==scroller.window?METHOD_POSITION:METHOD_OFFSET;var method=this.$config.method==='auto'?autoMethod:this.$config.method;var methodFn=method===METHOD_POSITION?position:offset$1;var offsetBase=method===METHOD_POSITION?this.getScrollTop():0;this.$offsets=[];this.$targets=[];this.$scrollHeight=this.getScrollHeight();// Find all the unique link HREFs that we will control\nselectAll(this.$selector,this.$el)// Get HREF value\n.map(function(link){return getAttr(link,'href');})// Filter out HREFs that do not match our RegExp\n.filter(function(href){return href&&RX_HREF.test(href||'');})// Find all elements with ID that match HREF hash\n.map(function(href){// Convert HREF into an ID (including # at beginning)\nvar id=href.replace(RX_HREF,'$1').trim();if(!id){return null;}// Find the element with the ID specified by id\nvar el=select(id,scroller);if(el&&isVisible(el)){return{offset:toInteger(methodFn(el).top,0)+offsetBase,target:id};}return null;}).filter(identity)// Sort them by their offsets (smallest first)\n.sort(function(a,b){return a.offset-b.offset;})// record only unique targets/offsets\n.reduce(function(memo,item){if(!memo[item.target]){_this4.$offsets.push(item.offset);_this4.$targets.push(item.target);memo[item.target]=true;}return memo;},{});// Return this for easy chaining\nreturn this;}// Handle activating/clearing\n},{key:\"process\",value:function process(){var scrollTop=this.getScrollTop()+this.$config.offset;var scrollHeight=this.getScrollHeight();var maxScroll=this.$config.offset+scrollHeight-this.getOffsetHeight();if(this.$scrollHeight!==scrollHeight){this.refresh();}if(scrollTop>=maxScroll){var target=this.$targets[this.$targets.length-1];if(this.$activeTarget!==target){this.activate(target);}return;}if(this.$activeTarget&&scrollTop<this.$offsets[0]&&this.$offsets[0]>0){this.$activeTarget=null;this.clear();return;}for(var i=this.$offsets.length;i--;){var isActiveTarget=this.$activeTarget!==this.$targets[i]&&scrollTop>=this.$offsets[i]&&(isUndefined(this.$offsets[i+1])||scrollTop<this.$offsets[i+1]);if(isActiveTarget){this.activate(this.$targets[i]);}}}},{key:\"getScroller\",value:function getScroller(){if(this.$scroller){return this.$scroller;}var scroller=this.$config.element;if(!scroller){return null;}else if(isElement(scroller.$el)){scroller=scroller.$el;}else if(isString(scroller)){scroller=select(scroller);}if(!scroller){return null;}this.$scroller=scroller.tagName==='BODY'?window:scroller;return this.$scroller;}},{key:\"getScrollTop\",value:function getScrollTop(){var scroller=this.getScroller();return scroller===window?scroller.pageYOffset:scroller.scrollTop;}},{key:\"getScrollHeight\",value:function getScrollHeight(){return this.getScroller().scrollHeight||mathMax(document.body.scrollHeight,document.documentElement.scrollHeight);}},{key:\"getOffsetHeight\",value:function getOffsetHeight(){var scroller=this.getScroller();return scroller===window?window.innerHeight:getBCR(scroller).height;}},{key:\"activate\",value:function activate(target){var _this5=this;this.$activeTarget=target;this.clear();// Grab the list of target links (<a href=\"{$target}\">)\nvar links=selectAll(this.$selector// Split out the base selectors\n.split(',')// Map to a selector that matches links with HREF ending in the ID (including '#')\n.map(function(selector){return\"\".concat(selector,\"[href$=\\\"\").concat(target,\"\\\"]\");})// Join back into a single selector string\n.join(','),this.$el);links.forEach(function(link){if(hasClass(link,CLASS_NAME_DROPDOWN_ITEM)){// This is a dropdown item, so find the .dropdown-toggle and set its state\nvar dropdown=closest(SELECTOR_DROPDOWN,link);if(dropdown){_this5.setActiveState(select(SELECTOR_DROPDOWN_TOGGLE,dropdown),true);}// Also set this link's state\n_this5.setActiveState(link,true);}else{// Set triggered link as active\n_this5.setActiveState(link,true);if(matches(link.parentElement,SELECTOR_NAV_ITEMS)){// Handle nav-link inside nav-item, and set nav-item active\n_this5.setActiveState(link.parentElement,true);}// Set triggered links parents as active\n// With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\nvar el=link;while(el){el=closest(SELECTOR_NAV_LIST_GROUP,el);var sibling=el?el.previousElementSibling:null;if(sibling&&matches(sibling,\"\".concat(SELECTOR_NAV_LINKS,\", \").concat(SELECTOR_LIST_ITEMS))){_this5.setActiveState(sibling,true);}// Handle special case where nav-link is inside a nav-item\nif(sibling&&matches(sibling,SELECTOR_NAV_ITEMS)){_this5.setActiveState(select(SELECTOR_NAV_LINKS,sibling),true);// Add active state to nav-item as well\n_this5.setActiveState(sibling,true);}}}});// Signal event to via $root, passing ID of activated target and reference to array of links\nif(links&&links.length>0&&this.$root){this.$root.$emit(ROOT_EVENT_NAME_ACTIVATE,target,links);}}},{key:\"clear\",value:function clear(){var _this6=this;selectAll(\"\".concat(this.$selector,\", \").concat(SELECTOR_NAV_ITEMS),this.$el).filter(function(el){return hasClass(el,CLASS_NAME_ACTIVE);}).forEach(function(el){return _this6.setActiveState(el,false);});}},{key:\"setActiveState\",value:function setActiveState(el,active){if(!el){return;}if(active){addClass(el,CLASS_NAME_ACTIVE);}else{removeClass(el,CLASS_NAME_ACTIVE);}}}],[{key:\"Name\",get:function get(){return NAME$1;}},{key:\"Default\",get:function get(){return Default;}},{key:\"DefaultType\",get:function get(){return DefaultType;}}]);return BVScrollspy;}();var BV_SCROLLSPY='__BV_Scrollspy__';// Pre-compiled regular expressions\nvar onlyDigitsRE=/^\\d+$/;var offsetRE=/^(auto|position|offset)$/;// Build a Scrollspy config based on bindings (if any)\n// Arguments and modifiers take precedence over passed value config object\n/* istanbul ignore next: not easy to test */var parseBindings=function parseBindings(bindings)/* istanbul ignore next: not easy to test */{var config={};// If argument, assume element ID\nif(bindings.arg){// Element ID specified as arg\n// We must prepend '#' to become a CSS selector\nconfig.element=\"#\".concat(bindings.arg);}// Process modifiers\nkeys(bindings.modifiers).forEach(function(mod){if(onlyDigitsRE.test(mod)){// Offset value\nconfig.offset=toInteger(mod,0);}else if(offsetRE.test(mod)){// Offset method\nconfig.method=mod;}});// Process value\nif(isString(bindings.value)){// Value is a CSS ID or selector\nconfig.element=bindings.value;}else if(isNumber(bindings.value)){// Value is offset\nconfig.offset=mathRound(bindings.value);}else if(isObject(bindings.value)){// Value is config object\n// Filter the object based on our supported config options\nkeys(bindings.value).filter(function(k){return!!BVScrollspy.DefaultType[k];}).forEach(function(k){config[k]=bindings.value[k];});}return config;};// Add or update Scrollspy on our element\nvar applyScrollspy=function applyScrollspy(el,bindings,vnode)/* istanbul ignore next: not easy to test */{if(!IS_BROWSER){/* istanbul ignore next */return;}var config=parseBindings(bindings);if(el[BV_SCROLLSPY]){el[BV_SCROLLSPY].updateConfig(config,vnode.context.$root);}else{el[BV_SCROLLSPY]=new BVScrollspy(el,config,vnode.context.$root);}};// Remove Scrollspy on our element\n/* istanbul ignore next: not easy to test */var removeScrollspy=function removeScrollspy(el)/* istanbul ignore next: not easy to test */{if(el[BV_SCROLLSPY]){el[BV_SCROLLSPY].dispose();el[BV_SCROLLSPY]=null;delete el[BV_SCROLLSPY];}};/*\n   * Export our directive\n   */var VBScrollspy={/* istanbul ignore next: not easy to test */bind:function bind(el,bindings,vnode){applyScrollspy(el,bindings,vnode);},/* istanbul ignore next: not easy to test */inserted:function inserted(el,bindings,vnode){applyScrollspy(el,bindings,vnode);},/* istanbul ignore next: not easy to test */update:function update(el,bindings,vnode){if(bindings.value!==bindings.oldValue){applyScrollspy(el,bindings,vnode);}},/* istanbul ignore next: not easy to test */componentUpdated:function componentUpdated(el,bindings,vnode){if(bindings.value!==bindings.oldValue){applyScrollspy(el,bindings,vnode);}},/* istanbul ignore next: not easy to test */unbind:function unbind(el){removeScrollspy(el);}};var VBScrollspyPlugin=/*#__PURE__*/pluginFactory({directives:{VBScrollspy:VBScrollspy}});var VBVisiblePlugin=/*#__PURE__*/pluginFactory({directives:{VBVisible:VBVisible}});var directivesPlugin=/*#__PURE__*/pluginFactory({plugins:{VBHoverPlugin:VBHoverPlugin,VBModalPlugin:VBModalPlugin,VBPopoverPlugin:VBPopoverPlugin,VBScrollspyPlugin:VBScrollspyPlugin,VBTogglePlugin:VBTogglePlugin,VBTooltipPlugin:VBTooltipPlugin,VBVisiblePlugin:VBVisiblePlugin}});var NAME='BootstrapVue';// --- BootstrapVue installer ---\nvar install=/*#__PURE__*/installFactory({plugins:{componentsPlugin:componentsPlugin,directivesPlugin:directivesPlugin}});// --- BootstrapVue plugin ---\nvar BootstrapVue=/*#__PURE__*/{install:install,NAME:NAME};// --- Named exports for BvConfigPlugin ---\n// Main entry point for the browser build\nvueUse(BootstrapVue);return BootstrapVue;});\n\n//# sourceURL=webpack://kloster/./node_modules/bootstrap-vue/dist/bootstrap-vue.js?")},"./node_modules/vue-element-loading/lib/vue-element-loading.min.js":function(module){eval('/*!\n * vue-element-loading v2.0.2\n * (c) 2019-present biig_pongsatorn <biig_pongsatorn@hotmail.com>\n * Released under the MIT License.\n */\n!function (t, e) {\n   true ? module.exports = e() : 0;\n}(this, function () {\n  "use strict";\n\n  var t = {\n    name: "spinner",\n    props: {\n      color: {\n        type: String,\n        default: "#CCC"\n      },\n      size: {\n        type: String,\n        default: "40px"\n      },\n      duration: {\n        type: String,\n        default: "0.6s"\n      }\n    }\n  };\n\n  function e(t, e, i, a, n, r, s, o, d, l) {\n    "function" == typeof s && (d = o, o = s, s = !1);\n    const u = "function" == typeof i ? i.options : i;\n    let c;\n    if (t && t.render && (u.render = t.render, u.staticRenderFns = t.staticRenderFns, u._compiled = !0, n && (u.functional = !0)), a && (u._scopeId = a), r ? (c = function (t) {\n      (t = t || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) || "undefined" == typeof __VUE_SSR_CONTEXT__ || (t = __VUE_SSR_CONTEXT__), e && e.call(this, d(t)), t && t._registeredComponents && t._registeredComponents.add(r);\n    }, u._ssrRegister = c) : e && (c = s ? function () {\n      e.call(this, l(this.$root.$options.shadowRoot));\n    } : function (t) {\n      e.call(this, o(t));\n    }), c) if (u.functional) {\n      const t = u.render;\n\n      u.render = function (e, i) {\n        return c.call(i), t(e, i);\n      };\n    } else {\n      const t = u.beforeCreate;\n      u.beforeCreate = t ? [].concat(t, c) : [c];\n    }\n    return i;\n  }\n\n  const i = t;\n  t.__file = "spinner.vue";\n  var a = e({\n    render: function () {\n      var t = this.$createElement,\n          e = this._self._c || t;\n      return e("svg", {\n        staticStyle: {\n          "enable-background": "new 0 0 50 50"\n        },\n        attrs: {\n          version: "1.1",\n          id: "loader-1",\n          xmlns: "http://www.w3.org/2000/svg",\n          "xmlns:xlink": "http://www.w3.org/1999/xlink",\n          x: "0px",\n          y: "0px",\n          width: this.size,\n          height: this.size,\n          viewBox: "0 0 50 50",\n          "xml:space": "preserve"\n        }\n      }, [e("path", {\n        attrs: {\n          fill: this.color,\n          d: "M43.935,25.145c0-10.318-8.364-18.683-18.683-18.683c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615c8.072,0,14.615,6.543,14.615,14.615H43.935z"\n        }\n      }, [e("animateTransform", {\n        attrs: {\n          attributeType: "xml",\n          attributeName: "transform",\n          type: "rotate",\n          from: "0 25 25",\n          to: "360 25 25",\n          dur: this.duration,\n          repeatCount: "indefinite"\n        }\n      })], 1)]);\n    },\n    staticRenderFns: []\n  }, void 0, i, void 0, !1, void 0, void 0, void 0),\n      n = {\n    name: "ring",\n    props: {\n      color: {\n        type: String,\n        default: "#CCC"\n      },\n      size: {\n        type: String,\n        default: "40px"\n      },\n      duration: {\n        type: String,\n        default: "0.6s"\n      }\n    }\n  };\n  const r = n;\n  n.__file = "ring.vue";\n  var s = e({\n    render: function () {\n      var t = this.$createElement,\n          e = this._self._c || t;\n      return e("svg", {\n        attrs: {\n          version: "1.1",\n          id: "loader-1",\n          xmlns: "http://www.w3.org/2000/svg",\n          "xmlns:xlink": "http://www.w3.org/1999/xlink",\n          x: "0px",\n          y: "0px",\n          width: this.size,\n          height: this.size,\n          viewBox: "0 0 40 40",\n          "enable-background": "new 0 0 40 40",\n          "xml:space": "preserve"\n        }\n      }, [e("path", {\n        attrs: {\n          opacity: "0.2",\n          fill: this.color,\n          d: "M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946\\n    s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634\\n    c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"\n        }\n      }), this._v(" "), e("path", {\n        attrs: {\n          fill: this.color,\n          d: "M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0\\n    C22.32,8.481,24.301,9.057,26.013,10.047z"\n        }\n      }, [e("animateTransform", {\n        attrs: {\n          attributeType: "xml",\n          attributeName: "transform",\n          type: "rotate",\n          from: "0 20 20",\n          to: "360 20 20",\n          dur: this.duration,\n          repeatCount: "indefinite"\n        }\n      })], 1)]);\n    },\n    staticRenderFns: []\n  }, void 0, r, void 0, !1, void 0, void 0, void 0),\n      o = {\n    name: "mini-spinner",\n    props: {\n      color: {\n        type: String,\n        default: "#CCC"\n      },\n      size: {\n        type: String,\n        default: "40px"\n      },\n      duration: {\n        type: String,\n        default: "0.6s"\n      }\n    }\n  };\n  const d = o;\n  o.__file = "mini-spinner.vue";\n  var l = e({\n    render: function () {\n      var t = this.$createElement,\n          e = this._self._c || t;\n      return e("svg", {\n        staticStyle: {\n          "enable-background": "new 0 0 50 50"\n        },\n        attrs: {\n          version: "1.1",\n          id: "loader-1",\n          xmlns: "http://www.w3.org/2000/svg",\n          "xmlns:xlink": "http://www.w3.org/1999/xlink",\n          x: "0px",\n          y: "0px",\n          width: this.size,\n          height: this.size,\n          viewBox: "0 0 50 50",\n          "xml:space": "preserve"\n        }\n      }, [e("path", {\n        attrs: {\n          fill: this.color,\n          d: "M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z"\n        }\n      }, [e("animateTransform", {\n        attrs: {\n          attributeType: "xml",\n          attributeName: "transform",\n          type: "rotate",\n          from: "0 25 25",\n          to: "360 25 25",\n          dur: this.duration,\n          repeatCount: "indefinite"\n        }\n      })], 1)]);\n    },\n    staticRenderFns: []\n  }, void 0, d, void 0, !1, void 0, void 0, void 0),\n      u = {\n    name: "line-wave",\n    props: {\n      color: {\n        type: String,\n        default: "#CCC"\n      },\n      size: {\n        type: String,\n        default: "40px"\n      },\n      duration: {\n        type: String,\n        default: "0.6s"\n      }\n    }\n  };\n  const c = u;\n  u.__file = "line-wave.vue";\n  var p = e({\n    render: function () {\n      var t = this,\n          e = t.$createElement,\n          i = t._self._c || e;\n      return i("svg", {\n        staticStyle: {\n          "enable-background": "new 0 0 50 50"\n        },\n        attrs: {\n          version: "1.1",\n          id: "Layer_1",\n          xmlns: "http://www.w3.org/2000/svg",\n          "xmlns:xlink": "http://www.w3.org/1999/xlink",\n          x: "0px",\n          y: "0px",\n          width: t.size,\n          height: t.size,\n          viewBox: "0 0 24 30",\n          "xml:space": "preserve"\n        }\n      }, [i("rect", {\n        attrs: {\n          x: "0",\n          y: "0",\n          width: "4",\n          height: "10",\n          fill: t.color\n        }\n      }, [i("animateTransform", {\n        attrs: {\n          attributeType: "xml",\n          attributeName: "transform",\n          type: "translate",\n          values: "0 0; 0 20; 0 0",\n          begin: "0",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      })], 1), t._v(" "), i("rect", {\n        attrs: {\n          x: "10",\n          y: "0",\n          width: "4",\n          height: "10",\n          fill: t.color\n        }\n      }, [i("animateTransform", {\n        attrs: {\n          attributeType: "xml",\n          attributeName: "transform",\n          type: "translate",\n          values: "0 0; 0 20; 0 0",\n          begin: "0.2s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      })], 1), t._v(" "), i("rect", {\n        attrs: {\n          x: "20",\n          y: "0",\n          width: "4",\n          height: "10",\n          fill: t.color\n        }\n      }, [i("animateTransform", {\n        attrs: {\n          attributeType: "xml",\n          attributeName: "transform",\n          type: "translate",\n          values: "0 0; 0 20; 0 0",\n          begin: "0.4s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      })], 1)]);\n    },\n    staticRenderFns: []\n  }, void 0, c, void 0, !1, void 0, void 0, void 0),\n      v = {\n    name: "line-scale",\n    props: {\n      color: {\n        type: String,\n        default: "#CCC"\n      },\n      size: {\n        type: String,\n        default: "40px"\n      },\n      duration: {\n        type: String,\n        default: "0.6s"\n      }\n    }\n  };\n  const m = v;\n  v.__file = "line-scale.vue";\n  var f = e({\n    render: function () {\n      var t = this,\n          e = t.$createElement,\n          i = t._self._c || e;\n      return i("svg", {\n        staticStyle: {\n          "enable-background": "new 0 0 50 50"\n        },\n        attrs: {\n          version: "1.1",\n          id: "Layer_1",\n          xmlns: "http://www.w3.org/2000/svg",\n          "xmlns:xlink": "http://www.w3.org/1999/xlink",\n          x: "0px",\n          y: "0px",\n          width: t.size,\n          height: t.size,\n          viewBox: "0 0 24 30",\n          "xml:space": "preserve"\n        }\n      }, [i("rect", {\n        attrs: {\n          x: "0",\n          y: "13",\n          width: "4",\n          height: "5",\n          fill: t.color\n        }\n      }, [i("animate", {\n        attrs: {\n          attributeName: "height",\n          attributeType: "XML",\n          values: "5;21;5",\n          begin: "0s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      }), t._v(" "), i("animate", {\n        attrs: {\n          attributeName: "y",\n          attributeType: "XML",\n          values: "13; 5; 13",\n          begin: "0s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      })]), t._v(" "), i("rect", {\n        attrs: {\n          x: "10",\n          y: "13",\n          width: "4",\n          height: "5",\n          fill: t.color\n        }\n      }, [i("animate", {\n        attrs: {\n          attributeName: "height",\n          attributeType: "XML",\n          values: "5;21;5",\n          begin: "0.15s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      }), t._v(" "), i("animate", {\n        attrs: {\n          attributeName: "y",\n          attributeType: "XML",\n          values: "13; 5; 13",\n          begin: "0.15s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      })]), t._v(" "), i("rect", {\n        attrs: {\n          x: "20",\n          y: "13",\n          width: "4",\n          height: "5",\n          fill: t.color\n        }\n      }, [i("animate", {\n        attrs: {\n          attributeName: "height",\n          attributeType: "XML",\n          values: "5;21;5",\n          begin: "0.3s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      }), t._v(" "), i("animate", {\n        attrs: {\n          attributeName: "y",\n          attributeType: "XML",\n          values: "13; 5; 13",\n          begin: "0.3s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      })])]);\n    },\n    staticRenderFns: []\n  }, void 0, m, void 0, !1, void 0, void 0, void 0),\n      h = {\n    name: "line-down",\n    props: {\n      color: {\n        type: String,\n        default: "#CCC"\n      },\n      size: {\n        type: String,\n        default: "40px"\n      },\n      duration: {\n        type: String,\n        default: "0.6s"\n      }\n    }\n  };\n  const y = h;\n  h.__file = "line-down.vue";\n  var g = e({\n    render: function () {\n      var t = this,\n          e = t.$createElement,\n          i = t._self._c || e;\n      return i("svg", {\n        staticStyle: {\n          "enable-background": "new 0 0 50 50"\n        },\n        attrs: {\n          version: "1.1",\n          id: "Layer_1",\n          xmlns: "http://www.w3.org/2000/svg",\n          "xmlns:xlink": "http://www.w3.org/1999/xlink",\n          x: "0px",\n          y: "0px",\n          width: t.size,\n          height: t.size,\n          viewBox: "0 0 24 24",\n          "xml:space": "preserve"\n        }\n      }, [i("rect", {\n        attrs: {\n          x: "0",\n          y: "0",\n          width: "4",\n          height: "7",\n          fill: t.color\n        }\n      }, [i("animateTransform", {\n        attrs: {\n          attributeType: "xml",\n          attributeName: "transform",\n          type: "scale",\n          values: "1,1; 1,3; 1,1",\n          begin: "0s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      })], 1), t._v(" "), i("rect", {\n        attrs: {\n          x: "10",\n          y: "0",\n          width: "4",\n          height: "7",\n          fill: t.color\n        }\n      }, [i("animateTransform", {\n        attrs: {\n          attributeType: "xml",\n          attributeName: "transform",\n          type: "scale",\n          values: "1,1; 1,3; 1,1",\n          begin: "0.2s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      })], 1), t._v(" "), i("rect", {\n        attrs: {\n          x: "20",\n          y: "0",\n          width: "4",\n          height: "7",\n          fill: t.color\n        }\n      }, [i("animateTransform", {\n        attrs: {\n          attributeType: "xml",\n          attributeName: "transform",\n          type: "scale",\n          values: "1,1; 1,3; 1,1",\n          begin: "0.4s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      })], 1)]);\n    },\n    staticRenderFns: []\n  }, void 0, y, void 0, !1, void 0, void 0, void 0),\n      x = {\n    name: "bar-fade",\n    props: {\n      color: {\n        type: String,\n        default: "#CCC"\n      },\n      size: {\n        type: String,\n        default: "40px"\n      },\n      duration: {\n        type: String,\n        default: "0.6s"\n      }\n    }\n  };\n  const b = x;\n  x.__file = "bar-fade.vue";\n  var w = e({\n    render: function () {\n      var t = this,\n          e = t.$createElement,\n          i = t._self._c || e;\n      return i("svg", {\n        staticStyle: {\n          "enable-background": "new 0 0 50 50"\n        },\n        attrs: {\n          version: "1.1",\n          id: "Layer_1",\n          xmlns: "http://www.w3.org/2000/svg",\n          "xmlns:xlink": "http://www.w3.org/1999/xlink",\n          x: "0px",\n          y: "0px",\n          width: t.size,\n          height: t.size,\n          viewBox: "0 0 24 30",\n          "xml:space": "preserve"\n        }\n      }, [i("rect", {\n        attrs: {\n          x: "0",\n          y: "0",\n          width: "4",\n          height: "20",\n          fill: t.color\n        }\n      }, [i("animate", {\n        attrs: {\n          attributeName: "opacity",\n          attributeType: "XML",\n          values: "1; .2; 1",\n          begin: "0s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      })]), t._v(" "), i("rect", {\n        attrs: {\n          x: "7",\n          y: "0",\n          width: "4",\n          height: "20",\n          fill: t.color\n        }\n      }, [i("animate", {\n        attrs: {\n          attributeName: "opacity",\n          attributeType: "XML",\n          values: "1; .2; 1",\n          begin: "0.2s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      })]), t._v(" "), i("rect", {\n        attrs: {\n          x: "14",\n          y: "0",\n          width: "4",\n          height: "20",\n          fill: t.color\n        }\n      }, [i("animate", {\n        attrs: {\n          attributeName: "opacity",\n          attributeType: "XML",\n          values: "1; .2; 1",\n          begin: "0.4s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      })])]);\n    },\n    staticRenderFns: []\n  }, void 0, b, void 0, !1, void 0, void 0, void 0),\n      _ = {\n    name: "bar-fade-scale",\n    props: {\n      color: {\n        type: String,\n        default: "#CCC"\n      },\n      size: {\n        type: String,\n        default: "40px"\n      },\n      duration: {\n        type: String,\n        default: "0.6s"\n      }\n    }\n  };\n  const C = _;\n  _.__file = "bar-fade-scale.vue";\n  var S = e({\n    render: function () {\n      var t = this,\n          e = t.$createElement,\n          i = t._self._c || e;\n      return i("svg", {\n        staticStyle: {\n          "enable-background": "new 0 0 50 50"\n        },\n        attrs: {\n          version: "1.1",\n          id: "Layer_1",\n          xmlns: "http://www.w3.org/2000/svg",\n          "xmlns:xlink": "http://www.w3.org/1999/xlink",\n          x: "0px",\n          y: "0px",\n          width: t.size,\n          height: t.size,\n          viewBox: "0 0 24 30",\n          "xml:space": "preserve"\n        }\n      }, [i("rect", {\n        attrs: {\n          x: "0",\n          y: "10",\n          width: "4",\n          height: "10",\n          fill: t.color,\n          opacity: "0.2"\n        }\n      }, [i("animate", {\n        attrs: {\n          attributeName: "opacity",\n          attributeType: "XML",\n          values: "0.2; 1; .2",\n          begin: "0s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      }), t._v(" "), i("animate", {\n        attrs: {\n          attributeName: "height",\n          attributeType: "XML",\n          values: "10; 20; 10",\n          begin: "0s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      }), t._v(" "), i("animate", {\n        attrs: {\n          attributeName: "y",\n          attributeType: "XML",\n          values: "10; 5; 10",\n          begin: "0s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      })]), t._v(" "), i("rect", {\n        attrs: {\n          x: "8",\n          y: "10",\n          width: "4",\n          height: "10",\n          fill: t.color,\n          opacity: "0.2"\n        }\n      }, [i("animate", {\n        attrs: {\n          attributeName: "opacity",\n          attributeType: "XML",\n          values: "0.2; 1; .2",\n          begin: "0.15s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      }), t._v(" "), i("animate", {\n        attrs: {\n          attributeName: "height",\n          attributeType: "XML",\n          values: "10; 20; 10",\n          begin: "0.15s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      }), t._v(" "), i("animate", {\n        attrs: {\n          attributeName: "y",\n          attributeType: "XML",\n          values: "10; 5; 10",\n          begin: "0.15s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      })]), t._v(" "), i("rect", {\n        attrs: {\n          x: "16",\n          y: "10",\n          width: "4",\n          height: "10",\n          fill: t.color,\n          opacity: "0.2"\n        }\n      }, [i("animate", {\n        attrs: {\n          attributeName: "opacity",\n          attributeType: "XML",\n          values: "0.2; 1; .2",\n          begin: "0.3s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      }), t._v(" "), i("animate", {\n        attrs: {\n          attributeName: "height",\n          attributeType: "XML",\n          values: "10; 20; 10",\n          begin: "0.3s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      }), t._v(" "), i("animate", {\n        attrs: {\n          attributeName: "y",\n          attributeType: "XML",\n          values: "10; 5; 10",\n          begin: "0.3s",\n          dur: t.duration,\n          repeatCount: "indefinite"\n        }\n      })])]);\n    },\n    staticRenderFns: []\n  }, void 0, C, void 0, !1, void 0, void 0, void 0),\n      T = {\n    name: "vue-element-loading",\n    props: {\n      active: Boolean,\n      spinner: {\n        type: String,\n        default: "spinner"\n      },\n      text: {\n        type: String,\n        default: ""\n      },\n      textStyle: {\n        type: Object,\n        default: function () {\n          return {};\n        }\n      },\n      color: {\n        type: String,\n        default: "#000"\n      },\n      isFullScreen: {\n        type: Boolean,\n        default: !1\n      },\n      backgroundColor: {\n        type: String,\n        default: "rgba(255, 255, 255, .9)"\n      },\n      size: {\n        type: String,\n        default: "40"\n      },\n      duration: {\n        type: String,\n        default: "0.6"\n      },\n      delay: {\n        type: [String, Number],\n        default: 0\n      }\n    },\n    data: function () {\n      return {\n        isActive: this.active || !1,\n        isActiveDelay: !1\n      };\n    },\n    mounted: function () {\n      if (this.$refs.velmld.parentNode.classList.add("velmld-parent"), this.delay) {\n        var t = 1e3 * +this.delay;\n        this.delayActive(t);\n      }\n    },\n    methods: {\n      delayActive: function (t) {\n        var e = this;\n        this.isActiveDelay = !0, setTimeout(function () {\n          e.isActiveDelay = !1;\n        }, t);\n      }\n    },\n    watch: {\n      active: function (t) {\n        this.isActive = t, t && this.$refs.velmld.parentNode.classList.add("velmld-parent");\n      }\n    },\n    components: {\n      Spinner: a,\n      Ring: s,\n      MiniSpinner: l,\n      LineWave: p,\n      LineScale: f,\n      LineDown: g,\n      BarFade: w,\n      BarFadeScale: S\n    }\n  };\n  const N = "undefined" != typeof navigator && /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\n  const z = document.head || document.getElementsByTagName("head")[0],\n        L = {};\n  const k = T;\n  T.__file = "index.vue";\n  return e({\n    render: function () {\n      var t = this,\n          e = t.$createElement,\n          i = t._self._c || e;\n      return i("transition", {\n        attrs: {\n          name: "fade"\n        }\n      }, [i("div", {\n        directives: [{\n          name: "show",\n          rawName: "v-show",\n          value: t.isActive || t.isActiveDelay,\n          expression: "isActive || isActiveDelay"\n        }],\n        ref: "velmld",\n        staticClass: "velmld-overlay",\n        class: {\n          "velmld-full-screen": t.isFullScreen\n        },\n        style: {\n          backgroundColor: t.backgroundColor\n        }\n      }, [i("div", {\n        staticClass: "velmld-spinner"\n      }, [t._t("default", [i(t.spinner, {\n        tag: "component",\n        attrs: {\n          color: t.color,\n          size: t.size + "px",\n          duration: t.duration + "s"\n        }\n      })]), t._v(" "), t.text.length ? i("div", {\n        style: Object.assign({}, {\n          color: t.color\n        }, t.textStyle)\n      }, [t._v("\\n        " + t._s(t.text) + "\\n      ")]) : t._e()], 2)])]);\n    },\n    staticRenderFns: []\n  }, function (t) {\n    t && (t("data-v-27234dc7_0", {\n      source: ".fade-enter-active[data-v-27234dc7],.fade-leave-active[data-v-27234dc7]{transition:opacity .3s}.fade-enter[data-v-27234dc7],.fade-leave-to[data-v-27234dc7]{opacity:0}.velmld-overlay[data-v-27234dc7]{position:absolute;z-index:3000;margin:0;top:0;right:0;bottom:0;left:0;transition:opacity .3s}.velmld-spinner[data-v-27234dc7]{top:50%;left:50%;transform:translate(-50%,-50%);position:absolute;text-align:center}.velmld-full-screen[data-v-27234dc7]{position:fixed}",\n      map: void 0,\n      media: void 0\n    }), t("data-v-27234dc7_1", {\n      source: ".velmld-parent{position:relative!important}",\n      map: void 0,\n      media: void 0\n    }));\n  }, k, "data-v-27234dc7", !1, void 0, function (t) {\n    return (t, e) => function (t, e) {\n      const i = N ? e.media || "default" : t,\n            a = L[i] || (L[i] = {\n        ids: new Set(),\n        styles: []\n      });\n\n      if (!a.ids.has(t)) {\n        a.ids.add(t);\n        let i = e.source;\n        if (e.map && (i += "\\n/*# sourceURL=" + e.map.sources[0] + " */", i += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(e.map)))) + " */"), a.element || (a.element = document.createElement("style"), a.element.type = "text/css", e.media && a.element.setAttribute("media", e.media), z.appendChild(a.element)), "styleSheet" in a.element) a.styles.push(i), a.element.styleSheet.cssText = a.styles.filter(Boolean).join("\\n");else {\n          const t = a.ids.size - 1,\n                e = document.createTextNode(i),\n                n = a.element.childNodes;\n          n[t] && a.element.removeChild(n[t]), n.length ? a.element.insertBefore(e, n[t]) : a.element.appendChild(e);\n        }\n      }\n    }(t, e);\n  }, void 0);\n});\n\n//# sourceURL=webpack://kloster/./node_modules/vue-element-loading/lib/vue-element-loading.min.js?')},"./node_modules/vue-gallery/dist/js/vue-gallery.js":function(module,__unused_webpack_exports,__webpack_require__){eval("(function (global, factory) {\n   true ? module.exports = factory(__webpack_require__(/*! blueimp-gallery/css/blueimp-gallery.min.css */ \"./node_modules/blueimp-gallery/css/blueimp-gallery.min.css\"), __webpack_require__(/*! blueimp-gallery/js/blueimp-gallery-fullscreen.js */ \"./node_modules/blueimp-gallery/js/blueimp-gallery-fullscreen.js\"), __webpack_require__(/*! blueimp-gallery/js/blueimp-gallery-video.js */ \"./node_modules/blueimp-gallery/js/blueimp-gallery-video.js\"), __webpack_require__(/*! blueimp-gallery/js/blueimp-gallery-youtube.js */ \"./node_modules/blueimp-gallery/js/blueimp-gallery-youtube.js\"), __webpack_require__(/*! blueimp-gallery/js/blueimp-gallery.js */ \"./node_modules/blueimp-gallery/js/blueimp-gallery.js\")) : 0;\n})(this, function (blueimpGallery_min_css, blueimpGalleryFullscreen_js, blueimpGalleryVideo_js, blueimpGalleryYoutube_js, blueimp) {\n  'use strict';\n\n  blueimp = blueimp && blueimp.hasOwnProperty('default') ? blueimp['default'] : blueimp; //\n\n  var script = {\n    props: {\n      images: {\n        type: Array,\n        default: function _default() {\n          return [];\n        }\n      },\n      options: {\n        type: Object,\n        default: function _default() {\n          return {};\n        }\n      },\n      carousel: {\n        type: Boolean,\n        default: false\n      },\n      index: {\n        type: Number\n      },\n      id: {\n        type: String,\n        default: 'blueimp-gallery'\n      }\n    },\n    data: function data() {\n      return {\n        instance: null\n      };\n    },\n    watch: {\n      index: function index(value) {\n        if (this.carousel) {\n          return;\n        }\n\n        if (value !== null) {\n          this.open(value);\n        } else {\n          if (this.instance) {\n            this.instance.close();\n          }\n\n          this.$emit('close');\n        }\n      }\n    },\n    mounted: function mounted() {\n      if (this.carousel) {\n        this.open();\n      }\n    },\n    destroyed: function destroyed() {\n      if (this.instance !== null) {\n        this.instance.destroyEventListeners();\n        this.instance.close();\n        this.instance = null;\n      }\n    },\n    methods: {\n      open: function open() {\n        var _this = this;\n\n        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var instance = typeof blueimp.Gallery !== 'undefined' ? blueimp.Gallery : blueimp;\n        var options = Object.assign({\n          toggleControlsOnReturn: false,\n          toggleControlsOnSlideClick: false,\n          closeOnSlideClick: false,\n          carousel: this.carousel,\n          container: \"#\".concat(this.id),\n          index: index,\n          onopen: function onopen() {\n            return _this.$emit('onopen');\n          },\n          onopened: function onopened() {\n            return _this.$emit('onopened');\n          },\n          onslide: this.onSlideCustom,\n          onslideend: function onslideend(index, slide) {\n            return _this.$emit('onslideend', {\n              index: index,\n              slide: slide\n            });\n          },\n          onslidecomplete: function onslidecomplete(index, slide) {\n            return _this.$emit('onslidecomplete', {\n              index: index,\n              slide: slide\n            });\n          },\n          onclose: function onclose() {\n            return _this.$emit('close');\n          },\n          onclosed: function onclosed() {\n            return _this.$emit('onclosed');\n          }\n        }, this.options);\n\n        if (this.carousel) {\n          options.container = this.$el;\n        }\n\n        this.instance = instance(this.images, options);\n      },\n      onSlideCustom: function onSlideCustom(index, slide) {\n        this.$emit('onslide', {\n          index: index,\n          slide: slide\n        });\n        var image = this.images[index];\n\n        if (image !== undefined) {\n          var text = image.description;\n          var node = this.instance.container.find('.description');\n\n          if (text) {\n            node.empty();\n            node[0].appendChild(document.createTextNode(text));\n          }\n        }\n      }\n    }\n  };\n\n  function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier\n  /* server only */\n  , shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\n    if (typeof shadowMode !== 'boolean') {\n      createInjectorSSR = createInjector;\n      createInjector = shadowMode;\n      shadowMode = false;\n    } // Vue.extend constructor export interop.\n\n\n    var options = typeof script === 'function' ? script.options : script; // render functions\n\n    if (template && template.render) {\n      options.render = template.render;\n      options.staticRenderFns = template.staticRenderFns;\n      options._compiled = true; // functional template\n\n      if (isFunctionalTemplate) {\n        options.functional = true;\n      }\n    } // scopedId\n\n\n    if (scopeId) {\n      options._scopeId = scopeId;\n    }\n\n    var hook;\n\n    if (moduleIdentifier) {\n      // server build\n      hook = function hook(context) {\n        // 2.3 injection\n        context = context || // cached call\n        this.$vnode && this.$vnode.ssrContext || // stateful\n        this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional\n        // 2.2 with runInNewContext: true\n\n        if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n          context = __VUE_SSR_CONTEXT__;\n        } // inject component styles\n\n\n        if (style) {\n          style.call(this, createInjectorSSR(context));\n        } // register component module identifier for async chunk inference\n\n\n        if (context && context._registeredComponents) {\n          context._registeredComponents.add(moduleIdentifier);\n        }\n      }; // used by ssr in case component is cached and beforeCreate\n      // never gets called\n\n\n      options._ssrRegister = hook;\n    } else if (style) {\n      hook = shadowMode ? function () {\n        style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));\n      } : function (context) {\n        style.call(this, createInjector(context));\n      };\n    }\n\n    if (hook) {\n      if (options.functional) {\n        // register for functional component in vue file\n        var originalRender = options.render;\n\n        options.render = function renderWithStyleInjection(h, context) {\n          hook.call(context);\n          return originalRender(h, context);\n        };\n      } else {\n        // inject component registration as beforeCreate hook\n        var existing = options.beforeCreate;\n        options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n      }\n    }\n\n    return script;\n  }\n\n  var normalizeComponent_1 = normalizeComponent;\n  var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\n\n  function createInjector(context) {\n    return function (id, style) {\n      return addStyle(id, style);\n    };\n  }\n\n  var HEAD = document.head || document.getElementsByTagName('head')[0];\n  var styles = {};\n\n  function addStyle(id, css) {\n    var group = isOldIE ? css.media || 'default' : id;\n    var style = styles[group] || (styles[group] = {\n      ids: new Set(),\n      styles: []\n    });\n\n    if (!style.ids.has(id)) {\n      style.ids.add(id);\n      var code = css.source;\n\n      if (css.map) {\n        // https://developer.chrome.com/devtools/docs/javascript-debugging\n        // this makes source maps inside style tags work properly in Chrome\n        code += '\\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875\n\n        code += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';\n      }\n\n      if (!style.element) {\n        style.element = document.createElement('style');\n        style.element.type = 'text/css';\n        if (css.media) style.element.setAttribute('media', css.media);\n        HEAD.appendChild(style.element);\n      }\n\n      if ('styleSheet' in style.element) {\n        style.styles.push(code);\n        style.element.styleSheet.cssText = style.styles.filter(Boolean).join('\\n');\n      } else {\n        var index = style.ids.size - 1;\n        var textNode = document.createTextNode(code);\n        var nodes = style.element.childNodes;\n        if (nodes[index]) style.element.removeChild(nodes[index]);\n        if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);\n      }\n    }\n  }\n\n  var browser = createInjector;\n  /* script */\n\n  const __vue_script__ = script;\n  /* template */\n\n  var __vue_render__ = function () {\n    var _vm = this;\n\n    var _h = _vm.$createElement;\n\n    var _c = _vm._self._c || _h;\n\n    return _c('div', {\n      staticClass: \"blueimp-gallery blueimp-gallery-controls\",\n      class: {\n        'blueimp-gallery-carousel': _vm.carousel\n      },\n      attrs: {\n        \"id\": _vm.id\n      }\n    }, [_c('div', {\n      staticClass: \"slides\"\n    }), _vm._v(\" \"), _c('h3', {\n      staticClass: \"title\"\n    }), _vm._v(\" \"), _c('p', {\n      staticClass: \"description\"\n    }), _vm._v(\" \"), _c('a', {\n      staticClass: \"prev\"\n    }, [_vm._t(\"prev\", [_vm._v(\"\")])], 2), _vm._v(\" \"), _c('a', {\n      staticClass: \"next\"\n    }, [_vm._t(\"next\", [_vm._v(\"\")])], 2), _vm._v(\" \"), !_vm.carousel ? _c('a', {\n      staticClass: \"close\"\n    }, [_vm._t(\"close\", [_vm._v(\"\")])], 2) : _vm._e(), _vm._v(\" \"), !_vm.carousel ? _c('ol', {\n      staticClass: \"indicator\"\n    }) : _vm._e(), _vm._v(\" \"), _vm.carousel ? _c('a', {\n      staticClass: \"play-pause\"\n    }) : _vm._e()]);\n  };\n\n  var __vue_staticRenderFns__ = [];\n  /* style */\n\n  const __vue_inject_styles__ = function (inject) {\n    if (!inject) return;\n    inject(\"data-v-6d2033ba_0\", {\n      source: \".blueimp-gallery>.description{position:absolute;top:30px;left:15px;color:#fff;display:none}.blueimp-gallery-controls>.description{display:block}\",\n      map: undefined,\n      media: undefined\n    });\n  };\n  /* scoped */\n\n\n  const __vue_scope_id__ = undefined;\n  /* module identifier */\n\n  const __vue_module_identifier__ = undefined;\n  /* functional template */\n\n  const __vue_is_functional_template__ = false;\n  /* style inject SSR */\n\n  var VueGallery = normalizeComponent_1({\n    render: __vue_render__,\n    staticRenderFns: __vue_staticRenderFns__\n  }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, browser, undefined);\n  return VueGallery;\n});\n\n//# sourceURL=webpack://kloster/./node_modules/vue-gallery/dist/js/vue-gallery.js?")},"./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/js/components/ContactForm.vue?vue&type=script&lang=js&":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var vue_element_loading__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue-element-loading */ \"./node_modules/vue-element-loading/lib/vue-element-loading.min.js\");\n/* harmony import */ var vue_element_loading__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue_element_loading__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var vue_recaptcha__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue-recaptcha */ \"./node_modules/vue-recaptcha/dist/vue-recaptcha.es.js\");\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: \"ContactForm\",\n\n  data() {\n    return {\n      submitted: false,\n      success: false,\n      messageProgress: 0,\n      maxProgress: 100,\n      requiredFields: ['name', 'text', 'email'],\n      message: '',\n      form: {\n        name: '',\n        text: '',\n        email: ''\n      }\n    };\n  },\n\n  props: ['nameText', 'messageText', 'sendText', 'fillText', 'captchaNotPassed', 'fieldsNotFilled', 'messageSent', 'sendingError'],\n  methods: {\n    checkFields(fields) {\n      for (var i = 0; i < this.requiredFields.length; i++) {\n        if (!fields[this.requiredFields[i]].trim()) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n\n    submit() {\n      this.submitted = true;\n      const $vm = this;\n      var fields = this.form,\n          gRecaptchaValue = document.querySelector('.contact-form').querySelector('#g-recaptcha-response').value;\n\n      if (!this.checkFields(fields)) {\n        this.showResult(0, this.fieldsNotFilled);\n        return;\n      }\n\n      if (!gRecaptchaValue) {\n        this.showResult(0, this.captchaNotPassed);\n        return;\n      }\n\n      fields = Object.assign({}, fields, {\n        'g-recaptcha-response': gRecaptchaValue\n      });\n      axios.post('/mail', fields).then(function (response) {\n        $vm.clean();\n        var message = '';\n\n        if (response.data.errorCode) {\n          switch (response.data.errorCode) {\n            case 1:\n              message = $vm.captchaNotPassed;\n              break;\n\n            case 2:\n              message = $vm.fieldsNotFilled;\n              break;\n          }\n        } else {\n          message = $vm.messageSent;\n        }\n\n        $vm.showResult(response.data.success, message);\n      }, function (response) {\n        $vm.showResult(false, $vm.sendingError);\n      });\n    },\n\n    showResult(success, message) {\n      this.submitted = false;\n      this.success = success;\n      this.message = message;\n      this.messageProgress = 100;\n      this.startProgress();\n      window.scrollTo({\n        top: document.querySelector('#contacts').offsetTop,\n        behavior: 'smooth'\n      });\n    },\n\n    startProgress() {\n      const $vm = this;\n\n      const progress = function () {\n        $vm.messageProgress -= 2;\n\n        if ($vm.messageProgress > 0) {\n          setTimeout(progress, 100);\n        }\n      };\n\n      setTimeout(progress, 100);\n    },\n\n    clean() {\n      this.resetCaptcha();\n\n      for (var key in this.form) {\n        this.form[key] = '';\n      }\n    },\n\n    resetCaptcha() {\n      window.grecaptcha.reset();\n    }\n\n  },\n  components: {\n    VueLoading: (vue_element_loading__WEBPACK_IMPORTED_MODULE_0___default()),\n    VueRecaptcha: vue_recaptcha__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n  }\n});\n\n//# sourceURL=webpack://kloster/./src/js/components/ContactForm.vue?./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options")},"./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/js/components/Socials.vue?vue&type=script&lang=js&":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n//\n//\n//\n//\n//\n//\n//\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: "Socials"\n});\n\n//# sourceURL=webpack://kloster/./src/js/components/Socials.vue?./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options')},"./node_modules/vue-owl-carousel/dist/vue-owl-carousel.js":function(module){eval('!function (e, t) {\n   true ? module.exports = t() : 0;\n}(this, function () {\n  return function (e) {\n    function t(i) {\n      if (n[i]) return n[i].exports;\n      var r = n[i] = {\n        exports: {},\n        id: i,\n        loaded: !1\n      };\n      return e[i].call(r.exports, r, r.exports, t), r.loaded = !0, r.exports;\n    }\n\n    var n = {};\n    return t.m = e, t.c = n, t.p = "", t(0);\n  }([function (e, t, n) {\n    var i = n(1)(n(2), n(15), null, null);\n    e.exports = i.exports;\n  }, function (e, t) {\n    e.exports = function (e, t, n, i) {\n      var r,\n          o = e = e || {},\n          s = typeof e["default"];\n      "object" !== s && "function" !== s || (r = e, o = e["default"]);\n      var a = "function" == typeof o ? o.options : o;\n\n      if (t && (a.render = t.render, a.staticRenderFns = t.staticRenderFns), n && (a._scopeId = n), i) {\n        var l = Object.create(a.computed || null);\n        Object.keys(i).forEach(function (e) {\n          var t = i[e];\n\n          l[e] = function () {\n            return t;\n          };\n        }), a.computed = l;\n      }\n\n      return {\n        esModule: r,\n        exports: o,\n        options: a\n      };\n    };\n  }, function (e, t, n) {\n    (function (e) {\n      "use strict";\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          "default": e\n        };\n      }\n\n      Object.defineProperty(t, "__esModule", {\n        value: !0\n      }), n(4), n(11), n(13);\n      var r = n(14),\n          o = i(r);\n      t["default"] = {\n        name: "VOwlCarousel",\n        props: {\n          items: {\n            type: Number,\n            "default": 3\n          },\n          margin: {\n            type: Number,\n            "default": 0\n          },\n          loop: {\n            type: Boolean,\n            "default": !1\n          },\n          center: {\n            type: Boolean,\n            "default": !1\n          },\n          mouseDrag: {\n            type: Boolean,\n            "default": !0\n          },\n          touchDrag: {\n            type: Boolean,\n            "default": !0\n          },\n          pullDrag: {\n            type: Boolean,\n            "default": !0\n          },\n          freeDrag: {\n            type: Boolean,\n            "default": !1\n          },\n          stagePadding: {\n            type: Number,\n            "default": 0\n          },\n          merge: {\n            type: Boolean,\n            "default": !1\n          },\n          mergeFit: {\n            type: Boolean,\n            "default": !1\n          },\n          autoWidth: {\n            type: Boolean,\n            "default": !1\n          },\n          startPosition: {\n            type: Number,\n            "default": 0\n          },\n          uRLhashListener: {\n            type: Boolean,\n            "default": !1\n          },\n          nav: {\n            type: Boolean,\n            "default": !0\n          },\n          rewind: {\n            type: Boolean,\n            "default": !0\n          },\n          navText: {\n            type: Array,\n            "default": function () {\n              return ["next", "prev"];\n            }\n          },\n          navElement: {\n            type: String,\n            "default": "div"\n          },\n          slideBy: {\n            type: [Number, String],\n            "default": 1\n          },\n          slideTransition: {\n            type: String,\n            "default": ""\n          },\n          dots: {\n            type: Boolean,\n            "default": !0\n          },\n          dotsEach: {\n            type: [Number, Boolean],\n            "default": !1\n          },\n          dotsData: {\n            type: Boolean,\n            "default": !1\n          },\n          lazyLoad: {\n            type: Boolean,\n            "default": !1\n          },\n          lazyLoadEager: {\n            type: Number,\n            "default": 0\n          },\n          autoplay: {\n            type: Boolean,\n            "default": !1\n          },\n          autoplaySpeed: {\n            type: Boolean,\n            "default": !1\n          },\n          autoplayTimeout: {\n            type: Number,\n            "default": 5e3\n          },\n          autoplayHoverPause: {\n            type: Boolean,\n            "default": !1\n          },\n          smartSpeed: {\n            type: Number,\n            "default": 250\n          },\n          fluidSpeed: {\n            type: [Number, Boolean],\n            "default": !1\n          },\n          navSpeed: {\n            type: [Number, Boolean],\n            "default": !1\n          },\n          dragEndSpeed: {\n            type: [Number, Boolean],\n            "default": !1\n          },\n          callbacks: {\n            type: Boolean,\n            "default": !0\n          },\n          responsive: {\n            type: Object,\n            "default": function () {}\n          },\n          responsiveRefreshRate: {\n            type: Number,\n            "default": 200\n          },\n          video: {\n            type: Boolean,\n            "default": !1\n          },\n          videoHeight: {\n            type: [Number, Boolean],\n            "default": !1\n          },\n          videoWidth: {\n            type: [Number, Boolean],\n            "default": !1\n          },\n          animateOut: {\n            type: [String, Boolean],\n            "default": !1\n          },\n          animateIn: {\n            type: [String, Boolean],\n            "default": !1\n          },\n          fallbackEasing: {\n            type: String,\n            "default": "swing"\n          },\n          info: {\n            type: Function,\n            "default": function () {}\n          },\n          itemElement: {\n            type: String,\n            "default": "div"\n          },\n          stageElement: {\n            type: String,\n            "default": "div"\n          },\n          navContainer: {\n            type: [String, Boolean],\n            "default": !1\n          },\n          dotsContainer: {\n            type: [String, Boolean],\n            "default": !1\n          },\n          checkVisible: {\n            type: Boolean,\n            "default": !0\n          }\n        },\n        data: function () {\n          return {\n            showPrev: !1,\n            showNext: !0,\n            prevHandler: "carousel_prev_" + this.generateUniqueId(),\n            elementHandle: "carousel_" + this.generateUniqueId(),\n            nextHandler: "carousel_next_" + this.generateUniqueId()\n          };\n        },\n        mounted: function () {\n          var t = this,\n              n = e("#" + this.elementHandle).owlCarousel({\n            items: this.items,\n            margin: this.margin,\n            loop: this.loop,\n            center: this.center,\n            mouseDrag: this.mouseDrag,\n            touchDrag: this.touchDrag,\n            pullDrag: this.pullDrag,\n            freeDrag: this.freeDrag,\n            stagePadding: this.stagePadding,\n            merge: this.merge,\n            mergeFit: this.mergeFit,\n            autoWidth: this.autoWidth,\n            startPosition: this.startPosition,\n            uRLhashListener: this.uRLhashListener,\n            nav: this.nav,\n            rewind: this.rewind,\n            navText: this.navText,\n            navElement: this.navElement,\n            slideBy: this.slideBy,\n            slideTransition: this.slideTransition,\n            dots: this.dots,\n            dotsEach: this.dotsEach,\n            dotsData: this.dotsData,\n            lazyLoad: this.lazyLoad,\n            lazyLoadEager: this.lazyLoadEager,\n            autoplay: this.autoplay,\n            autoplaySpeed: this.autoplaySpeed,\n            autoplayTimeout: this.autoplayTimeout,\n            autoplayHoverPause: this.autoplayHoverPause,\n            smartSpeed: this.smartSpeed,\n            fluidSpeed: this.fluidSpeed,\n            navSpeed: this.navSpeed,\n            dragEndSpeed: this.dragEndSpeed,\n            callbacks: this.callbacks,\n            responsive: this.responsive,\n            responsiveRefreshRate: this.responsiveRefreshRate,\n            video: this.video,\n            videoHeight: this.videoHeight,\n            videoWidth: this.videoWidth,\n            animateOut: this.animateOut,\n            animateIn: this.animateIn,\n            fallbackEasing: this.fallbackEasing,\n            info: this.info,\n            itemElement: this.itemElement,\n            stageElement: this.stageElement,\n            navContainer: this.navContainer,\n            dotsContainer: this.dotsContainer,\n            checkVisible: this.checkVisible\n          });\n          e("#" + this.prevHandler).click(function () {\n            n.trigger("prev.owl.carousel");\n          }), e("#" + this.nextHandler).click(function () {\n            n.trigger("next.owl.carousel");\n          }), o["default"].forEach(function (e) {\n            n.on(e + ".owl.carousel", function (n) {\n              t.$emit(e, n);\n            });\n          }), this.loop || n.on("changed.owl.carousel", function (e) {\n            if (0 === e.item.index) t.showPrev = !1, t.showNext = !0;else {\n              var n = Math.floor(e.item.index + e.page.size);\n              n === e.item.count ? (t.showPrev = !0, t.showNext = !1) : (t.showPrev = !0, t.showNext = !0);\n            }\n          });\n        },\n        methods: {\n          generateUniqueId: function () {\n            return Math.random().toString(36).substring(2, 15);\n          }\n        }\n      };\n    }).call(t, n(3));\n  }, function (e, t, n) {\n    var i, r;\n    /*!\n    * jQuery JavaScript Library v3.3.1\n    * https://jquery.com/\n    *\n    * Includes Sizzle.js\n    * https://sizzlejs.com/\n    *\n    * Copyright JS Foundation and other contributors\n    * Released under the MIT license\n    * https://jquery.org/license\n    *\n    * Date: 2018-01-20T17:24Z\n    */\n\n    !function (t, n) {\n      "use strict";\n\n      "object" == typeof e && "object" == typeof e.exports ? e.exports = t.document ? n(t, !0) : function (e) {\n        if (!e.document) throw new Error("jQuery requires a window with a document");\n        return n(e);\n      } : n(t);\n    }("undefined" != typeof window ? window : this, function (n, o) {\n      "use strict";\n\n      function s(e, t, n) {\n        t = t || ce;\n        var i,\n            r = t.createElement("script");\n        if (r.text = e, n) for (i in Te) n[i] && (r[i] = n[i]);\n        t.head.appendChild(r).parentNode.removeChild(r);\n      }\n\n      function a(e) {\n        return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? me[ve.call(e)] || "object" : typeof e;\n      }\n\n      function l(e) {\n        var t = !!e && "length" in e && e.length,\n            n = a(e);\n        return !_e(e) && !Ce(e) && ("array" === n || 0 === t || "number" == typeof t && t > 0 && t - 1 in e);\n      }\n\n      function u(e, t) {\n        return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase();\n      }\n\n      function c(e, t, n) {\n        return _e(t) ? ke.grep(e, function (e, i) {\n          return !!t.call(e, i, e) !== n;\n        }) : t.nodeType ? ke.grep(e, function (e) {\n          return e === t !== n;\n        }) : "string" != typeof t ? ke.grep(e, function (e) {\n          return ge.call(t, e) > -1 !== n;\n        }) : ke.filter(t, e, n);\n      }\n\n      function h(e, t) {\n        for (; (e = e[t]) && 1 !== e.nodeType;);\n\n        return e;\n      }\n\n      function p(e) {\n        var t = {};\n        return ke.each(e.match(qe) || [], function (e, n) {\n          t[n] = !0;\n        }), t;\n      }\n\n      function d(e) {\n        return e;\n      }\n\n      function f(e) {\n        throw e;\n      }\n\n      function g(e, t, n, i) {\n        var r;\n\n        try {\n          e && _e(r = e.promise) ? r.call(e).done(t).fail(n) : e && _e(r = e.then) ? r.call(e, t, n) : t.apply(void 0, [e].slice(i));\n        } catch (e) {\n          n.apply(void 0, [e]);\n        }\n      }\n\n      function m() {\n        ce.removeEventListener("DOMContentLoaded", m), n.removeEventListener("load", m), ke.ready();\n      }\n\n      function v(e, t) {\n        return t.toUpperCase();\n      }\n\n      function y(e) {\n        return e.replace(Be, "ms-").replace(We, v);\n      }\n\n      function w() {\n        this.expando = ke.expando + w.uid++;\n      }\n\n      function x(e) {\n        return "true" === e || "false" !== e && ("null" === e ? null : e === +e + "" ? +e : Xe.test(e) ? JSON.parse(e) : e);\n      }\n\n      function b(e, t, n) {\n        var i;\n        if (void 0 === n && 1 === e.nodeType) if (i = "data-" + t.replace(Ye, "-$&").toLowerCase(), n = e.getAttribute(i), "string" == typeof n) {\n          try {\n            n = x(n);\n          } catch (r) {}\n\n          Ve.set(e, t, n);\n        } else n = void 0;\n        return n;\n      }\n\n      function _(e, t, n, i) {\n        var r,\n            o,\n            s = 20,\n            a = i ? function () {\n          return i.cur();\n        } : function () {\n          return ke.css(e, t, "");\n        },\n            l = a(),\n            u = n && n[3] || (ke.cssNumber[t] ? "" : "px"),\n            c = (ke.cssNumber[t] || "px" !== u && +l) && Ze.exec(ke.css(e, t));\n\n        if (c && c[3] !== u) {\n          for (l /= 2, u = u || c[3], c = +l || 1; s--;) ke.style(e, t, c + u), (1 - o) * (1 - (o = a() / l || .5)) <= 0 && (s = 0), c /= o;\n\n          c = 2 * c, ke.style(e, t, c + u), n = n || [];\n        }\n\n        return n && (c = +c || +l || 0, r = n[1] ? c + (n[1] + 1) * n[2] : +n[2], i && (i.unit = u, i.start = c, i.end = r)), r;\n      }\n\n      function C(e) {\n        var t,\n            n = e.ownerDocument,\n            i = e.nodeName,\n            r = et[i];\n        return r ? r : (t = n.body.appendChild(n.createElement(i)), r = ke.css(t, "display"), t.parentNode.removeChild(t), "none" === r && (r = "block"), et[i] = r, r);\n      }\n\n      function T(e, t) {\n        for (var n, i, r = [], o = 0, s = e.length; o < s; o++) i = e[o], i.style && (n = i.style.display, t ? ("none" === n && (r[o] = Ue.get(i, "display") || null, r[o] || (i.style.display = "")), "" === i.style.display && Qe(i) && (r[o] = C(i))) : "none" !== n && (r[o] = "none", Ue.set(i, "display", n)));\n\n        for (o = 0; o < s; o++) null != r[o] && (e[o].style.display = r[o]);\n\n        return e;\n      }\n\n      function E(e, t) {\n        var n;\n        return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && u(e, t) ? ke.merge([e], n) : n;\n      }\n\n      function k(e, t) {\n        for (var n = 0, i = e.length; n < i; n++) Ue.set(e[n], "globalEval", !t || Ue.get(t[n], "globalEval"));\n      }\n\n      function S(e, t, n, i, r) {\n        for (var o, s, l, u, c, h, p = t.createDocumentFragment(), d = [], f = 0, g = e.length; f < g; f++) if (o = e[f], o || 0 === o) if ("object" === a(o)) ke.merge(d, o.nodeType ? [o] : o);else if (ot.test(o)) {\n          for (s = s || p.appendChild(t.createElement("div")), l = (nt.exec(o) || ["", ""])[1].toLowerCase(), u = rt[l] || rt._default, s.innerHTML = u[1] + ke.htmlPrefilter(o) + u[2], h = u[0]; h--;) s = s.lastChild;\n\n          ke.merge(d, s.childNodes), s = p.firstChild, s.textContent = "";\n        } else d.push(t.createTextNode(o));\n\n        for (p.textContent = "", f = 0; o = d[f++];) if (i && ke.inArray(o, i) > -1) r && r.push(o);else if (c = ke.contains(o.ownerDocument, o), s = E(p.appendChild(o), "script"), c && k(s), n) for (h = 0; o = s[h++];) it.test(o.type || "") && n.push(o);\n\n        return p;\n      }\n\n      function D() {\n        return !0;\n      }\n\n      function N() {\n        return !1;\n      }\n\n      function j() {\n        try {\n          return ce.activeElement;\n        } catch (e) {}\n      }\n\n      function A(e, t, n, i, r, o) {\n        var s, a;\n\n        if ("object" == typeof t) {\n          "string" != typeof n && (i = i || n, n = void 0);\n\n          for (a in t) A(e, a, n, i, t[a], o);\n\n          return e;\n        }\n\n        if (null == i && null == r ? (r = n, i = n = void 0) : null == r && ("string" == typeof n ? (r = i, i = void 0) : (r = i, i = n, n = void 0)), r === !1) r = N;else if (!r) return e;\n        return 1 === o && (s = r, r = function (e) {\n          return ke().off(e), s.apply(this, arguments);\n        }, r.guid = s.guid || (s.guid = ke.guid++)), e.each(function () {\n          ke.event.add(this, t, r, i, n);\n        });\n      }\n\n      function $(e, t) {\n        return u(e, "table") && u(11 !== t.nodeType ? t : t.firstChild, "tr") ? ke(e).children("tbody")[0] || e : e;\n      }\n\n      function L(e) {\n        return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e;\n      }\n\n      function z(e) {\n        return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e;\n      }\n\n      function O(e, t) {\n        var n, i, r, o, s, a, l, u;\n\n        if (1 === t.nodeType) {\n          if (Ue.hasData(e) && (o = Ue.access(e), s = Ue.set(t, o), u = o.events)) {\n            delete s.handle, s.events = {};\n\n            for (r in u) for (n = 0, i = u[r].length; n < i; n++) ke.event.add(t, r, u[r][n]);\n          }\n\n          Ve.hasData(e) && (a = Ve.access(e), l = ke.extend({}, a), Ve.set(t, l));\n        }\n      }\n\n      function P(e, t) {\n        var n = t.nodeName.toLowerCase();\n        "input" === n && tt.test(e.type) ? t.checked = e.checked : "input" !== n && "textarea" !== n || (t.defaultValue = e.defaultValue);\n      }\n\n      function H(e, t, n, i) {\n        t = de.apply([], t);\n\n        var r,\n            o,\n            a,\n            l,\n            u,\n            c,\n            h = 0,\n            p = e.length,\n            d = p - 1,\n            f = t[0],\n            g = _e(f);\n\n        if (g || p > 1 && "string" == typeof f && !be.checkClone && pt.test(f)) return e.each(function (r) {\n          var o = e.eq(r);\n          g && (t[0] = f.call(this, r, o.html())), H(o, t, n, i);\n        });\n\n        if (p && (r = S(t, e[0].ownerDocument, !1, e, i), o = r.firstChild, 1 === r.childNodes.length && (r = o), o || i)) {\n          for (a = ke.map(E(r, "script"), L), l = a.length; h < p; h++) u = r, h !== d && (u = ke.clone(u, !0, !0), l && ke.merge(a, E(u, "script"))), n.call(e[h], u, h);\n\n          if (l) for (c = a[a.length - 1].ownerDocument, ke.map(a, z), h = 0; h < l; h++) u = a[h], it.test(u.type || "") && !Ue.access(u, "globalEval") && ke.contains(c, u) && (u.src && "module" !== (u.type || "").toLowerCase() ? ke._evalUrl && ke._evalUrl(u.src) : s(u.textContent.replace(dt, ""), c, u));\n        }\n\n        return e;\n      }\n\n      function q(e, t, n) {\n        for (var i, r = t ? ke.filter(t, e) : e, o = 0; null != (i = r[o]); o++) n || 1 !== i.nodeType || ke.cleanData(E(i)), i.parentNode && (n && ke.contains(i.ownerDocument, i) && k(E(i, "script")), i.parentNode.removeChild(i));\n\n        return e;\n      }\n\n      function M(e, t, n) {\n        var i,\n            r,\n            o,\n            s,\n            a = e.style;\n        return n = n || gt(e), n && (s = n.getPropertyValue(t) || n[t], "" !== s || ke.contains(e.ownerDocument, e) || (s = ke.style(e, t)), !be.pixelBoxStyles() && ft.test(s) && mt.test(t) && (i = a.width, r = a.minWidth, o = a.maxWidth, a.minWidth = a.maxWidth = a.width = s, s = n.width, a.width = i, a.minWidth = r, a.maxWidth = o)), void 0 !== s ? s + "" : s;\n      }\n\n      function R(e, t) {\n        return {\n          get: function () {\n            return e() ? void delete this.get : (this.get = t).apply(this, arguments);\n          }\n        };\n      }\n\n      function I(e) {\n        if (e in _t) return e;\n\n        for (var t = e[0].toUpperCase() + e.slice(1), n = bt.length; n--;) if (e = bt[n] + t, e in _t) return e;\n      }\n\n      function B(e) {\n        var t = ke.cssProps[e];\n        return t || (t = ke.cssProps[e] = I(e) || e), t;\n      }\n\n      function W(e, t, n) {\n        var i = Ze.exec(t);\n        return i ? Math.max(0, i[2] - (n || 0)) + (i[3] || "px") : t;\n      }\n\n      function F(e, t, n, i, r, o) {\n        var s = "width" === t ? 1 : 0,\n            a = 0,\n            l = 0;\n        if (n === (i ? "border" : "content")) return 0;\n\n        for (; s < 4; s += 2) "margin" === n && (l += ke.css(e, n + Je[s], !0, r)), i ? ("content" === n && (l -= ke.css(e, "padding" + Je[s], !0, r)), "margin" !== n && (l -= ke.css(e, "border" + Je[s] + "Width", !0, r))) : (l += ke.css(e, "padding" + Je[s], !0, r), "padding" !== n ? l += ke.css(e, "border" + Je[s] + "Width", !0, r) : a += ke.css(e, "border" + Je[s] + "Width", !0, r));\n\n        return !i && o >= 0 && (l += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - l - a - .5))), l;\n      }\n\n      function U(e, t, n) {\n        var i = gt(e),\n            r = M(e, t, i),\n            o = "border-box" === ke.css(e, "boxSizing", !1, i),\n            s = o;\n\n        if (ft.test(r)) {\n          if (!n) return r;\n          r = "auto";\n        }\n\n        return s = s && (be.boxSizingReliable() || r === e.style[t]), ("auto" === r || !parseFloat(r) && "inline" === ke.css(e, "display", !1, i)) && (r = e["offset" + t[0].toUpperCase() + t.slice(1)], s = !0), r = parseFloat(r) || 0, r + F(e, t, n || (o ? "border" : "content"), s, i, r) + "px";\n      }\n\n      function V(e, t, n, i, r) {\n        return new V.prototype.init(e, t, n, i, r);\n      }\n\n      function X() {\n        Tt && (ce.hidden === !1 && n.requestAnimationFrame ? n.requestAnimationFrame(X) : n.setTimeout(X, ke.fx.interval), ke.fx.tick());\n      }\n\n      function Y() {\n        return n.setTimeout(function () {\n          Ct = void 0;\n        }), Ct = Date.now();\n      }\n\n      function G(e, t) {\n        var n,\n            i = 0,\n            r = {\n          height: e\n        };\n\n        for (t = t ? 1 : 0; i < 4; i += 2 - t) n = Je[i], r["margin" + n] = r["padding" + n] = e;\n\n        return t && (r.opacity = r.width = e), r;\n      }\n\n      function Z(e, t, n) {\n        for (var i, r = (K.tweeners[t] || []).concat(K.tweeners["*"]), o = 0, s = r.length; o < s; o++) if (i = r[o].call(n, t, e)) return i;\n      }\n\n      function J(e, t, n) {\n        var i,\n            r,\n            o,\n            s,\n            a,\n            l,\n            u,\n            c,\n            h = "width" in t || "height" in t,\n            p = this,\n            d = {},\n            f = e.style,\n            g = e.nodeType && Qe(e),\n            m = Ue.get(e, "fxshow");\n        n.queue || (s = ke._queueHooks(e, "fx"), null == s.unqueued && (s.unqueued = 0, a = s.empty.fire, s.empty.fire = function () {\n          s.unqueued || a();\n        }), s.unqueued++, p.always(function () {\n          p.always(function () {\n            s.unqueued--, ke.queue(e, "fx").length || s.empty.fire();\n          });\n        }));\n\n        for (i in t) if (r = t[i], Et.test(r)) {\n          if (delete t[i], o = o || "toggle" === r, r === (g ? "hide" : "show")) {\n            if ("show" !== r || !m || void 0 === m[i]) continue;\n            g = !0;\n          }\n\n          d[i] = m && m[i] || ke.style(e, i);\n        }\n\n        if (l = !ke.isEmptyObject(t), l || !ke.isEmptyObject(d)) {\n          h && 1 === e.nodeType && (n.overflow = [f.overflow, f.overflowX, f.overflowY], u = m && m.display, null == u && (u = Ue.get(e, "display")), c = ke.css(e, "display"), "none" === c && (u ? c = u : (T([e], !0), u = e.style.display || u, c = ke.css(e, "display"), T([e]))), ("inline" === c || "inline-block" === c && null != u) && "none" === ke.css(e, "float") && (l || (p.done(function () {\n            f.display = u;\n          }), null == u && (c = f.display, u = "none" === c ? "" : c)), f.display = "inline-block")), n.overflow && (f.overflow = "hidden", p.always(function () {\n            f.overflow = n.overflow[0], f.overflowX = n.overflow[1], f.overflowY = n.overflow[2];\n          })), l = !1;\n\n          for (i in d) l || (m ? "hidden" in m && (g = m.hidden) : m = Ue.access(e, "fxshow", {\n            display: u\n          }), o && (m.hidden = !g), g && T([e], !0), p.done(function () {\n            g || T([e]), Ue.remove(e, "fxshow");\n\n            for (i in d) ke.style(e, i, d[i]);\n          })), l = Z(g ? m[i] : 0, i, p), i in m || (m[i] = l.start, g && (l.end = l.start, l.start = 0));\n        }\n      }\n\n      function Q(e, t) {\n        var n, i, r, o, s;\n\n        for (n in e) if (i = y(n), r = t[i], o = e[n], Array.isArray(o) && (r = o[1], o = e[n] = o[0]), n !== i && (e[i] = o, delete e[n]), s = ke.cssHooks[i], s && "expand" in s) {\n          o = s.expand(o), delete e[i];\n\n          for (n in o) n in e || (e[n] = o[n], t[n] = r);\n        } else t[i] = r;\n      }\n\n      function K(e, t, n) {\n        var i,\n            r,\n            o = 0,\n            s = K.prefilters.length,\n            a = ke.Deferred().always(function () {\n          delete l.elem;\n        }),\n            l = function () {\n          if (r) return !1;\n\n          for (var t = Ct || Y(), n = Math.max(0, u.startTime + u.duration - t), i = n / u.duration || 0, o = 1 - i, s = 0, l = u.tweens.length; s < l; s++) u.tweens[s].run(o);\n\n          return a.notifyWith(e, [u, o, n]), o < 1 && l ? n : (l || a.notifyWith(e, [u, 1, 0]), a.resolveWith(e, [u]), !1);\n        },\n            u = a.promise({\n          elem: e,\n          props: ke.extend({}, t),\n          opts: ke.extend(!0, {\n            specialEasing: {},\n            easing: ke.easing._default\n          }, n),\n          originalProperties: t,\n          originalOptions: n,\n          startTime: Ct || Y(),\n          duration: n.duration,\n          tweens: [],\n          createTween: function (t, n) {\n            var i = ke.Tween(e, u.opts, t, n, u.opts.specialEasing[t] || u.opts.easing);\n            return u.tweens.push(i), i;\n          },\n          stop: function (t) {\n            var n = 0,\n                i = t ? u.tweens.length : 0;\n            if (r) return this;\n\n            for (r = !0; n < i; n++) u.tweens[n].run(1);\n\n            return t ? (a.notifyWith(e, [u, 1, 0]), a.resolveWith(e, [u, t])) : a.rejectWith(e, [u, t]), this;\n          }\n        }),\n            c = u.props;\n\n        for (Q(c, u.opts.specialEasing); o < s; o++) if (i = K.prefilters[o].call(u, e, c, u.opts)) return _e(i.stop) && (ke._queueHooks(u.elem, u.opts.queue).stop = i.stop.bind(i)), i;\n\n        return ke.map(c, Z, u), _e(u.opts.start) && u.opts.start.call(e, u), u.progress(u.opts.progress).done(u.opts.done, u.opts.complete).fail(u.opts.fail).always(u.opts.always), ke.fx.timer(ke.extend(l, {\n          elem: e,\n          anim: u,\n          queue: u.opts.queue\n        })), u;\n      }\n\n      function ee(e) {\n        var t = e.match(qe) || [];\n        return t.join(" ");\n      }\n\n      function te(e) {\n        return e.getAttribute && e.getAttribute("class") || "";\n      }\n\n      function ne(e) {\n        return Array.isArray(e) ? e : "string" == typeof e ? e.match(qe) || [] : [];\n      }\n\n      function ie(e, t, n, i) {\n        var r;\n        if (Array.isArray(t)) ke.each(t, function (t, r) {\n          n || Ht.test(e) ? i(e, r) : ie(e + "[" + ("object" == typeof r && null != r ? t : "") + "]", r, n, i);\n        });else if (n || "object" !== a(t)) i(e, t);else for (r in t) ie(e + "[" + r + "]", t[r], n, i);\n      }\n\n      function re(e) {\n        return function (t, n) {\n          "string" != typeof t && (n = t, t = "*");\n          var i,\n              r = 0,\n              o = t.toLowerCase().match(qe) || [];\n          if (_e(n)) for (; i = o[r++];) "+" === i[0] ? (i = i.slice(1) || "*", (e[i] = e[i] || []).unshift(n)) : (e[i] = e[i] || []).push(n);\n        };\n      }\n\n      function oe(e, t, n, i) {\n        function r(a) {\n          var l;\n          return o[a] = !0, ke.each(e[a] || [], function (e, a) {\n            var u = a(t, n, i);\n            return "string" != typeof u || s || o[u] ? s ? !(l = u) : void 0 : (t.dataTypes.unshift(u), r(u), !1);\n          }), l;\n        }\n\n        var o = {},\n            s = e === Gt;\n        return r(t.dataTypes[0]) || !o["*"] && r("*");\n      }\n\n      function se(e, t) {\n        var n,\n            i,\n            r = ke.ajaxSettings.flatOptions || {};\n\n        for (n in t) void 0 !== t[n] && ((r[n] ? e : i || (i = {}))[n] = t[n]);\n\n        return i && ke.extend(!0, e, i), e;\n      }\n\n      function ae(e, t, n) {\n        for (var i, r, o, s, a = e.contents, l = e.dataTypes; "*" === l[0];) l.shift(), void 0 === i && (i = e.mimeType || t.getResponseHeader("Content-Type"));\n\n        if (i) for (r in a) if (a[r] && a[r].test(i)) {\n          l.unshift(r);\n          break;\n        }\n        if (l[0] in n) o = l[0];else {\n          for (r in n) {\n            if (!l[0] || e.converters[r + " " + l[0]]) {\n              o = r;\n              break;\n            }\n\n            s || (s = r);\n          }\n\n          o = o || s;\n        }\n        if (o) return o !== l[0] && l.unshift(o), n[o];\n      }\n\n      function le(e, t, n, i) {\n        var r,\n            o,\n            s,\n            a,\n            l,\n            u = {},\n            c = e.dataTypes.slice();\n        if (c[1]) for (s in e.converters) u[s.toLowerCase()] = e.converters[s];\n\n        for (o = c.shift(); o;) if (e.responseFields[o] && (n[e.responseFields[o]] = t), !l && i && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = o, o = c.shift()) if ("*" === o) o = l;else if ("*" !== l && l !== o) {\n          if (s = u[l + " " + o] || u["* " + o], !s) for (r in u) if (a = r.split(" "), a[1] === o && (s = u[l + " " + a[0]] || u["* " + a[0]])) {\n            s === !0 ? s = u[r] : u[r] !== !0 && (o = a[0], c.unshift(a[1]));\n            break;\n          }\n          if (s !== !0) if (s && e["throws"]) t = s(t);else try {\n            t = s(t);\n          } catch (h) {\n            return {\n              state: "parsererror",\n              error: s ? h : "No conversion from " + l + " to " + o\n            };\n          }\n        }\n\n        return {\n          state: "success",\n          data: t\n        };\n      }\n\n      var ue = [],\n          ce = n.document,\n          he = Object.getPrototypeOf,\n          pe = ue.slice,\n          de = ue.concat,\n          fe = ue.push,\n          ge = ue.indexOf,\n          me = {},\n          ve = me.toString,\n          ye = me.hasOwnProperty,\n          we = ye.toString,\n          xe = we.call(Object),\n          be = {},\n          _e = function (e) {\n        return "function" == typeof e && "number" != typeof e.nodeType;\n      },\n          Ce = function (e) {\n        return null != e && e === e.window;\n      },\n          Te = {\n        type: !0,\n        src: !0,\n        noModule: !0\n      },\n          Ee = "3.3.1",\n          ke = function (e, t) {\n        return new ke.fn.init(e, t);\n      },\n          Se = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\n      ke.fn = ke.prototype = {\n        jquery: Ee,\n        constructor: ke,\n        length: 0,\n        toArray: function () {\n          return pe.call(this);\n        },\n        get: function (e) {\n          return null == e ? pe.call(this) : e < 0 ? this[e + this.length] : this[e];\n        },\n        pushStack: function (e) {\n          var t = ke.merge(this.constructor(), e);\n          return t.prevObject = this, t;\n        },\n        each: function (e) {\n          return ke.each(this, e);\n        },\n        map: function (e) {\n          return this.pushStack(ke.map(this, function (t, n) {\n            return e.call(t, n, t);\n          }));\n        },\n        slice: function () {\n          return this.pushStack(pe.apply(this, arguments));\n        },\n        first: function () {\n          return this.eq(0);\n        },\n        last: function () {\n          return this.eq(-1);\n        },\n        eq: function (e) {\n          var t = this.length,\n              n = +e + (e < 0 ? t : 0);\n          return this.pushStack(n >= 0 && n < t ? [this[n]] : []);\n        },\n        end: function () {\n          return this.prevObject || this.constructor();\n        },\n        push: fe,\n        sort: ue.sort,\n        splice: ue.splice\n      }, ke.extend = ke.fn.extend = function () {\n        var e,\n            t,\n            n,\n            i,\n            r,\n            o,\n            s = arguments[0] || {},\n            a = 1,\n            l = arguments.length,\n            u = !1;\n\n        for ("boolean" == typeof s && (u = s, s = arguments[a] || {}, a++), "object" == typeof s || _e(s) || (s = {}), a === l && (s = this, a--); a < l; a++) if (null != (e = arguments[a])) for (t in e) n = s[t], i = e[t], s !== i && (u && i && (ke.isPlainObject(i) || (r = Array.isArray(i))) ? (r ? (r = !1, o = n && Array.isArray(n) ? n : []) : o = n && ke.isPlainObject(n) ? n : {}, s[t] = ke.extend(u, o, i)) : void 0 !== i && (s[t] = i));\n\n        return s;\n      }, ke.extend({\n        expando: "jQuery" + (Ee + Math.random()).replace(/\\D/g, ""),\n        isReady: !0,\n        error: function (e) {\n          throw new Error(e);\n        },\n        noop: function () {},\n        isPlainObject: function (e) {\n          var t, n;\n          return !(!e || "[object Object]" !== ve.call(e)) && (!(t = he(e)) || (n = ye.call(t, "constructor") && t.constructor, "function" == typeof n && we.call(n) === xe));\n        },\n        isEmptyObject: function (e) {\n          var t;\n\n          for (t in e) return !1;\n\n          return !0;\n        },\n        globalEval: function (e) {\n          s(e);\n        },\n        each: function (e, t) {\n          var n,\n              i = 0;\n          if (l(e)) for (n = e.length; i < n && t.call(e[i], i, e[i]) !== !1; i++);else for (i in e) if (t.call(e[i], i, e[i]) === !1) break;\n          return e;\n        },\n        trim: function (e) {\n          return null == e ? "" : (e + "").replace(Se, "");\n        },\n        makeArray: function (e, t) {\n          var n = t || [];\n          return null != e && (l(Object(e)) ? ke.merge(n, "string" == typeof e ? [e] : e) : fe.call(n, e)), n;\n        },\n        inArray: function (e, t, n) {\n          return null == t ? -1 : ge.call(t, e, n);\n        },\n        merge: function (e, t) {\n          for (var n = +t.length, i = 0, r = e.length; i < n; i++) e[r++] = t[i];\n\n          return e.length = r, e;\n        },\n        grep: function (e, t, n) {\n          for (var i, r = [], o = 0, s = e.length, a = !n; o < s; o++) i = !t(e[o], o), i !== a && r.push(e[o]);\n\n          return r;\n        },\n        map: function (e, t, n) {\n          var i,\n              r,\n              o = 0,\n              s = [];\n          if (l(e)) for (i = e.length; o < i; o++) r = t(e[o], o, n), null != r && s.push(r);else for (o in e) r = t(e[o], o, n), null != r && s.push(r);\n          return de.apply([], s);\n        },\n        guid: 1,\n        support: be\n      }), "function" == typeof Symbol && (ke.fn[Symbol.iterator] = ue[Symbol.iterator]), ke.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) {\n        me["[object " + t + "]"] = t.toLowerCase();\n      });\n\n      var De =\n      /*!\n      * Sizzle CSS Selector Engine v2.3.3\n      * https://sizzlejs.com/\n      *\n      * Copyright jQuery Foundation and other contributors\n      * Released under the MIT license\n      * http://jquery.org/license\n      *\n      * Date: 2016-08-08\n      */\n      function (e) {\n        function t(e, t, n, i) {\n          var r,\n              o,\n              s,\n              a,\n              l,\n              u,\n              c,\n              p = t && t.ownerDocument,\n              f = t ? t.nodeType : 9;\n          if (n = n || [], "string" != typeof e || !e || 1 !== f && 9 !== f && 11 !== f) return n;\n\n          if (!i && ((t ? t.ownerDocument || t : I) !== L && $(t), t = t || L, O)) {\n            if (11 !== f && (l = ve.exec(e))) if (r = l[1]) {\n              if (9 === f) {\n                if (!(s = t.getElementById(r))) return n;\n                if (s.id === r) return n.push(s), n;\n              } else if (p && (s = p.getElementById(r)) && M(t, s) && s.id === r) return n.push(s), n;\n            } else {\n              if (l[2]) return Q.apply(n, t.getElementsByTagName(e)), n;\n              if ((r = l[3]) && _.getElementsByClassName && t.getElementsByClassName) return Q.apply(n, t.getElementsByClassName(r)), n;\n            }\n\n            if (_.qsa && !V[e + " "] && (!P || !P.test(e))) {\n              if (1 !== f) p = t, c = e;else if ("object" !== t.nodeName.toLowerCase()) {\n                for ((a = t.getAttribute("id")) ? a = a.replace(be, _e) : t.setAttribute("id", a = R), u = k(e), o = u.length; o--;) u[o] = "#" + a + " " + d(u[o]);\n\n                c = u.join(","), p = ye.test(e) && h(t.parentNode) || t;\n              }\n              if (c) try {\n                return Q.apply(n, p.querySelectorAll(c)), n;\n              } catch (g) {} finally {\n                a === R && t.removeAttribute("id");\n              }\n            }\n          }\n\n          return D(e.replace(ae, "$1"), t, n, i);\n        }\n\n        function n() {\n          function e(n, i) {\n            return t.push(n + " ") > C.cacheLength && delete e[t.shift()], e[n + " "] = i;\n          }\n\n          var t = [];\n          return e;\n        }\n\n        function i(e) {\n          return e[R] = !0, e;\n        }\n\n        function r(e) {\n          var t = L.createElement("fieldset");\n\n          try {\n            return !!e(t);\n          } catch (n) {\n            return !1;\n          } finally {\n            t.parentNode && t.parentNode.removeChild(t), t = null;\n          }\n        }\n\n        function o(e, t) {\n          for (var n = e.split("|"), i = n.length; i--;) C.attrHandle[n[i]] = t;\n        }\n\n        function s(e, t) {\n          var n = t && e,\n              i = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;\n          if (i) return i;\n          if (n) for (; n = n.nextSibling;) if (n === t) return -1;\n          return e ? 1 : -1;\n        }\n\n        function a(e) {\n          return function (t) {\n            var n = t.nodeName.toLowerCase();\n            return "input" === n && t.type === e;\n          };\n        }\n\n        function l(e) {\n          return function (t) {\n            var n = t.nodeName.toLowerCase();\n            return ("input" === n || "button" === n) && t.type === e;\n          };\n        }\n\n        function u(e) {\n          return function (t) {\n            return "form" in t ? t.parentNode && t.disabled === !1 ? "label" in t ? "label" in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && Te(t) === e : t.disabled === e : "label" in t && t.disabled === e;\n          };\n        }\n\n        function c(e) {\n          return i(function (t) {\n            return t = +t, i(function (n, i) {\n              for (var r, o = e([], n.length, t), s = o.length; s--;) n[r = o[s]] && (n[r] = !(i[r] = n[r]));\n            });\n          });\n        }\n\n        function h(e) {\n          return e && "undefined" != typeof e.getElementsByTagName && e;\n        }\n\n        function p() {}\n\n        function d(e) {\n          for (var t = 0, n = e.length, i = ""; t < n; t++) i += e[t].value;\n\n          return i;\n        }\n\n        function f(e, t, n) {\n          var i = t.dir,\n              r = t.next,\n              o = r || i,\n              s = n && "parentNode" === o,\n              a = W++;\n          return t.first ? function (t, n, r) {\n            for (; t = t[i];) if (1 === t.nodeType || s) return e(t, n, r);\n\n            return !1;\n          } : function (t, n, l) {\n            var u,\n                c,\n                h,\n                p = [B, a];\n\n            if (l) {\n              for (; t = t[i];) if ((1 === t.nodeType || s) && e(t, n, l)) return !0;\n            } else for (; t = t[i];) if (1 === t.nodeType || s) if (h = t[R] || (t[R] = {}), c = h[t.uniqueID] || (h[t.uniqueID] = {}), r && r === t.nodeName.toLowerCase()) t = t[i] || t;else {\n              if ((u = c[o]) && u[0] === B && u[1] === a) return p[2] = u[2];\n              if (c[o] = p, p[2] = e(t, n, l)) return !0;\n            }\n\n            return !1;\n          };\n        }\n\n        function g(e) {\n          return e.length > 1 ? function (t, n, i) {\n            for (var r = e.length; r--;) if (!e[r](t, n, i)) return !1;\n\n            return !0;\n          } : e[0];\n        }\n\n        function m(e, n, i) {\n          for (var r = 0, o = n.length; r < o; r++) t(e, n[r], i);\n\n          return i;\n        }\n\n        function v(e, t, n, i, r) {\n          for (var o, s = [], a = 0, l = e.length, u = null != t; a < l; a++) (o = e[a]) && (n && !n(o, i, r) || (s.push(o), u && t.push(a)));\n\n          return s;\n        }\n\n        function y(e, t, n, r, o, s) {\n          return r && !r[R] && (r = y(r)), o && !o[R] && (o = y(o, s)), i(function (i, s, a, l) {\n            var u,\n                c,\n                h,\n                p = [],\n                d = [],\n                f = s.length,\n                g = i || m(t || "*", a.nodeType ? [a] : a, []),\n                y = !e || !i && t ? g : v(g, p, e, a, l),\n                w = n ? o || (i ? e : f || r) ? [] : s : y;\n            if (n && n(y, w, a, l), r) for (u = v(w, d), r(u, [], a, l), c = u.length; c--;) (h = u[c]) && (w[d[c]] = !(y[d[c]] = h));\n\n            if (i) {\n              if (o || e) {\n                if (o) {\n                  for (u = [], c = w.length; c--;) (h = w[c]) && u.push(y[c] = h);\n\n                  o(null, w = [], u, l);\n                }\n\n                for (c = w.length; c--;) (h = w[c]) && (u = o ? ee(i, h) : p[c]) > -1 && (i[u] = !(s[u] = h));\n              }\n            } else w = v(w === s ? w.splice(f, w.length) : w), o ? o(null, s, w, l) : Q.apply(s, w);\n          });\n        }\n\n        function w(e) {\n          for (var t, n, i, r = e.length, o = C.relative[e[0].type], s = o || C.relative[" "], a = o ? 1 : 0, l = f(function (e) {\n            return e === t;\n          }, s, !0), u = f(function (e) {\n            return ee(t, e) > -1;\n          }, s, !0), c = [function (e, n, i) {\n            var r = !o && (i || n !== N) || ((t = n).nodeType ? l(e, n, i) : u(e, n, i));\n            return t = null, r;\n          }]; a < r; a++) if (n = C.relative[e[a].type]) c = [f(g(c), n)];else {\n            if (n = C.filter[e[a].type].apply(null, e[a].matches), n[R]) {\n              for (i = ++a; i < r && !C.relative[e[i].type]; i++);\n\n              return y(a > 1 && g(c), a > 1 && d(e.slice(0, a - 1).concat({\n                value: " " === e[a - 2].type ? "*" : ""\n              })).replace(ae, "$1"), n, a < i && w(e.slice(a, i)), i < r && w(e = e.slice(i)), i < r && d(e));\n            }\n\n            c.push(n);\n          }\n\n          return g(c);\n        }\n\n        function x(e, n) {\n          var r = n.length > 0,\n              o = e.length > 0,\n              s = function (i, s, a, l, u) {\n            var c,\n                h,\n                p,\n                d = 0,\n                f = "0",\n                g = i && [],\n                m = [],\n                y = N,\n                w = i || o && C.find.TAG("*", u),\n                x = B += null == y ? 1 : Math.random() || .1,\n                b = w.length;\n\n            for (u && (N = s === L || s || u); f !== b && null != (c = w[f]); f++) {\n              if (o && c) {\n                for (h = 0, s || c.ownerDocument === L || ($(c), a = !O); p = e[h++];) if (p(c, s || L, a)) {\n                  l.push(c);\n                  break;\n                }\n\n                u && (B = x);\n              }\n\n              r && ((c = !p && c) && d--, i && g.push(c));\n            }\n\n            if (d += f, r && f !== d) {\n              for (h = 0; p = n[h++];) p(g, m, s, a);\n\n              if (i) {\n                if (d > 0) for (; f--;) g[f] || m[f] || (m[f] = Z.call(l));\n                m = v(m);\n              }\n\n              Q.apply(l, m), u && !i && m.length > 0 && d + n.length > 1 && t.uniqueSort(l);\n            }\n\n            return u && (B = x, N = y), g;\n          };\n\n          return r ? i(s) : s;\n        }\n\n        var b,\n            _,\n            C,\n            T,\n            E,\n            k,\n            S,\n            D,\n            N,\n            j,\n            A,\n            $,\n            L,\n            z,\n            O,\n            P,\n            H,\n            q,\n            M,\n            R = "sizzle" + 1 * new Date(),\n            I = e.document,\n            B = 0,\n            W = 0,\n            F = n(),\n            U = n(),\n            V = n(),\n            X = function (e, t) {\n          return e === t && (A = !0), 0;\n        },\n            Y = {}.hasOwnProperty,\n            G = [],\n            Z = G.pop,\n            J = G.push,\n            Q = G.push,\n            K = G.slice,\n            ee = function (e, t) {\n          for (var n = 0, i = e.length; n < i; n++) if (e[n] === t) return n;\n\n          return -1;\n        },\n            te = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",\n            ne = "[\\\\x20\\\\t\\\\r\\\\n\\\\f]",\n            ie = "(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+",\n            re = "\\\\[" + ne + "*(" + ie + ")(?:" + ne + "*([*^$|!~]?=)" + ne + "*(?:\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\"|(" + ie + "))|)" + ne + "*\\\\]",\n            oe = ":(" + ie + ")(?:\\\\(((\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|" + re + ")*)|.*)\\\\)|)",\n            se = new RegExp(ne + "+", "g"),\n            ae = new RegExp("^" + ne + "+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)" + ne + "+$", "g"),\n            le = new RegExp("^" + ne + "*," + ne + "*"),\n            ue = new RegExp("^" + ne + "*([>+~]|" + ne + ")" + ne + "*"),\n            ce = new RegExp("=" + ne + "*([^\\\\]\'\\"]*?)" + ne + "*\\\\]", "g"),\n            he = new RegExp(oe),\n            pe = new RegExp("^" + ie + "$"),\n            de = {\n          ID: new RegExp("^#(" + ie + ")"),\n          CLASS: new RegExp("^\\\\.(" + ie + ")"),\n          TAG: new RegExp("^(" + ie + "|[*])"),\n          ATTR: new RegExp("^" + re),\n          PSEUDO: new RegExp("^" + oe),\n          CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(" + ne + "*(even|odd|(([+-]|)(\\\\d*)n|)" + ne + "*(?:([+-]|)" + ne + "*(\\\\d+)|))" + ne + "*\\\\)|)", "i"),\n          bool: new RegExp("^(?:" + te + ")$", "i"),\n          needsContext: new RegExp("^" + ne + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(" + ne + "*((?:-\\\\d)?\\\\d*)" + ne + "*\\\\)|)(?=[^-]|$)", "i")\n        },\n            fe = /^(?:input|select|textarea|button)$/i,\n            ge = /^h\\d$/i,\n            me = /^[^{]+\\{\\s*\\[native \\w/,\n            ve = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n            ye = /[+~]/,\n            we = new RegExp("\\\\\\\\([\\\\da-f]{1,6}" + ne + "?|(" + ne + ")|.)", "ig"),\n            xe = function (e, t, n) {\n          var i = "0x" + t - 65536;\n          return i !== i || n ? t : i < 0 ? String.fromCharCode(i + 65536) : String.fromCharCode(i >> 10 | 55296, 1023 & i | 56320);\n        },\n            be = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n            _e = function (e, t) {\n          return t ? "\\0" === e ? "" : e.slice(0, -1) + "\\\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\\\" + e;\n        },\n            Ce = function () {\n          $();\n        },\n            Te = f(function (e) {\n          return e.disabled === !0 && ("form" in e || "label" in e);\n        }, {\n          dir: "parentNode",\n          next: "legend"\n        });\n\n        try {\n          Q.apply(G = K.call(I.childNodes), I.childNodes), G[I.childNodes.length].nodeType;\n        } catch (Ee) {\n          Q = {\n            apply: G.length ? function (e, t) {\n              J.apply(e, K.call(t));\n            } : function (e, t) {\n              for (var n = e.length, i = 0; e[n++] = t[i++];);\n\n              e.length = n - 1;\n            }\n          };\n        }\n\n        _ = t.support = {}, E = t.isXML = function (e) {\n          var t = e && (e.ownerDocument || e).documentElement;\n          return !!t && "HTML" !== t.nodeName;\n        }, $ = t.setDocument = function (e) {\n          var t,\n              n,\n              i = e ? e.ownerDocument || e : I;\n          return i !== L && 9 === i.nodeType && i.documentElement ? (L = i, z = L.documentElement, O = !E(L), I !== L && (n = L.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener("unload", Ce, !1) : n.attachEvent && n.attachEvent("onunload", Ce)), _.attributes = r(function (e) {\n            return e.className = "i", !e.getAttribute("className");\n          }), _.getElementsByTagName = r(function (e) {\n            return e.appendChild(L.createComment("")), !e.getElementsByTagName("*").length;\n          }), _.getElementsByClassName = me.test(L.getElementsByClassName), _.getById = r(function (e) {\n            return z.appendChild(e).id = R, !L.getElementsByName || !L.getElementsByName(R).length;\n          }), _.getById ? (C.filter.ID = function (e) {\n            var t = e.replace(we, xe);\n            return function (e) {\n              return e.getAttribute("id") === t;\n            };\n          }, C.find.ID = function (e, t) {\n            if ("undefined" != typeof t.getElementById && O) {\n              var n = t.getElementById(e);\n              return n ? [n] : [];\n            }\n          }) : (C.filter.ID = function (e) {\n            var t = e.replace(we, xe);\n            return function (e) {\n              var n = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id");\n              return n && n.value === t;\n            };\n          }, C.find.ID = function (e, t) {\n            if ("undefined" != typeof t.getElementById && O) {\n              var n,\n                  i,\n                  r,\n                  o = t.getElementById(e);\n\n              if (o) {\n                if (n = o.getAttributeNode("id"), n && n.value === e) return [o];\n\n                for (r = t.getElementsByName(e), i = 0; o = r[i++];) if (n = o.getAttributeNode("id"), n && n.value === e) return [o];\n              }\n\n              return [];\n            }\n          }), C.find.TAG = _.getElementsByTagName ? function (e, t) {\n            return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : _.qsa ? t.querySelectorAll(e) : void 0;\n          } : function (e, t) {\n            var n,\n                i = [],\n                r = 0,\n                o = t.getElementsByTagName(e);\n\n            if ("*" === e) {\n              for (; n = o[r++];) 1 === n.nodeType && i.push(n);\n\n              return i;\n            }\n\n            return o;\n          }, C.find.CLASS = _.getElementsByClassName && function (e, t) {\n            if ("undefined" != typeof t.getElementsByClassName && O) return t.getElementsByClassName(e);\n          }, H = [], P = [], (_.qsa = me.test(L.querySelectorAll)) && (r(function (e) {\n            z.appendChild(e).innerHTML = "<a id=\'" + R + "\'></a><select id=\'" + R + "-\\r\\\\\' msallowcapture=\'\'><option selected=\'\'></option></select>", e.querySelectorAll("[msallowcapture^=\'\']").length && P.push("[*^$]=" + ne + "*(?:\'\'|\\"\\")"), e.querySelectorAll("[selected]").length || P.push("\\\\[" + ne + "*(?:value|" + te + ")"), e.querySelectorAll("[id~=" + R + "-]").length || P.push("~="), e.querySelectorAll(":checked").length || P.push(":checked"), e.querySelectorAll("a#" + R + "+*").length || P.push(".#.+[+~]");\n          }), r(function (e) {\n            e.innerHTML = "<a href=\'\' disabled=\'disabled\'></a><select disabled=\'disabled\'><option/></select>";\n            var t = L.createElement("input");\n            t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && P.push("name" + ne + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && P.push(":enabled", ":disabled"), z.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && P.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), P.push(",.*:");\n          })), (_.matchesSelector = me.test(q = z.matches || z.webkitMatchesSelector || z.mozMatchesSelector || z.oMatchesSelector || z.msMatchesSelector)) && r(function (e) {\n            _.disconnectedMatch = q.call(e, "*"), q.call(e, "[s!=\'\']:x"), H.push("!=", oe);\n          }), P = P.length && new RegExp(P.join("|")), H = H.length && new RegExp(H.join("|")), t = me.test(z.compareDocumentPosition), M = t || me.test(z.contains) ? function (e, t) {\n            var n = 9 === e.nodeType ? e.documentElement : e,\n                i = t && t.parentNode;\n            return e === i || !(!i || 1 !== i.nodeType || !(n.contains ? n.contains(i) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(i)));\n          } : function (e, t) {\n            if (t) for (; t = t.parentNode;) if (t === e) return !0;\n            return !1;\n          }, X = t ? function (e, t) {\n            if (e === t) return A = !0, 0;\n            var n = !e.compareDocumentPosition - !t.compareDocumentPosition;\n            return n ? n : (n = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1, 1 & n || !_.sortDetached && t.compareDocumentPosition(e) === n ? e === L || e.ownerDocument === I && M(I, e) ? -1 : t === L || t.ownerDocument === I && M(I, t) ? 1 : j ? ee(j, e) - ee(j, t) : 0 : 4 & n ? -1 : 1);\n          } : function (e, t) {\n            if (e === t) return A = !0, 0;\n            var n,\n                i = 0,\n                r = e.parentNode,\n                o = t.parentNode,\n                a = [e],\n                l = [t];\n            if (!r || !o) return e === L ? -1 : t === L ? 1 : r ? -1 : o ? 1 : j ? ee(j, e) - ee(j, t) : 0;\n            if (r === o) return s(e, t);\n\n            for (n = e; n = n.parentNode;) a.unshift(n);\n\n            for (n = t; n = n.parentNode;) l.unshift(n);\n\n            for (; a[i] === l[i];) i++;\n\n            return i ? s(a[i], l[i]) : a[i] === I ? -1 : l[i] === I ? 1 : 0;\n          }, L) : L;\n        }, t.matches = function (e, n) {\n          return t(e, null, null, n);\n        }, t.matchesSelector = function (e, n) {\n          if ((e.ownerDocument || e) !== L && $(e), n = n.replace(ce, "=\'$1\']"), _.matchesSelector && O && !V[n + " "] && (!H || !H.test(n)) && (!P || !P.test(n))) try {\n            var i = q.call(e, n);\n            if (i || _.disconnectedMatch || e.document && 11 !== e.document.nodeType) return i;\n          } catch (r) {}\n          return t(n, L, null, [e]).length > 0;\n        }, t.contains = function (e, t) {\n          return (e.ownerDocument || e) !== L && $(e), M(e, t);\n        }, t.attr = function (e, t) {\n          (e.ownerDocument || e) !== L && $(e);\n          var n = C.attrHandle[t.toLowerCase()],\n              i = n && Y.call(C.attrHandle, t.toLowerCase()) ? n(e, t, !O) : void 0;\n          return void 0 !== i ? i : _.attributes || !O ? e.getAttribute(t) : (i = e.getAttributeNode(t)) && i.specified ? i.value : null;\n        }, t.escape = function (e) {\n          return (e + "").replace(be, _e);\n        }, t.error = function (e) {\n          throw new Error("Syntax error, unrecognized expression: " + e);\n        }, t.uniqueSort = function (e) {\n          var t,\n              n = [],\n              i = 0,\n              r = 0;\n\n          if (A = !_.detectDuplicates, j = !_.sortStable && e.slice(0), e.sort(X), A) {\n            for (; t = e[r++];) t === e[r] && (i = n.push(r));\n\n            for (; i--;) e.splice(n[i], 1);\n          }\n\n          return j = null, e;\n        }, T = t.getText = function (e) {\n          var t,\n              n = "",\n              i = 0,\n              r = e.nodeType;\n\n          if (r) {\n            if (1 === r || 9 === r || 11 === r) {\n              if ("string" == typeof e.textContent) return e.textContent;\n\n              for (e = e.firstChild; e; e = e.nextSibling) n += T(e);\n            } else if (3 === r || 4 === r) return e.nodeValue;\n          } else for (; t = e[i++];) n += T(t);\n\n          return n;\n        }, C = t.selectors = {\n          cacheLength: 50,\n          createPseudo: i,\n          match: de,\n          attrHandle: {},\n          find: {},\n          relative: {\n            ">": {\n              dir: "parentNode",\n              first: !0\n            },\n            " ": {\n              dir: "parentNode"\n            },\n            "+": {\n              dir: "previousSibling",\n              first: !0\n            },\n            "~": {\n              dir: "previousSibling"\n            }\n          },\n          preFilter: {\n            ATTR: function (e) {\n              return e[1] = e[1].replace(we, xe), e[3] = (e[3] || e[4] || e[5] || "").replace(we, xe), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4);\n            },\n            CHILD: function (e) {\n              return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || t.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && t.error(e[0]), e;\n            },\n            PSEUDO: function (e) {\n              var t,\n                  n = !e[6] && e[2];\n              return de.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && he.test(n) && (t = k(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3));\n            }\n          },\n          filter: {\n            TAG: function (e) {\n              var t = e.replace(we, xe).toLowerCase();\n              return "*" === e ? function () {\n                return !0;\n              } : function (e) {\n                return e.nodeName && e.nodeName.toLowerCase() === t;\n              };\n            },\n            CLASS: function (e) {\n              var t = F[e + " "];\n              return t || (t = new RegExp("(^|" + ne + ")" + e + "(" + ne + "|$)")) && F(e, function (e) {\n                return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "");\n              });\n            },\n            ATTR: function (e, n, i) {\n              return function (r) {\n                var o = t.attr(r, e);\n                return null == o ? "!=" === n : !n || (o += "", "=" === n ? o === i : "!=" === n ? o !== i : "^=" === n ? i && 0 === o.indexOf(i) : "*=" === n ? i && o.indexOf(i) > -1 : "$=" === n ? i && o.slice(-i.length) === i : "~=" === n ? (" " + o.replace(se, " ") + " ").indexOf(i) > -1 : "|=" === n && (o === i || o.slice(0, i.length + 1) === i + "-"));\n              };\n            },\n            CHILD: function (e, t, n, i, r) {\n              var o = "nth" !== e.slice(0, 3),\n                  s = "last" !== e.slice(-4),\n                  a = "of-type" === t;\n              return 1 === i && 0 === r ? function (e) {\n                return !!e.parentNode;\n              } : function (t, n, l) {\n                var u,\n                    c,\n                    h,\n                    p,\n                    d,\n                    f,\n                    g = o !== s ? "nextSibling" : "previousSibling",\n                    m = t.parentNode,\n                    v = a && t.nodeName.toLowerCase(),\n                    y = !l && !a,\n                    w = !1;\n\n                if (m) {\n                  if (o) {\n                    for (; g;) {\n                      for (p = t; p = p[g];) if (a ? p.nodeName.toLowerCase() === v : 1 === p.nodeType) return !1;\n\n                      f = g = "only" === e && !f && "nextSibling";\n                    }\n\n                    return !0;\n                  }\n\n                  if (f = [s ? m.firstChild : m.lastChild], s && y) {\n                    for (p = m, h = p[R] || (p[R] = {}), c = h[p.uniqueID] || (h[p.uniqueID] = {}), u = c[e] || [], d = u[0] === B && u[1], w = d && u[2], p = d && m.childNodes[d]; p = ++d && p && p[g] || (w = d = 0) || f.pop();) if (1 === p.nodeType && ++w && p === t) {\n                      c[e] = [B, d, w];\n                      break;\n                    }\n                  } else if (y && (p = t, h = p[R] || (p[R] = {}), c = h[p.uniqueID] || (h[p.uniqueID] = {}), u = c[e] || [], d = u[0] === B && u[1], w = d), w === !1) for (; (p = ++d && p && p[g] || (w = d = 0) || f.pop()) && ((a ? p.nodeName.toLowerCase() !== v : 1 !== p.nodeType) || !++w || (y && (h = p[R] || (p[R] = {}), c = h[p.uniqueID] || (h[p.uniqueID] = {}), c[e] = [B, w]), p !== t)););\n\n                  return w -= r, w === i || w % i === 0 && w / i >= 0;\n                }\n              };\n            },\n            PSEUDO: function (e, n) {\n              var r,\n                  o = C.pseudos[e] || C.setFilters[e.toLowerCase()] || t.error("unsupported pseudo: " + e);\n              return o[R] ? o(n) : o.length > 1 ? (r = [e, e, "", n], C.setFilters.hasOwnProperty(e.toLowerCase()) ? i(function (e, t) {\n                for (var i, r = o(e, n), s = r.length; s--;) i = ee(e, r[s]), e[i] = !(t[i] = r[s]);\n              }) : function (e) {\n                return o(e, 0, r);\n              }) : o;\n            }\n          },\n          pseudos: {\n            not: i(function (e) {\n              var t = [],\n                  n = [],\n                  r = S(e.replace(ae, "$1"));\n              return r[R] ? i(function (e, t, n, i) {\n                for (var o, s = r(e, null, i, []), a = e.length; a--;) (o = s[a]) && (e[a] = !(t[a] = o));\n              }) : function (e, i, o) {\n                return t[0] = e, r(t, null, o, n), t[0] = null, !n.pop();\n              };\n            }),\n            has: i(function (e) {\n              return function (n) {\n                return t(e, n).length > 0;\n              };\n            }),\n            contains: i(function (e) {\n              return e = e.replace(we, xe), function (t) {\n                return (t.textContent || t.innerText || T(t)).indexOf(e) > -1;\n              };\n            }),\n            lang: i(function (e) {\n              return pe.test(e || "") || t.error("unsupported lang: " + e), e = e.replace(we, xe).toLowerCase(), function (t) {\n                var n;\n\n                do if (n = O ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return n = n.toLowerCase(), n === e || 0 === n.indexOf(e + "-"); while ((t = t.parentNode) && 1 === t.nodeType);\n\n                return !1;\n              };\n            }),\n            target: function (t) {\n              var n = e.location && e.location.hash;\n              return n && n.slice(1) === t.id;\n            },\n            root: function (e) {\n              return e === z;\n            },\n            focus: function (e) {\n              return e === L.activeElement && (!L.hasFocus || L.hasFocus()) && !!(e.type || e.href || ~e.tabIndex);\n            },\n            enabled: u(!1),\n            disabled: u(!0),\n            checked: function (e) {\n              var t = e.nodeName.toLowerCase();\n              return "input" === t && !!e.checked || "option" === t && !!e.selected;\n            },\n            selected: function (e) {\n              return e.parentNode && e.parentNode.selectedIndex, e.selected === !0;\n            },\n            empty: function (e) {\n              for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType < 6) return !1;\n\n              return !0;\n            },\n            parent: function (e) {\n              return !C.pseudos.empty(e);\n            },\n            header: function (e) {\n              return ge.test(e.nodeName);\n            },\n            input: function (e) {\n              return fe.test(e.nodeName);\n            },\n            button: function (e) {\n              var t = e.nodeName.toLowerCase();\n              return "input" === t && "button" === e.type || "button" === t;\n            },\n            text: function (e) {\n              var t;\n              return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase());\n            },\n            first: c(function () {\n              return [0];\n            }),\n            last: c(function (e, t) {\n              return [t - 1];\n            }),\n            eq: c(function (e, t, n) {\n              return [n < 0 ? n + t : n];\n            }),\n            even: c(function (e, t) {\n              for (var n = 0; n < t; n += 2) e.push(n);\n\n              return e;\n            }),\n            odd: c(function (e, t) {\n              for (var n = 1; n < t; n += 2) e.push(n);\n\n              return e;\n            }),\n            lt: c(function (e, t, n) {\n              for (var i = n < 0 ? n + t : n; --i >= 0;) e.push(i);\n\n              return e;\n            }),\n            gt: c(function (e, t, n) {\n              for (var i = n < 0 ? n + t : n; ++i < t;) e.push(i);\n\n              return e;\n            })\n          }\n        }, C.pseudos.nth = C.pseudos.eq;\n\n        for (b in {\n          radio: !0,\n          checkbox: !0,\n          file: !0,\n          password: !0,\n          image: !0\n        }) C.pseudos[b] = a(b);\n\n        for (b in {\n          submit: !0,\n          reset: !0\n        }) C.pseudos[b] = l(b);\n\n        return p.prototype = C.filters = C.pseudos, C.setFilters = new p(), k = t.tokenize = function (e, n) {\n          var i,\n              r,\n              o,\n              s,\n              a,\n              l,\n              u,\n              c = U[e + " "];\n          if (c) return n ? 0 : c.slice(0);\n\n          for (a = e, l = [], u = C.preFilter; a;) {\n            i && !(r = le.exec(a)) || (r && (a = a.slice(r[0].length) || a), l.push(o = [])), i = !1, (r = ue.exec(a)) && (i = r.shift(), o.push({\n              value: i,\n              type: r[0].replace(ae, " ")\n            }), a = a.slice(i.length));\n\n            for (s in C.filter) !(r = de[s].exec(a)) || u[s] && !(r = u[s](r)) || (i = r.shift(), o.push({\n              value: i,\n              type: s,\n              matches: r\n            }), a = a.slice(i.length));\n\n            if (!i) break;\n          }\n\n          return n ? a.length : a ? t.error(e) : U(e, l).slice(0);\n        }, S = t.compile = function (e, t) {\n          var n,\n              i = [],\n              r = [],\n              o = V[e + " "];\n\n          if (!o) {\n            for (t || (t = k(e)), n = t.length; n--;) o = w(t[n]), o[R] ? i.push(o) : r.push(o);\n\n            o = V(e, x(r, i)), o.selector = e;\n          }\n\n          return o;\n        }, D = t.select = function (e, t, n, i) {\n          var r,\n              o,\n              s,\n              a,\n              l,\n              u = "function" == typeof e && e,\n              c = !i && k(e = u.selector || e);\n\n          if (n = n || [], 1 === c.length) {\n            if (o = c[0] = c[0].slice(0), o.length > 2 && "ID" === (s = o[0]).type && 9 === t.nodeType && O && C.relative[o[1].type]) {\n              if (t = (C.find.ID(s.matches[0].replace(we, xe), t) || [])[0], !t) return n;\n              u && (t = t.parentNode), e = e.slice(o.shift().value.length);\n            }\n\n            for (r = de.needsContext.test(e) ? 0 : o.length; r-- && (s = o[r], !C.relative[a = s.type]);) if ((l = C.find[a]) && (i = l(s.matches[0].replace(we, xe), ye.test(o[0].type) && h(t.parentNode) || t))) {\n              if (o.splice(r, 1), e = i.length && d(o), !e) return Q.apply(n, i), n;\n              break;\n            }\n          }\n\n          return (u || S(e, c))(i, t, !O, n, !t || ye.test(e) && h(t.parentNode) || t), n;\n        }, _.sortStable = R.split("").sort(X).join("") === R, _.detectDuplicates = !!A, $(), _.sortDetached = r(function (e) {\n          return 1 & e.compareDocumentPosition(L.createElement("fieldset"));\n        }), r(function (e) {\n          return e.innerHTML = "<a href=\'#\'></a>", "#" === e.firstChild.getAttribute("href");\n        }) || o("type|href|height|width", function (e, t, n) {\n          if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2);\n        }), _.attributes && r(function (e) {\n          return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value");\n        }) || o("value", function (e, t, n) {\n          if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue;\n        }), r(function (e) {\n          return null == e.getAttribute("disabled");\n        }) || o(te, function (e, t, n) {\n          var i;\n          if (!n) return e[t] === !0 ? t.toLowerCase() : (i = e.getAttributeNode(t)) && i.specified ? i.value : null;\n        }), t;\n      }(n);\n\n      ke.find = De, ke.expr = De.selectors, ke.expr[":"] = ke.expr.pseudos, ke.uniqueSort = ke.unique = De.uniqueSort, ke.text = De.getText, ke.isXMLDoc = De.isXML, ke.contains = De.contains, ke.escapeSelector = De.escape;\n\n      var Ne = function (e, t, n) {\n        for (var i = [], r = void 0 !== n; (e = e[t]) && 9 !== e.nodeType;) if (1 === e.nodeType) {\n          if (r && ke(e).is(n)) break;\n          i.push(e);\n        }\n\n        return i;\n      },\n          je = function (e, t) {\n        for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);\n\n        return n;\n      },\n          Ae = ke.expr.match.needsContext,\n          $e = /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i;\n\n      ke.filter = function (e, t, n) {\n        var i = t[0];\n        return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === i.nodeType ? ke.find.matchesSelector(i, e) ? [i] : [] : ke.find.matches(e, ke.grep(t, function (e) {\n          return 1 === e.nodeType;\n        }));\n      }, ke.fn.extend({\n        find: function (e) {\n          var t,\n              n,\n              i = this.length,\n              r = this;\n          if ("string" != typeof e) return this.pushStack(ke(e).filter(function () {\n            for (t = 0; t < i; t++) if (ke.contains(r[t], this)) return !0;\n          }));\n\n          for (n = this.pushStack([]), t = 0; t < i; t++) ke.find(e, r[t], n);\n\n          return i > 1 ? ke.uniqueSort(n) : n;\n        },\n        filter: function (e) {\n          return this.pushStack(c(this, e || [], !1));\n        },\n        not: function (e) {\n          return this.pushStack(c(this, e || [], !0));\n        },\n        is: function (e) {\n          return !!c(this, "string" == typeof e && Ae.test(e) ? ke(e) : e || [], !1).length;\n        }\n      });\n\n      var Le,\n          ze = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n          Oe = ke.fn.init = function (e, t, n) {\n        var i, r;\n        if (!e) return this;\n\n        if (n = n || Le, "string" == typeof e) {\n          if (i = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : ze.exec(e), !i || !i[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);\n\n          if (i[1]) {\n            if (t = t instanceof ke ? t[0] : t, ke.merge(this, ke.parseHTML(i[1], t && t.nodeType ? t.ownerDocument || t : ce, !0)), $e.test(i[1]) && ke.isPlainObject(t)) for (i in t) _e(this[i]) ? this[i](t[i]) : this.attr(i, t[i]);\n            return this;\n          }\n\n          return r = ce.getElementById(i[2]), r && (this[0] = r, this.length = 1), this;\n        }\n\n        return e.nodeType ? (this[0] = e, this.length = 1, this) : _e(e) ? void 0 !== n.ready ? n.ready(e) : e(ke) : ke.makeArray(e, this);\n      };\n\n      Oe.prototype = ke.fn, Le = ke(ce);\n      var Pe = /^(?:parents|prev(?:Until|All))/,\n          He = {\n        children: !0,\n        contents: !0,\n        next: !0,\n        prev: !0\n      };\n      ke.fn.extend({\n        has: function (e) {\n          var t = ke(e, this),\n              n = t.length;\n          return this.filter(function () {\n            for (var e = 0; e < n; e++) if (ke.contains(this, t[e])) return !0;\n          });\n        },\n        closest: function (e, t) {\n          var n,\n              i = 0,\n              r = this.length,\n              o = [],\n              s = "string" != typeof e && ke(e);\n          if (!Ae.test(e)) for (; i < r; i++) for (n = this[i]; n && n !== t; n = n.parentNode) if (n.nodeType < 11 && (s ? s.index(n) > -1 : 1 === n.nodeType && ke.find.matchesSelector(n, e))) {\n            o.push(n);\n            break;\n          }\n          return this.pushStack(o.length > 1 ? ke.uniqueSort(o) : o);\n        },\n        index: function (e) {\n          return e ? "string" == typeof e ? ge.call(ke(e), this[0]) : ge.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n        },\n        add: function (e, t) {\n          return this.pushStack(ke.uniqueSort(ke.merge(this.get(), ke(e, t))));\n        },\n        addBack: function (e) {\n          return this.add(null == e ? this.prevObject : this.prevObject.filter(e));\n        }\n      }), ke.each({\n        parent: function (e) {\n          var t = e.parentNode;\n          return t && 11 !== t.nodeType ? t : null;\n        },\n        parents: function (e) {\n          return Ne(e, "parentNode");\n        },\n        parentsUntil: function (e, t, n) {\n          return Ne(e, "parentNode", n);\n        },\n        next: function (e) {\n          return h(e, "nextSibling");\n        },\n        prev: function (e) {\n          return h(e, "previousSibling");\n        },\n        nextAll: function (e) {\n          return Ne(e, "nextSibling");\n        },\n        prevAll: function (e) {\n          return Ne(e, "previousSibling");\n        },\n        nextUntil: function (e, t, n) {\n          return Ne(e, "nextSibling", n);\n        },\n        prevUntil: function (e, t, n) {\n          return Ne(e, "previousSibling", n);\n        },\n        siblings: function (e) {\n          return je((e.parentNode || {}).firstChild, e);\n        },\n        children: function (e) {\n          return je(e.firstChild);\n        },\n        contents: function (e) {\n          return u(e, "iframe") ? e.contentDocument : (u(e, "template") && (e = e.content || e), ke.merge([], e.childNodes));\n        }\n      }, function (e, t) {\n        ke.fn[e] = function (n, i) {\n          var r = ke.map(this, t, n);\n          return "Until" !== e.slice(-5) && (i = n), i && "string" == typeof i && (r = ke.filter(i, r)), this.length > 1 && (He[e] || ke.uniqueSort(r), Pe.test(e) && r.reverse()), this.pushStack(r);\n        };\n      });\n      var qe = /[^\\x20\\t\\r\\n\\f]+/g;\n      ke.Callbacks = function (e) {\n        e = "string" == typeof e ? p(e) : ke.extend({}, e);\n\n        var t,\n            n,\n            i,\n            r,\n            o = [],\n            s = [],\n            l = -1,\n            u = function () {\n          for (r = r || e.once, i = t = !0; s.length; l = -1) for (n = s.shift(); ++l < o.length;) o[l].apply(n[0], n[1]) === !1 && e.stopOnFalse && (l = o.length, n = !1);\n\n          e.memory || (n = !1), t = !1, r && (o = n ? [] : "");\n        },\n            c = {\n          add: function () {\n            return o && (n && !t && (l = o.length - 1, s.push(n)), function i(t) {\n              ke.each(t, function (t, n) {\n                _e(n) ? e.unique && c.has(n) || o.push(n) : n && n.length && "string" !== a(n) && i(n);\n              });\n            }(arguments), n && !t && u()), this;\n          },\n          remove: function () {\n            return ke.each(arguments, function (e, t) {\n              for (var n; (n = ke.inArray(t, o, n)) > -1;) o.splice(n, 1), n <= l && l--;\n            }), this;\n          },\n          has: function (e) {\n            return e ? ke.inArray(e, o) > -1 : o.length > 0;\n          },\n          empty: function () {\n            return o && (o = []), this;\n          },\n          disable: function () {\n            return r = s = [], o = n = "", this;\n          },\n          disabled: function () {\n            return !o;\n          },\n          lock: function () {\n            return r = s = [], n || t || (o = n = ""), this;\n          },\n          locked: function () {\n            return !!r;\n          },\n          fireWith: function (e, n) {\n            return r || (n = n || [], n = [e, n.slice ? n.slice() : n], s.push(n), t || u()), this;\n          },\n          fire: function () {\n            return c.fireWith(this, arguments), this;\n          },\n          fired: function () {\n            return !!i;\n          }\n        };\n\n        return c;\n      }, ke.extend({\n        Deferred: function (e) {\n          var t = [["notify", "progress", ke.Callbacks("memory"), ke.Callbacks("memory"), 2], ["resolve", "done", ke.Callbacks("once memory"), ke.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", ke.Callbacks("once memory"), ke.Callbacks("once memory"), 1, "rejected"]],\n              i = "pending",\n              r = {\n            state: function () {\n              return i;\n            },\n            always: function () {\n              return o.done(arguments).fail(arguments), this;\n            },\n            "catch": function (e) {\n              return r.then(null, e);\n            },\n            pipe: function () {\n              var e = arguments;\n              return ke.Deferred(function (n) {\n                ke.each(t, function (t, i) {\n                  var r = _e(e[i[4]]) && e[i[4]];\n                  o[i[1]](function () {\n                    var e = r && r.apply(this, arguments);\n                    e && _e(e.promise) ? e.promise().progress(n.notify).done(n.resolve).fail(n.reject) : n[i[0] + "With"](this, r ? [e] : arguments);\n                  });\n                }), e = null;\n              }).promise();\n            },\n            then: function (e, i, r) {\n              function o(e, t, i, r) {\n                return function () {\n                  var a = this,\n                      l = arguments,\n                      u = function () {\n                    var n, u;\n\n                    if (!(e < s)) {\n                      if (n = i.apply(a, l), n === t.promise()) throw new TypeError("Thenable self-resolution");\n                      u = n && ("object" == typeof n || "function" == typeof n) && n.then, _e(u) ? r ? u.call(n, o(s, t, d, r), o(s, t, f, r)) : (s++, u.call(n, o(s, t, d, r), o(s, t, f, r), o(s, t, d, t.notifyWith))) : (i !== d && (a = void 0, l = [n]), (r || t.resolveWith)(a, l));\n                    }\n                  },\n                      c = r ? u : function () {\n                    try {\n                      u();\n                    } catch (n) {\n                      ke.Deferred.exceptionHook && ke.Deferred.exceptionHook(n, c.stackTrace), e + 1 >= s && (i !== f && (a = void 0, l = [n]), t.rejectWith(a, l));\n                    }\n                  };\n\n                  e ? c() : (ke.Deferred.getStackHook && (c.stackTrace = ke.Deferred.getStackHook()), n.setTimeout(c));\n                };\n              }\n\n              var s = 0;\n              return ke.Deferred(function (n) {\n                t[0][3].add(o(0, n, _e(r) ? r : d, n.notifyWith)), t[1][3].add(o(0, n, _e(e) ? e : d)), t[2][3].add(o(0, n, _e(i) ? i : f));\n              }).promise();\n            },\n            promise: function (e) {\n              return null != e ? ke.extend(e, r) : r;\n            }\n          },\n              o = {};\n          return ke.each(t, function (e, n) {\n            var s = n[2],\n                a = n[5];\n            r[n[1]] = s.add, a && s.add(function () {\n              i = a;\n            }, t[3 - e][2].disable, t[3 - e][3].disable, t[0][2].lock, t[0][3].lock), s.add(n[3].fire), o[n[0]] = function () {\n              return o[n[0] + "With"](this === o ? void 0 : this, arguments), this;\n            }, o[n[0] + "With"] = s.fireWith;\n          }), r.promise(o), e && e.call(o, o), o;\n        },\n        when: function (e) {\n          var t = arguments.length,\n              n = t,\n              i = Array(n),\n              r = pe.call(arguments),\n              o = ke.Deferred(),\n              s = function (e) {\n            return function (n) {\n              i[e] = this, r[e] = arguments.length > 1 ? pe.call(arguments) : n, --t || o.resolveWith(i, r);\n            };\n          };\n\n          if (t <= 1 && (g(e, o.done(s(n)).resolve, o.reject, !t), "pending" === o.state() || _e(r[n] && r[n].then))) return o.then();\n\n          for (; n--;) g(r[n], s(n), o.reject);\n\n          return o.promise();\n        }\n      });\n      var Me = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n      ke.Deferred.exceptionHook = function (e, t) {\n        n.console && n.console.warn && e && Me.test(e.name) && n.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t);\n      }, ke.readyException = function (e) {\n        n.setTimeout(function () {\n          throw e;\n        });\n      };\n      var Re = ke.Deferred();\n      ke.fn.ready = function (e) {\n        return Re.then(e)["catch"](function (e) {\n          ke.readyException(e);\n        }), this;\n      }, ke.extend({\n        isReady: !1,\n        readyWait: 1,\n        ready: function (e) {\n          (e === !0 ? --ke.readyWait : ke.isReady) || (ke.isReady = !0, e !== !0 && --ke.readyWait > 0 || Re.resolveWith(ce, [ke]));\n        }\n      }), ke.ready.then = Re.then, "complete" === ce.readyState || "loading" !== ce.readyState && !ce.documentElement.doScroll ? n.setTimeout(ke.ready) : (ce.addEventListener("DOMContentLoaded", m), n.addEventListener("load", m));\n\n      var Ie = function (e, t, n, i, r, o, s) {\n        var l = 0,\n            u = e.length,\n            c = null == n;\n\n        if ("object" === a(n)) {\n          r = !0;\n\n          for (l in n) Ie(e, t, l, n[l], !0, o, s);\n        } else if (void 0 !== i && (r = !0, _e(i) || (s = !0), c && (s ? (t.call(e, i), t = null) : (c = t, t = function (e, t, n) {\n          return c.call(ke(e), n);\n        })), t)) for (; l < u; l++) t(e[l], n, s ? i : i.call(e[l], l, t(e[l], n)));\n\n        return r ? e : c ? t.call(e) : u ? t(e[0], n) : o;\n      },\n          Be = /^-ms-/,\n          We = /-([a-z])/g,\n          Fe = function (e) {\n        return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType;\n      };\n\n      w.uid = 1, w.prototype = {\n        cache: function (e) {\n          var t = e[this.expando];\n          return t || (t = {}, Fe(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {\n            value: t,\n            configurable: !0\n          }))), t;\n        },\n        set: function (e, t, n) {\n          var i,\n              r = this.cache(e);\n          if ("string" == typeof t) r[y(t)] = n;else for (i in t) r[y(i)] = t[i];\n          return r;\n        },\n        get: function (e, t) {\n          return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][y(t)];\n        },\n        access: function (e, t, n) {\n          return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t);\n        },\n        remove: function (e, t) {\n          var n,\n              i = e[this.expando];\n\n          if (void 0 !== i) {\n            if (void 0 !== t) {\n              Array.isArray(t) ? t = t.map(y) : (t = y(t), t = t in i ? [t] : t.match(qe) || []), n = t.length;\n\n              for (; n--;) delete i[t[n]];\n            }\n\n            (void 0 === t || ke.isEmptyObject(i)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]);\n          }\n        },\n        hasData: function (e) {\n          var t = e[this.expando];\n          return void 0 !== t && !ke.isEmptyObject(t);\n        }\n      };\n      var Ue = new w(),\n          Ve = new w(),\n          Xe = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n          Ye = /[A-Z]/g;\n      ke.extend({\n        hasData: function (e) {\n          return Ve.hasData(e) || Ue.hasData(e);\n        },\n        data: function (e, t, n) {\n          return Ve.access(e, t, n);\n        },\n        removeData: function (e, t) {\n          Ve.remove(e, t);\n        },\n        _data: function (e, t, n) {\n          return Ue.access(e, t, n);\n        },\n        _removeData: function (e, t) {\n          Ue.remove(e, t);\n        }\n      }), ke.fn.extend({\n        data: function (e, t) {\n          var n,\n              i,\n              r,\n              o = this[0],\n              s = o && o.attributes;\n\n          if (void 0 === e) {\n            if (this.length && (r = Ve.get(o), 1 === o.nodeType && !Ue.get(o, "hasDataAttrs"))) {\n              for (n = s.length; n--;) s[n] && (i = s[n].name, 0 === i.indexOf("data-") && (i = y(i.slice(5)), b(o, i, r[i])));\n\n              Ue.set(o, "hasDataAttrs", !0);\n            }\n\n            return r;\n          }\n\n          return "object" == typeof e ? this.each(function () {\n            Ve.set(this, e);\n          }) : Ie(this, function (t) {\n            var n;\n\n            if (o && void 0 === t) {\n              if (n = Ve.get(o, e), void 0 !== n) return n;\n              if (n = b(o, e), void 0 !== n) return n;\n            } else this.each(function () {\n              Ve.set(this, e, t);\n            });\n          }, null, t, arguments.length > 1, null, !0);\n        },\n        removeData: function (e) {\n          return this.each(function () {\n            Ve.remove(this, e);\n          });\n        }\n      }), ke.extend({\n        queue: function (e, t, n) {\n          var i;\n          if (e) return t = (t || "fx") + "queue", i = Ue.get(e, t), n && (!i || Array.isArray(n) ? i = Ue.access(e, t, ke.makeArray(n)) : i.push(n)), i || [];\n        },\n        dequeue: function (e, t) {\n          t = t || "fx";\n\n          var n = ke.queue(e, t),\n              i = n.length,\n              r = n.shift(),\n              o = ke._queueHooks(e, t),\n              s = function () {\n            ke.dequeue(e, t);\n          };\n\n          "inprogress" === r && (r = n.shift(), i--), r && ("fx" === t && n.unshift("inprogress"), delete o.stop, r.call(e, s, o)), !i && o && o.empty.fire();\n        },\n        _queueHooks: function (e, t) {\n          var n = t + "queueHooks";\n          return Ue.get(e, n) || Ue.access(e, n, {\n            empty: ke.Callbacks("once memory").add(function () {\n              Ue.remove(e, [t + "queue", n]);\n            })\n          });\n        }\n      }), ke.fn.extend({\n        queue: function (e, t) {\n          var n = 2;\n          return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? ke.queue(this[0], e) : void 0 === t ? this : this.each(function () {\n            var n = ke.queue(this, e, t);\n            ke._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && ke.dequeue(this, e);\n          });\n        },\n        dequeue: function (e) {\n          return this.each(function () {\n            ke.dequeue(this, e);\n          });\n        },\n        clearQueue: function (e) {\n          return this.queue(e || "fx", []);\n        },\n        promise: function (e, t) {\n          var n,\n              i = 1,\n              r = ke.Deferred(),\n              o = this,\n              s = this.length,\n              a = function () {\n            --i || r.resolveWith(o, [o]);\n          };\n\n          for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; s--;) n = Ue.get(o[s], e + "queueHooks"), n && n.empty && (i++, n.empty.add(a));\n\n          return a(), r.promise(t);\n        }\n      });\n\n      var Ge = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n          Ze = new RegExp("^(?:([+-])=|)(" + Ge + ")([a-z%]*)$", "i"),\n          Je = ["Top", "Right", "Bottom", "Left"],\n          Qe = function (e, t) {\n        return e = t || e, "none" === e.style.display || "" === e.style.display && ke.contains(e.ownerDocument, e) && "none" === ke.css(e, "display");\n      },\n          Ke = function (e, t, n, i) {\n        var r,\n            o,\n            s = {};\n\n        for (o in t) s[o] = e.style[o], e.style[o] = t[o];\n\n        r = n.apply(e, i || []);\n\n        for (o in t) e.style[o] = s[o];\n\n        return r;\n      },\n          et = {};\n\n      ke.fn.extend({\n        show: function () {\n          return T(this, !0);\n        },\n        hide: function () {\n          return T(this);\n        },\n        toggle: function (e) {\n          return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () {\n            Qe(this) ? ke(this).show() : ke(this).hide();\n          });\n        }\n      });\n      var tt = /^(?:checkbox|radio)$/i,\n          nt = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i,\n          it = /^$|^module$|\\/(?:java|ecma)script/i,\n          rt = {\n        option: [1, "<select multiple=\'multiple\'>", "</select>"],\n        thead: [1, "<table>", "</table>"],\n        col: [2, "<table><colgroup>", "</colgroup></table>"],\n        tr: [2, "<table><tbody>", "</tbody></table>"],\n        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],\n        _default: [0, "", ""]\n      };\n      rt.optgroup = rt.option, rt.tbody = rt.tfoot = rt.colgroup = rt.caption = rt.thead, rt.th = rt.td;\n      var ot = /<|&#?\\w+;/;\n      !function () {\n        var e = ce.createDocumentFragment(),\n            t = e.appendChild(ce.createElement("div")),\n            n = ce.createElement("input");\n        n.setAttribute("type", "radio"), n.setAttribute("checked", "checked"), n.setAttribute("name", "t"), t.appendChild(n), be.checkClone = t.cloneNode(!0).cloneNode(!0).lastChild.checked, t.innerHTML = "<textarea>x</textarea>", be.noCloneChecked = !!t.cloneNode(!0).lastChild.defaultValue;\n      }();\n      var st = ce.documentElement,\n          at = /^key/,\n          lt = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n          ut = /^([^.]*)(?:\\.(.+)|)/;\n      ke.event = {\n        global: {},\n        add: function (e, t, n, i, r) {\n          var o,\n              s,\n              a,\n              l,\n              u,\n              c,\n              h,\n              p,\n              d,\n              f,\n              g,\n              m = Ue.get(e);\n          if (m) for (n.handler && (o = n, n = o.handler, r = o.selector), r && ke.find.matchesSelector(st, r), n.guid || (n.guid = ke.guid++), (l = m.events) || (l = m.events = {}), (s = m.handle) || (s = m.handle = function (t) {\n            return "undefined" != typeof ke && ke.event.triggered !== t.type ? ke.event.dispatch.apply(e, arguments) : void 0;\n          }), t = (t || "").match(qe) || [""], u = t.length; u--;) a = ut.exec(t[u]) || [], d = g = a[1], f = (a[2] || "").split(".").sort(), d && (h = ke.event.special[d] || {}, d = (r ? h.delegateType : h.bindType) || d, h = ke.event.special[d] || {}, c = ke.extend({\n            type: d,\n            origType: g,\n            data: i,\n            handler: n,\n            guid: n.guid,\n            selector: r,\n            needsContext: r && ke.expr.match.needsContext.test(r),\n            namespace: f.join(".")\n          }, o), (p = l[d]) || (p = l[d] = [], p.delegateCount = 0, h.setup && h.setup.call(e, i, f, s) !== !1 || e.addEventListener && e.addEventListener(d, s)), h.add && (h.add.call(e, c), c.handler.guid || (c.handler.guid = n.guid)), r ? p.splice(p.delegateCount++, 0, c) : p.push(c), ke.event.global[d] = !0);\n        },\n        remove: function (e, t, n, i, r) {\n          var o,\n              s,\n              a,\n              l,\n              u,\n              c,\n              h,\n              p,\n              d,\n              f,\n              g,\n              m = Ue.hasData(e) && Ue.get(e);\n\n          if (m && (l = m.events)) {\n            for (t = (t || "").match(qe) || [""], u = t.length; u--;) if (a = ut.exec(t[u]) || [], d = g = a[1], f = (a[2] || "").split(".").sort(), d) {\n              for (h = ke.event.special[d] || {}, d = (i ? h.delegateType : h.bindType) || d, p = l[d] || [], a = a[2] && new RegExp("(^|\\\\.)" + f.join("\\\\.(?:.*\\\\.|)") + "(\\\\.|$)"), s = o = p.length; o--;) c = p[o], !r && g !== c.origType || n && n.guid !== c.guid || a && !a.test(c.namespace) || i && i !== c.selector && ("**" !== i || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, h.remove && h.remove.call(e, c));\n\n              s && !p.length && (h.teardown && h.teardown.call(e, f, m.handle) !== !1 || ke.removeEvent(e, d, m.handle), delete l[d]);\n            } else for (d in l) ke.event.remove(e, d + t[u], n, i, !0);\n\n            ke.isEmptyObject(l) && Ue.remove(e, "handle events");\n          }\n        },\n        dispatch: function (e) {\n          var t,\n              n,\n              i,\n              r,\n              o,\n              s,\n              a = ke.event.fix(e),\n              l = new Array(arguments.length),\n              u = (Ue.get(this, "events") || {})[a.type] || [],\n              c = ke.event.special[a.type] || {};\n\n          for (l[0] = a, t = 1; t < arguments.length; t++) l[t] = arguments[t];\n\n          if (a.delegateTarget = this, !c.preDispatch || c.preDispatch.call(this, a) !== !1) {\n            for (s = ke.event.handlers.call(this, a, u), t = 0; (r = s[t++]) && !a.isPropagationStopped();) for (a.currentTarget = r.elem, n = 0; (o = r.handlers[n++]) && !a.isImmediatePropagationStopped();) a.rnamespace && !a.rnamespace.test(o.namespace) || (a.handleObj = o, a.data = o.data, i = ((ke.event.special[o.origType] || {}).handle || o.handler).apply(r.elem, l), void 0 !== i && (a.result = i) === !1 && (a.preventDefault(), a.stopPropagation()));\n\n            return c.postDispatch && c.postDispatch.call(this, a), a.result;\n          }\n        },\n        handlers: function (e, t) {\n          var n,\n              i,\n              r,\n              o,\n              s,\n              a = [],\n              l = t.delegateCount,\n              u = e.target;\n          if (l && u.nodeType && !("click" === e.type && e.button >= 1)) for (; u !== this; u = u.parentNode || this) if (1 === u.nodeType && ("click" !== e.type || u.disabled !== !0)) {\n            for (o = [], s = {}, n = 0; n < l; n++) i = t[n], r = i.selector + " ", void 0 === s[r] && (s[r] = i.needsContext ? ke(r, this).index(u) > -1 : ke.find(r, this, null, [u]).length), s[r] && o.push(i);\n\n            o.length && a.push({\n              elem: u,\n              handlers: o\n            });\n          }\n          return u = this, l < t.length && a.push({\n            elem: u,\n            handlers: t.slice(l)\n          }), a;\n        },\n        addProp: function (e, t) {\n          Object.defineProperty(ke.Event.prototype, e, {\n            enumerable: !0,\n            configurable: !0,\n            get: _e(t) ? function () {\n              if (this.originalEvent) return t(this.originalEvent);\n            } : function () {\n              if (this.originalEvent) return this.originalEvent[e];\n            },\n            set: function (t) {\n              Object.defineProperty(this, e, {\n                enumerable: !0,\n                configurable: !0,\n                writable: !0,\n                value: t\n              });\n            }\n          });\n        },\n        fix: function (e) {\n          return e[ke.expando] ? e : new ke.Event(e);\n        },\n        special: {\n          load: {\n            noBubble: !0\n          },\n          focus: {\n            trigger: function () {\n              if (this !== j() && this.focus) return this.focus(), !1;\n            },\n            delegateType: "focusin"\n          },\n          blur: {\n            trigger: function () {\n              if (this === j() && this.blur) return this.blur(), !1;\n            },\n            delegateType: "focusout"\n          },\n          click: {\n            trigger: function () {\n              if ("checkbox" === this.type && this.click && u(this, "input")) return this.click(), !1;\n            },\n            _default: function (e) {\n              return u(e.target, "a");\n            }\n          },\n          beforeunload: {\n            postDispatch: function (e) {\n              void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result);\n            }\n          }\n        }\n      }, ke.removeEvent = function (e, t, n) {\n        e.removeEventListener && e.removeEventListener(t, n);\n      }, ke.Event = function (e, t) {\n        return this instanceof ke.Event ? (e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && e.returnValue === !1 ? D : N, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && ke.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), void (this[ke.expando] = !0)) : new ke.Event(e, t);\n      }, ke.Event.prototype = {\n        constructor: ke.Event,\n        isDefaultPrevented: N,\n        isPropagationStopped: N,\n        isImmediatePropagationStopped: N,\n        isSimulated: !1,\n        preventDefault: function () {\n          var e = this.originalEvent;\n          this.isDefaultPrevented = D, e && !this.isSimulated && e.preventDefault();\n        },\n        stopPropagation: function () {\n          var e = this.originalEvent;\n          this.isPropagationStopped = D, e && !this.isSimulated && e.stopPropagation();\n        },\n        stopImmediatePropagation: function () {\n          var e = this.originalEvent;\n          this.isImmediatePropagationStopped = D, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation();\n        }\n      }, ke.each({\n        altKey: !0,\n        bubbles: !0,\n        cancelable: !0,\n        changedTouches: !0,\n        ctrlKey: !0,\n        detail: !0,\n        eventPhase: !0,\n        metaKey: !0,\n        pageX: !0,\n        pageY: !0,\n        shiftKey: !0,\n        view: !0,\n        "char": !0,\n        charCode: !0,\n        key: !0,\n        keyCode: !0,\n        button: !0,\n        buttons: !0,\n        clientX: !0,\n        clientY: !0,\n        offsetX: !0,\n        offsetY: !0,\n        pointerId: !0,\n        pointerType: !0,\n        screenX: !0,\n        screenY: !0,\n        targetTouches: !0,\n        toElement: !0,\n        touches: !0,\n        which: function (e) {\n          var t = e.button;\n          return null == e.which && at.test(e.type) ? null != e.charCode ? e.charCode : e.keyCode : !e.which && void 0 !== t && lt.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0 : e.which;\n        }\n      }, ke.event.addProp), ke.each({\n        mouseenter: "mouseover",\n        mouseleave: "mouseout",\n        pointerenter: "pointerover",\n        pointerleave: "pointerout"\n      }, function (e, t) {\n        ke.event.special[e] = {\n          delegateType: t,\n          bindType: t,\n          handle: function (e) {\n            var n,\n                i = this,\n                r = e.relatedTarget,\n                o = e.handleObj;\n            return r && (r === i || ke.contains(i, r)) || (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n;\n          }\n        };\n      }), ke.fn.extend({\n        on: function (e, t, n, i) {\n          return A(this, e, t, n, i);\n        },\n        one: function (e, t, n, i) {\n          return A(this, e, t, n, i, 1);\n        },\n        off: function (e, t, n) {\n          var i, r;\n          if (e && e.preventDefault && e.handleObj) return i = e.handleObj, ke(e.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler), this;\n\n          if ("object" == typeof e) {\n            for (r in e) this.off(r, t, e[r]);\n\n            return this;\n          }\n\n          return t !== !1 && "function" != typeof t || (n = t, t = void 0), n === !1 && (n = N), this.each(function () {\n            ke.event.remove(this, e, n, t);\n          });\n        }\n      });\n      var ct = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n          ht = /<script|<style|<link/i,\n          pt = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n          dt = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n      ke.extend({\n        htmlPrefilter: function (e) {\n          return e.replace(ct, "<$1></$2>");\n        },\n        clone: function (e, t, n) {\n          var i,\n              r,\n              o,\n              s,\n              a = e.cloneNode(!0),\n              l = ke.contains(e.ownerDocument, e);\n          if (!(be.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || ke.isXMLDoc(e))) for (s = E(a), o = E(e), i = 0, r = o.length; i < r; i++) P(o[i], s[i]);\n          if (t) if (n) for (o = o || E(e), s = s || E(a), i = 0, r = o.length; i < r; i++) O(o[i], s[i]);else O(e, a);\n          return s = E(a, "script"), s.length > 0 && k(s, !l && E(e, "script")), a;\n        },\n        cleanData: function (e) {\n          for (var t, n, i, r = ke.event.special, o = 0; void 0 !== (n = e[o]); o++) if (Fe(n)) {\n            if (t = n[Ue.expando]) {\n              if (t.events) for (i in t.events) r[i] ? ke.event.remove(n, i) : ke.removeEvent(n, i, t.handle);\n              n[Ue.expando] = void 0;\n            }\n\n            n[Ve.expando] && (n[Ve.expando] = void 0);\n          }\n        }\n      }), ke.fn.extend({\n        detach: function (e) {\n          return q(this, e, !0);\n        },\n        remove: function (e) {\n          return q(this, e);\n        },\n        text: function (e) {\n          return Ie(this, function (e) {\n            return void 0 === e ? ke.text(this) : this.empty().each(function () {\n              1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e);\n            });\n          }, null, e, arguments.length);\n        },\n        append: function () {\n          return H(this, arguments, function (e) {\n            if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n              var t = $(this, e);\n              t.appendChild(e);\n            }\n          });\n        },\n        prepend: function () {\n          return H(this, arguments, function (e) {\n            if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n              var t = $(this, e);\n              t.insertBefore(e, t.firstChild);\n            }\n          });\n        },\n        before: function () {\n          return H(this, arguments, function (e) {\n            this.parentNode && this.parentNode.insertBefore(e, this);\n          });\n        },\n        after: function () {\n          return H(this, arguments, function (e) {\n            this.parentNode && this.parentNode.insertBefore(e, this.nextSibling);\n          });\n        },\n        empty: function () {\n          for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (ke.cleanData(E(e, !1)), e.textContent = "");\n\n          return this;\n        },\n        clone: function (e, t) {\n          return e = null != e && e, t = null == t ? e : t, this.map(function () {\n            return ke.clone(this, e, t);\n          });\n        },\n        html: function (e) {\n          return Ie(this, function (e) {\n            var t = this[0] || {},\n                n = 0,\n                i = this.length;\n            if (void 0 === e && 1 === t.nodeType) return t.innerHTML;\n\n            if ("string" == typeof e && !ht.test(e) && !rt[(nt.exec(e) || ["", ""])[1].toLowerCase()]) {\n              e = ke.htmlPrefilter(e);\n\n              try {\n                for (; n < i; n++) t = this[n] || {}, 1 === t.nodeType && (ke.cleanData(E(t, !1)), t.innerHTML = e);\n\n                t = 0;\n              } catch (r) {}\n            }\n\n            t && this.empty().append(e);\n          }, null, e, arguments.length);\n        },\n        replaceWith: function () {\n          var e = [];\n          return H(this, arguments, function (t) {\n            var n = this.parentNode;\n            ke.inArray(this, e) < 0 && (ke.cleanData(E(this)), n && n.replaceChild(t, this));\n          }, e);\n        }\n      }), ke.each({\n        appendTo: "append",\n        prependTo: "prepend",\n        insertBefore: "before",\n        insertAfter: "after",\n        replaceAll: "replaceWith"\n      }, function (e, t) {\n        ke.fn[e] = function (e) {\n          for (var n, i = [], r = ke(e), o = r.length - 1, s = 0; s <= o; s++) n = s === o ? this : this.clone(!0), ke(r[s])[t](n), fe.apply(i, n.get());\n\n          return this.pushStack(i);\n        };\n      });\n\n      var ft = new RegExp("^(" + Ge + ")(?!px)[a-z%]+$", "i"),\n          gt = function (e) {\n        var t = e.ownerDocument.defaultView;\n        return t && t.opener || (t = n), t.getComputedStyle(e);\n      },\n          mt = new RegExp(Je.join("|"), "i");\n\n      !function () {\n        function e() {\n          if (u) {\n            l.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", u.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", st.appendChild(l).appendChild(u);\n            var e = n.getComputedStyle(u);\n            i = "1%" !== e.top, a = 12 === t(e.marginLeft), u.style.right = "60%", s = 36 === t(e.right), r = 36 === t(e.width), u.style.position = "absolute", o = 36 === u.offsetWidth || "absolute", st.removeChild(l), u = null;\n          }\n        }\n\n        function t(e) {\n          return Math.round(parseFloat(e));\n        }\n\n        var i,\n            r,\n            o,\n            s,\n            a,\n            l = ce.createElement("div"),\n            u = ce.createElement("div");\n        u.style && (u.style.backgroundClip = "content-box", u.cloneNode(!0).style.backgroundClip = "", be.clearCloneStyle = "content-box" === u.style.backgroundClip, ke.extend(be, {\n          boxSizingReliable: function () {\n            return e(), r;\n          },\n          pixelBoxStyles: function () {\n            return e(), s;\n          },\n          pixelPosition: function () {\n            return e(), i;\n          },\n          reliableMarginLeft: function () {\n            return e(), a;\n          },\n          scrollboxSize: function () {\n            return e(), o;\n          }\n        }));\n      }();\n      var vt = /^(none|table(?!-c[ea]).+)/,\n          yt = /^--/,\n          wt = {\n        position: "absolute",\n        visibility: "hidden",\n        display: "block"\n      },\n          xt = {\n        letterSpacing: "0",\n        fontWeight: "400"\n      },\n          bt = ["Webkit", "Moz", "ms"],\n          _t = ce.createElement("div").style;\n      ke.extend({\n        cssHooks: {\n          opacity: {\n            get: function (e, t) {\n              if (t) {\n                var n = M(e, "opacity");\n                return "" === n ? "1" : n;\n              }\n            }\n          }\n        },\n        cssNumber: {\n          animationIterationCount: !0,\n          columnCount: !0,\n          fillOpacity: !0,\n          flexGrow: !0,\n          flexShrink: !0,\n          fontWeight: !0,\n          lineHeight: !0,\n          opacity: !0,\n          order: !0,\n          orphans: !0,\n          widows: !0,\n          zIndex: !0,\n          zoom: !0\n        },\n        cssProps: {},\n        style: function (e, t, n, i) {\n          if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {\n            var r,\n                o,\n                s,\n                a = y(t),\n                l = yt.test(t),\n                u = e.style;\n            return l || (t = B(a)), s = ke.cssHooks[t] || ke.cssHooks[a], void 0 === n ? s && "get" in s && void 0 !== (r = s.get(e, !1, i)) ? r : u[t] : (o = typeof n, "string" === o && (r = Ze.exec(n)) && r[1] && (n = _(e, t, r), o = "number"), null != n && n === n && ("number" === o && (n += r && r[3] || (ke.cssNumber[a] ? "" : "px")), be.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (u[t] = "inherit"), s && "set" in s && void 0 === (n = s.set(e, n, i)) || (l ? u.setProperty(t, n) : u[t] = n)), void 0);\n          }\n        },\n        css: function (e, t, n, i) {\n          var r,\n              o,\n              s,\n              a = y(t),\n              l = yt.test(t);\n          return l || (t = B(a)), s = ke.cssHooks[t] || ke.cssHooks[a], s && "get" in s && (r = s.get(e, !0, n)), void 0 === r && (r = M(e, t, i)), "normal" === r && t in xt && (r = xt[t]), "" === n || n ? (o = parseFloat(r), n === !0 || isFinite(o) ? o || 0 : r) : r;\n        }\n      }), ke.each(["height", "width"], function (e, t) {\n        ke.cssHooks[t] = {\n          get: function (e, n, i) {\n            if (n) return !vt.test(ke.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? U(e, t, i) : Ke(e, wt, function () {\n              return U(e, t, i);\n            });\n          },\n          set: function (e, n, i) {\n            var r,\n                o = gt(e),\n                s = "border-box" === ke.css(e, "boxSizing", !1, o),\n                a = i && F(e, t, i, s, o);\n            return s && be.scrollboxSize() === o.position && (a -= Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - parseFloat(o[t]) - F(e, t, "border", !1, o) - .5)), a && (r = Ze.exec(n)) && "px" !== (r[3] || "px") && (e.style[t] = n, n = ke.css(e, t)), W(e, n, a);\n          }\n        };\n      }), ke.cssHooks.marginLeft = R(be.reliableMarginLeft, function (e, t) {\n        if (t) return (parseFloat(M(e, "marginLeft")) || e.getBoundingClientRect().left - Ke(e, {\n          marginLeft: 0\n        }, function () {\n          return e.getBoundingClientRect().left;\n        })) + "px";\n      }), ke.each({\n        margin: "",\n        padding: "",\n        border: "Width"\n      }, function (e, t) {\n        ke.cssHooks[e + t] = {\n          expand: function (n) {\n            for (var i = 0, r = {}, o = "string" == typeof n ? n.split(" ") : [n]; i < 4; i++) r[e + Je[i] + t] = o[i] || o[i - 2] || o[0];\n\n            return r;\n          }\n        }, "margin" !== e && (ke.cssHooks[e + t].set = W);\n      }), ke.fn.extend({\n        css: function (e, t) {\n          return Ie(this, function (e, t, n) {\n            var i,\n                r,\n                o = {},\n                s = 0;\n\n            if (Array.isArray(t)) {\n              for (i = gt(e), r = t.length; s < r; s++) o[t[s]] = ke.css(e, t[s], !1, i);\n\n              return o;\n            }\n\n            return void 0 !== n ? ke.style(e, t, n) : ke.css(e, t);\n          }, e, t, arguments.length > 1);\n        }\n      }), ke.Tween = V, V.prototype = {\n        constructor: V,\n        init: function (e, t, n, i, r, o) {\n          this.elem = e, this.prop = n, this.easing = r || ke.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = i, this.unit = o || (ke.cssNumber[n] ? "" : "px");\n        },\n        cur: function () {\n          var e = V.propHooks[this.prop];\n          return e && e.get ? e.get(this) : V.propHooks._default.get(this);\n        },\n        run: function (e) {\n          var t,\n              n = V.propHooks[this.prop];\n          return this.options.duration ? this.pos = t = ke.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : V.propHooks._default.set(this), this;\n        }\n      }, V.prototype.init.prototype = V.prototype, V.propHooks = {\n        _default: {\n          get: function (e) {\n            var t;\n            return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = ke.css(e.elem, e.prop, ""), t && "auto" !== t ? t : 0);\n          },\n          set: function (e) {\n            ke.fx.step[e.prop] ? ke.fx.step[e.prop](e) : 1 !== e.elem.nodeType || null == e.elem.style[ke.cssProps[e.prop]] && !ke.cssHooks[e.prop] ? e.elem[e.prop] = e.now : ke.style(e.elem, e.prop, e.now + e.unit);\n          }\n        }\n      }, V.propHooks.scrollTop = V.propHooks.scrollLeft = {\n        set: function (e) {\n          e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now);\n        }\n      }, ke.easing = {\n        linear: function (e) {\n          return e;\n        },\n        swing: function (e) {\n          return .5 - Math.cos(e * Math.PI) / 2;\n        },\n        _default: "swing"\n      }, ke.fx = V.prototype.init, ke.fx.step = {};\n      var Ct,\n          Tt,\n          Et = /^(?:toggle|show|hide)$/,\n          kt = /queueHooks$/;\n      ke.Animation = ke.extend(K, {\n        tweeners: {\n          "*": [function (e, t) {\n            var n = this.createTween(e, t);\n            return _(n.elem, e, Ze.exec(t), n), n;\n          }]\n        },\n        tweener: function (e, t) {\n          _e(e) ? (t = e, e = ["*"]) : e = e.match(qe);\n\n          for (var n, i = 0, r = e.length; i < r; i++) n = e[i], K.tweeners[n] = K.tweeners[n] || [], K.tweeners[n].unshift(t);\n        },\n        prefilters: [J],\n        prefilter: function (e, t) {\n          t ? K.prefilters.unshift(e) : K.prefilters.push(e);\n        }\n      }), ke.speed = function (e, t, n) {\n        var i = e && "object" == typeof e ? ke.extend({}, e) : {\n          complete: n || !n && t || _e(e) && e,\n          duration: e,\n          easing: n && t || t && !_e(t) && t\n        };\n        return ke.fx.off ? i.duration = 0 : "number" != typeof i.duration && (i.duration in ke.fx.speeds ? i.duration = ke.fx.speeds[i.duration] : i.duration = ke.fx.speeds._default), null != i.queue && i.queue !== !0 || (i.queue = "fx"), i.old = i.complete, i.complete = function () {\n          _e(i.old) && i.old.call(this), i.queue && ke.dequeue(this, i.queue);\n        }, i;\n      }, ke.fn.extend({\n        fadeTo: function (e, t, n, i) {\n          return this.filter(Qe).css("opacity", 0).show().end().animate({\n            opacity: t\n          }, e, n, i);\n        },\n        animate: function (e, t, n, i) {\n          var r = ke.isEmptyObject(e),\n              o = ke.speed(t, n, i),\n              s = function () {\n            var t = K(this, ke.extend({}, e), o);\n            (r || Ue.get(this, "finish")) && t.stop(!0);\n          };\n\n          return s.finish = s, r || o.queue === !1 ? this.each(s) : this.queue(o.queue, s);\n        },\n        stop: function (e, t, n) {\n          var i = function (e) {\n            var t = e.stop;\n            delete e.stop, t(n);\n          };\n\n          return "string" != typeof e && (n = t, t = e, e = void 0), t && e !== !1 && this.queue(e || "fx", []), this.each(function () {\n            var t = !0,\n                r = null != e && e + "queueHooks",\n                o = ke.timers,\n                s = Ue.get(this);\n            if (r) s[r] && s[r].stop && i(s[r]);else for (r in s) s[r] && s[r].stop && kt.test(r) && i(s[r]);\n\n            for (r = o.length; r--;) o[r].elem !== this || null != e && o[r].queue !== e || (o[r].anim.stop(n), t = !1, o.splice(r, 1));\n\n            !t && n || ke.dequeue(this, e);\n          });\n        },\n        finish: function (e) {\n          return e !== !1 && (e = e || "fx"), this.each(function () {\n            var t,\n                n = Ue.get(this),\n                i = n[e + "queue"],\n                r = n[e + "queueHooks"],\n                o = ke.timers,\n                s = i ? i.length : 0;\n\n            for (n.finish = !0, ke.queue(this, e, []), r && r.stop && r.stop.call(this, !0), t = o.length; t--;) o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1));\n\n            for (t = 0; t < s; t++) i[t] && i[t].finish && i[t].finish.call(this);\n\n            delete n.finish;\n          });\n        }\n      }), ke.each(["toggle", "show", "hide"], function (e, t) {\n        var n = ke.fn[t];\n\n        ke.fn[t] = function (e, i, r) {\n          return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(G(t, !0), e, i, r);\n        };\n      }), ke.each({\n        slideDown: G("show"),\n        slideUp: G("hide"),\n        slideToggle: G("toggle"),\n        fadeIn: {\n          opacity: "show"\n        },\n        fadeOut: {\n          opacity: "hide"\n        },\n        fadeToggle: {\n          opacity: "toggle"\n        }\n      }, function (e, t) {\n        ke.fn[e] = function (e, n, i) {\n          return this.animate(t, e, n, i);\n        };\n      }), ke.timers = [], ke.fx.tick = function () {\n        var e,\n            t = 0,\n            n = ke.timers;\n\n        for (Ct = Date.now(); t < n.length; t++) e = n[t], e() || n[t] !== e || n.splice(t--, 1);\n\n        n.length || ke.fx.stop(), Ct = void 0;\n      }, ke.fx.timer = function (e) {\n        ke.timers.push(e), ke.fx.start();\n      }, ke.fx.interval = 13, ke.fx.start = function () {\n        Tt || (Tt = !0, X());\n      }, ke.fx.stop = function () {\n        Tt = null;\n      }, ke.fx.speeds = {\n        slow: 600,\n        fast: 200,\n        _default: 400\n      }, ke.fn.delay = function (e, t) {\n        return e = ke.fx ? ke.fx.speeds[e] || e : e, t = t || "fx", this.queue(t, function (t, i) {\n          var r = n.setTimeout(t, e);\n\n          i.stop = function () {\n            n.clearTimeout(r);\n          };\n        });\n      }, function () {\n        var e = ce.createElement("input"),\n            t = ce.createElement("select"),\n            n = t.appendChild(ce.createElement("option"));\n        e.type = "checkbox", be.checkOn = "" !== e.value, be.optSelected = n.selected, e = ce.createElement("input"), e.value = "t", e.type = "radio", be.radioValue = "t" === e.value;\n      }();\n      var St,\n          Dt = ke.expr.attrHandle;\n      ke.fn.extend({\n        attr: function (e, t) {\n          return Ie(this, ke.attr, e, t, arguments.length > 1);\n        },\n        removeAttr: function (e) {\n          return this.each(function () {\n            ke.removeAttr(this, e);\n          });\n        }\n      }), ke.extend({\n        attr: function (e, t, n) {\n          var i,\n              r,\n              o = e.nodeType;\n          if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? ke.prop(e, t, n) : (1 === o && ke.isXMLDoc(e) || (r = ke.attrHooks[t.toLowerCase()] || (ke.expr.match.bool.test(t) ? St : void 0)), void 0 !== n ? null === n ? void ke.removeAttr(e, t) : r && "set" in r && void 0 !== (i = r.set(e, n, t)) ? i : (e.setAttribute(t, n + ""), n) : r && "get" in r && null !== (i = r.get(e, t)) ? i : (i = ke.find.attr(e, t), null == i ? void 0 : i));\n        },\n        attrHooks: {\n          type: {\n            set: function (e, t) {\n              if (!be.radioValue && "radio" === t && u(e, "input")) {\n                var n = e.value;\n                return e.setAttribute("type", t), n && (e.value = n), t;\n              }\n            }\n          }\n        },\n        removeAttr: function (e, t) {\n          var n,\n              i = 0,\n              r = t && t.match(qe);\n          if (r && 1 === e.nodeType) for (; n = r[i++];) e.removeAttribute(n);\n        }\n      }), St = {\n        set: function (e, t, n) {\n          return t === !1 ? ke.removeAttr(e, n) : e.setAttribute(n, n), n;\n        }\n      }, ke.each(ke.expr.match.bool.source.match(/\\w+/g), function (e, t) {\n        var n = Dt[t] || ke.find.attr;\n\n        Dt[t] = function (e, t, i) {\n          var r,\n              o,\n              s = t.toLowerCase();\n          return i || (o = Dt[s], Dt[s] = r, r = null != n(e, t, i) ? s : null, Dt[s] = o), r;\n        };\n      });\n      var Nt = /^(?:input|select|textarea|button)$/i,\n          jt = /^(?:a|area)$/i;\n      ke.fn.extend({\n        prop: function (e, t) {\n          return Ie(this, ke.prop, e, t, arguments.length > 1);\n        },\n        removeProp: function (e) {\n          return this.each(function () {\n            delete this[ke.propFix[e] || e];\n          });\n        }\n      }), ke.extend({\n        prop: function (e, t, n) {\n          var i,\n              r,\n              o = e.nodeType;\n          if (3 !== o && 8 !== o && 2 !== o) return 1 === o && ke.isXMLDoc(e) || (t = ke.propFix[t] || t, r = ke.propHooks[t]), void 0 !== n ? r && "set" in r && void 0 !== (i = r.set(e, n, t)) ? i : e[t] = n : r && "get" in r && null !== (i = r.get(e, t)) ? i : e[t];\n        },\n        propHooks: {\n          tabIndex: {\n            get: function (e) {\n              var t = ke.find.attr(e, "tabindex");\n              return t ? parseInt(t, 10) : Nt.test(e.nodeName) || jt.test(e.nodeName) && e.href ? 0 : -1;\n            }\n          }\n        },\n        propFix: {\n          "for": "htmlFor",\n          "class": "className"\n        }\n      }), be.optSelected || (ke.propHooks.selected = {\n        get: function (e) {\n          var t = e.parentNode;\n          return t && t.parentNode && t.parentNode.selectedIndex, null;\n        },\n        set: function (e) {\n          var t = e.parentNode;\n          t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex);\n        }\n      }), ke.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {\n        ke.propFix[this.toLowerCase()] = this;\n      }), ke.fn.extend({\n        addClass: function (e) {\n          var t,\n              n,\n              i,\n              r,\n              o,\n              s,\n              a,\n              l = 0;\n          if (_e(e)) return this.each(function (t) {\n            ke(this).addClass(e.call(this, t, te(this)));\n          });\n          if (t = ne(e), t.length) for (; n = this[l++];) if (r = te(n), i = 1 === n.nodeType && " " + ee(r) + " ") {\n            for (s = 0; o = t[s++];) i.indexOf(" " + o + " ") < 0 && (i += o + " ");\n\n            a = ee(i), r !== a && n.setAttribute("class", a);\n          }\n          return this;\n        },\n        removeClass: function (e) {\n          var t,\n              n,\n              i,\n              r,\n              o,\n              s,\n              a,\n              l = 0;\n          if (_e(e)) return this.each(function (t) {\n            ke(this).removeClass(e.call(this, t, te(this)));\n          });\n          if (!arguments.length) return this.attr("class", "");\n          if (t = ne(e), t.length) for (; n = this[l++];) if (r = te(n), i = 1 === n.nodeType && " " + ee(r) + " ") {\n            for (s = 0; o = t[s++];) for (; i.indexOf(" " + o + " ") > -1;) i = i.replace(" " + o + " ", " ");\n\n            a = ee(i), r !== a && n.setAttribute("class", a);\n          }\n          return this;\n        },\n        toggleClass: function (e, t) {\n          var n = typeof e,\n              i = "string" === n || Array.isArray(e);\n          return "boolean" == typeof t && i ? t ? this.addClass(e) : this.removeClass(e) : _e(e) ? this.each(function (n) {\n            ke(this).toggleClass(e.call(this, n, te(this), t), t);\n          }) : this.each(function () {\n            var t, r, o, s;\n            if (i) for (r = 0, o = ke(this), s = ne(e); t = s[r++];) o.hasClass(t) ? o.removeClass(t) : o.addClass(t);else void 0 !== e && "boolean" !== n || (t = te(this), t && Ue.set(this, "__className__", t), this.setAttribute && this.setAttribute("class", t || e === !1 ? "" : Ue.get(this, "__className__") || ""));\n          });\n        },\n        hasClass: function (e) {\n          var t,\n              n,\n              i = 0;\n\n          for (t = " " + e + " "; n = this[i++];) if (1 === n.nodeType && (" " + ee(te(n)) + " ").indexOf(t) > -1) return !0;\n\n          return !1;\n        }\n      });\n      var At = /\\r/g;\n      ke.fn.extend({\n        val: function (e) {\n          var t,\n              n,\n              i,\n              r = this[0];\n          {\n            if (arguments.length) return i = _e(e), this.each(function (n) {\n              var r;\n              1 === this.nodeType && (r = i ? e.call(this, n, ke(this).val()) : e, null == r ? r = "" : "number" == typeof r ? r += "" : Array.isArray(r) && (r = ke.map(r, function (e) {\n                return null == e ? "" : e + "";\n              })), t = ke.valHooks[this.type] || ke.valHooks[this.nodeName.toLowerCase()], t && "set" in t && void 0 !== t.set(this, r, "value") || (this.value = r));\n            });\n            if (r) return t = ke.valHooks[r.type] || ke.valHooks[r.nodeName.toLowerCase()], t && "get" in t && void 0 !== (n = t.get(r, "value")) ? n : (n = r.value, "string" == typeof n ? n.replace(At, "") : null == n ? "" : n);\n          }\n        }\n      }), ke.extend({\n        valHooks: {\n          option: {\n            get: function (e) {\n              var t = ke.find.attr(e, "value");\n              return null != t ? t : ee(ke.text(e));\n            }\n          },\n          select: {\n            get: function (e) {\n              var t,\n                  n,\n                  i,\n                  r = e.options,\n                  o = e.selectedIndex,\n                  s = "select-one" === e.type,\n                  a = s ? null : [],\n                  l = s ? o + 1 : r.length;\n\n              for (i = o < 0 ? l : s ? o : 0; i < l; i++) if (n = r[i], (n.selected || i === o) && !n.disabled && (!n.parentNode.disabled || !u(n.parentNode, "optgroup"))) {\n                if (t = ke(n).val(), s) return t;\n                a.push(t);\n              }\n\n              return a;\n            },\n            set: function (e, t) {\n              for (var n, i, r = e.options, o = ke.makeArray(t), s = r.length; s--;) i = r[s], (i.selected = ke.inArray(ke.valHooks.option.get(i), o) > -1) && (n = !0);\n\n              return n || (e.selectedIndex = -1), o;\n            }\n          }\n        }\n      }), ke.each(["radio", "checkbox"], function () {\n        ke.valHooks[this] = {\n          set: function (e, t) {\n            if (Array.isArray(t)) return e.checked = ke.inArray(ke(e).val(), t) > -1;\n          }\n        }, be.checkOn || (ke.valHooks[this].get = function (e) {\n          return null === e.getAttribute("value") ? "on" : e.value;\n        });\n      }), be.focusin = "onfocusin" in n;\n\n      var $t = /^(?:focusinfocus|focusoutblur)$/,\n          Lt = function (e) {\n        e.stopPropagation();\n      };\n\n      ke.extend(ke.event, {\n        trigger: function (e, t, i, r) {\n          var o,\n              s,\n              a,\n              l,\n              u,\n              c,\n              h,\n              p,\n              d = [i || ce],\n              f = ye.call(e, "type") ? e.type : e,\n              g = ye.call(e, "namespace") ? e.namespace.split(".") : [];\n\n          if (s = p = a = i = i || ce, 3 !== i.nodeType && 8 !== i.nodeType && !$t.test(f + ke.event.triggered) && (f.indexOf(".") > -1 && (g = f.split("."), f = g.shift(), g.sort()), u = f.indexOf(":") < 0 && "on" + f, e = e[ke.expando] ? e : new ke.Event(f, "object" == typeof e && e), e.isTrigger = r ? 2 : 3, e.namespace = g.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\\\.)" + g.join("\\\\.(?:.*\\\\.|)") + "(\\\\.|$)") : null, e.result = void 0, e.target || (e.target = i), t = null == t ? [e] : ke.makeArray(t, [e]), h = ke.event.special[f] || {}, r || !h.trigger || h.trigger.apply(i, t) !== !1)) {\n            if (!r && !h.noBubble && !Ce(i)) {\n              for (l = h.delegateType || f, $t.test(l + f) || (s = s.parentNode); s; s = s.parentNode) d.push(s), a = s;\n\n              a === (i.ownerDocument || ce) && d.push(a.defaultView || a.parentWindow || n);\n            }\n\n            for (o = 0; (s = d[o++]) && !e.isPropagationStopped();) p = s, e.type = o > 1 ? l : h.bindType || f, c = (Ue.get(s, "events") || {})[e.type] && Ue.get(s, "handle"), c && c.apply(s, t), c = u && s[u], c && c.apply && Fe(s) && (e.result = c.apply(s, t), e.result === !1 && e.preventDefault());\n\n            return e.type = f, r || e.isDefaultPrevented() || h._default && h._default.apply(d.pop(), t) !== !1 || !Fe(i) || u && _e(i[f]) && !Ce(i) && (a = i[u], a && (i[u] = null), ke.event.triggered = f, e.isPropagationStopped() && p.addEventListener(f, Lt), i[f](), e.isPropagationStopped() && p.removeEventListener(f, Lt), ke.event.triggered = void 0, a && (i[u] = a)), e.result;\n          }\n        },\n        simulate: function (e, t, n) {\n          var i = ke.extend(new ke.Event(), n, {\n            type: e,\n            isSimulated: !0\n          });\n          ke.event.trigger(i, null, t);\n        }\n      }), ke.fn.extend({\n        trigger: function (e, t) {\n          return this.each(function () {\n            ke.event.trigger(e, t, this);\n          });\n        },\n        triggerHandler: function (e, t) {\n          var n = this[0];\n          if (n) return ke.event.trigger(e, t, n, !0);\n        }\n      }), be.focusin || ke.each({\n        focus: "focusin",\n        blur: "focusout"\n      }, function (e, t) {\n        var n = function (e) {\n          ke.event.simulate(t, e.target, ke.event.fix(e));\n        };\n\n        ke.event.special[t] = {\n          setup: function () {\n            var i = this.ownerDocument || this,\n                r = Ue.access(i, t);\n            r || i.addEventListener(e, n, !0), Ue.access(i, t, (r || 0) + 1);\n          },\n          teardown: function () {\n            var i = this.ownerDocument || this,\n                r = Ue.access(i, t) - 1;\n            r ? Ue.access(i, t, r) : (i.removeEventListener(e, n, !0), Ue.remove(i, t));\n          }\n        };\n      });\n      var zt = n.location,\n          Ot = Date.now(),\n          Pt = /\\?/;\n\n      ke.parseXML = function (e) {\n        var t;\n        if (!e || "string" != typeof e) return null;\n\n        try {\n          t = new n.DOMParser().parseFromString(e, "text/xml");\n        } catch (i) {\n          t = void 0;\n        }\n\n        return t && !t.getElementsByTagName("parsererror").length || ke.error("Invalid XML: " + e), t;\n      };\n\n      var Ht = /\\[\\]$/,\n          qt = /\\r?\\n/g,\n          Mt = /^(?:submit|button|image|reset|file)$/i,\n          Rt = /^(?:input|select|textarea|keygen)/i;\n      ke.param = function (e, t) {\n        var n,\n            i = [],\n            r = function (e, t) {\n          var n = _e(t) ? t() : t;\n          i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n);\n        };\n\n        if (Array.isArray(e) || e.jquery && !ke.isPlainObject(e)) ke.each(e, function () {\n          r(this.name, this.value);\n        });else for (n in e) ie(n, e[n], t, r);\n        return i.join("&");\n      }, ke.fn.extend({\n        serialize: function () {\n          return ke.param(this.serializeArray());\n        },\n        serializeArray: function () {\n          return this.map(function () {\n            var e = ke.prop(this, "elements");\n            return e ? ke.makeArray(e) : this;\n          }).filter(function () {\n            var e = this.type;\n            return this.name && !ke(this).is(":disabled") && Rt.test(this.nodeName) && !Mt.test(e) && (this.checked || !tt.test(e));\n          }).map(function (e, t) {\n            var n = ke(this).val();\n            return null == n ? null : Array.isArray(n) ? ke.map(n, function (e) {\n              return {\n                name: t.name,\n                value: e.replace(qt, "\\r\\n")\n              };\n            }) : {\n              name: t.name,\n              value: n.replace(qt, "\\r\\n")\n            };\n          }).get();\n        }\n      });\n      var It = /%20/g,\n          Bt = /#.*$/,\n          Wt = /([?&])_=[^&]*/,\n          Ft = /^(.*?):[ \\t]*([^\\r\\n]*)$/gm,\n          Ut = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n          Vt = /^(?:GET|HEAD)$/,\n          Xt = /^\\/\\//,\n          Yt = {},\n          Gt = {},\n          Zt = "*/".concat("*"),\n          Jt = ce.createElement("a");\n      Jt.href = zt.href, ke.extend({\n        active: 0,\n        lastModified: {},\n        etag: {},\n        ajaxSettings: {\n          url: zt.href,\n          type: "GET",\n          isLocal: Ut.test(zt.protocol),\n          global: !0,\n          processData: !0,\n          async: !0,\n          contentType: "application/x-www-form-urlencoded; charset=UTF-8",\n          accepts: {\n            "*": Zt,\n            text: "text/plain",\n            html: "text/html",\n            xml: "application/xml, text/xml",\n            json: "application/json, text/javascript"\n          },\n          contents: {\n            xml: /\\bxml\\b/,\n            html: /\\bhtml/,\n            json: /\\bjson\\b/\n          },\n          responseFields: {\n            xml: "responseXML",\n            text: "responseText",\n            json: "responseJSON"\n          },\n          converters: {\n            "* text": String,\n            "text html": !0,\n            "text json": JSON.parse,\n            "text xml": ke.parseXML\n          },\n          flatOptions: {\n            url: !0,\n            context: !0\n          }\n        },\n        ajaxSetup: function (e, t) {\n          return t ? se(se(e, ke.ajaxSettings), t) : se(ke.ajaxSettings, e);\n        },\n        ajaxPrefilter: re(Yt),\n        ajaxTransport: re(Gt),\n        ajax: function (e, t) {\n          function i(e, t, i, a) {\n            var u,\n                p,\n                d,\n                x,\n                b,\n                _ = t;\n            c || (c = !0, l && n.clearTimeout(l), r = void 0, s = a || "", C.readyState = e > 0 ? 4 : 0, u = e >= 200 && e < 300 || 304 === e, i && (x = ae(f, C, i)), x = le(f, x, C, u), u ? (f.ifModified && (b = C.getResponseHeader("Last-Modified"), b && (ke.lastModified[o] = b), b = C.getResponseHeader("etag"), b && (ke.etag[o] = b)), 204 === e || "HEAD" === f.type ? _ = "nocontent" : 304 === e ? _ = "notmodified" : (_ = x.state, p = x.data, d = x.error, u = !d)) : (d = _, !e && _ || (_ = "error", e < 0 && (e = 0))), C.status = e, C.statusText = (t || _) + "", u ? v.resolveWith(g, [p, _, C]) : v.rejectWith(g, [C, _, d]), C.statusCode(w), w = void 0, h && m.trigger(u ? "ajaxSuccess" : "ajaxError", [C, f, u ? p : d]), y.fireWith(g, [C, _]), h && (m.trigger("ajaxComplete", [C, f]), --ke.active || ke.event.trigger("ajaxStop")));\n          }\n\n          "object" == typeof e && (t = e, e = void 0), t = t || {};\n          var r,\n              o,\n              s,\n              a,\n              l,\n              u,\n              c,\n              h,\n              p,\n              d,\n              f = ke.ajaxSetup({}, t),\n              g = f.context || f,\n              m = f.context && (g.nodeType || g.jquery) ? ke(g) : ke.event,\n              v = ke.Deferred(),\n              y = ke.Callbacks("once memory"),\n              w = f.statusCode || {},\n              x = {},\n              b = {},\n              _ = "canceled",\n              C = {\n            readyState: 0,\n            getResponseHeader: function (e) {\n              var t;\n\n              if (c) {\n                if (!a) for (a = {}; t = Ft.exec(s);) a[t[1].toLowerCase()] = t[2];\n                t = a[e.toLowerCase()];\n              }\n\n              return null == t ? null : t;\n            },\n            getAllResponseHeaders: function () {\n              return c ? s : null;\n            },\n            setRequestHeader: function (e, t) {\n              return null == c && (e = b[e.toLowerCase()] = b[e.toLowerCase()] || e, x[e] = t), this;\n            },\n            overrideMimeType: function (e) {\n              return null == c && (f.mimeType = e), this;\n            },\n            statusCode: function (e) {\n              var t;\n              if (e) if (c) C.always(e[C.status]);else for (t in e) w[t] = [w[t], e[t]];\n              return this;\n            },\n            abort: function (e) {\n              var t = e || _;\n              return r && r.abort(t), i(0, t), this;\n            }\n          };\n\n          if (v.promise(C), f.url = ((e || f.url || zt.href) + "").replace(Xt, zt.protocol + "//"), f.type = t.method || t.type || f.method || f.type, f.dataTypes = (f.dataType || "*").toLowerCase().match(qe) || [""], null == f.crossDomain) {\n            u = ce.createElement("a");\n\n            try {\n              u.href = f.url, u.href = u.href, f.crossDomain = Jt.protocol + "//" + Jt.host != u.protocol + "//" + u.host;\n            } catch (T) {\n              f.crossDomain = !0;\n            }\n          }\n\n          if (f.data && f.processData && "string" != typeof f.data && (f.data = ke.param(f.data, f.traditional)), oe(Yt, f, t, C), c) return C;\n          h = ke.event && f.global, h && 0 === ke.active++ && ke.event.trigger("ajaxStart"), f.type = f.type.toUpperCase(), f.hasContent = !Vt.test(f.type), o = f.url.replace(Bt, ""), f.hasContent ? f.data && f.processData && 0 === (f.contentType || "").indexOf("application/x-www-form-urlencoded") && (f.data = f.data.replace(It, "+")) : (d = f.url.slice(o.length), f.data && (f.processData || "string" == typeof f.data) && (o += (Pt.test(o) ? "&" : "?") + f.data, delete f.data), f.cache === !1 && (o = o.replace(Wt, "$1"), d = (Pt.test(o) ? "&" : "?") + "_=" + Ot++ + d), f.url = o + d), f.ifModified && (ke.lastModified[o] && C.setRequestHeader("If-Modified-Since", ke.lastModified[o]), ke.etag[o] && C.setRequestHeader("If-None-Match", ke.etag[o])), (f.data && f.hasContent && f.contentType !== !1 || t.contentType) && C.setRequestHeader("Content-Type", f.contentType), C.setRequestHeader("Accept", f.dataTypes[0] && f.accepts[f.dataTypes[0]] ? f.accepts[f.dataTypes[0]] + ("*" !== f.dataTypes[0] ? ", " + Zt + "; q=0.01" : "") : f.accepts["*"]);\n\n          for (p in f.headers) C.setRequestHeader(p, f.headers[p]);\n\n          if (f.beforeSend && (f.beforeSend.call(g, C, f) === !1 || c)) return C.abort();\n\n          if (_ = "abort", y.add(f.complete), C.done(f.success), C.fail(f.error), r = oe(Gt, f, t, C)) {\n            if (C.readyState = 1, h && m.trigger("ajaxSend", [C, f]), c) return C;\n            f.async && f.timeout > 0 && (l = n.setTimeout(function () {\n              C.abort("timeout");\n            }, f.timeout));\n\n            try {\n              c = !1, r.send(x, i);\n            } catch (T) {\n              if (c) throw T;\n              i(-1, T);\n            }\n          } else i(-1, "No Transport");\n\n          return C;\n        },\n        getJSON: function (e, t, n) {\n          return ke.get(e, t, n, "json");\n        },\n        getScript: function (e, t) {\n          return ke.get(e, void 0, t, "script");\n        }\n      }), ke.each(["get", "post"], function (e, t) {\n        ke[t] = function (e, n, i, r) {\n          return _e(n) && (r = r || i, i = n, n = void 0), ke.ajax(ke.extend({\n            url: e,\n            type: t,\n            dataType: r,\n            data: n,\n            success: i\n          }, ke.isPlainObject(e) && e));\n        };\n      }), ke._evalUrl = function (e) {\n        return ke.ajax({\n          url: e,\n          type: "GET",\n          dataType: "script",\n          cache: !0,\n          async: !1,\n          global: !1,\n          "throws": !0\n        });\n      }, ke.fn.extend({\n        wrapAll: function (e) {\n          var t;\n          return this[0] && (_e(e) && (e = e.call(this[0])), t = ke(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () {\n            for (var e = this; e.firstElementChild;) e = e.firstElementChild;\n\n            return e;\n          }).append(this)), this;\n        },\n        wrapInner: function (e) {\n          return _e(e) ? this.each(function (t) {\n            ke(this).wrapInner(e.call(this, t));\n          }) : this.each(function () {\n            var t = ke(this),\n                n = t.contents();\n            n.length ? n.wrapAll(e) : t.append(e);\n          });\n        },\n        wrap: function (e) {\n          var t = _e(e);\n\n          return this.each(function (n) {\n            ke(this).wrapAll(t ? e.call(this, n) : e);\n          });\n        },\n        unwrap: function (e) {\n          return this.parent(e).not("body").each(function () {\n            ke(this).replaceWith(this.childNodes);\n          }), this;\n        }\n      }), ke.expr.pseudos.hidden = function (e) {\n        return !ke.expr.pseudos.visible(e);\n      }, ke.expr.pseudos.visible = function (e) {\n        return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);\n      }, ke.ajaxSettings.xhr = function () {\n        try {\n          return new n.XMLHttpRequest();\n        } catch (e) {}\n      };\n      var Qt = {\n        0: 200,\n        1223: 204\n      },\n          Kt = ke.ajaxSettings.xhr();\n      be.cors = !!Kt && "withCredentials" in Kt, be.ajax = Kt = !!Kt, ke.ajaxTransport(function (e) {\n        var t, i;\n        if (be.cors || Kt && !e.crossDomain) return {\n          send: function (r, o) {\n            var s,\n                a = e.xhr();\n            if (a.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields) for (s in e.xhrFields) a[s] = e.xhrFields[s];\n            e.mimeType && a.overrideMimeType && a.overrideMimeType(e.mimeType), e.crossDomain || r["X-Requested-With"] || (r["X-Requested-With"] = "XMLHttpRequest");\n\n            for (s in r) a.setRequestHeader(s, r[s]);\n\n            t = function (e) {\n              return function () {\n                t && (t = i = a.onload = a.onerror = a.onabort = a.ontimeout = a.onreadystatechange = null, "abort" === e ? a.abort() : "error" === e ? "number" != typeof a.status ? o(0, "error") : o(a.status, a.statusText) : o(Qt[a.status] || a.status, a.statusText, "text" !== (a.responseType || "text") || "string" != typeof a.responseText ? {\n                  binary: a.response\n                } : {\n                  text: a.responseText\n                }, a.getAllResponseHeaders()));\n              };\n            }, a.onload = t(), i = a.onerror = a.ontimeout = t("error"), void 0 !== a.onabort ? a.onabort = i : a.onreadystatechange = function () {\n              4 === a.readyState && n.setTimeout(function () {\n                t && i();\n              });\n            }, t = t("abort");\n\n            try {\n              a.send(e.hasContent && e.data || null);\n            } catch (l) {\n              if (t) throw l;\n            }\n          },\n          abort: function () {\n            t && t();\n          }\n        };\n      }), ke.ajaxPrefilter(function (e) {\n        e.crossDomain && (e.contents.script = !1);\n      }), ke.ajaxSetup({\n        accepts: {\n          script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"\n        },\n        contents: {\n          script: /\\b(?:java|ecma)script\\b/\n        },\n        converters: {\n          "text script": function (e) {\n            return ke.globalEval(e), e;\n          }\n        }\n      }), ke.ajaxPrefilter("script", function (e) {\n        void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET");\n      }), ke.ajaxTransport("script", function (e) {\n        if (e.crossDomain) {\n          var t, n;\n          return {\n            send: function (i, r) {\n              t = ke("<script>").prop({\n                charset: e.scriptCharset,\n                src: e.url\n              }).on("load error", n = function (e) {\n                t.remove(), n = null, e && r("error" === e.type ? 404 : 200, e.type);\n              }), ce.head.appendChild(t[0]);\n            },\n            abort: function () {\n              n && n();\n            }\n          };\n        }\n      });\n      var en = [],\n          tn = /(=)\\?(?=&|$)|\\?\\?/;\n      ke.ajaxSetup({\n        jsonp: "callback",\n        jsonpCallback: function () {\n          var e = en.pop() || ke.expando + "_" + Ot++;\n          return this[e] = !0, e;\n        }\n      }), ke.ajaxPrefilter("json jsonp", function (e, t, i) {\n        var r,\n            o,\n            s,\n            a = e.jsonp !== !1 && (tn.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && tn.test(e.data) && "data");\n        if (a || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = _e(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(tn, "$1" + r) : e.jsonp !== !1 && (e.url += (Pt.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function () {\n          return s || ke.error(r + " was not called"), s[0];\n        }, e.dataTypes[0] = "json", o = n[r], n[r] = function () {\n          s = arguments;\n        }, i.always(function () {\n          void 0 === o ? ke(n).removeProp(r) : n[r] = o, e[r] && (e.jsonpCallback = t.jsonpCallback, en.push(r)), s && _e(o) && o(s[0]), s = o = void 0;\n        }), "script";\n      }), be.createHTMLDocument = function () {\n        var e = ce.implementation.createHTMLDocument("").body;\n        return e.innerHTML = "<form></form><form></form>", 2 === e.childNodes.length;\n      }(), ke.parseHTML = function (e, t, n) {\n        if ("string" != typeof e) return [];\n        "boolean" == typeof t && (n = t, t = !1);\n        var i, r, o;\n        return t || (be.createHTMLDocument ? (t = ce.implementation.createHTMLDocument(""), i = t.createElement("base"), i.href = ce.location.href, t.head.appendChild(i)) : t = ce), r = $e.exec(e), o = !n && [], r ? [t.createElement(r[1])] : (r = S([e], t, o), o && o.length && ke(o).remove(), ke.merge([], r.childNodes));\n      }, ke.fn.load = function (e, t, n) {\n        var i,\n            r,\n            o,\n            s = this,\n            a = e.indexOf(" ");\n        return a > -1 && (i = ee(e.slice(a)), e = e.slice(0, a)), _e(t) ? (n = t, t = void 0) : t && "object" == typeof t && (r = "POST"), s.length > 0 && ke.ajax({\n          url: e,\n          type: r || "GET",\n          dataType: "html",\n          data: t\n        }).done(function (e) {\n          o = arguments, s.html(i ? ke("<div>").append(ke.parseHTML(e)).find(i) : e);\n        }).always(n && function (e, t) {\n          s.each(function () {\n            n.apply(this, o || [e.responseText, t, e]);\n          });\n        }), this;\n      }, ke.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) {\n        ke.fn[t] = function (e) {\n          return this.on(t, e);\n        };\n      }), ke.expr.pseudos.animated = function (e) {\n        return ke.grep(ke.timers, function (t) {\n          return e === t.elem;\n        }).length;\n      }, ke.offset = {\n        setOffset: function (e, t, n) {\n          var i,\n              r,\n              o,\n              s,\n              a,\n              l,\n              u,\n              c = ke.css(e, "position"),\n              h = ke(e),\n              p = {};\n          "static" === c && (e.style.position = "relative"), a = h.offset(), o = ke.css(e, "top"), l = ke.css(e, "left"), u = ("absolute" === c || "fixed" === c) && (o + l).indexOf("auto") > -1, u ? (i = h.position(), s = i.top, r = i.left) : (s = parseFloat(o) || 0, r = parseFloat(l) || 0), _e(t) && (t = t.call(e, n, ke.extend({}, a))), null != t.top && (p.top = t.top - a.top + s), null != t.left && (p.left = t.left - a.left + r), "using" in t ? t.using.call(e, p) : h.css(p);\n        }\n      }, ke.fn.extend({\n        offset: function (e) {\n          if (arguments.length) return void 0 === e ? this : this.each(function (t) {\n            ke.offset.setOffset(this, e, t);\n          });\n          var t,\n              n,\n              i = this[0];\n          if (i) return i.getClientRects().length ? (t = i.getBoundingClientRect(), n = i.ownerDocument.defaultView, {\n            top: t.top + n.pageYOffset,\n            left: t.left + n.pageXOffset\n          }) : {\n            top: 0,\n            left: 0\n          };\n        },\n        position: function () {\n          if (this[0]) {\n            var e,\n                t,\n                n,\n                i = this[0],\n                r = {\n              top: 0,\n              left: 0\n            };\n            if ("fixed" === ke.css(i, "position")) t = i.getBoundingClientRect();else {\n              for (t = this.offset(), n = i.ownerDocument, e = i.offsetParent || n.documentElement; e && (e === n.body || e === n.documentElement) && "static" === ke.css(e, "position");) e = e.parentNode;\n\n              e && e !== i && 1 === e.nodeType && (r = ke(e).offset(), r.top += ke.css(e, "borderTopWidth", !0), r.left += ke.css(e, "borderLeftWidth", !0));\n            }\n            return {\n              top: t.top - r.top - ke.css(i, "marginTop", !0),\n              left: t.left - r.left - ke.css(i, "marginLeft", !0)\n            };\n          }\n        },\n        offsetParent: function () {\n          return this.map(function () {\n            for (var e = this.offsetParent; e && "static" === ke.css(e, "position");) e = e.offsetParent;\n\n            return e || st;\n          });\n        }\n      }), ke.each({\n        scrollLeft: "pageXOffset",\n        scrollTop: "pageYOffset"\n      }, function (e, t) {\n        var n = "pageYOffset" === t;\n\n        ke.fn[e] = function (i) {\n          return Ie(this, function (e, i, r) {\n            var o;\n            return Ce(e) ? o = e : 9 === e.nodeType && (o = e.defaultView), void 0 === r ? o ? o[t] : e[i] : void (o ? o.scrollTo(n ? o.pageXOffset : r, n ? r : o.pageYOffset) : e[i] = r);\n          }, e, i, arguments.length);\n        };\n      }), ke.each(["top", "left"], function (e, t) {\n        ke.cssHooks[t] = R(be.pixelPosition, function (e, n) {\n          if (n) return n = M(e, t), ft.test(n) ? ke(e).position()[t] + "px" : n;\n        });\n      }), ke.each({\n        Height: "height",\n        Width: "width"\n      }, function (e, t) {\n        ke.each({\n          padding: "inner" + e,\n          content: t,\n          "": "outer" + e\n        }, function (n, i) {\n          ke.fn[i] = function (r, o) {\n            var s = arguments.length && (n || "boolean" != typeof r),\n                a = n || (r === !0 || o === !0 ? "margin" : "border");\n            return Ie(this, function (t, n, r) {\n              var o;\n              return Ce(t) ? 0 === i.indexOf("outer") ? t["inner" + e] : t.document.documentElement["client" + e] : 9 === t.nodeType ? (o = t.documentElement, Math.max(t.body["scroll" + e], o["scroll" + e], t.body["offset" + e], o["offset" + e], o["client" + e])) : void 0 === r ? ke.css(t, n, a) : ke.style(t, n, r, a);\n            }, t, s ? r : void 0, s);\n          };\n        });\n      }), ke.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, t) {\n        ke.fn[t] = function (e, n) {\n          return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t);\n        };\n      }), ke.fn.extend({\n        hover: function (e, t) {\n          return this.mouseenter(e).mouseleave(t || e);\n        }\n      }), ke.fn.extend({\n        bind: function (e, t, n) {\n          return this.on(e, null, t, n);\n        },\n        unbind: function (e, t) {\n          return this.off(e, null, t);\n        },\n        delegate: function (e, t, n, i) {\n          return this.on(t, e, n, i);\n        },\n        undelegate: function (e, t, n) {\n          return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n);\n        }\n      }), ke.proxy = function (e, t) {\n        var n, i, r;\n        if ("string" == typeof t && (n = e[t], t = e, e = n), _e(e)) return i = pe.call(arguments, 2), r = function () {\n          return e.apply(t || this, i.concat(pe.call(arguments)));\n        }, r.guid = e.guid = e.guid || ke.guid++, r;\n      }, ke.holdReady = function (e) {\n        e ? ke.readyWait++ : ke.ready(!0);\n      }, ke.isArray = Array.isArray, ke.parseJSON = JSON.parse, ke.nodeName = u, ke.isFunction = _e, ke.isWindow = Ce, ke.camelCase = y, ke.type = a, ke.now = Date.now, ke.isNumeric = function (e) {\n        var t = ke.type(e);\n        return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e));\n      }, i = [], r = function () {\n        return ke;\n      }.apply(t, i), !(void 0 !== r && (e.exports = r));\n      var nn = n.jQuery,\n          rn = n.$;\n      return ke.noConflict = function (e) {\n        return n.$ === ke && (n.$ = rn), e && n.jQuery === ke && (n.jQuery = nn), ke;\n      }, o || (n.jQuery = n.$ = ke), ke;\n    });\n  }, function (e, t, n) {\n    var i = n(5);\n    "string" == typeof i && (i = [[e.id, i, ""]]), i.locals && (e.exports = i.locals);\n    n(9)("c9621516", i, !0);\n  }, function (e, t, n) {\n    var i = n(6);\n    t = e.exports = n(7)(!1), t.push([e.id, \'/**\\n * Owl Carousel v2.3.4\\n * Copyright 2013-2018 David Deutsch\\n * Licensed under: SEE LICENSE IN https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE\\n */\\n/*\\n *  Owl Carousel - Core\\n */\\n.owl-carousel {\\n  display: none;\\n  width: 100%;\\n  -webkit-tap-highlight-color: transparent;\\n  /* position relative and z-index fix webkit rendering fonts issue */\\n  position: relative;\\n  z-index: 1; }\\n  .owl-carousel .owl-stage {\\n    position: relative;\\n    -ms-touch-action: pan-Y;\\n    touch-action: manipulation;\\n    -moz-backface-visibility: hidden;\\n    /* fix firefox animation glitch */ }\\n  .owl-carousel .owl-stage:after {\\n    content: ".";\\n    display: block;\\n    clear: both;\\n    visibility: hidden;\\n    line-height: 0;\\n    height: 0; }\\n  .owl-carousel .owl-stage-outer {\\n    position: relative;\\n    overflow: hidden;\\n    /* fix for flashing background */\\n    -webkit-transform: translate3d(0px, 0px, 0px); }\\n  .owl-carousel .owl-wrapper,\\n  .owl-carousel .owl-item {\\n    -webkit-backface-visibility: hidden;\\n    -moz-backface-visibility: hidden;\\n    -ms-backface-visibility: hidden;\\n    -webkit-transform: translate3d(0, 0, 0);\\n    -moz-transform: translate3d(0, 0, 0);\\n    -ms-transform: translate3d(0, 0, 0); }\\n  .owl-carousel .owl-item {\\n    position: relative;\\n    min-height: 1px;\\n    float: left;\\n    -webkit-backface-visibility: hidden;\\n    -webkit-tap-highlight-color: transparent;\\n    -webkit-touch-callout: none; }\\n  .owl-carousel .owl-item img {\\n    display: block;\\n    width: 100%; }\\n  .owl-carousel .owl-nav.disabled,\\n  .owl-carousel .owl-dots.disabled {\\n    display: none; }\\n  .owl-carousel .owl-nav .owl-prev,\\n  .owl-carousel .owl-nav .owl-next,\\n  .owl-carousel .owl-dot {\\n    cursor: pointer;\\n    -webkit-user-select: none;\\n    -khtml-user-select: none;\\n    -moz-user-select: none;\\n    -ms-user-select: none;\\n    user-select: none; }\\n  .owl-carousel .owl-nav button.owl-prev,\\n  .owl-carousel .owl-nav button.owl-next,\\n  .owl-carousel button.owl-dot {\\n    background: none;\\n    color: inherit;\\n    border: none;\\n    padding: 0 !important;\\n    font: inherit; }\\n  .owl-carousel.owl-loaded {\\n    display: block; }\\n  .owl-carousel.owl-loading {\\n    opacity: 0;\\n    display: block; }\\n  .owl-carousel.owl-hidden {\\n    opacity: 0; }\\n  .owl-carousel.owl-refresh .owl-item {\\n    visibility: hidden; }\\n  .owl-carousel.owl-drag .owl-item {\\n    -ms-touch-action: pan-y;\\n        touch-action: pan-y;\\n    -webkit-user-select: none;\\n    -moz-user-select: none;\\n    -ms-user-select: none;\\n    user-select: none; }\\n  .owl-carousel.owl-grab {\\n    cursor: move;\\n    cursor: grab; }\\n  .owl-carousel.owl-rtl {\\n    direction: rtl; }\\n  .owl-carousel.owl-rtl .owl-item {\\n    float: right; }\\n\\n/* No Js */\\n.no-js .owl-carousel {\\n  display: block; }\\n\\n/*\\n *  Owl Carousel - Animate Plugin\\n */\\n.owl-carousel .animated {\\n  animation-duration: 1000ms;\\n  animation-fill-mode: both; }\\n\\n.owl-carousel .owl-animated-in {\\n  z-index: 0; }\\n\\n.owl-carousel .owl-animated-out {\\n  z-index: 1; }\\n\\n.owl-carousel .fadeOut {\\n  animation-name: fadeOut; }\\n\\n@keyframes fadeOut {\\n  0% {\\n    opacity: 1; }\\n  100% {\\n    opacity: 0; } }\\n\\n/*\\n * \\tOwl Carousel - Auto Height Plugin\\n */\\n.owl-height {\\n  transition: height 500ms ease-in-out; }\\n\\n/*\\n * \\tOwl Carousel - Lazy Load Plugin\\n */\\n.owl-carousel .owl-item {\\n  /**\\n\\t\\t\\tThis is introduced due to a bug in IE11 where lazy loading combined with autoheight plugin causes a wrong\\n\\t\\t\\tcalculation of the height of the owl-item that breaks page layouts\\n\\t\\t */ }\\n  .owl-carousel .owl-item .owl-lazy {\\n    opacity: 0;\\n    transition: opacity 400ms ease; }\\n  .owl-carousel .owl-item .owl-lazy[src^=""], .owl-carousel .owl-item .owl-lazy:not([src]) {\\n    max-height: 0; }\\n  .owl-carousel .owl-item img.owl-lazy {\\n    transform-style: preserve-3d; }\\n\\n/*\\n * \\tOwl Carousel - Video Plugin\\n */\\n.owl-carousel .owl-video-wrapper {\\n  position: relative;\\n  height: 100%;\\n  background: #000; }\\n\\n.owl-carousel .owl-video-play-icon {\\n  position: absolute;\\n  height: 80px;\\n  width: 80px;\\n  left: 50%;\\n  top: 50%;\\n  margin-left: -40px;\\n  margin-top: -40px;\\n  background: url(\' + i(n(8)) + ") no-repeat;\\n  cursor: pointer;\\n  z-index: 1;\\n  -webkit-backface-visibility: hidden;\\n  transition: transform 100ms ease; }\\n\\n.owl-carousel .owl-video-play-icon:hover {\\n  -ms-transform: scale(1.3, 1.3);\\n      transform: scale(1.3, 1.3); }\\n\\n.owl-carousel .owl-video-playing .owl-video-tn,\\n.owl-carousel .owl-video-playing .owl-video-play-icon {\\n  display: none; }\\n\\n.owl-carousel .owl-video-tn {\\n  opacity: 0;\\n  height: 100%;\\n  background-position: center center;\\n  background-repeat: no-repeat;\\n  background-size: contain;\\n  transition: opacity 400ms ease; }\\n\\n.owl-carousel .owl-video-frame {\\n  position: relative;\\n  z-index: 1;\\n  height: 100%;\\n  width: 100%; }\\n", ""]);\n  }, function (e, t) {\n    e.exports = function (e) {\n      return "string" != typeof e ? e : (/^[\'"].*[\'"]$/.test(e) && (e = e.slice(1, -1)), /["\'() \\t\\n]/.test(e) ? \'"\' + e.replace(/"/g, \'\\\\"\').replace(/\\n/g, "\\\\n") + \'"\' : e);\n    };\n  }, function (e, t) {\n    function n(e, t) {\n      var n = e[1] || "",\n          r = e[3];\n      if (!r) return n;\n\n      if (t && "function" == typeof btoa) {\n        var o = i(r),\n            s = r.sources.map(function (e) {\n          return "/*# sourceURL=" + r.sourceRoot + e + " */";\n        });\n        return [n].concat(s).concat([o]).join("\\n");\n      }\n\n      return [n].join("\\n");\n    }\n\n    function i(e) {\n      var t = btoa(unescape(encodeURIComponent(JSON.stringify(e)))),\n          n = "sourceMappingURL=data:application/json;charset=utf-8;base64," + t;\n      return "/*# " + n + " */";\n    }\n\n    e.exports = function (e) {\n      var t = [];\n      return t.toString = function () {\n        return this.map(function (t) {\n          var i = n(t, e);\n          return t[2] ? "@media " + t[2] + "{" + i + "}" : i;\n        }).join("");\n      }, t.i = function (e, n) {\n        "string" == typeof e && (e = [[null, e, ""]]);\n\n        for (var i = {}, r = 0; r < this.length; r++) {\n          var o = this[r][0];\n          "number" == typeof o && (i[o] = !0);\n        }\n\n        for (r = 0; r < e.length; r++) {\n          var s = e[r];\n          "number" == typeof s[0] && i[s[0]] || (n && !s[2] ? s[2] = n : n && (s[2] = "(" + s[2] + ") and (" + n + ")"), t.push(s));\n        }\n      }, t;\n    };\n  }, function (e, t, n) {\n    e.exports = n.p + "4a37f8008959c75f619bf0a3a4e2d7a2.png";\n  }, function (e, t, n) {\n    function i(e) {\n      for (var t = 0; t < e.length; t++) {\n        var n = e[t],\n            i = c[n.id];\n\n        if (i) {\n          i.refs++;\n\n          for (var r = 0; r < i.parts.length; r++) i.parts[r](n.parts[r]);\n\n          for (; r < n.parts.length; r++) i.parts.push(o(n.parts[r]));\n\n          i.parts.length > n.parts.length && (i.parts.length = n.parts.length);\n        } else {\n          for (var s = [], r = 0; r < n.parts.length; r++) s.push(o(n.parts[r]));\n\n          c[n.id] = {\n            id: n.id,\n            refs: 1,\n            parts: s\n          };\n        }\n      }\n    }\n\n    function r() {\n      var e = document.createElement("style");\n      return e.type = "text/css", h.appendChild(e), e;\n    }\n\n    function o(e) {\n      var t,\n          n,\n          i = document.querySelector(\'style[data-vue-ssr-id~="\' + e.id + \'"]\');\n\n      if (i) {\n        if (f) return g;\n        i.parentNode.removeChild(i);\n      }\n\n      if (m) {\n        var o = d++;\n        i = p || (p = r()), t = s.bind(null, i, o, !1), n = s.bind(null, i, o, !0);\n      } else i = r(), t = a.bind(null, i), n = function () {\n        i.parentNode.removeChild(i);\n      };\n\n      return t(e), function (i) {\n        if (i) {\n          if (i.css === e.css && i.media === e.media && i.sourceMap === e.sourceMap) return;\n          t(e = i);\n        } else n();\n      };\n    }\n\n    function s(e, t, n, i) {\n      var r = n ? "" : i.css;\n      if (e.styleSheet) e.styleSheet.cssText = v(t, r);else {\n        var o = document.createTextNode(r),\n            s = e.childNodes;\n        s[t] && e.removeChild(s[t]), s.length ? e.insertBefore(o, s[t]) : e.appendChild(o);\n      }\n    }\n\n    function a(e, t) {\n      var n = t.css,\n          i = t.media,\n          r = t.sourceMap;\n      if (i && e.setAttribute("media", i), r && (n += "\\n/*# sourceURL=" + r.sources[0] + " */", n += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(r)))) + " */"), e.styleSheet) e.styleSheet.cssText = n;else {\n        for (; e.firstChild;) e.removeChild(e.firstChild);\n\n        e.appendChild(document.createTextNode(n));\n      }\n    }\n\n    var l = "undefined" != typeof document,\n        u = n(10),\n        c = {},\n        h = l && (document.head || document.getElementsByTagName("head")[0]),\n        p = null,\n        d = 0,\n        f = !1,\n        g = function () {},\n        m = "undefined" != typeof navigator && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());\n\n    e.exports = function (e, t, n) {\n      f = n;\n      var r = u(e, t);\n      return i(r), function (t) {\n        for (var n = [], o = 0; o < r.length; o++) {\n          var s = r[o],\n              a = c[s.id];\n          a.refs--, n.push(a);\n        }\n\n        t ? (r = u(e, t), i(r)) : r = [];\n\n        for (var o = 0; o < n.length; o++) {\n          var a = n[o];\n\n          if (0 === a.refs) {\n            for (var l = 0; l < a.parts.length; l++) a.parts[l]();\n\n            delete c[a.id];\n          }\n        }\n      };\n    };\n\n    var v = function () {\n      var e = [];\n      return function (t, n) {\n        return e[t] = n, e.filter(Boolean).join("\\n");\n      };\n    }();\n  }, function (e, t) {\n    e.exports = function (e, t) {\n      for (var n = [], i = {}, r = 0; r < t.length; r++) {\n        var o = t[r],\n            s = o[0],\n            a = o[1],\n            l = o[2],\n            u = o[3],\n            c = {\n          id: e + ":" + r,\n          css: a,\n          media: l,\n          sourceMap: u\n        };\n        i[s] ? i[s].parts.push(c) : n.push(i[s] = {\n          id: s,\n          parts: [c]\n        });\n      }\n\n      return n;\n    };\n  }, function (e, t, n) {\n    var i = n(12);\n    "string" == typeof i && (i = [[e.id, i, ""]]), i.locals && (e.exports = i.locals);\n    n(9)("25bb882e", i, !0);\n  }, function (e, t, n) {\n    t = e.exports = n(7)(!1), t.push([e.id, "/**\\n * Owl Carousel v2.3.4\\n * Copyright 2013-2018 David Deutsch\\n * Licensed under: SEE LICENSE IN https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE\\n */\\n/*\\n * \\tDefault theme - Owl Carousel CSS File\\n */\\n.owl-theme .owl-nav {\\n  margin-top: 10px;\\n  text-align: center;\\n  -webkit-tap-highlight-color: transparent; }\\n  .owl-theme .owl-nav [class*=\'owl-\'] {\\n    color: #FFF;\\n    font-size: 14px;\\n    margin: 5px;\\n    padding: 4px 7px;\\n    background: #D6D6D6;\\n    display: inline-block;\\n    cursor: pointer;\\n    border-radius: 3px; }\\n    .owl-theme .owl-nav [class*=\'owl-\']:hover {\\n      background: #869791;\\n      color: #FFF;\\n      text-decoration: none; }\\n  .owl-theme .owl-nav .disabled {\\n    opacity: 0.5;\\n    cursor: default; }\\n\\n.owl-theme .owl-nav.disabled + .owl-dots {\\n  margin-top: 10px; }\\n\\n.owl-theme .owl-dots {\\n  text-align: center;\\n  -webkit-tap-highlight-color: transparent; }\\n  .owl-theme .owl-dots .owl-dot {\\n    display: inline-block;\\n    zoom: 1;\\n    *display: inline; }\\n    .owl-theme .owl-dots .owl-dot span {\\n      width: 10px;\\n      height: 10px;\\n      margin: 5px 7px;\\n      background: #D6D6D6;\\n      display: block;\\n      -webkit-backface-visibility: visible;\\n      transition: opacity 200ms ease;\\n      border-radius: 30px; }\\n    .owl-theme .owl-dots .owl-dot.active span, .owl-theme .owl-dots .owl-dot:hover span {\\n      background: #869791; }\\n", ""]);\n  }, function (e, t, n) {\n    (function (e, t) {\n      !function (e, n, i, r) {\n        function o(t, n) {\n          this.settings = null, this.options = e.extend({}, o.Defaults, n), this.$element = e(t), this._handlers = {}, this._plugins = {}, this._supress = {}, this._current = null, this._speed = null, this._coordinates = [], this._breakpoint = null, this._width = null, this._items = [], this._clones = [], this._mergers = [], this._widths = [], this._invalidated = {}, this._pipe = [], this._drag = {\n            time: null,\n            target: null,\n            pointer: null,\n            stage: {\n              start: null,\n              current: null\n            },\n            direction: null\n          }, this._states = {\n            current: {},\n            tags: {\n              initializing: ["busy"],\n              animating: ["busy"],\n              dragging: ["interacting"]\n            }\n          }, e.each(["onResize", "onThrottledResize"], e.proxy(function (t, n) {\n            this._handlers[n] = e.proxy(this[n], this);\n          }, this)), e.each(o.Plugins, e.proxy(function (e, t) {\n            this._plugins[e.charAt(0).toLowerCase() + e.slice(1)] = new t(this);\n          }, this)), e.each(o.Workers, e.proxy(function (t, n) {\n            this._pipe.push({\n              filter: n.filter,\n              run: e.proxy(n.run, this)\n            });\n          }, this)), this.setup(), this.initialize();\n        }\n\n        o.Defaults = {\n          items: 3,\n          loop: !1,\n          center: !1,\n          rewind: !1,\n          checkVisibility: !0,\n          mouseDrag: !0,\n          touchDrag: !0,\n          pullDrag: !0,\n          freeDrag: !1,\n          margin: 0,\n          stagePadding: 0,\n          merge: !1,\n          mergeFit: !0,\n          autoWidth: !1,\n          startPosition: 0,\n          rtl: !1,\n          smartSpeed: 250,\n          fluidSpeed: !1,\n          dragEndSpeed: !1,\n          responsive: {},\n          responsiveRefreshRate: 200,\n          responsiveBaseElement: n,\n          fallbackEasing: "swing",\n          slideTransition: "",\n          info: !1,\n          nestedItemSelector: !1,\n          itemElement: "div",\n          stageElement: "div",\n          refreshClass: "owl-refresh",\n          loadedClass: "owl-loaded",\n          loadingClass: "owl-loading",\n          rtlClass: "owl-rtl",\n          responsiveClass: "owl-responsive",\n          dragClass: "owl-drag",\n          itemClass: "owl-item",\n          stageClass: "owl-stage",\n          stageOuterClass: "owl-stage-outer",\n          grabClass: "owl-grab"\n        }, o.Width = {\n          Default: "default",\n          Inner: "inner",\n          Outer: "outer"\n        }, o.Type = {\n          Event: "event",\n          State: "state"\n        }, o.Plugins = {}, o.Workers = [{\n          filter: ["width", "settings"],\n          run: function () {\n            this._width = this.$element.width();\n          }\n        }, {\n          filter: ["width", "items", "settings"],\n          run: function (e) {\n            e.current = this._items && this._items[this.relative(this._current)];\n          }\n        }, {\n          filter: ["items", "settings"],\n          run: function () {\n            this.$stage.children(".cloned").remove();\n          }\n        }, {\n          filter: ["width", "items", "settings"],\n          run: function (e) {\n            var t = this.settings.margin || "",\n                n = !this.settings.autoWidth,\n                i = this.settings.rtl,\n                r = {\n              width: "auto",\n              "margin-left": i ? t : "",\n              "margin-right": i ? "" : t\n            };\n            !n && this.$stage.children().css(r), e.css = r;\n          }\n        }, {\n          filter: ["width", "items", "settings"],\n          run: function (e) {\n            var t = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,\n                n = null,\n                i = this._items.length,\n                r = !this.settings.autoWidth,\n                o = [];\n\n            for (e.items = {\n              merge: !1,\n              width: t\n            }; i--;) n = this._mergers[i], n = this.settings.mergeFit && Math.min(n, this.settings.items) || n, e.items.merge = n > 1 || e.items.merge, o[i] = r ? t * n : this._items[i].width();\n\n            this._widths = o;\n          }\n        }, {\n          filter: ["items", "settings"],\n          run: function () {\n            var t = [],\n                n = this._items,\n                i = this.settings,\n                r = Math.max(2 * i.items, 4),\n                o = 2 * Math.ceil(n.length / 2),\n                s = i.loop && n.length ? i.rewind ? r : Math.max(r, o) : 0,\n                a = "",\n                l = "";\n\n            for (s /= 2; s > 0;) t.push(this.normalize(t.length / 2, !0)), a += n[t[t.length - 1]][0].outerHTML, t.push(this.normalize(n.length - 1 - (t.length - 1) / 2, !0)), l = n[t[t.length - 1]][0].outerHTML + l, s -= 1;\n\n            this._clones = t, e(a).addClass("cloned").appendTo(this.$stage), e(l).addClass("cloned").prependTo(this.$stage);\n          }\n        }, {\n          filter: ["width", "items", "settings"],\n          run: function () {\n            for (var e = this.settings.rtl ? 1 : -1, t = this._clones.length + this._items.length, n = -1, i = 0, r = 0, o = []; ++n < t;) i = o[n - 1] || 0, r = this._widths[this.relative(n)] + this.settings.margin, o.push(i + r * e);\n\n            this._coordinates = o;\n          }\n        }, {\n          filter: ["width", "items", "settings"],\n          run: function () {\n            var e = this.settings.stagePadding,\n                t = this._coordinates,\n                n = {\n              width: Math.ceil(Math.abs(t[t.length - 1])) + 2 * e,\n              "padding-left": e || "",\n              "padding-right": e || ""\n            };\n            this.$stage.css(n);\n          }\n        }, {\n          filter: ["width", "items", "settings"],\n          run: function (e) {\n            var t = this._coordinates.length,\n                n = !this.settings.autoWidth,\n                i = this.$stage.children();\n            if (n && e.items.merge) for (; t--;) e.css.width = this._widths[this.relative(t)], i.eq(t).css(e.css);else n && (e.css.width = e.items.width, i.css(e.css));\n          }\n        }, {\n          filter: ["items"],\n          run: function () {\n            this._coordinates.length < 1 && this.$stage.removeAttr("style");\n          }\n        }, {\n          filter: ["width", "items", "settings"],\n          run: function (e) {\n            e.current = e.current ? this.$stage.children().index(e.current) : 0, e.current = Math.max(this.minimum(), Math.min(this.maximum(), e.current)), this.reset(e.current);\n          }\n        }, {\n          filter: ["position"],\n          run: function () {\n            this.animate(this.coordinates(this._current));\n          }\n        }, {\n          filter: ["width", "position", "items", "settings"],\n          run: function () {\n            var e,\n                t,\n                n,\n                i,\n                r = this.settings.rtl ? 1 : -1,\n                o = 2 * this.settings.stagePadding,\n                s = this.coordinates(this.current()) + o,\n                a = s + this.width() * r,\n                l = [];\n\n            for (n = 0, i = this._coordinates.length; n < i; n++) e = this._coordinates[n - 1] || 0, t = Math.abs(this._coordinates[n]) + o * r, (this.op(e, "<=", s) && this.op(e, ">", a) || this.op(t, "<", s) && this.op(t, ">", a)) && l.push(n);\n\n            this.$stage.children(".active").removeClass("active"), this.$stage.children(":eq(" + l.join("), :eq(") + ")").addClass("active"), this.$stage.children(".center").removeClass("center"), this.settings.center && this.$stage.children().eq(this.current()).addClass("center");\n          }\n        }], o.prototype.initializeStage = function () {\n          this.$stage = this.$element.find("." + this.settings.stageClass), this.$stage.length || (this.$element.addClass(this.options.loadingClass), this.$stage = e("<" + this.settings.stageElement + ">", {\n            "class": this.settings.stageClass\n          }).wrap(e("<div/>", {\n            "class": this.settings.stageOuterClass\n          })), this.$element.append(this.$stage.parent()));\n        }, o.prototype.initializeItems = function () {\n          var t = this.$element.find(".owl-item");\n          return t.length ? (this._items = t.get().map(function (t) {\n            return e(t);\n          }), this._mergers = this._items.map(function () {\n            return 1;\n          }), void this.refresh()) : (this.replace(this.$element.children().not(this.$stage.parent())), this.isVisible() ? this.refresh() : this.invalidate("width"), void this.$element.removeClass(this.options.loadingClass).addClass(this.options.loadedClass));\n        }, o.prototype.initialize = function () {\n          if (this.enter("initializing"), this.trigger("initialize"), this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl), this.settings.autoWidth && !this.is("pre-loading")) {\n            var e, t, n;\n            e = this.$element.find("img"), t = this.settings.nestedItemSelector ? "." + this.settings.nestedItemSelector : r, n = this.$element.children(t).width(), e.length && n <= 0 && this.preloadAutoWidthImages(e);\n          }\n\n          this.initializeStage(), this.initializeItems(), this.registerEventHandlers(), this.leave("initializing"), this.trigger("initialized");\n        }, o.prototype.isVisible = function () {\n          return !this.settings.checkVisibility || this.$element.is(":visible");\n        }, o.prototype.setup = function () {\n          var t = this.viewport(),\n              n = this.options.responsive,\n              i = -1,\n              r = null;\n          n ? (e.each(n, function (e) {\n            e <= t && e > i && (i = Number(e));\n          }), r = e.extend({}, this.options, n[i]), "function" == typeof r.stagePadding && (r.stagePadding = r.stagePadding()), delete r.responsive, r.responsiveClass && this.$element.attr("class", this.$element.attr("class").replace(new RegExp("(" + this.options.responsiveClass + "-)\\\\S+\\\\s", "g"), "$1" + i))) : r = e.extend({}, this.options), this.trigger("change", {\n            property: {\n              name: "settings",\n              value: r\n            }\n          }), this._breakpoint = i, this.settings = r, this.invalidate("settings"), this.trigger("changed", {\n            property: {\n              name: "settings",\n              value: this.settings\n            }\n          });\n        }, o.prototype.optionsLogic = function () {\n          this.settings.autoWidth && (this.settings.stagePadding = !1, this.settings.merge = !1);\n        }, o.prototype.prepare = function (t) {\n          var n = this.trigger("prepare", {\n            content: t\n          });\n          return n.data || (n.data = e("<" + this.settings.itemElement + "/>").addClass(this.options.itemClass).append(t)), this.trigger("prepared", {\n            content: n.data\n          }), n.data;\n        }, o.prototype.update = function () {\n          for (var t = 0, n = this._pipe.length, i = e.proxy(function (e) {\n            return this[e];\n          }, this._invalidated), r = {}; t < n;) (this._invalidated.all || e.grep(this._pipe[t].filter, i).length > 0) && this._pipe[t].run(r), t++;\n\n          this._invalidated = {}, !this.is("valid") && this.enter("valid");\n        }, o.prototype.width = function (e) {\n          switch (e = e || o.Width.Default) {\n            case o.Width.Inner:\n            case o.Width.Outer:\n              return this._width;\n\n            default:\n              return this._width - 2 * this.settings.stagePadding + this.settings.margin;\n          }\n        }, o.prototype.refresh = function () {\n          this.enter("refreshing"), this.trigger("refresh"), this.setup(), this.optionsLogic(), this.$element.addClass(this.options.refreshClass), this.update(), this.$element.removeClass(this.options.refreshClass), this.leave("refreshing"), this.trigger("refreshed");\n        }, o.prototype.onThrottledResize = function () {\n          n.clearTimeout(this.resizeTimer), this.resizeTimer = n.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);\n        }, o.prototype.onResize = function () {\n          return !!this._items.length && this._width !== this.$element.width() && !!this.isVisible() && (this.enter("resizing"), this.trigger("resize").isDefaultPrevented() ? (this.leave("resizing"), !1) : (this.invalidate("width"), this.refresh(), this.leave("resizing"), void this.trigger("resized")));\n        }, o.prototype.registerEventHandlers = function () {\n          e.support.transition && this.$stage.on(e.support.transition.end + ".owl.core", e.proxy(this.onTransitionEnd, this)), this.settings.responsive !== !1 && this.on(n, "resize", this._handlers.onThrottledResize), this.settings.mouseDrag && (this.$element.addClass(this.options.dragClass), this.$stage.on("mousedown.owl.core", e.proxy(this.onDragStart, this)), this.$stage.on("dragstart.owl.core selectstart.owl.core", function () {\n            return !1;\n          })), this.settings.touchDrag && (this.$stage.on("touchstart.owl.core", e.proxy(this.onDragStart, this)), this.$stage.on("touchcancel.owl.core", e.proxy(this.onDragEnd, this)));\n        }, o.prototype.onDragStart = function (t) {\n          var n = null;\n          3 !== t.which && (e.support.transform ? (n = this.$stage.css("transform").replace(/.*\\(|\\)| /g, "").split(","), n = {\n            x: n[16 === n.length ? 12 : 4],\n            y: n[16 === n.length ? 13 : 5]\n          }) : (n = this.$stage.position(), n = {\n            x: this.settings.rtl ? n.left + this.$stage.width() - this.width() + this.settings.margin : n.left,\n            y: n.top\n          }), this.is("animating") && (e.support.transform ? this.animate(n.x) : this.$stage.stop(), this.invalidate("position")), this.$element.toggleClass(this.options.grabClass, "mousedown" === t.type), this.speed(0), this._drag.time = new Date().getTime(), this._drag.target = e(t.target), this._drag.stage.start = n, this._drag.stage.current = n, this._drag.pointer = this.pointer(t), e(i).on("mouseup.owl.core touchend.owl.core", e.proxy(this.onDragEnd, this)), e(i).one("mousemove.owl.core touchmove.owl.core", e.proxy(function (t) {\n            var n = this.difference(this._drag.pointer, this.pointer(t));\n            e(i).on("mousemove.owl.core touchmove.owl.core", e.proxy(this.onDragMove, this)), Math.abs(n.x) < Math.abs(n.y) && this.is("valid") || (t.preventDefault(), this.enter("dragging"), this.trigger("drag"));\n          }, this)));\n        }, o.prototype.onDragMove = function (e) {\n          var t = null,\n              n = null,\n              i = null,\n              r = this.difference(this._drag.pointer, this.pointer(e)),\n              o = this.difference(this._drag.stage.start, r);\n          this.is("dragging") && (e.preventDefault(), this.settings.loop ? (t = this.coordinates(this.minimum()), n = this.coordinates(this.maximum() + 1) - t, o.x = ((o.x - t) % n + n) % n + t) : (t = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum()), n = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum()), i = this.settings.pullDrag ? -1 * r.x / 5 : 0, o.x = Math.max(Math.min(o.x, t + i), n + i)), this._drag.stage.current = o, this.animate(o.x));\n        }, o.prototype.onDragEnd = function (t) {\n          var n = this.difference(this._drag.pointer, this.pointer(t)),\n              r = this._drag.stage.current,\n              o = n.x > 0 ^ this.settings.rtl ? "left" : "right";\n          e(i).off(".owl.core"), this.$element.removeClass(this.options.grabClass), (0 !== n.x && this.is("dragging") || !this.is("valid")) && (this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed), this.current(this.closest(r.x, 0 !== n.x ? o : this._drag.direction)), this.invalidate("position"), this.update(), this._drag.direction = o, (Math.abs(n.x) > 3 || new Date().getTime() - this._drag.time > 300) && this._drag.target.one("click.owl.core", function () {\n            return !1;\n          })), this.is("dragging") && (this.leave("dragging"), this.trigger("dragged"));\n        }, o.prototype.closest = function (t, n) {\n          var i = -1,\n              o = 30,\n              s = this.width(),\n              a = this.coordinates();\n          return this.settings.freeDrag || e.each(a, e.proxy(function (e, l) {\n            return "left" === n && t > l - o && t < l + o ? i = e : "right" === n && t > l - s - o && t < l - s + o ? i = e + 1 : this.op(t, "<", l) && this.op(t, ">", a[e + 1] !== r ? a[e + 1] : l - s) && (i = "left" === n ? e + 1 : e), i === -1;\n          }, this)), this.settings.loop || (this.op(t, ">", a[this.minimum()]) ? i = t = this.minimum() : this.op(t, "<", a[this.maximum()]) && (i = t = this.maximum())), i;\n        }, o.prototype.animate = function (t) {\n          var n = this.speed() > 0;\n          this.is("animating") && this.onTransitionEnd(), n && (this.enter("animating"), this.trigger("translate")), e.support.transform3d && e.support.transition ? this.$stage.css({\n            transform: "translate3d(" + t + "px,0px,0px)",\n            transition: this.speed() / 1e3 + "s" + (this.settings.slideTransition ? " " + this.settings.slideTransition : "")\n          }) : n ? this.$stage.animate({\n            left: t + "px"\n          }, this.speed(), this.settings.fallbackEasing, e.proxy(this.onTransitionEnd, this)) : this.$stage.css({\n            left: t + "px"\n          });\n        }, o.prototype.is = function (e) {\n          return this._states.current[e] && this._states.current[e] > 0;\n        }, o.prototype.current = function (e) {\n          if (e === r) return this._current;\n          if (0 === this._items.length) return r;\n\n          if (e = this.normalize(e), this._current !== e) {\n            var t = this.trigger("change", {\n              property: {\n                name: "position",\n                value: e\n              }\n            });\n            t.data !== r && (e = this.normalize(t.data)), this._current = e, this.invalidate("position"), this.trigger("changed", {\n              property: {\n                name: "position",\n                value: this._current\n              }\n            });\n          }\n\n          return this._current;\n        }, o.prototype.invalidate = function (t) {\n          return "string" === e.type(t) && (this._invalidated[t] = !0, this.is("valid") && this.leave("valid")), e.map(this._invalidated, function (e, t) {\n            return t;\n          });\n        }, o.prototype.reset = function (e) {\n          e = this.normalize(e), e !== r && (this._speed = 0, this._current = e, this.suppress(["translate", "translated"]), this.animate(this.coordinates(e)), this.release(["translate", "translated"]));\n        }, o.prototype.normalize = function (e, t) {\n          var n = this._items.length,\n              i = t ? 0 : this._clones.length;\n          return !this.isNumeric(e) || n < 1 ? e = r : (e < 0 || e >= n + i) && (e = ((e - i / 2) % n + n) % n + i / 2), e;\n        }, o.prototype.relative = function (e) {\n          return e -= this._clones.length / 2, this.normalize(e, !0);\n        }, o.prototype.maximum = function (e) {\n          var t,\n              n,\n              i,\n              r = this.settings,\n              o = this._coordinates.length;\n          if (r.loop) o = this._clones.length / 2 + this._items.length - 1;else if (r.autoWidth || r.merge) {\n            if (t = this._items.length) for (n = this._items[--t].width(), i = this.$element.width(); t-- && (n += this._items[t].width() + this.settings.margin, !(n > i)););\n            o = t + 1;\n          } else o = r.center ? this._items.length - 1 : this._items.length - r.items;\n          return e && (o -= this._clones.length / 2), Math.max(o, 0);\n        }, o.prototype.minimum = function (e) {\n          return e ? 0 : this._clones.length / 2;\n        }, o.prototype.items = function (e) {\n          return e === r ? this._items.slice() : (e = this.normalize(e, !0), this._items[e]);\n        }, o.prototype.mergers = function (e) {\n          return e === r ? this._mergers.slice() : (e = this.normalize(e, !0), this._mergers[e]);\n        }, o.prototype.clones = function (t) {\n          var n = this._clones.length / 2,\n              i = n + this._items.length,\n              o = function (e) {\n            return e % 2 === 0 ? i + e / 2 : n - (e + 1) / 2;\n          };\n\n          return t === r ? e.map(this._clones, function (e, t) {\n            return o(t);\n          }) : e.map(this._clones, function (e, n) {\n            return e === t ? o(n) : null;\n          });\n        }, o.prototype.speed = function (e) {\n          return e !== r && (this._speed = e), this._speed;\n        }, o.prototype.coordinates = function (t) {\n          var n,\n              i = 1,\n              o = t - 1;\n          return t === r ? e.map(this._coordinates, e.proxy(function (e, t) {\n            return this.coordinates(t);\n          }, this)) : (this.settings.center ? (this.settings.rtl && (i = -1, o = t + 1), n = this._coordinates[t], n += (this.width() - n + (this._coordinates[o] || 0)) / 2 * i) : n = this._coordinates[o] || 0, n = Math.ceil(n));\n        }, o.prototype.duration = function (e, t, n) {\n          return 0 === n ? 0 : Math.min(Math.max(Math.abs(t - e), 1), 6) * Math.abs(n || this.settings.smartSpeed);\n        }, o.prototype.to = function (e, t) {\n          var n = this.current(),\n              i = null,\n              r = e - this.relative(n),\n              o = (r > 0) - (r < 0),\n              s = this._items.length,\n              a = this.minimum(),\n              l = this.maximum();\n          this.settings.loop ? (!this.settings.rewind && Math.abs(r) > s / 2 && (r += o * -1 * s), e = n + r, i = ((e - a) % s + s) % s + a, i !== e && i - r <= l && i - r > 0 && (n = i - r, e = i, this.reset(n))) : this.settings.rewind ? (l += 1, e = (e % l + l) % l) : e = Math.max(a, Math.min(l, e)), this.speed(this.duration(n, e, t)), this.current(e), this.isVisible() && this.update();\n        }, o.prototype.next = function (e) {\n          e = e || !1, this.to(this.relative(this.current()) + 1, e);\n        }, o.prototype.prev = function (e) {\n          e = e || !1, this.to(this.relative(this.current()) - 1, e);\n        }, o.prototype.onTransitionEnd = function (e) {\n          return (e === r || (e.stopPropagation(), (e.target || e.srcElement || e.originalTarget) === this.$stage.get(0))) && (this.leave("animating"), void this.trigger("translated"));\n        }, o.prototype.viewport = function () {\n          var t;\n          return this.options.responsiveBaseElement !== n ? t = e(this.options.responsiveBaseElement).width() : n.innerWidth ? t = n.innerWidth : i.documentElement && i.documentElement.clientWidth ? t = i.documentElement.clientWidth : console.warn("Can not detect viewport width."), t;\n        }, o.prototype.replace = function (n) {\n          this.$stage.empty(), this._items = [], n && (n = n instanceof t ? n : e(n)), this.settings.nestedItemSelector && (n = n.find("." + this.settings.nestedItemSelector)), n.filter(function () {\n            return 1 === this.nodeType;\n          }).each(e.proxy(function (e, t) {\n            t = this.prepare(t), this.$stage.append(t), this._items.push(t), this._mergers.push(1 * t.find("[data-merge]").addBack("[data-merge]").attr("data-merge") || 1);\n          }, this)), this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0), this.invalidate("items");\n        }, o.prototype.add = function (n, i) {\n          var o = this.relative(this._current);\n          i = i === r ? this._items.length : this.normalize(i, !0), n = n instanceof t ? n : e(n), this.trigger("add", {\n            content: n,\n            position: i\n          }), n = this.prepare(n), 0 === this._items.length || i === this._items.length ? (0 === this._items.length && this.$stage.append(n), 0 !== this._items.length && this._items[i - 1].after(n), this._items.push(n), this._mergers.push(1 * n.find("[data-merge]").addBack("[data-merge]").attr("data-merge") || 1)) : (this._items[i].before(n), this._items.splice(i, 0, n), this._mergers.splice(i, 0, 1 * n.find("[data-merge]").addBack("[data-merge]").attr("data-merge") || 1)), this._items[o] && this.reset(this._items[o].index()), this.invalidate("items"), this.trigger("added", {\n            content: n,\n            position: i\n          });\n        }, o.prototype.remove = function (e) {\n          e = this.normalize(e, !0), e !== r && (this.trigger("remove", {\n            content: this._items[e],\n            position: e\n          }), this._items[e].remove(), this._items.splice(e, 1), this._mergers.splice(e, 1), this.invalidate("items"), this.trigger("removed", {\n            content: null,\n            position: e\n          }));\n        }, o.prototype.preloadAutoWidthImages = function (t) {\n          t.each(e.proxy(function (t, n) {\n            this.enter("pre-loading"), n = e(n), e(new Image()).one("load", e.proxy(function (e) {\n              n.attr("src", e.target.src), n.css("opacity", 1), this.leave("pre-loading"), !this.is("pre-loading") && !this.is("initializing") && this.refresh();\n            }, this)).attr("src", n.attr("src") || n.attr("data-src") || n.attr("data-src-retina"));\n          }, this));\n        }, o.prototype.destroy = function () {\n          this.$element.off(".owl.core"), this.$stage.off(".owl.core"), e(i).off(".owl.core"), this.settings.responsive !== !1 && (n.clearTimeout(this.resizeTimer), this.off(n, "resize", this._handlers.onThrottledResize));\n\n          for (var t in this._plugins) this._plugins[t].destroy();\n\n          this.$stage.children(".cloned").remove(), this.$stage.unwrap(), this.$stage.children().contents().unwrap(), this.$stage.children().unwrap(), this.$stage.remove(), this.$element.removeClass(this.options.refreshClass).removeClass(this.options.loadingClass).removeClass(this.options.loadedClass).removeClass(this.options.rtlClass).removeClass(this.options.dragClass).removeClass(this.options.grabClass).attr("class", this.$element.attr("class").replace(new RegExp(this.options.responsiveClass + "-\\\\S+\\\\s", "g"), "")).removeData("owl.carousel");\n        }, o.prototype.op = function (e, t, n) {\n          var i = this.settings.rtl;\n\n          switch (t) {\n            case "<":\n              return i ? e > n : e < n;\n\n            case ">":\n              return i ? e < n : e > n;\n\n            case ">=":\n              return i ? e <= n : e >= n;\n\n            case "<=":\n              return i ? e >= n : e <= n;\n          }\n        }, o.prototype.on = function (e, t, n, i) {\n          e.addEventListener ? e.addEventListener(t, n, i) : e.attachEvent && e.attachEvent("on" + t, n);\n        }, o.prototype.off = function (e, t, n, i) {\n          e.removeEventListener ? e.removeEventListener(t, n, i) : e.detachEvent && e.detachEvent("on" + t, n);\n        }, o.prototype.trigger = function (t, n, i, r, s) {\n          var a = {\n            item: {\n              count: this._items.length,\n              index: this.current()\n            }\n          },\n              l = e.camelCase(e.grep(["on", t, i], function (e) {\n            return e;\n          }).join("-").toLowerCase()),\n              u = e.Event([t, "owl", i || "carousel"].join(".").toLowerCase(), e.extend({\n            relatedTarget: this\n          }, a, n));\n          return this._supress[t] || (e.each(this._plugins, function (e, t) {\n            t.onTrigger && t.onTrigger(u);\n          }), this.register({\n            type: o.Type.Event,\n            name: t\n          }), this.$element.trigger(u), this.settings && "function" == typeof this.settings[l] && this.settings[l].call(this, u)), u;\n        }, o.prototype.enter = function (t) {\n          e.each([t].concat(this._states.tags[t] || []), e.proxy(function (e, t) {\n            this._states.current[t] === r && (this._states.current[t] = 0), this._states.current[t]++;\n          }, this));\n        }, o.prototype.leave = function (t) {\n          e.each([t].concat(this._states.tags[t] || []), e.proxy(function (e, t) {\n            this._states.current[t]--;\n          }, this));\n        }, o.prototype.register = function (t) {\n          if (t.type === o.Type.Event) {\n            if (e.event.special[t.name] || (e.event.special[t.name] = {}), !e.event.special[t.name].owl) {\n              var n = e.event.special[t.name]._default;\n              e.event.special[t.name]._default = function (e) {\n                return !n || !n.apply || e.namespace && e.namespace.indexOf("owl") !== -1 ? e.namespace && e.namespace.indexOf("owl") > -1 : n.apply(this, arguments);\n              }, e.event.special[t.name].owl = !0;\n            }\n          } else t.type === o.Type.State && (this._states.tags[t.name] ? this._states.tags[t.name] = this._states.tags[t.name].concat(t.tags) : this._states.tags[t.name] = t.tags, this._states.tags[t.name] = e.grep(this._states.tags[t.name], e.proxy(function (n, i) {\n            return e.inArray(n, this._states.tags[t.name]) === i;\n          }, this)));\n        }, o.prototype.suppress = function (t) {\n          e.each(t, e.proxy(function (e, t) {\n            this._supress[t] = !0;\n          }, this));\n        }, o.prototype.release = function (t) {\n          e.each(t, e.proxy(function (e, t) {\n            delete this._supress[t];\n          }, this));\n        }, o.prototype.pointer = function (e) {\n          var t = {\n            x: null,\n            y: null\n          };\n          return e = e.originalEvent || e || n.event, e = e.touches && e.touches.length ? e.touches[0] : e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : e, e.pageX ? (t.x = e.pageX, t.y = e.pageY) : (t.x = e.clientX, t.y = e.clientY), t;\n        }, o.prototype.isNumeric = function (e) {\n          return !isNaN(parseFloat(e));\n        }, o.prototype.difference = function (e, t) {\n          return {\n            x: e.x - t.x,\n            y: e.y - t.y\n          };\n        }, e.fn.owlCarousel = function (t) {\n          var n = Array.prototype.slice.call(arguments, 1);\n          return this.each(function () {\n            var i = e(this),\n                r = i.data("owl.carousel");\n            r || (r = new o(this, "object" == typeof t && t), i.data("owl.carousel", r), e.each(["next", "prev", "to", "destroy", "refresh", "replace", "add", "remove"], function (t, n) {\n              r.register({\n                type: o.Type.Event,\n                name: n\n              }), r.$element.on(n + ".owl.carousel.core", e.proxy(function (e) {\n                e.namespace && e.relatedTarget !== this && (this.suppress([n]), r[n].apply(this, [].slice.call(arguments, 1)), this.release([n]));\n              }, r));\n            })), "string" == typeof t && "_" !== t.charAt(0) && r[t].apply(r, n);\n          });\n        }, e.fn.owlCarousel.Constructor = o;\n      }(window.Zepto || e, window, document), function (e, t, n, i) {\n        var r = function (t) {\n          this._core = t, this._interval = null, this._visible = null, this._handlers = {\n            "initialized.owl.carousel": e.proxy(function (e) {\n              e.namespace && this._core.settings.autoRefresh && this.watch();\n            }, this)\n          }, this._core.options = e.extend({}, r.Defaults, this._core.options), this._core.$element.on(this._handlers);\n        };\n\n        r.Defaults = {\n          autoRefresh: !0,\n          autoRefreshInterval: 500\n        }, r.prototype.watch = function () {\n          this._interval || (this._visible = this._core.isVisible(), this._interval = t.setInterval(e.proxy(this.refresh, this), this._core.settings.autoRefreshInterval));\n        }, r.prototype.refresh = function () {\n          this._core.isVisible() !== this._visible && (this._visible = !this._visible, this._core.$element.toggleClass("owl-hidden", !this._visible), this._visible && this._core.invalidate("width") && this._core.refresh());\n        }, r.prototype.destroy = function () {\n          var e, n;\n          t.clearInterval(this._interval);\n\n          for (e in this._handlers) this._core.$element.off(e, this._handlers[e]);\n\n          for (n in Object.getOwnPropertyNames(this)) "function" != typeof this[n] && (this[n] = null);\n        }, e.fn.owlCarousel.Constructor.Plugins.AutoRefresh = r;\n      }(window.Zepto || e, window, document), function (e, t, n, i) {\n        var r = function (t) {\n          this._core = t, this._loaded = [], this._handlers = {\n            "initialized.owl.carousel change.owl.carousel resized.owl.carousel": e.proxy(function (t) {\n              if (t.namespace && this._core.settings && this._core.settings.lazyLoad && (t.property && "position" == t.property.name || "initialized" == t.type)) {\n                var n = this._core.settings,\n                    r = n.center && Math.ceil(n.items / 2) || n.items,\n                    o = n.center && r * -1 || 0,\n                    s = (t.property && t.property.value !== i ? t.property.value : this._core.current()) + o,\n                    a = this._core.clones().length,\n                    l = e.proxy(function (e, t) {\n                  this.load(t);\n                }, this);\n\n                for (n.lazyLoadEager > 0 && (r += n.lazyLoadEager, n.loop && (s -= n.lazyLoadEager, r++)); o++ < r;) this.load(a / 2 + this._core.relative(s)), a && e.each(this._core.clones(this._core.relative(s)), l), s++;\n              }\n            }, this)\n          }, this._core.options = e.extend({}, r.Defaults, this._core.options), this._core.$element.on(this._handlers);\n        };\n\n        r.Defaults = {\n          lazyLoad: !1,\n          lazyLoadEager: 0\n        }, r.prototype.load = function (n) {\n          var i = this._core.$stage.children().eq(n),\n              r = i && i.find(".owl-lazy");\n\n          !r || e.inArray(i.get(0), this._loaded) > -1 || (r.each(e.proxy(function (n, i) {\n            var r,\n                o = e(i),\n                s = t.devicePixelRatio > 1 && o.attr("data-src-retina") || o.attr("data-src") || o.attr("data-srcset");\n            this._core.trigger("load", {\n              element: o,\n              url: s\n            }, "lazy"), o.is("img") ? o.one("load.owl.lazy", e.proxy(function () {\n              o.css("opacity", 1), this._core.trigger("loaded", {\n                element: o,\n                url: s\n              }, "lazy");\n            }, this)).attr("src", s) : o.is("source") ? o.one("load.owl.lazy", e.proxy(function () {\n              this._core.trigger("loaded", {\n                element: o,\n                url: s\n              }, "lazy");\n            }, this)).attr("srcset", s) : (r = new Image(), r.onload = e.proxy(function () {\n              o.css({\n                "background-image": \'url("\' + s + \'")\',\n                opacity: "1"\n              }), this._core.trigger("loaded", {\n                element: o,\n                url: s\n              }, "lazy");\n            }, this), r.src = s);\n          }, this)), this._loaded.push(i.get(0)));\n        }, r.prototype.destroy = function () {\n          var e, t;\n\n          for (e in this.handlers) this._core.$element.off(e, this.handlers[e]);\n\n          for (t in Object.getOwnPropertyNames(this)) "function" != typeof this[t] && (this[t] = null);\n        }, e.fn.owlCarousel.Constructor.Plugins.Lazy = r;\n      }(window.Zepto || e, window, document), function (e, t, n, i) {\n        var r = function (n) {\n          this._core = n, this._previousHeight = null, this._handlers = {\n            "initialized.owl.carousel refreshed.owl.carousel": e.proxy(function (e) {\n              e.namespace && this._core.settings.autoHeight && this.update();\n            }, this),\n            "changed.owl.carousel": e.proxy(function (e) {\n              e.namespace && this._core.settings.autoHeight && "position" === e.property.name && this.update();\n            }, this),\n            "loaded.owl.lazy": e.proxy(function (e) {\n              e.namespace && this._core.settings.autoHeight && e.element.closest("." + this._core.settings.itemClass).index() === this._core.current() && this.update();\n            }, this)\n          }, this._core.options = e.extend({}, r.Defaults, this._core.options), this._core.$element.on(this._handlers), this._intervalId = null;\n          var i = this;\n          e(t).on("load", function () {\n            i._core.settings.autoHeight && i.update();\n          }), e(t).resize(function () {\n            i._core.settings.autoHeight && (null != i._intervalId && clearTimeout(i._intervalId), i._intervalId = setTimeout(function () {\n              i.update();\n            }, 250));\n          });\n        };\n\n        r.Defaults = {\n          autoHeight: !1,\n          autoHeightClass: "owl-height"\n        }, r.prototype.update = function () {\n          var t = this._core._current,\n              n = t + this._core.settings.items,\n              i = this._core.settings.lazyLoad,\n              r = this._core.$stage.children().toArray().slice(t, n),\n              o = [],\n              s = 0;\n\n          e.each(r, function (t, n) {\n            o.push(e(n).height());\n          }), s = Math.max.apply(null, o), s <= 1 && i && this._previousHeight && (s = this._previousHeight), this._previousHeight = s, this._core.$stage.parent().height(s).addClass(this._core.settings.autoHeightClass);\n        }, r.prototype.destroy = function () {\n          var e, t;\n\n          for (e in this._handlers) this._core.$element.off(e, this._handlers[e]);\n\n          for (t in Object.getOwnPropertyNames(this)) "function" != typeof this[t] && (this[t] = null);\n        }, e.fn.owlCarousel.Constructor.Plugins.AutoHeight = r;\n      }(window.Zepto || e, window, document), function (e, t, n, i) {\n        var r = function (t) {\n          this._core = t, this._videos = {}, this._playing = null, this._handlers = {\n            "initialized.owl.carousel": e.proxy(function (e) {\n              e.namespace && this._core.register({\n                type: "state",\n                name: "playing",\n                tags: ["interacting"]\n              });\n            }, this),\n            "resize.owl.carousel": e.proxy(function (e) {\n              e.namespace && this._core.settings.video && this.isInFullScreen() && e.preventDefault();\n            }, this),\n            "refreshed.owl.carousel": e.proxy(function (e) {\n              e.namespace && this._core.is("resizing") && this._core.$stage.find(".cloned .owl-video-frame").remove();\n            }, this),\n            "changed.owl.carousel": e.proxy(function (e) {\n              e.namespace && "position" === e.property.name && this._playing && this.stop();\n            }, this),\n            "prepared.owl.carousel": e.proxy(function (t) {\n              if (t.namespace) {\n                var n = e(t.content).find(".owl-video");\n                n.length && (n.css("display", "none"), this.fetch(n, e(t.content)));\n              }\n            }, this)\n          }, this._core.options = e.extend({}, r.Defaults, this._core.options), this._core.$element.on(this._handlers), this._core.$element.on("click.owl.video", ".owl-video-play-icon", e.proxy(function (e) {\n            this.play(e);\n          }, this));\n        };\n\n        r.Defaults = {\n          video: !1,\n          videoHeight: !1,\n          videoWidth: !1\n        }, r.prototype.fetch = function (e, t) {\n          var n = function () {\n            return e.attr("data-vimeo-id") ? "vimeo" : e.attr("data-vzaar-id") ? "vzaar" : "youtube";\n          }(),\n              i = e.attr("data-vimeo-id") || e.attr("data-youtube-id") || e.attr("data-vzaar-id"),\n              r = e.attr("data-width") || this._core.settings.videoWidth,\n              o = e.attr("data-height") || this._core.settings.videoHeight,\n              s = e.attr("href");\n\n          if (!s) throw new Error("Missing video URL.");\n          if (i = s.match(/(http:|https:|)\\/\\/(player.|www.|app.)?(vimeo\\.com|youtu(be\\.com|\\.be|be\\.googleapis\\.com|be\\-nocookie\\.com)|vzaar\\.com)\\/(video\\/|videos\\/|embed\\/|channels\\/.+\\/|groups\\/.+\\/|watch\\?v=|v\\/)?([A-Za-z0-9._%-]*)(\\&\\S+)?/), i[3].indexOf("youtu") > -1) n = "youtube";else if (i[3].indexOf("vimeo") > -1) n = "vimeo";else {\n            if (!(i[3].indexOf("vzaar") > -1)) throw new Error("Video URL not supported.");\n            n = "vzaar";\n          }\n          i = i[6], this._videos[s] = {\n            type: n,\n            id: i,\n            width: r,\n            height: o\n          }, t.attr("data-video", s), this.thumbnail(e, this._videos[s]);\n        }, r.prototype.thumbnail = function (t, n) {\n          var i,\n              r,\n              o,\n              s = n.width && n.height ? "width:" + n.width + "px;height:" + n.height + "px;" : "",\n              a = t.find("img"),\n              l = "src",\n              u = "",\n              c = this._core.settings,\n              h = function (n) {\n            r = \'<div class="owl-video-play-icon"></div>\', i = c.lazyLoad ? e("<div/>", {\n              "class": "owl-video-tn " + u,\n              srcType: n\n            }) : e("<div/>", {\n              "class": "owl-video-tn",\n              style: "opacity:1;background-image:url(" + n + ")"\n            }), t.after(i), t.after(r);\n          };\n\n          return t.wrap(e("<div/>", {\n            "class": "owl-video-wrapper",\n            style: s\n          })), this._core.settings.lazyLoad && (l = "data-src", u = "owl-lazy"), a.length ? (h(a.attr(l)), a.remove(), !1) : void ("youtube" === n.type ? (o = "//img.youtube.com/vi/" + n.id + "/hqdefault.jpg", h(o)) : "vimeo" === n.type ? e.ajax({\n            type: "GET",\n            url: "//vimeo.com/api/v2/video/" + n.id + ".json",\n            jsonp: "callback",\n            dataType: "jsonp",\n            success: function (e) {\n              o = e[0].thumbnail_large, h(o);\n            }\n          }) : "vzaar" === n.type && e.ajax({\n            type: "GET",\n            url: "//vzaar.com/api/videos/" + n.id + ".json",\n            jsonp: "callback",\n            dataType: "jsonp",\n            success: function (e) {\n              o = e.framegrab_url, h(o);\n            }\n          }));\n        }, r.prototype.stop = function () {\n          this._core.trigger("stop", null, "video"), this._playing.find(".owl-video-frame").remove(), this._playing.removeClass("owl-video-playing"), this._playing = null, this._core.leave("playing"), this._core.trigger("stopped", null, "video");\n        }, r.prototype.play = function (t) {\n          var n,\n              i,\n              r = e(t.target),\n              o = r.closest("." + this._core.settings.itemClass),\n              s = this._videos[o.attr("data-video")],\n              a = s.width || "100%",\n              l = s.height || this._core.$stage.height();\n\n          this._playing || (this._core.enter("playing"), this._core.trigger("play", null, "video"), o = this._core.items(this._core.relative(o.index())), this._core.reset(o.index()), n = e(\'<iframe frameborder="0" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>\'), n.attr("height", l), n.attr("width", a), "youtube" === s.type ? n.attr("src", "//www.youtube.com/embed/" + s.id + "?autoplay=1&rel=0&v=" + s.id) : "vimeo" === s.type ? n.attr("src", "//player.vimeo.com/video/" + s.id + "?autoplay=1") : "vzaar" === s.type && n.attr("src", "//view.vzaar.com/" + s.id + "/player?autoplay=true"), i = e(n).wrap(\'<div class="owl-video-frame" />\').insertAfter(o.find(".owl-video")), this._playing = o.addClass("owl-video-playing"));\n        }, r.prototype.isInFullScreen = function () {\n          var t = n.fullscreenElement || n.mozFullScreenElement || n.webkitFullscreenElement;\n          return t && e(t).parent().hasClass("owl-video-frame");\n        }, r.prototype.destroy = function () {\n          var e, t;\n\n          this._core.$element.off("click.owl.video");\n\n          for (e in this._handlers) this._core.$element.off(e, this._handlers[e]);\n\n          for (t in Object.getOwnPropertyNames(this)) "function" != typeof this[t] && (this[t] = null);\n        }, e.fn.owlCarousel.Constructor.Plugins.Video = r;\n      }(window.Zepto || e, window, document), function (e, t, n, i) {\n        var r = function (t) {\n          this.core = t, this.core.options = e.extend({}, r.Defaults, this.core.options), this.swapping = !0, this.previous = i, this.next = i, this.handlers = {\n            "change.owl.carousel": e.proxy(function (e) {\n              e.namespace && "position" == e.property.name && (this.previous = this.core.current(), this.next = e.property.value);\n            }, this),\n            "drag.owl.carousel dragged.owl.carousel translated.owl.carousel": e.proxy(function (e) {\n              e.namespace && (this.swapping = "translated" == e.type);\n            }, this),\n            "translate.owl.carousel": e.proxy(function (e) {\n              e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn) && this.swap();\n            }, this)\n          }, this.core.$element.on(this.handlers);\n        };\n\n        r.Defaults = {\n          animateOut: !1,\n          animateIn: !1\n        }, r.prototype.swap = function () {\n          if (1 === this.core.settings.items && e.support.animation && e.support.transition) {\n            this.core.speed(0);\n            var t,\n                n = e.proxy(this.clear, this),\n                i = this.core.$stage.children().eq(this.previous),\n                r = this.core.$stage.children().eq(this.next),\n                o = this.core.settings.animateIn,\n                s = this.core.settings.animateOut;\n            this.core.current() !== this.previous && (s && (t = this.core.coordinates(this.previous) - this.core.coordinates(this.next), i.one(e.support.animation.end, n).css({\n              left: t + "px"\n            }).addClass("animated owl-animated-out").addClass(s)), o && r.one(e.support.animation.end, n).addClass("animated owl-animated-in").addClass(o));\n          }\n        }, r.prototype.clear = function (t) {\n          e(t.target).css({\n            left: ""\n          }).removeClass("animated owl-animated-out owl-animated-in").removeClass(this.core.settings.animateIn).removeClass(this.core.settings.animateOut), this.core.onTransitionEnd();\n        }, r.prototype.destroy = function () {\n          var e, t;\n\n          for (e in this.handlers) this.core.$element.off(e, this.handlers[e]);\n\n          for (t in Object.getOwnPropertyNames(this)) "function" != typeof this[t] && (this[t] = null);\n        }, e.fn.owlCarousel.Constructor.Plugins.Animate = r;\n      }(window.Zepto || e, window, document), function (e, t, n, i) {\n        var r = function (t) {\n          this._core = t, this._call = null, this._time = 0, this._timeout = 0, this._paused = !0, this._handlers = {\n            "changed.owl.carousel": e.proxy(function (e) {\n              e.namespace && "settings" === e.property.name ? this._core.settings.autoplay ? this.play() : this.stop() : e.namespace && "position" === e.property.name && this._paused && (this._time = 0);\n            }, this),\n            "initialized.owl.carousel": e.proxy(function (e) {\n              e.namespace && this._core.settings.autoplay && this.play();\n            }, this),\n            "play.owl.autoplay": e.proxy(function (e, t, n) {\n              e.namespace && this.play(t, n);\n            }, this),\n            "stop.owl.autoplay": e.proxy(function (e) {\n              e.namespace && this.stop();\n            }, this),\n            "mouseover.owl.autoplay": e.proxy(function () {\n              this._core.settings.autoplayHoverPause && this._core.is("rotating") && this.pause();\n            }, this),\n            "mouseleave.owl.autoplay": e.proxy(function () {\n              this._core.settings.autoplayHoverPause && this._core.is("rotating") && this.play();\n            }, this),\n            "touchstart.owl.core": e.proxy(function () {\n              this._core.settings.autoplayHoverPause && this._core.is("rotating") && this.pause();\n            }, this),\n            "touchend.owl.core": e.proxy(function () {\n              this._core.settings.autoplayHoverPause && this.play();\n            }, this)\n          }, this._core.$element.on(this._handlers), this._core.options = e.extend({}, r.Defaults, this._core.options);\n        };\n\n        r.Defaults = {\n          autoplay: !1,\n          autoplayTimeout: 5e3,\n          autoplayHoverPause: !1,\n          autoplaySpeed: !1\n        }, r.prototype._next = function (i) {\n          this._call = t.setTimeout(e.proxy(this._next, this, i), this._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read()), this._core.is("interacting") || n.hidden || this._core.next(i || this._core.settings.autoplaySpeed);\n        }, r.prototype.read = function () {\n          return new Date().getTime() - this._time;\n        }, r.prototype.play = function (n, i) {\n          var r;\n          this._core.is("rotating") || this._core.enter("rotating"), n = n || this._core.settings.autoplayTimeout, r = Math.min(this._time % (this._timeout || n), n), this._paused ? (this._time = this.read(), this._paused = !1) : t.clearTimeout(this._call), this._time += this.read() % n - r, this._timeout = n, this._call = t.setTimeout(e.proxy(this._next, this, i), n - r);\n        }, r.prototype.stop = function () {\n          this._core.is("rotating") && (this._time = 0, this._paused = !0, t.clearTimeout(this._call), this._core.leave("rotating"));\n        }, r.prototype.pause = function () {\n          this._core.is("rotating") && !this._paused && (this._time = this.read(), this._paused = !0, t.clearTimeout(this._call));\n        }, r.prototype.destroy = function () {\n          var e, t;\n          this.stop();\n\n          for (e in this._handlers) this._core.$element.off(e, this._handlers[e]);\n\n          for (t in Object.getOwnPropertyNames(this)) "function" != typeof this[t] && (this[t] = null);\n        }, e.fn.owlCarousel.Constructor.Plugins.autoplay = r;\n      }(window.Zepto || e, window, document), function (e, t, n, i) {\n        "use strict";\n\n        var r = function (t) {\n          this._core = t, this._initialized = !1, this._pages = [], this._controls = {}, this._templates = [], this.$element = this._core.$element, this._overrides = {\n            next: this._core.next,\n            prev: this._core.prev,\n            to: this._core.to\n          }, this._handlers = {\n            "prepared.owl.carousel": e.proxy(function (t) {\n              t.namespace && this._core.settings.dotsData && this._templates.push(\'<div class="\' + this._core.settings.dotClass + \'">\' + e(t.content).find("[data-dot]").addBack("[data-dot]").attr("data-dot") + "</div>");\n            }, this),\n            "added.owl.carousel": e.proxy(function (e) {\n              e.namespace && this._core.settings.dotsData && this._templates.splice(e.position, 0, this._templates.pop());\n            }, this),\n            "remove.owl.carousel": e.proxy(function (e) {\n              e.namespace && this._core.settings.dotsData && this._templates.splice(e.position, 1);\n            }, this),\n            "changed.owl.carousel": e.proxy(function (e) {\n              e.namespace && "position" == e.property.name && this.draw();\n            }, this),\n            "initialized.owl.carousel": e.proxy(function (e) {\n              e.namespace && !this._initialized && (this._core.trigger("initialize", null, "navigation"), this.initialize(), this.update(), this.draw(), this._initialized = !0, this._core.trigger("initialized", null, "navigation"));\n            }, this),\n            "refreshed.owl.carousel": e.proxy(function (e) {\n              e.namespace && this._initialized && (this._core.trigger("refresh", null, "navigation"), this.update(), this.draw(), this._core.trigger("refreshed", null, "navigation"));\n            }, this)\n          }, this._core.options = e.extend({}, r.Defaults, this._core.options), this.$element.on(this._handlers);\n        };\n\n        r.Defaults = {\n          nav: !1,\n          navText: [\'<span aria-label="Previous">&#x2039;</span>\', \'<span aria-label="Next">&#x203a;</span>\'],\n          navSpeed: !1,\n          navElement: \'button type="button" role="presentation"\',\n          navContainer: !1,\n          navContainerClass: "owl-nav",\n          navClass: ["owl-prev", "owl-next"],\n          slideBy: 1,\n          dotClass: "owl-dot",\n          dotsClass: "owl-dots",\n          dots: !0,\n          dotsEach: !1,\n          dotsData: !1,\n          dotsSpeed: !1,\n          dotsContainer: !1\n        }, r.prototype.initialize = function () {\n          var t,\n              n = this._core.settings;\n          this._controls.$relative = (n.navContainer ? e(n.navContainer) : e("<div>").addClass(n.navContainerClass).appendTo(this.$element)).addClass("disabled"), this._controls.$previous = e("<" + n.navElement + ">").addClass(n.navClass[0]).html(n.navText[0]).prependTo(this._controls.$relative).on("click", e.proxy(function (e) {\n            this.prev(n.navSpeed);\n          }, this)), this._controls.$next = e("<" + n.navElement + ">").addClass(n.navClass[1]).html(n.navText[1]).appendTo(this._controls.$relative).on("click", e.proxy(function (e) {\n            this.next(n.navSpeed);\n          }, this)), n.dotsData || (this._templates = [e(\'<button role="button">\').addClass(n.dotClass).append(e("<span>")).prop("outerHTML")]), this._controls.$absolute = (n.dotsContainer ? e(n.dotsContainer) : e("<div>").addClass(n.dotsClass).appendTo(this.$element)).addClass("disabled"), this._controls.$absolute.on("click", "button", e.proxy(function (t) {\n            var i = e(t.target).parent().is(this._controls.$absolute) ? e(t.target).index() : e(t.target).parent().index();\n            t.preventDefault(), this.to(i, n.dotsSpeed);\n          }, this));\n\n          for (t in this._overrides) this._core[t] = e.proxy(this[t], this);\n        }, r.prototype.destroy = function () {\n          var e, t, n, i, r;\n          r = this._core.settings;\n\n          for (e in this._handlers) this.$element.off(e, this._handlers[e]);\n\n          for (t in this._controls) "$relative" === t && r.navContainer ? this._controls[t].html("") : this._controls[t].remove();\n\n          for (i in this.overides) this._core[i] = this._overrides[i];\n\n          for (n in Object.getOwnPropertyNames(this)) "function" != typeof this[n] && (this[n] = null);\n        }, r.prototype.update = function () {\n          var e,\n              t,\n              n,\n              i = this._core.clones().length / 2,\n              r = i + this._core.items().length,\n              o = this._core.maximum(!0),\n              s = this._core.settings,\n              a = s.center || s.autoWidth || s.dotsData ? 1 : s.dotsEach || s.items;\n\n          if ("page" !== s.slideBy && (s.slideBy = Math.min(s.slideBy, s.items)), s.dots || "page" == s.slideBy) for (this._pages = [], e = i, t = 0, n = 0; e < r; e++) {\n            if (t >= a || 0 === t) {\n              if (this._pages.push({\n                start: Math.min(o, e - i),\n                end: e - i + a - 1\n              }), Math.min(o, e - i) === o) break;\n              t = 0, ++n;\n            }\n\n            t += this._core.mergers(this._core.relative(e));\n          }\n        }, r.prototype.draw = function () {\n          var t,\n              n = this._core.settings,\n              i = this._core.items().length <= n.items,\n              r = this._core.relative(this._core.current()),\n              o = n.loop || n.rewind;\n\n          this._controls.$relative.toggleClass("disabled", !n.nav || i), n.nav && (this._controls.$previous.toggleClass("disabled", !o && r <= this._core.minimum(!0)), this._controls.$next.toggleClass("disabled", !o && r >= this._core.maximum(!0))), this._controls.$absolute.toggleClass("disabled", !n.dots || i), n.dots && (t = this._pages.length - this._controls.$absolute.children().length, n.dotsData && 0 !== t ? this._controls.$absolute.html(this._templates.join("")) : t > 0 ? this._controls.$absolute.append(new Array(t + 1).join(this._templates[0])) : t < 0 && this._controls.$absolute.children().slice(t).remove(), this._controls.$absolute.find(".active").removeClass("active"), this._controls.$absolute.children().eq(e.inArray(this.current(), this._pages)).addClass("active"));\n        }, r.prototype.onTrigger = function (t) {\n          var n = this._core.settings;\n          t.page = {\n            index: e.inArray(this.current(), this._pages),\n            count: this._pages.length,\n            size: n && (n.center || n.autoWidth || n.dotsData ? 1 : n.dotsEach || n.items)\n          };\n        }, r.prototype.current = function () {\n          var t = this._core.relative(this._core.current());\n\n          return e.grep(this._pages, e.proxy(function (e, n) {\n            return e.start <= t && e.end >= t;\n          }, this)).pop();\n        }, r.prototype.getPosition = function (t) {\n          var n,\n              i,\n              r = this._core.settings;\n          return "page" == r.slideBy ? (n = e.inArray(this.current(), this._pages), i = this._pages.length, t ? ++n : --n, n = this._pages[(n % i + i) % i].start) : (n = this._core.relative(this._core.current()), i = this._core.items().length, t ? n += r.slideBy : n -= r.slideBy), n;\n        }, r.prototype.next = function (t) {\n          e.proxy(this._overrides.to, this._core)(this.getPosition(!0), t);\n        }, r.prototype.prev = function (t) {\n          e.proxy(this._overrides.to, this._core)(this.getPosition(!1), t);\n        }, r.prototype.to = function (t, n, i) {\n          var r;\n          !i && this._pages.length ? (r = this._pages.length, e.proxy(this._overrides.to, this._core)(this._pages[(t % r + r) % r].start, n)) : e.proxy(this._overrides.to, this._core)(t, n);\n        }, e.fn.owlCarousel.Constructor.Plugins.Navigation = r;\n      }(window.Zepto || e, window, document), function (e, t, n, i) {\n        "use strict";\n\n        var r = function (n) {\n          this._core = n, this._hashes = {}, this.$element = this._core.$element, this._handlers = {\n            "initialized.owl.carousel": e.proxy(function (n) {\n              n.namespace && "URLHash" === this._core.settings.startPosition && e(t).trigger("hashchange.owl.navigation");\n            }, this),\n            "prepared.owl.carousel": e.proxy(function (t) {\n              if (t.namespace) {\n                var n = e(t.content).find("[data-hash]").addBack("[data-hash]").attr("data-hash");\n                if (!n) return;\n                this._hashes[n] = t.content;\n              }\n            }, this),\n            "changed.owl.carousel": e.proxy(function (n) {\n              if (n.namespace && "position" === n.property.name) {\n                var i = this._core.items(this._core.relative(this._core.current())),\n                    r = e.map(this._hashes, function (e, t) {\n                  return e === i ? t : null;\n                }).join();\n\n                if (!r || t.location.hash.slice(1) === r) return;\n                t.location.hash = r;\n              }\n            }, this)\n          }, this._core.options = e.extend({}, r.Defaults, this._core.options), this.$element.on(this._handlers), e(t).on("hashchange.owl.navigation", e.proxy(function (e) {\n            var n = t.location.hash.substring(1),\n                r = this._core.$stage.children(),\n                o = this._hashes[n] && r.index(this._hashes[n]);\n\n            o !== i && o !== this._core.current() && this._core.to(this._core.relative(o), !1, !0);\n          }, this));\n        };\n\n        r.Defaults = {\n          URLhashListener: !1\n        }, r.prototype.destroy = function () {\n          var n, i;\n          e(t).off("hashchange.owl.navigation");\n\n          for (n in this._handlers) this._core.$element.off(n, this._handlers[n]);\n\n          for (i in Object.getOwnPropertyNames(this)) "function" != typeof this[i] && (this[i] = null);\n        }, e.fn.owlCarousel.Constructor.Plugins.Hash = r;\n      }(window.Zepto || e, window, document), function (e, t, n, i) {\n        function r(t, n) {\n          var r = !1,\n              o = t.charAt(0).toUpperCase() + t.slice(1);\n          return e.each((t + " " + a.join(o + " ") + o).split(" "), function (e, t) {\n            if (s[t] !== i) return r = !n || t, !1;\n          }), r;\n        }\n\n        function o(e) {\n          return r(e, !0);\n        }\n\n        var s = e("<support>").get(0).style,\n            a = "Webkit Moz O ms".split(" "),\n            l = {\n          transition: {\n            end: {\n              WebkitTransition: "webkitTransitionEnd",\n              MozTransition: "transitionend",\n              OTransition: "oTransitionEnd",\n              transition: "transitionend"\n            }\n          },\n          animation: {\n            end: {\n              WebkitAnimation: "webkitAnimationEnd",\n              MozAnimation: "animationend",\n              OAnimation: "oAnimationEnd",\n              animation: "animationend"\n            }\n          }\n        },\n            u = {\n          csstransforms: function () {\n            return !!r("transform");\n          },\n          csstransforms3d: function () {\n            return !!r("perspective");\n          },\n          csstransitions: function () {\n            return !!r("transition");\n          },\n          cssanimations: function () {\n            return !!r("animation");\n          }\n        };\n        u.csstransitions() && (e.support.transition = new String(o("transition")), e.support.transition.end = l.transition.end[e.support.transition]), u.cssanimations() && (e.support.animation = new String(o("animation")), e.support.animation.end = l.animation.end[e.support.animation]), u.csstransforms() && (e.support.transform = new String(o("transform")), e.support.transform3d = u.csstransforms3d());\n      }(window.Zepto || e, window, document);\n    }).call(t, n(3), n(3));\n  }, function (e, t) {\n    "use strict";\n\n    Object.defineProperty(t, "__esModule", {\n      value: !0\n    }), t["default"] = ["initialize", "initialized", "resize", "resized", "refresh", "refreshed", "update", "updated", "drag", "dragged", "translate", "translated", "to", "changed"];\n  }, function (e, t) {\n    e.exports = {\n      render: function () {\n        var e = this,\n            t = e.$createElement,\n            n = e._self._c || t;\n        return n("div", [n("span", {\n          directives: [{\n            name: "show",\n            rawName: "v-show",\n            value: e.showPrev,\n            expression: "showPrev"\n          }],\n          attrs: {\n            id: e.prevHandler\n          }\n        }, [e._t("prev")], 2), e._v(" "), n("div", {\n          "class": ["owl-carousel", "owl-theme"],\n          attrs: {\n            id: e.elementHandle\n          }\n        }, [e._t("default")], 2), e._v(" "), n("span", {\n          directives: [{\n            name: "show",\n            rawName: "v-show",\n            value: e.showNext,\n            expression: "showNext"\n          }],\n          attrs: {\n            id: e.nextHandler\n          }\n        }, [e._t("next")], 2)]);\n      },\n      staticRenderFns: []\n    };\n  }]);\n});\n\n//# sourceURL=webpack://kloster/./node_modules/vue-owl-carousel/dist/vue-owl-carousel.js?')},"./node_modules/vue-recaptcha/dist/vue-recaptcha.es.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VueRecaptcha\": () => (/* binding */ Recaptcha)\n/* harmony export */ });\n/* harmony import */ var vue_demi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue-demi */ \"./node_modules/vue-demi/lib/index.mjs\");\n\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar defer = function defer() {\n  var state = false; // Resolved or not\n\n  var callbacks = [];\n\n  var resolve = function resolve() {\n    if (state) {\n      return;\n    }\n\n    state = true;\n\n    for (var i = 0, len = callbacks.length; i < len; i++) {\n      callbacks[i]();\n    }\n  };\n\n  var then = function then(cb) {\n    if (!state) {\n      callbacks.push(cb);\n      return;\n    }\n\n    cb();\n  };\n\n  var deferred = {\n    resolved: function resolved() {\n      return state;\n    },\n    resolve: resolve,\n    promise: {\n      then: then\n    }\n  };\n  return deferred;\n};\n\nvar ownProp = Object.prototype.hasOwnProperty;\n\nfunction createRecaptcha() {\n  var deferred = defer();\n  return {\n    notify: function notify() {\n      deferred.resolve();\n    },\n    wait: function wait() {\n      return deferred.promise;\n    },\n    render: function render(ele, options, cb) {\n      this.wait().then(function () {\n        cb(window.grecaptcha.render(ele, options));\n      });\n    },\n    reset: function reset(widgetId) {\n      if (typeof widgetId === 'undefined') {\n        return;\n      }\n\n      this.assertLoaded();\n      this.wait().then(function () {\n        return window.grecaptcha.reset(widgetId);\n      });\n    },\n    execute: function execute(widgetId) {\n      if (typeof widgetId === 'undefined') {\n        return;\n      }\n\n      this.assertLoaded();\n      this.wait().then(function () {\n        return window.grecaptcha.execute(widgetId);\n      });\n    },\n    checkRecaptchaLoad: function checkRecaptchaLoad() {\n      if (ownProp.call(window, 'grecaptcha') && ownProp.call(window.grecaptcha, 'render')) {\n        this.notify();\n      }\n    },\n    assertLoaded: function assertLoaded() {\n      if (!deferred.resolved()) {\n        throw new Error('ReCAPTCHA has not been loaded');\n      }\n    }\n  };\n}\n\nvar recaptcha = createRecaptcha();\n\nif (typeof window !== 'undefined') {\n  window.vueRecaptchaApiLoaded = recaptcha.notify;\n}\n\nvar Recaptcha = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({\n  name: 'VueRecaptcha',\n  props: {\n    sitekey: {\n      type: String,\n      required: true\n    },\n    theme: {\n      type: String\n    },\n    badge: {\n      type: String\n    },\n    type: {\n      type: String\n    },\n    size: {\n      type: String\n    },\n    tabindex: {\n      type: String\n    },\n    loadRecaptchaScript: {\n      type: Boolean,\n      \"default\": true\n    },\n    recaptchaScriptId: {\n      type: String,\n      \"default\": '__RECAPTCHA_SCRIPT'\n    },\n    recaptchaHost: {\n      type: String,\n      \"default\": 'www.google.com'\n    },\n    language: {\n      type: String,\n      \"default\": ''\n    }\n  },\n  emits: ['render', 'verify', 'expired', 'error'],\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots,\n        emit = _ref.emit;\n    var root = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(null);\n    var widgetId = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(null);\n\n    var emitVerify = function emitVerify(response) {\n      emit('verify', response);\n    };\n\n    var emitExpired = function emitExpired() {\n      emit('expired');\n    };\n\n    var emitError = function emitError() {\n      emit('error');\n    };\n\n    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.onMounted)(function () {\n      recaptcha.checkRecaptchaLoad();\n\n      if (props.loadRecaptchaScript) {\n        if (!document.getElementById(props.recaptchaScriptId)) {\n          // Note: vueRecaptchaApiLoaded load callback name is per the latest documentation\n          var script = document.createElement('script');\n          script.id = props.recaptchaScriptId;\n          script.src = \"https://\" + props.recaptchaHost + \"/recaptcha/api.js?onload=vueRecaptchaApiLoaded&render=explicit&hl=\" + props.language;\n          script.async = true;\n          script.defer = true;\n          document.head.appendChild(script);\n        }\n      }\n\n      var opts = _extends({}, props, {\n        callback: emitVerify,\n        'expired-callback': emitExpired,\n        'error-callback': emitError\n      });\n\n      var $root = root.value;\n      var container = slots[\"default\"] ? $root.children[0] : $root;\n      recaptcha.render(container, opts, function (id) {\n        widgetId.value = id;\n        emit('render', id);\n      });\n    });\n    return {\n      root: root,\n      widgetId: widgetId,\n      reset: function reset() {\n        recaptcha.reset(widgetId.value);\n      },\n      execute: function execute() {\n        recaptcha.execute(widgetId.value);\n      }\n    };\n  },\n  render: function render() {\n    var defaultSlot = this.$slots[\"default\"];\n    var defaultContent;\n\n    if (typeof defaultSlot === 'function') {\n      defaultContent = defaultSlot();\n    } else {\n      defaultContent = defaultSlot;\n    }\n\n    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.h)('div', {\n      ref: 'root'\n    }, defaultContent);\n  }\n});\n\n\n//# sourceURL=webpack://kloster/./node_modules/vue-recaptcha/dist/vue-recaptcha.es.js?")},"./node_modules/vue/dist/vue.js":function(module,__unused_webpack_exports,__webpack_require__){eval("/*!\n * Vue.js v2.6.14\n * (c) 2014-2021 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n   true ? module.exports = factory() : 0;\n})(this, function () {\n  'use strict';\n  /*  */\n\n  var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their\n  // explicitness and function inlining.\n\n  function isUndef(v) {\n    return v === undefined || v === null;\n  }\n\n  function isDef(v) {\n    return v !== undefined && v !== null;\n  }\n\n  function isTrue(v) {\n    return v === true;\n  }\n\n  function isFalse(v) {\n    return v === false;\n  }\n  /**\n   * Check if value is primitive.\n   */\n\n\n  function isPrimitive(value) {\n    return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line\n    typeof value === 'symbol' || typeof value === 'boolean';\n  }\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   */\n\n\n  function isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n  }\n  /**\n   * Get the raw type string of a value, e.g., [object Object].\n   */\n\n\n  var _toString = Object.prototype.toString;\n\n  function toRawType(value) {\n    return _toString.call(value).slice(8, -1);\n  }\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */\n\n\n  function isPlainObject(obj) {\n    return _toString.call(obj) === '[object Object]';\n  }\n\n  function isRegExp(v) {\n    return _toString.call(v) === '[object RegExp]';\n  }\n  /**\n   * Check if val is a valid array index.\n   */\n\n\n  function isValidArrayIndex(val) {\n    var n = parseFloat(String(val));\n    return n >= 0 && Math.floor(n) === n && isFinite(val);\n  }\n\n  function isPromise(val) {\n    return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';\n  }\n  /**\n   * Convert a value to a string that is actually rendered.\n   */\n\n\n  function toString(val) {\n    return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);\n  }\n  /**\n   * Convert an input value to a number for persistence.\n   * If the conversion fails, return original string.\n   */\n\n\n  function toNumber(val) {\n    var n = parseFloat(val);\n    return isNaN(n) ? val : n;\n  }\n  /**\n   * Make a map and return a function for checking if a key\n   * is in that map.\n   */\n\n\n  function makeMap(str, expectsLowerCase) {\n    var map = Object.create(null);\n    var list = str.split(',');\n\n    for (var i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n\n    return expectsLowerCase ? function (val) {\n      return map[val.toLowerCase()];\n    } : function (val) {\n      return map[val];\n    };\n  }\n  /**\n   * Check if a tag is a built-in tag.\n   */\n\n\n  var isBuiltInTag = makeMap('slot,component', true);\n  /**\n   * Check if an attribute is a reserved attribute.\n   */\n\n  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n  /**\n   * Remove an item from an array.\n   */\n\n  function remove(arr, item) {\n    if (arr.length) {\n      var index = arr.indexOf(item);\n\n      if (index > -1) {\n        return arr.splice(index, 1);\n      }\n    }\n  }\n  /**\n   * Check whether an object has the property.\n   */\n\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  function hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  }\n  /**\n   * Create a cached version of a pure function.\n   */\n\n\n  function cached(fn) {\n    var cache = Object.create(null);\n    return function cachedFn(str) {\n      var hit = cache[str];\n      return hit || (cache[str] = fn(str));\n    };\n  }\n  /**\n   * Camelize a hyphen-delimited string.\n   */\n\n\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cached(function (str) {\n    return str.replace(camelizeRE, function (_, c) {\n      return c ? c.toUpperCase() : '';\n    });\n  });\n  /**\n   * Capitalize a string.\n   */\n\n  var capitalize = cached(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  });\n  /**\n   * Hyphenate a camelCase string.\n   */\n\n  var hyphenateRE = /\\B([A-Z])/g;\n  var hyphenate = cached(function (str) {\n    return str.replace(hyphenateRE, '-$1').toLowerCase();\n  });\n  /**\n   * Simple bind polyfill for environments that do not support it,\n   * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n   * since native bind is now performant enough in most browsers.\n   * But removing it would mean breaking code that was able to run in\n   * PhantomJS 1.x, so this must be kept for backward compatibility.\n   */\n\n  /* istanbul ignore next */\n\n  function polyfillBind(fn, ctx) {\n    function boundFn(a) {\n      var l = arguments.length;\n      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n    }\n\n    boundFn._length = fn.length;\n    return boundFn;\n  }\n\n  function nativeBind(fn, ctx) {\n    return fn.bind(ctx);\n  }\n\n  var bind = Function.prototype.bind ? nativeBind : polyfillBind;\n  /**\n   * Convert an Array-like object to a real Array.\n   */\n\n  function toArray(list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n\n    return ret;\n  }\n  /**\n   * Mix properties into target object.\n   */\n\n\n  function extend(to, _from) {\n    for (var key in _from) {\n      to[key] = _from[key];\n    }\n\n    return to;\n  }\n  /**\n   * Merge an Array of Objects into a single Object.\n   */\n\n\n  function toObject(arr) {\n    var res = {};\n\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        extend(res, arr[i]);\n      }\n    }\n\n    return res;\n  }\n  /* eslint-disable no-unused-vars */\n\n  /**\n   * Perform no operation.\n   * Stubbing args to make Flow happy without leaving useless transpiled code\n   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n   */\n\n\n  function noop(a, b, c) {}\n  /**\n   * Always return false.\n   */\n\n\n  var no = function (a, b, c) {\n    return false;\n  };\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * Return the same value.\n   */\n\n\n  var identity = function (_) {\n    return _;\n  };\n  /**\n   * Generate a string containing static keys from compiler modules.\n   */\n\n\n  function genStaticKeys(modules) {\n    return modules.reduce(function (keys, m) {\n      return keys.concat(m.staticKeys || []);\n    }, []).join(',');\n  }\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   */\n\n\n  function looseEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    var isObjectA = isObject(a);\n    var isObjectB = isObject(b);\n\n    if (isObjectA && isObjectB) {\n      try {\n        var isArrayA = Array.isArray(a);\n        var isArrayB = Array.isArray(b);\n\n        if (isArrayA && isArrayB) {\n          return a.length === b.length && a.every(function (e, i) {\n            return looseEqual(e, b[i]);\n          });\n        } else if (a instanceof Date && b instanceof Date) {\n          return a.getTime() === b.getTime();\n        } else if (!isArrayA && !isArrayB) {\n          var keysA = Object.keys(a);\n          var keysB = Object.keys(b);\n          return keysA.length === keysB.length && keysA.every(function (key) {\n            return looseEqual(a[key], b[key]);\n          });\n        } else {\n          /* istanbul ignore next */\n          return false;\n        }\n      } catch (e) {\n        /* istanbul ignore next */\n        return false;\n      }\n    } else if (!isObjectA && !isObjectB) {\n      return String(a) === String(b);\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Return the first index at which a loosely equal value can be\n   * found in the array (if value is a plain object, the array must\n   * contain an object of the same shape), or -1 if it is not present.\n   */\n\n\n  function looseIndexOf(arr, val) {\n    for (var i = 0; i < arr.length; i++) {\n      if (looseEqual(arr[i], val)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Ensure a function is called only once.\n   */\n\n\n  function once(fn) {\n    var called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        fn.apply(this, arguments);\n      }\n    };\n  }\n\n  var SSR_ATTR = 'data-server-rendered';\n  var ASSET_TYPES = ['component', 'directive', 'filter'];\n  var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];\n  /*  */\n\n  var config = {\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    // $flow-disable-line\n    optionMergeStrategies: Object.create(null),\n\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: \"development\" !== 'production',\n\n    /**\n     * Whether to enable devtools\n     */\n    devtools: \"development\" !== 'production',\n\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n\n    /**\n     * Custom user key aliases for v-on\n     */\n    // $flow-disable-line\n    keyCodes: Object.create(null),\n\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n\n    /**\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\n     * This will significantly reduce performance if set to false.\n     */\n    async: true,\n\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n  };\n  /*  */\n\n  /**\n   * unicode letters used for parsing html tags, component names and property paths.\n   * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n   * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n   */\n\n  var unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n  /**\n   * Check if a string starts with $ or _\n   */\n\n  function isReserved(str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F;\n  }\n  /**\n   * Define a property.\n   */\n\n\n  function def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n  /**\n   * Parse simple path.\n   */\n\n\n  var bailRE = new RegExp(\"[^\" + unicodeRegExp.source + \".$_\\\\d]\");\n\n  function parsePath(path) {\n    if (bailRE.test(path)) {\n      return;\n    }\n\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) {\n          return;\n        }\n\n        obj = obj[segments[i]];\n      }\n\n      return obj;\n    };\n  }\n  /*  */\n  // can we use __proto__?\n\n\n  var hasProto = ('__proto__' in {}); // Browser environment sniffing\n\n  var inBrowser = typeof window !== 'undefined';\n  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\n  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIE = UA && /msie|trident/.test(UA);\n  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n  var isEdge = UA && UA.indexOf('edge/') > 0;\n  var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';\n  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';\n  var isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n  var isPhantomJS = UA && /phantomjs/.test(UA);\n  var isFF = UA && UA.match(/firefox\\/(\\d+)/); // Firefox has a \"watch\" function on Object.prototype...\n\n  var nativeWatch = {}.watch;\n  var supportsPassive = false;\n\n  if (inBrowser) {\n    try {\n      var opts = {};\n      Object.defineProperty(opts, 'passive', {\n        get: function get() {\n          /* istanbul ignore next */\n          supportsPassive = true;\n        }\n      }); // https://github.com/facebook/flow/issues/285\n\n      window.addEventListener('test-passive', null, opts);\n    } catch (e) {}\n  } // this needs to be lazy-evaled because vue may be required before\n  // vue-server-renderer can set VUE_ENV\n\n\n  var _isServer;\n\n  var isServerRendering = function () {\n    if (_isServer === undefined) {\n      /* istanbul ignore if */\n      if (!inBrowser && !inWeex && typeof __webpack_require__.g !== 'undefined') {\n        // detect presence of vue-server-renderer and avoid\n        // Webpack shimming the process\n        _isServer = __webpack_require__.g['process'] && __webpack_require__.g['process'].env.VUE_ENV === 'server';\n      } else {\n        _isServer = false;\n      }\n    }\n\n    return _isServer;\n  }; // detect devtools\n\n\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n  /* istanbul ignore next */\n\n  function isNative(Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n  }\n\n  var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n  var _Set;\n  /* istanbul ignore if */\n  // $flow-disable-line\n\n\n  if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n  } else {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = /*@__PURE__*/function () {\n      function Set() {\n        this.set = Object.create(null);\n      }\n\n      Set.prototype.has = function has(key) {\n        return this.set[key] === true;\n      };\n\n      Set.prototype.add = function add(key) {\n        this.set[key] = true;\n      };\n\n      Set.prototype.clear = function clear() {\n        this.set = Object.create(null);\n      };\n\n      return Set;\n    }();\n  }\n  /*  */\n\n\n  var warn = noop;\n  var tip = noop;\n  var generateComponentTrace = noop; // work around flow check\n\n  var formatComponentName = noop;\n  {\n    var hasConsole = typeof console !== 'undefined';\n    var classifyRE = /(?:^|[-_])(\\w)/g;\n\n    var classify = function (str) {\n      return str.replace(classifyRE, function (c) {\n        return c.toUpperCase();\n      }).replace(/[-_]/g, '');\n    };\n\n    warn = function (msg, vm) {\n      var trace = vm ? generateComponentTrace(vm) : '';\n\n      if (config.warnHandler) {\n        config.warnHandler.call(null, msg, vm, trace);\n      } else if (hasConsole && !config.silent) {\n        console.error(\"[Vue warn]: \" + msg + trace);\n      }\n    };\n\n    tip = function (msg, vm) {\n      if (hasConsole && !config.silent) {\n        console.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n      }\n    };\n\n    formatComponentName = function (vm, includeFile) {\n      if (vm.$root === vm) {\n        return '<Root>';\n      }\n\n      var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;\n      var name = options.name || options._componentTag;\n      var file = options.__file;\n\n      if (!name && file) {\n        var match = file.match(/([^/\\\\]+)\\.vue$/);\n        name = match && match[1];\n      }\n\n      return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n    };\n\n    var repeat = function (str, n) {\n      var res = '';\n\n      while (n) {\n        if (n % 2 === 1) {\n          res += str;\n        }\n\n        if (n > 1) {\n          str += str;\n        }\n\n        n >>= 1;\n      }\n\n      return res;\n    };\n\n    generateComponentTrace = function (vm) {\n      if (vm._isVue && vm.$parent) {\n        var tree = [];\n        var currentRecursiveSequence = 0;\n\n        while (vm) {\n          if (tree.length > 0) {\n            var last = tree[tree.length - 1];\n\n            if (last.constructor === vm.constructor) {\n              currentRecursiveSequence++;\n              vm = vm.$parent;\n              continue;\n            } else if (currentRecursiveSequence > 0) {\n              tree[tree.length - 1] = [last, currentRecursiveSequence];\n              currentRecursiveSequence = 0;\n            }\n          }\n\n          tree.push(vm);\n          vm = vm.$parent;\n        }\n\n        return '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n          return \"\" + (i === 0 ? '---\x3e ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n        }).join('\\n');\n      } else {\n        return \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n      }\n    };\n  }\n  /*  */\n\n  var uid = 0;\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   */\n\n  var Dep = function Dep() {\n    this.id = uid++;\n    this.subs = [];\n  };\n\n  Dep.prototype.addSub = function addSub(sub) {\n    this.subs.push(sub);\n  };\n\n  Dep.prototype.removeSub = function removeSub(sub) {\n    remove(this.subs, sub);\n  };\n\n  Dep.prototype.depend = function depend() {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n    }\n  };\n\n  Dep.prototype.notify = function notify() {\n    // stabilize the subscriber list first\n    var subs = this.subs.slice();\n\n    if (!config.async) {\n      // subs aren't sorted in scheduler if not running async\n      // we need to sort them now to make sure they fire in correct\n      // order\n      subs.sort(function (a, b) {\n        return a.id - b.id;\n      });\n    }\n\n    for (var i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();\n    }\n  }; // The current target watcher being evaluated.\n  // This is globally unique because only one watcher\n  // can be evaluated at a time.\n\n\n  Dep.target = null;\n  var targetStack = [];\n\n  function pushTarget(target) {\n    targetStack.push(target);\n    Dep.target = target;\n  }\n\n  function popTarget() {\n    targetStack.pop();\n    Dep.target = targetStack[targetStack.length - 1];\n  }\n  /*  */\n\n\n  var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n    this.tag = tag;\n    this.data = data;\n    this.children = children;\n    this.text = text;\n    this.elm = elm;\n    this.ns = undefined;\n    this.context = context;\n    this.fnContext = undefined;\n    this.fnOptions = undefined;\n    this.fnScopeId = undefined;\n    this.key = data && data.key;\n    this.componentOptions = componentOptions;\n    this.componentInstance = undefined;\n    this.parent = undefined;\n    this.raw = false;\n    this.isStatic = false;\n    this.isRootInsert = true;\n    this.isComment = false;\n    this.isCloned = false;\n    this.isOnce = false;\n    this.asyncFactory = asyncFactory;\n    this.asyncMeta = undefined;\n    this.isAsyncPlaceholder = false;\n  };\n\n  var prototypeAccessors = {\n    child: {\n      configurable: true\n    }\n  }; // DEPRECATED: alias for componentInstance for backwards compat.\n\n  /* istanbul ignore next */\n\n  prototypeAccessors.child.get = function () {\n    return this.componentInstance;\n  };\n\n  Object.defineProperties(VNode.prototype, prototypeAccessors);\n\n  var createEmptyVNode = function (text) {\n    if (text === void 0) text = '';\n    var node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node;\n  };\n\n  function createTextVNode(val) {\n    return new VNode(undefined, undefined, undefined, String(val));\n  } // optimized shallow clone\n  // used for static nodes and slot nodes because they may be reused across\n  // multiple renders, cloning them avoids errors when DOM manipulations rely\n  // on their elm reference.\n\n\n  function cloneVNode(vnode) {\n    var cloned = new VNode(vnode.tag, vnode.data, // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.fnContext = vnode.fnContext;\n    cloned.fnOptions = vnode.fnOptions;\n    cloned.fnScopeId = vnode.fnScopeId;\n    cloned.asyncMeta = vnode.asyncMeta;\n    cloned.isCloned = true;\n    return cloned;\n  }\n  /*\n   * not type checking this file because flow doesn't play well with\n   * dynamically accessing methods on Array prototype\n   */\n\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto);\n  var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\n  /**\n   * Intercept mutating methods and emit events\n   */\n\n  methodsToPatch.forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) args[len] = arguments[len];\n\n      var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n\n      switch (method) {\n        case 'push':\n        case 'unshift':\n          inserted = args;\n          break;\n\n        case 'splice':\n          inserted = args.slice(2);\n          break;\n      }\n\n      if (inserted) {\n        ob.observeArray(inserted);\n      } // notify change\n\n\n      ob.dep.notify();\n      return result;\n    });\n  });\n  /*  */\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n  /**\n   * In some cases we may want to disable observation inside a component's\n   * update computation.\n   */\n\n  var shouldObserve = true;\n\n  function toggleObserving(value) {\n    shouldObserve = value;\n  }\n  /**\n   * Observer class that is attached to each observed\n   * object. Once attached, the observer converts the target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatch updates.\n   */\n\n\n  var Observer = function Observer(value) {\n    this.value = value;\n    this.dep = new Dep();\n    this.vmCount = 0;\n    def(value, '__ob__', this);\n\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods);\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys);\n      }\n\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  };\n  /**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n\n\n  Observer.prototype.walk = function walk(obj) {\n    var keys = Object.keys(obj);\n\n    for (var i = 0; i < keys.length; i++) {\n      defineReactive$$1(obj, keys[i]);\n    }\n  };\n  /**\n   * Observe a list of Array items.\n   */\n\n\n  Observer.prototype.observeArray = function observeArray(items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  }; // helpers\n\n  /**\n   * Augment a target Object or Array by intercepting\n   * the prototype chain using __proto__\n   */\n\n\n  function protoAugment(target, src) {\n    /* eslint-disable no-proto */\n    target.__proto__ = src;\n    /* eslint-enable no-proto */\n  }\n  /**\n   * Augment a target Object or Array by defining\n   * hidden properties.\n   */\n\n  /* istanbul ignore next */\n\n\n  function copyAugment(target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   */\n\n\n  function observe(value, asRootData) {\n    if (!isObject(value) || value instanceof VNode) {\n      return;\n    }\n\n    var ob;\n\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n      ob = new Observer(value);\n    }\n\n    if (asRootData && ob) {\n      ob.vmCount++;\n    }\n\n    return ob;\n  }\n  /**\n   * Define a reactive property on an Object.\n   */\n\n\n  function defineReactive$$1(obj, key, val, customSetter, shallow) {\n    var dep = new Dep();\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n\n    if (property && property.configurable === false) {\n      return;\n    } // cater for pre-defined getter/setters\n\n\n    var getter = property && property.get;\n    var setter = property && property.set;\n\n    if ((!getter || setter) && arguments.length === 2) {\n      val = obj[key];\n    }\n\n    var childOb = !shallow && observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter() {\n        var value = getter ? getter.call(obj) : val;\n\n        if (Dep.target) {\n          dep.depend();\n\n          if (childOb) {\n            childOb.dep.depend();\n\n            if (Array.isArray(value)) {\n              dependArray(value);\n            }\n          }\n        }\n\n        return value;\n      },\n      set: function reactiveSetter(newVal) {\n        var value = getter ? getter.call(obj) : val;\n        /* eslint-disable no-self-compare */\n\n        if (newVal === value || newVal !== newVal && value !== value) {\n          return;\n        }\n        /* eslint-enable no-self-compare */\n\n\n        if (customSetter) {\n          customSetter();\n        } // #7981: for accessor properties without setter\n\n\n        if (getter && !setter) {\n          return;\n        }\n\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n\n        childOb = !shallow && observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n  /**\n   * Set a property on an object. Adds the new property and\n   * triggers change notification if the property doesn't\n   * already exist.\n   */\n\n\n  function set(target, key, val) {\n    if (isUndef(target) || isPrimitive(target)) {\n      warn(\"Cannot set reactive property on undefined, null, or primitive value: \" + target);\n    }\n\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val;\n    }\n\n    if (key in target && !(key in Object.prototype)) {\n      target[key] = val;\n      return val;\n    }\n\n    var ob = target.__ob__;\n\n    if (target._isVue || ob && ob.vmCount) {\n      warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n      return val;\n    }\n\n    if (!ob) {\n      target[key] = val;\n      return val;\n    }\n\n    defineReactive$$1(ob.value, key, val);\n    ob.dep.notify();\n    return val;\n  }\n  /**\n   * Delete a property and trigger change if necessary.\n   */\n\n\n  function del(target, key) {\n    if (isUndef(target) || isPrimitive(target)) {\n      warn(\"Cannot delete reactive property on undefined, null, or primitive value: \" + target);\n    }\n\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.splice(key, 1);\n      return;\n    }\n\n    var ob = target.__ob__;\n\n    if (target._isVue || ob && ob.vmCount) {\n      warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n      return;\n    }\n\n    if (!hasOwn(target, key)) {\n      return;\n    }\n\n    delete target[key];\n\n    if (!ob) {\n      return;\n    }\n\n    ob.dep.notify();\n  }\n  /**\n   * Collect dependencies on array elements when the array is touched, since\n   * we cannot intercept array element access like property getters.\n   */\n\n\n  function dependArray(value) {\n    for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n      e = value[i];\n      e && e.__ob__ && e.__ob__.dep.depend();\n\n      if (Array.isArray(e)) {\n        dependArray(e);\n      }\n    }\n  }\n  /*  */\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   */\n\n\n  var strats = config.optionMergeStrategies;\n  /**\n   * Options with restrictions\n   */\n\n  {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n      if (!vm) {\n        warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n      }\n\n      return defaultStrat(parent, child);\n    };\n  }\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n\n  function mergeData(to, from) {\n    if (!from) {\n      return to;\n    }\n\n    var key, toVal, fromVal;\n    var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);\n\n    for (var i = 0; i < keys.length; i++) {\n      key = keys[i]; // in case the object is already observed...\n\n      if (key === '__ob__') {\n        continue;\n      }\n\n      toVal = to[key];\n      fromVal = from[key];\n\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {\n        mergeData(toVal, fromVal);\n      }\n    }\n\n    return to;\n  }\n  /**\n   * Data\n   */\n\n\n  function mergeDataOrFn(parentVal, childVal, vm) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal;\n      }\n\n      if (!parentVal) {\n        return childVal;\n      } // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n\n\n      return function mergedDataFn() {\n        return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);\n      };\n    } else {\n      return function mergedInstanceDataFn() {\n        // instance merge\n        var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;\n        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;\n\n        if (instanceData) {\n          return mergeData(instanceData, defaultData);\n        } else {\n          return defaultData;\n        }\n      };\n    }\n  }\n\n  strats.data = function (parentVal, childVal, vm) {\n    if (!vm) {\n      if (childVal && typeof childVal !== 'function') {\n        warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n        return parentVal;\n      }\n\n      return mergeDataOrFn(parentVal, childVal);\n    }\n\n    return mergeDataOrFn(parentVal, childVal, vm);\n  };\n  /**\n   * Hooks and props are merged as arrays.\n   */\n\n\n  function mergeHook(parentVal, childVal) {\n    var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n    return res ? dedupeHooks(res) : res;\n  }\n\n  function dedupeHooks(hooks) {\n    var res = [];\n\n    for (var i = 0; i < hooks.length; i++) {\n      if (res.indexOf(hooks[i]) === -1) {\n        res.push(hooks[i]);\n      }\n    }\n\n    return res;\n  }\n\n  LIFECYCLE_HOOKS.forEach(function (hook) {\n    strats[hook] = mergeHook;\n  });\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n\n  function mergeAssets(parentVal, childVal, vm, key) {\n    var res = Object.create(parentVal || null);\n\n    if (childVal) {\n      assertObjectType(key, childVal, vm);\n      return extend(res, childVal);\n    } else {\n      return res;\n    }\n  }\n\n  ASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n  /**\n   * Watchers.\n   *\n   * Watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n\n  strats.watch = function (parentVal, childVal, vm, key) {\n    // work around Firefox's Object.prototype.watch...\n    if (parentVal === nativeWatch) {\n      parentVal = undefined;\n    }\n\n    if (childVal === nativeWatch) {\n      childVal = undefined;\n    }\n    /* istanbul ignore if */\n\n\n    if (!childVal) {\n      return Object.create(parentVal || null);\n    }\n\n    {\n      assertObjectType(key, childVal, vm);\n    }\n\n    if (!parentVal) {\n      return childVal;\n    }\n\n    var ret = {};\n    extend(ret, parentVal);\n\n    for (var key$1 in childVal) {\n      var parent = ret[key$1];\n      var child = childVal[key$1];\n\n      if (parent && !Array.isArray(parent)) {\n        parent = [parent];\n      }\n\n      ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];\n    }\n\n    return ret;\n  };\n  /**\n   * Other object hashes.\n   */\n\n\n  strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {\n    if (childVal && \"development\" !== 'production') {\n      assertObjectType(key, childVal, vm);\n    }\n\n    if (!parentVal) {\n      return childVal;\n    }\n\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n\n    if (childVal) {\n      extend(ret, childVal);\n    }\n\n    return ret;\n  };\n\n  strats.provide = mergeDataOrFn;\n  /**\n   * Default strategy.\n   */\n\n  var defaultStrat = function (parentVal, childVal) {\n    return childVal === undefined ? parentVal : childVal;\n  };\n  /**\n   * Validate component names\n   */\n\n\n  function checkComponents(options) {\n    for (var key in options.components) {\n      validateComponentName(key);\n    }\n  }\n\n  function validateComponentName(name) {\n    if (!new RegExp(\"^[a-zA-Z][\\\\-\\\\.0-9_\" + unicodeRegExp.source + \"]*$\").test(name)) {\n      warn('Invalid component name: \"' + name + '\". Component names ' + 'should conform to valid custom element name in html5 specification.');\n    }\n\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\n      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);\n    }\n  }\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   */\n\n\n  function normalizeProps(options, vm) {\n    var props = options.props;\n\n    if (!props) {\n      return;\n    }\n\n    var res = {};\n    var i, val, name;\n\n    if (Array.isArray(props)) {\n      i = props.length;\n\n      while (i--) {\n        val = props[i];\n\n        if (typeof val === 'string') {\n          name = camelize(val);\n          res[name] = {\n            type: null\n          };\n        } else {\n          warn('props must be strings when using array syntax.');\n        }\n      }\n    } else if (isPlainObject(props)) {\n      for (var key in props) {\n        val = props[key];\n        name = camelize(key);\n        res[name] = isPlainObject(val) ? val : {\n          type: val\n        };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"props\\\": expected an Array or an Object, \" + \"but got \" + toRawType(props) + \".\", vm);\n    }\n\n    options.props = res;\n  }\n  /**\n   * Normalize all injections into Object-based format\n   */\n\n\n  function normalizeInject(options, vm) {\n    var inject = options.inject;\n\n    if (!inject) {\n      return;\n    }\n\n    var normalized = options.inject = {};\n\n    if (Array.isArray(inject)) {\n      for (var i = 0; i < inject.length; i++) {\n        normalized[inject[i]] = {\n          from: inject[i]\n        };\n      }\n    } else if (isPlainObject(inject)) {\n      for (var key in inject) {\n        var val = inject[key];\n        normalized[key] = isPlainObject(val) ? extend({\n          from: key\n        }, val) : {\n          from: val\n        };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" + \"but got \" + toRawType(inject) + \".\", vm);\n    }\n  }\n  /**\n   * Normalize raw function directives into object format.\n   */\n\n\n  function normalizeDirectives(options) {\n    var dirs = options.directives;\n\n    if (dirs) {\n      for (var key in dirs) {\n        var def$$1 = dirs[key];\n\n        if (typeof def$$1 === 'function') {\n          dirs[key] = {\n            bind: def$$1,\n            update: def$$1\n          };\n        }\n      }\n    }\n  }\n\n  function assertObjectType(name, value, vm) {\n    if (!isPlainObject(value)) {\n      warn(\"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" + \"but got \" + toRawType(value) + \".\", vm);\n    }\n  }\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   */\n\n\n  function mergeOptions(parent, child, vm) {\n    {\n      checkComponents(child);\n    }\n\n    if (typeof child === 'function') {\n      child = child.options;\n    }\n\n    normalizeProps(child, vm);\n    normalizeInject(child, vm);\n    normalizeDirectives(child); // Apply extends and mixins on the child options,\n    // but only if it is a raw options object that isn't\n    // the result of another mergeOptions call.\n    // Only merged options has the _base property.\n\n    if (!child._base) {\n      if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm);\n      }\n\n      if (child.mixins) {\n        for (var i = 0, l = child.mixins.length; i < l; i++) {\n          parent = mergeOptions(parent, child.mixins[i], vm);\n        }\n      }\n    }\n\n    var options = {};\n    var key;\n\n    for (key in parent) {\n      mergeField(key);\n    }\n\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n\n    function mergeField(key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n\n    return options;\n  }\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   */\n\n\n  function resolveAsset(options, type, id, warnMissing) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n      return;\n    }\n\n    var assets = options[type]; // check local registration variations first\n\n    if (hasOwn(assets, id)) {\n      return assets[id];\n    }\n\n    var camelizedId = camelize(id);\n\n    if (hasOwn(assets, camelizedId)) {\n      return assets[camelizedId];\n    }\n\n    var PascalCaseId = capitalize(camelizedId);\n\n    if (hasOwn(assets, PascalCaseId)) {\n      return assets[PascalCaseId];\n    } // fallback to prototype chain\n\n\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n\n    if (warnMissing && !res) {\n      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  function validateProp(key, propOptions, propsData, vm) {\n    var prop = propOptions[key];\n    var absent = !hasOwn(propsData, key);\n    var value = propsData[key]; // boolean casting\n\n    var booleanIndex = getTypeIndex(Boolean, prop.type);\n\n    if (booleanIndex > -1) {\n      if (absent && !hasOwn(prop, 'default')) {\n        value = false;\n      } else if (value === '' || value === hyphenate(key)) {\n        // only cast empty string / same name to boolean if\n        // boolean has higher priority\n        var stringIndex = getTypeIndex(String, prop.type);\n\n        if (stringIndex < 0 || booleanIndex < stringIndex) {\n          value = true;\n        }\n      }\n    } // check default value\n\n\n    if (value === undefined) {\n      value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,\n      // make sure to observe it.\n\n      var prevShouldObserve = shouldObserve;\n      toggleObserving(true);\n      observe(value);\n      toggleObserving(prevShouldObserve);\n    }\n\n    {\n      assertProp(prop, key, value, vm, absent);\n    }\n    return value;\n  }\n  /**\n   * Get the default value of a prop.\n   */\n\n\n  function getPropDefaultValue(vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n      return undefined;\n    }\n\n    var def = prop.default; // warn against non-factory defaults for Object & Array\n\n    if (isObject(def)) {\n      warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n    } // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n\n\n    if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n      return vm._props[key];\n    } // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n\n\n    return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n  }\n  /**\n   * Assert whether a prop is valid.\n   */\n\n\n  function assertProp(prop, name, value, vm, absent) {\n    if (prop.required && absent) {\n      warn('Missing required prop: \"' + name + '\"', vm);\n      return;\n    }\n\n    if (value == null && !prop.required) {\n      return;\n    }\n\n    var type = prop.type;\n    var valid = !type || type === true;\n    var expectedTypes = [];\n\n    if (type) {\n      if (!Array.isArray(type)) {\n        type = [type];\n      }\n\n      for (var i = 0; i < type.length && !valid; i++) {\n        var assertedType = assertType(value, type[i], vm);\n        expectedTypes.push(assertedType.expectedType || '');\n        valid = assertedType.valid;\n      }\n    }\n\n    var haveExpectedTypes = expectedTypes.some(function (t) {\n      return t;\n    });\n\n    if (!valid && haveExpectedTypes) {\n      warn(getInvalidTypeMessage(name, value, expectedTypes), vm);\n      return;\n    }\n\n    var validator = prop.validator;\n\n    if (validator) {\n      if (!validator(value)) {\n        warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n      }\n    }\n  }\n\n  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;\n\n  function assertType(value, type, vm) {\n    var valid;\n    var expectedType = getType(type);\n\n    if (simpleCheckRE.test(expectedType)) {\n      var t = typeof value;\n      valid = t === expectedType.toLowerCase(); // for primitive wrapper objects\n\n      if (!valid && t === 'object') {\n        valid = value instanceof type;\n      }\n    } else if (expectedType === 'Object') {\n      valid = isPlainObject(value);\n    } else if (expectedType === 'Array') {\n      valid = Array.isArray(value);\n    } else {\n      try {\n        valid = value instanceof type;\n      } catch (e) {\n        warn('Invalid prop type: \"' + String(type) + '\" is not a constructor', vm);\n        valid = false;\n      }\n    }\n\n    return {\n      valid: valid,\n      expectedType: expectedType\n    };\n  }\n\n  var functionTypeCheckRE = /^\\s*function (\\w+)/;\n  /**\n   * Use function string name to check built-in types,\n   * because a simple equality check will fail when running\n   * across different vms / iframes.\n   */\n\n  function getType(fn) {\n    var match = fn && fn.toString().match(functionTypeCheckRE);\n    return match ? match[1] : '';\n  }\n\n  function isSameType(a, b) {\n    return getType(a) === getType(b);\n  }\n\n  function getTypeIndex(type, expectedTypes) {\n    if (!Array.isArray(expectedTypes)) {\n      return isSameType(expectedTypes, type) ? 0 : -1;\n    }\n\n    for (var i = 0, len = expectedTypes.length; i < len; i++) {\n      if (isSameType(expectedTypes[i], type)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function getInvalidTypeMessage(name, value, expectedTypes) {\n    var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" + \" Expected \" + expectedTypes.map(capitalize).join(', ');\n    var expectedType = expectedTypes[0];\n    var receivedType = toRawType(value); // check if we need to specify expected value\n\n    if (expectedTypes.length === 1 && isExplicable(expectedType) && isExplicable(typeof value) && !isBoolean(expectedType, receivedType)) {\n      message += \" with value \" + styleValue(value, expectedType);\n    }\n\n    message += \", got \" + receivedType + \" \"; // check if we need to specify received value\n\n    if (isExplicable(receivedType)) {\n      message += \"with value \" + styleValue(value, receivedType) + \".\";\n    }\n\n    return message;\n  }\n\n  function styleValue(value, type) {\n    if (type === 'String') {\n      return \"\\\"\" + value + \"\\\"\";\n    } else if (type === 'Number') {\n      return \"\" + Number(value);\n    } else {\n      return \"\" + value;\n    }\n  }\n\n  var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];\n\n  function isExplicable(value) {\n    return EXPLICABLE_TYPES.some(function (elem) {\n      return value.toLowerCase() === elem;\n    });\n  }\n\n  function isBoolean() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len];\n\n    return args.some(function (elem) {\n      return elem.toLowerCase() === 'boolean';\n    });\n  }\n  /*  */\n\n\n  function handleError(err, vm, info) {\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n    // See: https://github.com/vuejs/vuex/issues/1505\n    pushTarget();\n\n    try {\n      if (vm) {\n        var cur = vm;\n\n        while (cur = cur.$parent) {\n          var hooks = cur.$options.errorCaptured;\n\n          if (hooks) {\n            for (var i = 0; i < hooks.length; i++) {\n              try {\n                var capture = hooks[i].call(cur, err, vm, info) === false;\n\n                if (capture) {\n                  return;\n                }\n              } catch (e) {\n                globalHandleError(e, cur, 'errorCaptured hook');\n              }\n            }\n          }\n        }\n      }\n\n      globalHandleError(err, vm, info);\n    } finally {\n      popTarget();\n    }\n  }\n\n  function invokeWithErrorHandling(handler, context, args, vm, info) {\n    var res;\n\n    try {\n      res = args ? handler.apply(context, args) : handler.call(context);\n\n      if (res && !res._isVue && isPromise(res) && !res._handled) {\n        res.catch(function (e) {\n          return handleError(e, vm, info + \" (Promise/async)\");\n        }); // issue #9511\n        // avoid catch triggering multiple times when nested calls\n\n        res._handled = true;\n      }\n    } catch (e) {\n      handleError(e, vm, info);\n    }\n\n    return res;\n  }\n\n  function globalHandleError(err, vm, info) {\n    if (config.errorHandler) {\n      try {\n        return config.errorHandler.call(null, err, vm, info);\n      } catch (e) {\n        // if the user intentionally throws the original error in the handler,\n        // do not log it twice\n        if (e !== err) {\n          logError(e, null, 'config.errorHandler');\n        }\n      }\n    }\n\n    logError(err, vm, info);\n  }\n\n  function logError(err, vm, info) {\n    {\n      warn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n    }\n    /* istanbul ignore else */\n\n    if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err;\n    }\n  }\n  /*  */\n\n\n  var isUsingMicroTask = false;\n  var callbacks = [];\n  var pending = false;\n\n  function flushCallbacks() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  } // Here we have async deferring wrappers using microtasks.\n  // In 2.5 we used (macro) tasks (in combination with microtasks).\n  // However, it has subtle problems when state is changed right before repaint\n  // (e.g. #6813, out-in transitions).\n  // Also, using (macro) tasks in event handler would cause some weird behaviors\n  // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n  // So we now use microtasks everywhere, again.\n  // A major drawback of this tradeoff is that there are some scenarios\n  // where microtasks have too high a priority and fire in between supposedly\n  // sequential events (e.g. #4521, #6690, which have workarounds)\n  // or even between bubbling of the same event (#6566).\n\n\n  var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n\n  /* istanbul ignore next, $flow-disable-line */\n\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n\n    timerFunc = function () {\n      p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n\n      if (isIOS) {\n        setTimeout(noop);\n      }\n    };\n\n    isUsingMicroTask = true;\n  } else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]')) {\n    // Use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS, iOS7, Android 4.4\n    // (#6466 MutationObserver is unreliable in IE11)\n    var counter = 1;\n    var observer = new MutationObserver(flushCallbacks);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n\n    isUsingMicroTask = true;\n  } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    // Fallback to setImmediate.\n    // Technically it leverages the (macro) task queue,\n    // but it is still a better choice than setTimeout.\n    timerFunc = function () {\n      setImmediate(flushCallbacks);\n    };\n  } else {\n    // Fallback to setTimeout.\n    timerFunc = function () {\n      setTimeout(flushCallbacks, 0);\n    };\n  }\n\n  function nextTick(cb, ctx) {\n    var _resolve;\n\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    } // $flow-disable-line\n\n\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      });\n    }\n  }\n  /*  */\n\n\n  var mark;\n  var measure;\n  {\n    var perf = inBrowser && window.performance;\n    /* istanbul ignore if */\n\n    if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n      mark = function (tag) {\n        return perf.mark(tag);\n      };\n\n      measure = function (name, startTag, endTag) {\n        perf.measure(name, startTag, endTag);\n        perf.clearMarks(startTag);\n        perf.clearMarks(endTag); // perf.clearMeasures(name)\n      };\n    }\n  }\n  /* not type checking this file because flow doesn't play well with Proxy */\n\n  var initProxy;\n  {\n    var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' + 'require' // for Webpack/Browserify\n    );\n\n    var warnNonPresent = function (target, key) {\n      warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\n    };\n\n    var warnReservedPrefix = function (target, key) {\n      warn(\"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" + 'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals. ' + 'See: https://vuejs.org/v2/api/#data', target);\n    };\n\n    var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);\n\n    if (hasProxy) {\n      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n      config.keyCodes = new Proxy(config.keyCodes, {\n        set: function set(target, key, value) {\n          if (isBuiltInModifier(key)) {\n            warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n            return false;\n          } else {\n            target[key] = value;\n            return true;\n          }\n        }\n      });\n    }\n\n    var hasHandler = {\n      has: function has(target, key) {\n        var has = (key in target);\n        var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);\n\n        if (!has && !isAllowed) {\n          if (key in target.$data) {\n            warnReservedPrefix(target, key);\n          } else {\n            warnNonPresent(target, key);\n          }\n        }\n\n        return has || !isAllowed;\n      }\n    };\n    var getHandler = {\n      get: function get(target, key) {\n        if (typeof key === 'string' && !(key in target)) {\n          if (key in target.$data) {\n            warnReservedPrefix(target, key);\n          } else {\n            warnNonPresent(target, key);\n          }\n        }\n\n        return target[key];\n      }\n    };\n\n    initProxy = function initProxy(vm) {\n      if (hasProxy) {\n        // determine which proxy handler to use\n        var options = vm.$options;\n        var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n        vm._renderProxy = new Proxy(vm, handlers);\n      } else {\n        vm._renderProxy = vm;\n      }\n    };\n  }\n  /*  */\n\n  var seenObjects = new _Set();\n  /**\n   * Recursively traverse an object to evoke all converted\n   * getters, so that every nested property inside the object\n   * is collected as a \"deep\" dependency.\n   */\n\n  function traverse(val) {\n    _traverse(val, seenObjects);\n\n    seenObjects.clear();\n  }\n\n  function _traverse(val, seen) {\n    var i, keys;\n    var isA = Array.isArray(val);\n\n    if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {\n      return;\n    }\n\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n\n      if (seen.has(depId)) {\n        return;\n      }\n\n      seen.add(depId);\n    }\n\n    if (isA) {\n      i = val.length;\n\n      while (i--) {\n        _traverse(val[i], seen);\n      }\n    } else {\n      keys = Object.keys(val);\n      i = keys.length;\n\n      while (i--) {\n        _traverse(val[keys[i]], seen);\n      }\n    }\n  }\n  /*  */\n\n\n  var normalizeEvent = cached(function (name) {\n    var passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n\n    name = once$$1 ? name.slice(1) : name;\n    var capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n      name: name,\n      once: once$$1,\n      capture: capture,\n      passive: passive\n    };\n  });\n\n  function createFnInvoker(fns, vm) {\n    function invoker() {\n      var arguments$1 = arguments;\n      var fns = invoker.fns;\n\n      if (Array.isArray(fns)) {\n        var cloned = fns.slice();\n\n        for (var i = 0; i < cloned.length; i++) {\n          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n        }\n      } else {\n        // return handler return value for single handlers\n        return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\");\n      }\n    }\n\n    invoker.fns = fns;\n    return invoker;\n  }\n\n  function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {\n    var name, def$$1, cur, old, event;\n\n    for (name in on) {\n      def$$1 = cur = on[name];\n      old = oldOn[name];\n      event = normalizeEvent(name);\n\n      if (isUndef(cur)) {\n        warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n      } else if (isUndef(old)) {\n        if (isUndef(cur.fns)) {\n          cur = on[name] = createFnInvoker(cur, vm);\n        }\n\n        if (isTrue(event.once)) {\n          cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n        }\n\n        add(event.name, cur, event.capture, event.passive, event.params);\n      } else if (cur !== old) {\n        old.fns = cur;\n        on[name] = old;\n      }\n    }\n\n    for (name in oldOn) {\n      if (isUndef(on[name])) {\n        event = normalizeEvent(name);\n        remove$$1(event.name, oldOn[name], event.capture);\n      }\n    }\n  }\n  /*  */\n\n\n  function mergeVNodeHook(def, hookKey, hook) {\n    if (def instanceof VNode) {\n      def = def.data.hook || (def.data.hook = {});\n    }\n\n    var invoker;\n    var oldHook = def[hookKey];\n\n    function wrappedHook() {\n      hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once\n      // and prevent memory leak\n\n      remove(invoker.fns, wrappedHook);\n    }\n\n    if (isUndef(oldHook)) {\n      // no existing hook\n      invoker = createFnInvoker([wrappedHook]);\n    } else {\n      /* istanbul ignore if */\n      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n        // already a merged invoker\n        invoker = oldHook;\n        invoker.fns.push(wrappedHook);\n      } else {\n        // existing plain hook\n        invoker = createFnInvoker([oldHook, wrappedHook]);\n      }\n    }\n\n    invoker.merged = true;\n    def[hookKey] = invoker;\n  }\n  /*  */\n\n\n  function extractPropsFromVNodeData(data, Ctor, tag) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    var propOptions = Ctor.options.props;\n\n    if (isUndef(propOptions)) {\n      return;\n    }\n\n    var res = {};\n    var attrs = data.attrs;\n    var props = data.props;\n\n    if (isDef(attrs) || isDef(props)) {\n      for (var key in propOptions) {\n        var altKey = hyphenate(key);\n        {\n          var keyInLowerCase = key.toLowerCase();\n\n          if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n            tip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n          }\n        }\n        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n      }\n    }\n\n    return res;\n  }\n\n  function checkProp(res, hash, key, altKey, preserve) {\n    if (isDef(hash)) {\n      if (hasOwn(hash, key)) {\n        res[key] = hash[key];\n\n        if (!preserve) {\n          delete hash[key];\n        }\n\n        return true;\n      } else if (hasOwn(hash, altKey)) {\n        res[key] = hash[altKey];\n\n        if (!preserve) {\n          delete hash[altKey];\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /*  */\n  // The template compiler attempts to minimize the need for normalization by\n  // statically analyzing the template at compile time.\n  //\n  // For plain HTML markup, normalization can be completely skipped because the\n  // generated render function is guaranteed to return Array<VNode>. There are\n  // two cases where extra normalization is needed:\n  // 1. When the children contains components - because a functional component\n  // may return an Array instead of a single root. In this case, just a simple\n  // normalization is needed - if any child is an Array, we flatten the whole\n  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n  // because functional components already normalize their own children.\n\n\n  function simpleNormalizeChildren(children) {\n    for (var i = 0; i < children.length; i++) {\n      if (Array.isArray(children[i])) {\n        return Array.prototype.concat.apply([], children);\n      }\n    }\n\n    return children;\n  } // 2. When the children contains constructs that always generated nested Arrays,\n  // e.g. <template>, <slot>, v-for, or when the children is provided by user\n  // with hand-written render functions / JSX. In such cases a full normalization\n  // is needed to cater to all possible types of children values.\n\n\n  function normalizeChildren(children) {\n    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n  }\n\n  function isTextNode(node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n  }\n\n  function normalizeArrayChildren(children, nestedIndex) {\n    var res = [];\n    var i, c, lastIndex, last;\n\n    for (i = 0; i < children.length; i++) {\n      c = children[i];\n\n      if (isUndef(c) || typeof c === 'boolean') {\n        continue;\n      }\n\n      lastIndex = res.length - 1;\n      last = res[lastIndex]; //  nested\n\n      if (Array.isArray(c)) {\n        if (c.length > 0) {\n          c = normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i); // merge adjacent text nodes\n\n          if (isTextNode(c[0]) && isTextNode(last)) {\n            res[lastIndex] = createTextVNode(last.text + c[0].text);\n            c.shift();\n          }\n\n          res.push.apply(res, c);\n        }\n      } else if (isPrimitive(c)) {\n        if (isTextNode(last)) {\n          // merge adjacent text nodes\n          // this is necessary for SSR hydration because text nodes are\n          // essentially merged when rendered to HTML strings\n          res[lastIndex] = createTextVNode(last.text + c);\n        } else if (c !== '') {\n          // convert primitive to vnode\n          res.push(createTextVNode(c));\n        }\n      } else {\n        if (isTextNode(c) && isTextNode(last)) {\n          // merge adjacent text nodes\n          res[lastIndex] = createTextVNode(last.text + c.text);\n        } else {\n          // default key for nested array children (likely generated by v-for)\n          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n          }\n\n          res.push(c);\n        }\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  function initProvide(vm) {\n    var provide = vm.$options.provide;\n\n    if (provide) {\n      vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n    }\n  }\n\n  function initInjections(vm) {\n    var result = resolveInject(vm.$options.inject, vm);\n\n    if (result) {\n      toggleObserving(false);\n      Object.keys(result).forEach(function (key) {\n        /* istanbul ignore else */\n        {\n          defineReactive$$1(vm, key, result[key], function () {\n            warn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n          });\n        }\n      });\n      toggleObserving(true);\n    }\n  }\n\n  function resolveInject(inject, vm) {\n    if (inject) {\n      // inject is :any because flow is not smart enough to figure out cached\n      var result = Object.create(null);\n      var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i]; // #6574 in case the inject object is observed...\n\n        if (key === '__ob__') {\n          continue;\n        }\n\n        var provideKey = inject[key].from;\n        var source = vm;\n\n        while (source) {\n          if (source._provided && hasOwn(source._provided, provideKey)) {\n            result[key] = source._provided[provideKey];\n            break;\n          }\n\n          source = source.$parent;\n        }\n\n        if (!source) {\n          if ('default' in inject[key]) {\n            var provideDefault = inject[key].default;\n            result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;\n          } else {\n            warn(\"Injection \\\"\" + key + \"\\\" not found\", vm);\n          }\n        }\n      }\n\n      return result;\n    }\n  }\n  /*  */\n\n  /**\n   * Runtime helper for resolving raw children VNodes into a slot object.\n   */\n\n\n  function resolveSlots(children, context) {\n    if (!children || !children.length) {\n      return {};\n    }\n\n    var slots = {};\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node\n\n      if (data && data.attrs && data.attrs.slot) {\n        delete data.attrs.slot;\n      } // named slots should only be respected if the vnode was rendered in the\n      // same context.\n\n\n      if ((child.context === context || child.fnContext === context) && data && data.slot != null) {\n        var name = data.slot;\n        var slot = slots[name] || (slots[name] = []);\n\n        if (child.tag === 'template') {\n          slot.push.apply(slot, child.children || []);\n        } else {\n          slot.push(child);\n        }\n      } else {\n        (slots.default || (slots.default = [])).push(child);\n      }\n    } // ignore slots that contains only whitespace\n\n\n    for (var name$1 in slots) {\n      if (slots[name$1].every(isWhitespace)) {\n        delete slots[name$1];\n      }\n    }\n\n    return slots;\n  }\n\n  function isWhitespace(node) {\n    return node.isComment && !node.asyncFactory || node.text === ' ';\n  }\n  /*  */\n\n\n  function isAsyncPlaceholder(node) {\n    return node.isComment && node.asyncFactory;\n  }\n  /*  */\n\n\n  function normalizeScopedSlots(slots, normalSlots, prevSlots) {\n    var res;\n    var hasNormalSlots = Object.keys(normalSlots).length > 0;\n    var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n    var key = slots && slots.$key;\n\n    if (!slots) {\n      res = {};\n    } else if (slots._normalized) {\n      // fast path 1: child component re-render only, parent did not change\n      return slots._normalized;\n    } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {\n      // fast path 2: stable scoped slots w/ no normal slots to proxy,\n      // only need to normalize once\n      return prevSlots;\n    } else {\n      res = {};\n\n      for (var key$1 in slots) {\n        if (slots[key$1] && key$1[0] !== '$') {\n          res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n        }\n      }\n    } // expose normal slots on scopedSlots\n\n\n    for (var key$2 in normalSlots) {\n      if (!(key$2 in res)) {\n        res[key$2] = proxyNormalSlot(normalSlots, key$2);\n      }\n    } // avoriaz seems to mock a non-extensible $scopedSlots object\n    // and when that is passed down this would cause an error\n\n\n    if (slots && Object.isExtensible(slots)) {\n      slots._normalized = res;\n    }\n\n    def(res, '$stable', isStable);\n    def(res, '$key', key);\n    def(res, '$hasNormal', hasNormalSlots);\n    return res;\n  }\n\n  function normalizeScopedSlot(normalSlots, key, fn) {\n    var normalized = function () {\n      var res = arguments.length ? fn.apply(null, arguments) : fn({});\n      res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode\n      : normalizeChildren(res);\n      var vnode = res && res[0];\n      return res && (!vnode || res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode) // #9658, #10391\n      ) ? undefined : res;\n    }; // this is a slot using the new v-slot syntax without scope. although it is\n    // compiled as a scoped slot, render fn users would expect it to be present\n    // on this.$slots because the usage is semantically a normal slot.\n\n\n    if (fn.proxy) {\n      Object.defineProperty(normalSlots, key, {\n        get: normalized,\n        enumerable: true,\n        configurable: true\n      });\n    }\n\n    return normalized;\n  }\n\n  function proxyNormalSlot(slots, key) {\n    return function () {\n      return slots[key];\n    };\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering v-for lists.\n   */\n\n\n  function renderList(val, render) {\n    var ret, i, l, keys, key;\n\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      if (hasSymbol && val[Symbol.iterator]) {\n        ret = [];\n        var iterator = val[Symbol.iterator]();\n        var result = iterator.next();\n\n        while (!result.done) {\n          ret.push(render(result.value, ret.length));\n          result = iterator.next();\n        }\n      } else {\n        keys = Object.keys(val);\n        ret = new Array(keys.length);\n\n        for (i = 0, l = keys.length; i < l; i++) {\n          key = keys[i];\n          ret[i] = render(val[key], key, i);\n        }\n      }\n    }\n\n    if (!isDef(ret)) {\n      ret = [];\n    }\n\n    ret._isVList = true;\n    return ret;\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering <slot>\n   */\n\n\n  function renderSlot(name, fallbackRender, props, bindObject) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    var nodes;\n\n    if (scopedSlotFn) {\n      // scoped slot\n      props = props || {};\n\n      if (bindObject) {\n        if (!isObject(bindObject)) {\n          warn('slot v-bind without argument expects an Object', this);\n        }\n\n        props = extend(extend({}, bindObject), props);\n      }\n\n      nodes = scopedSlotFn(props) || (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);\n    } else {\n      nodes = this.$slots[name] || (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);\n    }\n\n    var target = props && props.slot;\n\n    if (target) {\n      return this.$createElement('template', {\n        slot: target\n      }, nodes);\n    } else {\n      return nodes;\n    }\n  }\n  /*  */\n\n  /**\n   * Runtime helper for resolving filters\n   */\n\n\n  function resolveFilter(id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity;\n  }\n  /*  */\n\n\n  function isKeyNotMatch(expect, actual) {\n    if (Array.isArray(expect)) {\n      return expect.indexOf(actual) === -1;\n    } else {\n      return expect !== actual;\n    }\n  }\n  /**\n   * Runtime helper for checking keyCodes from config.\n   * exposed as Vue.prototype._k\n   * passing in eventKeyName as last argument separately for backwards compat\n   */\n\n\n  function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\n    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n      return isKeyNotMatch(builtInKeyName, eventKeyName);\n    } else if (mappedKeyCode) {\n      return isKeyNotMatch(mappedKeyCode, eventKeyCode);\n    } else if (eventKeyName) {\n      return hyphenate(eventKeyName) !== key;\n    }\n\n    return eventKeyCode === undefined;\n  }\n  /*  */\n\n  /**\n   * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n   */\n\n\n  function bindObjectProps(data, tag, value, asProp, isSync) {\n    if (value) {\n      if (!isObject(value)) {\n        warn('v-bind without argument expects an Object or Array value', this);\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n\n        var hash;\n\n        var loop = function (key) {\n          if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n            hash = data;\n          } else {\n            var type = data.attrs && data.attrs.type;\n            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n          }\n\n          var camelizedKey = camelize(key);\n          var hyphenatedKey = hyphenate(key);\n\n          if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n            hash[key] = value[key];\n\n            if (isSync) {\n              var on = data.on || (data.on = {});\n\n              on[\"update:\" + key] = function ($event) {\n                value[key] = $event;\n              };\n            }\n          }\n        };\n\n        for (var key in value) loop(key);\n      }\n    }\n\n    return data;\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering static trees.\n   */\n\n\n  function renderStatic(index, isInFor) {\n    var cached = this._staticTrees || (this._staticTrees = []);\n    var tree = cached[index]; // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree.\n\n    if (tree && !isInFor) {\n      return tree;\n    } // otherwise, render a fresh tree.\n\n\n    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates\n    );\n    markStatic(tree, \"__static__\" + index, false);\n    return tree;\n  }\n  /**\n   * Runtime helper for v-once.\n   * Effectively it means marking the node as static with a unique key.\n   */\n\n\n  function markOnce(tree, index, key) {\n    markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n    return tree;\n  }\n\n  function markStatic(tree, key, isOnce) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], key + \"_\" + i, isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode(node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n  /*  */\n\n\n  function bindObjectListeners(data, value) {\n    if (value) {\n      if (!isPlainObject(value)) {\n        warn('v-on without argument expects an Object value', this);\n      } else {\n        var on = data.on = data.on ? extend({}, data.on) : {};\n\n        for (var key in value) {\n          var existing = on[key];\n          var ours = value[key];\n          on[key] = existing ? [].concat(existing, ours) : ours;\n        }\n      }\n    }\n\n    return data;\n  }\n  /*  */\n\n\n  function resolveScopedSlots(fns, // see flow/vnode\n  res, // the following are added in 2.6\n  hasDynamicKeys, contentHashKey) {\n    res = res || {\n      $stable: !hasDynamicKeys\n    };\n\n    for (var i = 0; i < fns.length; i++) {\n      var slot = fns[i];\n\n      if (Array.isArray(slot)) {\n        resolveScopedSlots(slot, res, hasDynamicKeys);\n      } else if (slot) {\n        // marker for reverse proxying v-slot without scope on this.$slots\n        if (slot.proxy) {\n          slot.fn.proxy = true;\n        }\n\n        res[slot.key] = slot.fn;\n      }\n    }\n\n    if (contentHashKey) {\n      res.$key = contentHashKey;\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  function bindDynamicKeys(baseObj, values) {\n    for (var i = 0; i < values.length; i += 2) {\n      var key = values[i];\n\n      if (typeof key === 'string' && key) {\n        baseObj[values[i]] = values[i + 1];\n      } else if (key !== '' && key !== null) {\n        // null is a special value for explicitly removing a binding\n        warn(\"Invalid value for dynamic directive argument (expected string or null): \" + key, this);\n      }\n    }\n\n    return baseObj;\n  } // helper to dynamically append modifier runtime markers to event names.\n  // ensure only append when value is already string, otherwise it will be cast\n  // to string and cause the type check to miss.\n\n\n  function prependModifier(value, symbol) {\n    return typeof value === 'string' ? symbol + value : value;\n  }\n  /*  */\n\n\n  function installRenderHelpers(target) {\n    target._o = markOnce;\n    target._n = toNumber;\n    target._s = toString;\n    target._l = renderList;\n    target._t = renderSlot;\n    target._q = looseEqual;\n    target._i = looseIndexOf;\n    target._m = renderStatic;\n    target._f = resolveFilter;\n    target._k = checkKeyCodes;\n    target._b = bindObjectProps;\n    target._v = createTextVNode;\n    target._e = createEmptyVNode;\n    target._u = resolveScopedSlots;\n    target._g = bindObjectListeners;\n    target._d = bindDynamicKeys;\n    target._p = prependModifier;\n  }\n  /*  */\n\n\n  function FunctionalRenderContext(data, props, children, parent, Ctor) {\n    var this$1 = this;\n    var options = Ctor.options; // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n\n    var contextVm;\n\n    if (hasOwn(parent, '_uid')) {\n      contextVm = Object.create(parent); // $flow-disable-line\n\n      contextVm._original = parent;\n    } else {\n      // the context vm passed in is a functional context as well.\n      // in this case we want to make sure we are able to get a hold to the\n      // real context instance.\n      contextVm = parent; // $flow-disable-line\n\n      parent = parent._original;\n    }\n\n    var isCompiled = isTrue(options._compiled);\n    var needNormalization = !isCompiled;\n    this.data = data;\n    this.props = props;\n    this.children = children;\n    this.parent = parent;\n    this.listeners = data.on || emptyObject;\n    this.injections = resolveInject(options.inject, parent);\n\n    this.slots = function () {\n      if (!this$1.$slots) {\n        normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));\n      }\n\n      return this$1.$slots;\n    };\n\n    Object.defineProperty(this, 'scopedSlots', {\n      enumerable: true,\n      get: function get() {\n        return normalizeScopedSlots(data.scopedSlots, this.slots());\n      }\n    }); // support for compiled functional template\n\n    if (isCompiled) {\n      // exposing $options for renderStatic()\n      this.$options = options; // pre-resolve slots for renderSlot()\n\n      this.$slots = this.slots();\n      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n    }\n\n    if (options._scopeId) {\n      this._c = function (a, b, c, d) {\n        var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n\n        if (vnode && !Array.isArray(vnode)) {\n          vnode.fnScopeId = options._scopeId;\n          vnode.fnContext = parent;\n        }\n\n        return vnode;\n      };\n    } else {\n      this._c = function (a, b, c, d) {\n        return createElement(contextVm, a, b, c, d, needNormalization);\n      };\n    }\n  }\n\n  installRenderHelpers(FunctionalRenderContext.prototype);\n\n  function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n    var options = Ctor.options;\n    var props = {};\n    var propOptions = options.props;\n\n    if (isDef(propOptions)) {\n      for (var key in propOptions) {\n        props[key] = validateProp(key, propOptions, propsData || emptyObject);\n      }\n    } else {\n      if (isDef(data.attrs)) {\n        mergeProps(props, data.attrs);\n      }\n\n      if (isDef(data.props)) {\n        mergeProps(props, data.props);\n      }\n    }\n\n    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n    var vnode = options.render.call(null, renderContext._c, renderContext);\n\n    if (vnode instanceof VNode) {\n      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\n    } else if (Array.isArray(vnode)) {\n      var vnodes = normalizeChildren(vnode) || [];\n      var res = new Array(vnodes.length);\n\n      for (var i = 0; i < vnodes.length; i++) {\n        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n      }\n\n      return res;\n    }\n  }\n\n  function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\n    // that should not be matched to match.\n    var clone = cloneVNode(vnode);\n    clone.fnContext = contextVm;\n    clone.fnOptions = options;\n    {\n      (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n    }\n\n    if (data.slot) {\n      (clone.data || (clone.data = {})).slot = data.slot;\n    }\n\n    return clone;\n  }\n\n  function mergeProps(to, from) {\n    for (var key in from) {\n      to[camelize(key)] = from[key];\n    }\n  }\n  /*  */\n\n  /*  */\n\n  /*  */\n\n  /*  */\n  // inline hooks to be invoked on component VNodes during patch\n\n\n  var componentVNodeHooks = {\n    init: function init(vnode, hydrating) {\n      if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {\n        // kept-alive components, treat as a patch\n        var mountedNode = vnode; // work around flow\n\n        componentVNodeHooks.prepatch(mountedNode, mountedNode);\n      } else {\n        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);\n        child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n      }\n    },\n    prepatch: function prepatch(oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(child, options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n      );\n    },\n    insert: function insert(vnode) {\n      var context = vnode.context;\n      var componentInstance = vnode.componentInstance;\n\n      if (!componentInstance._isMounted) {\n        componentInstance._isMounted = true;\n        callHook(componentInstance, 'mounted');\n      }\n\n      if (vnode.data.keepAlive) {\n        if (context._isMounted) {\n          // vue-router#1212\n          // During updates, a kept-alive component's child components may\n          // change, so directly walking the tree here may call activated hooks\n          // on incorrect children. Instead we push them into a queue which will\n          // be processed after the whole patch process ended.\n          queueActivatedComponent(componentInstance);\n        } else {\n          activateChildComponent(componentInstance, true\n          /* direct */\n          );\n        }\n      }\n    },\n    destroy: function destroy(vnode) {\n      var componentInstance = vnode.componentInstance;\n\n      if (!componentInstance._isDestroyed) {\n        if (!vnode.data.keepAlive) {\n          componentInstance.$destroy();\n        } else {\n          deactivateChildComponent(componentInstance, true\n          /* direct */\n          );\n        }\n      }\n    }\n  };\n  var hooksToMerge = Object.keys(componentVNodeHooks);\n\n  function createComponent(Ctor, data, context, children, tag) {\n    if (isUndef(Ctor)) {\n      return;\n    }\n\n    var baseCtor = context.$options._base; // plain options object: turn it into a constructor\n\n    if (isObject(Ctor)) {\n      Ctor = baseCtor.extend(Ctor);\n    } // if at this stage it's not a constructor or an async component factory,\n    // reject.\n\n\n    if (typeof Ctor !== 'function') {\n      {\n        warn(\"Invalid Component definition: \" + String(Ctor), context);\n      }\n      return;\n    } // async component\n\n\n    var asyncFactory;\n\n    if (isUndef(Ctor.cid)) {\n      asyncFactory = Ctor;\n      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n\n      if (Ctor === undefined) {\n        // return a placeholder node for async component, which is rendered\n        // as a comment node but preserves all the raw information for the node.\n        // the information will be used for async server-rendering and hydration.\n        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n      }\n    }\n\n    data = data || {}; // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n\n    resolveConstructorOptions(Ctor); // transform component v-model data into props & events\n\n    if (isDef(data.model)) {\n      transformModel(Ctor.options, data);\n    } // extract props\n\n\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component\n\n    if (isTrue(Ctor.options.functional)) {\n      return createFunctionalComponent(Ctor, propsData, data, context, children);\n    } // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n\n\n    var listeners = data.on; // replace with listeners with .native modifier\n    // so it gets processed during parent component patch.\n\n    data.on = data.nativeOn;\n\n    if (isTrue(Ctor.options.abstract)) {\n      // abstract components do not keep anything\n      // other than props & listeners & slot\n      // work around flow\n      var slot = data.slot;\n      data = {};\n\n      if (slot) {\n        data.slot = slot;\n      }\n    } // install component management hooks onto the placeholder node\n\n\n    installComponentHooks(data); // return a placeholder vnode\n\n    var name = Ctor.options.name || tag;\n    var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, {\n      Ctor: Ctor,\n      propsData: propsData,\n      listeners: listeners,\n      tag: tag,\n      children: children\n    }, asyncFactory);\n    return vnode;\n  }\n\n  function createComponentInstanceForVnode( // we know it's MountedComponentVNode but flow doesn't\n  vnode, // activeInstance in lifecycle state\n  parent) {\n    var options = {\n      _isComponent: true,\n      _parentVnode: vnode,\n      parent: parent\n    }; // check inline-template render functions\n\n    var inlineTemplate = vnode.data.inlineTemplate;\n\n    if (isDef(inlineTemplate)) {\n      options.render = inlineTemplate.render;\n      options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n\n    return new vnode.componentOptions.Ctor(options);\n  }\n\n  function installComponentHooks(data) {\n    var hooks = data.hook || (data.hook = {});\n\n    for (var i = 0; i < hooksToMerge.length; i++) {\n      var key = hooksToMerge[i];\n      var existing = hooks[key];\n      var toMerge = componentVNodeHooks[key];\n\n      if (existing !== toMerge && !(existing && existing._merged)) {\n        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n      }\n    }\n  }\n\n  function mergeHook$1(f1, f2) {\n    var merged = function (a, b) {\n      // flow complains about extra args which is why we use any\n      f1(a, b);\n      f2(a, b);\n    };\n\n    merged._merged = true;\n    return merged;\n  } // transform component v-model info (value and callback) into\n  // prop and event handler respectively.\n\n\n  function transformModel(options, data) {\n    var prop = options.model && options.model.prop || 'value';\n    var event = options.model && options.model.event || 'input';\n    (data.attrs || (data.attrs = {}))[prop] = data.model.value;\n    var on = data.on || (data.on = {});\n    var existing = on[event];\n    var callback = data.model.callback;\n\n    if (isDef(existing)) {\n      if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {\n        on[event] = [callback].concat(existing);\n      }\n    } else {\n      on[event] = callback;\n    }\n  }\n  /*  */\n\n\n  var SIMPLE_NORMALIZE = 1;\n  var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface\n  // without getting yelled at by flow\n\n  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n    if (Array.isArray(data) || isPrimitive(data)) {\n      normalizationType = children;\n      children = data;\n      data = undefined;\n    }\n\n    if (isTrue(alwaysNormalize)) {\n      normalizationType = ALWAYS_NORMALIZE;\n    }\n\n    return _createElement(context, tag, data, children, normalizationType);\n  }\n\n  function _createElement(context, tag, data, children, normalizationType) {\n    if (isDef(data) && isDef(data.__ob__)) {\n      warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n      return createEmptyVNode();\n    } // object syntax in v-bind\n\n\n    if (isDef(data) && isDef(data.is)) {\n      tag = data.is;\n    }\n\n    if (!tag) {\n      // in case of component :is set to falsy value\n      return createEmptyVNode();\n    } // warn against non-primitive key\n\n\n    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n      {\n        warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);\n      }\n    } // support single function children as default scoped slot\n\n\n    if (Array.isArray(children) && typeof children[0] === 'function') {\n      data = data || {};\n      data.scopedSlots = {\n        default: children[0]\n      };\n      children.length = 0;\n    }\n\n    if (normalizationType === ALWAYS_NORMALIZE) {\n      children = normalizeChildren(children);\n    } else if (normalizationType === SIMPLE_NORMALIZE) {\n      children = simpleNormalizeChildren(children);\n    }\n\n    var vnode, ns;\n\n    if (typeof tag === 'string') {\n      var Ctor;\n      ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);\n\n      if (config.isReservedTag(tag)) {\n        // platform built-in elements\n        if (isDef(data) && isDef(data.nativeOn) && data.tag !== 'component') {\n          warn(\"The .native modifier for v-on is only valid on components but it was used on <\" + tag + \">.\", context);\n        }\n\n        vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n        // component\n        vnode = createComponent(Ctor, data, context, children, tag);\n      } else {\n        // unknown or unlisted namespaced elements\n        // check at runtime because it may get assigned a namespace when its\n        // parent normalizes children\n        vnode = new VNode(tag, data, children, undefined, undefined, context);\n      }\n    } else {\n      // direct component options / constructor\n      vnode = createComponent(tag, data, context, children);\n    }\n\n    if (Array.isArray(vnode)) {\n      return vnode;\n    } else if (isDef(vnode)) {\n      if (isDef(ns)) {\n        applyNS(vnode, ns);\n      }\n\n      if (isDef(data)) {\n        registerDeepBindings(data);\n      }\n\n      return vnode;\n    } else {\n      return createEmptyVNode();\n    }\n  }\n\n  function applyNS(vnode, ns, force) {\n    vnode.ns = ns;\n\n    if (vnode.tag === 'foreignObject') {\n      // use default namespace inside foreignObject\n      ns = undefined;\n      force = true;\n    }\n\n    if (isDef(vnode.children)) {\n      for (var i = 0, l = vnode.children.length; i < l; i++) {\n        var child = vnode.children[i];\n\n        if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {\n          applyNS(child, ns, force);\n        }\n      }\n    }\n  } // ref #5318\n  // necessary to ensure parent re-render when deep bindings like :style and\n  // :class are used on slot nodes\n\n\n  function registerDeepBindings(data) {\n    if (isObject(data.style)) {\n      traverse(data.style);\n    }\n\n    if (isObject(data.class)) {\n      traverse(data.class);\n    }\n  }\n  /*  */\n\n\n  function initRender(vm) {\n    vm._vnode = null; // the root of the child tree\n\n    vm._staticTrees = null; // v-once cached trees\n\n    var options = vm.$options;\n    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n\n    var renderContext = parentVnode && parentVnode.context;\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\n    vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance\n    // so that we get proper render context inside it.\n    // args order: tag, data, children, normalizationType, alwaysNormalize\n    // internal version is used by render functions compiled from templates\n\n    vm._c = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, false);\n    }; // normalization is always applied for the public version, used in\n    // user-written render functions.\n\n\n    vm.$createElement = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, true);\n    }; // $attrs & $listeners are exposed for easier HOC creation.\n    // they need to be reactive so that HOCs using them are always updated\n\n\n    var parentData = parentVnode && parentVnode.data;\n    /* istanbul ignore else */\n\n    {\n      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n      }, true);\n      defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n      }, true);\n    }\n  }\n\n  var currentRenderingInstance = null;\n\n  function renderMixin(Vue) {\n    // install runtime convenience helpers\n    installRenderHelpers(Vue.prototype);\n\n    Vue.prototype.$nextTick = function (fn) {\n      return nextTick(fn, this);\n    };\n\n    Vue.prototype._render = function () {\n      var vm = this;\n      var ref = vm.$options;\n      var render = ref.render;\n      var _parentVnode = ref._parentVnode;\n\n      if (_parentVnode) {\n        vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);\n      } // set parent vnode. this allows render functions to have access\n      // to the data on the placeholder node.\n\n\n      vm.$vnode = _parentVnode; // render self\n\n      var vnode;\n\n      try {\n        // There's no need to maintain a stack because all render fns are called\n        // separately from one another. Nested component's render fns are called\n        // when parent component is patched.\n        currentRenderingInstance = vm;\n        vnode = render.call(vm._renderProxy, vm.$createElement);\n      } catch (e) {\n        handleError(e, vm, \"render\"); // return error render result,\n        // or previous vnode to prevent render error causing blank component\n\n        /* istanbul ignore else */\n\n        if (vm.$options.renderError) {\n          try {\n            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n          } catch (e) {\n            handleError(e, vm, \"renderError\");\n            vnode = vm._vnode;\n          }\n        } else {\n          vnode = vm._vnode;\n        }\n      } finally {\n        currentRenderingInstance = null;\n      } // if the returned array contains only a single node, allow it\n\n\n      if (Array.isArray(vnode) && vnode.length === 1) {\n        vnode = vnode[0];\n      } // return empty vnode in case the render function errored out\n\n\n      if (!(vnode instanceof VNode)) {\n        if (Array.isArray(vnode)) {\n          warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n        }\n\n        vnode = createEmptyVNode();\n      } // set parent\n\n\n      vnode.parent = _parentVnode;\n      return vnode;\n    };\n  }\n  /*  */\n\n\n  function ensureCtor(comp, base) {\n    if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {\n      comp = comp.default;\n    }\n\n    return isObject(comp) ? base.extend(comp) : comp;\n  }\n\n  function createAsyncPlaceholder(factory, data, context, children, tag) {\n    var node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = {\n      data: data,\n      context: context,\n      children: children,\n      tag: tag\n    };\n    return node;\n  }\n\n  function resolveAsyncComponent(factory, baseCtor) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n      return factory.errorComp;\n    }\n\n    if (isDef(factory.resolved)) {\n      return factory.resolved;\n    }\n\n    var owner = currentRenderingInstance;\n\n    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n      // already pending\n      factory.owners.push(owner);\n    }\n\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n      return factory.loadingComp;\n    }\n\n    if (owner && !isDef(factory.owners)) {\n      var owners = factory.owners = [owner];\n      var sync = true;\n      var timerLoading = null;\n      var timerTimeout = null;\n      owner.$on('hook:destroyed', function () {\n        return remove(owners, owner);\n      });\n\n      var forceRender = function (renderCompleted) {\n        for (var i = 0, l = owners.length; i < l; i++) {\n          owners[i].$forceUpdate();\n        }\n\n        if (renderCompleted) {\n          owners.length = 0;\n\n          if (timerLoading !== null) {\n            clearTimeout(timerLoading);\n            timerLoading = null;\n          }\n\n          if (timerTimeout !== null) {\n            clearTimeout(timerTimeout);\n            timerTimeout = null;\n          }\n        }\n      };\n\n      var resolve = once(function (res) {\n        // cache resolved\n        factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve\n        // (async resolves are shimmed as synchronous during SSR)\n\n        if (!sync) {\n          forceRender(true);\n        } else {\n          owners.length = 0;\n        }\n      });\n      var reject = once(function (reason) {\n        warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n\n        if (isDef(factory.errorComp)) {\n          factory.error = true;\n          forceRender(true);\n        }\n      });\n      var res = factory(resolve, reject);\n\n      if (isObject(res)) {\n        if (isPromise(res)) {\n          // () => Promise\n          if (isUndef(factory.resolved)) {\n            res.then(resolve, reject);\n          }\n        } else if (isPromise(res.component)) {\n          res.component.then(resolve, reject);\n\n          if (isDef(res.error)) {\n            factory.errorComp = ensureCtor(res.error, baseCtor);\n          }\n\n          if (isDef(res.loading)) {\n            factory.loadingComp = ensureCtor(res.loading, baseCtor);\n\n            if (res.delay === 0) {\n              factory.loading = true;\n            } else {\n              timerLoading = setTimeout(function () {\n                timerLoading = null;\n\n                if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                  factory.loading = true;\n                  forceRender(false);\n                }\n              }, res.delay || 200);\n            }\n          }\n\n          if (isDef(res.timeout)) {\n            timerTimeout = setTimeout(function () {\n              timerTimeout = null;\n\n              if (isUndef(factory.resolved)) {\n                reject(\"timeout (\" + res.timeout + \"ms)\");\n              }\n            }, res.timeout);\n          }\n        }\n      }\n\n      sync = false; // return in case resolved synchronously\n\n      return factory.loading ? factory.loadingComp : factory.resolved;\n    }\n  }\n  /*  */\n\n\n  function getFirstComponentChild(children) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var c = children[i];\n\n        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n          return c;\n        }\n      }\n    }\n  }\n  /*  */\n\n  /*  */\n\n\n  function initEvents(vm) {\n    vm._events = Object.create(null);\n    vm._hasHookEvent = false; // init parent attached events\n\n    var listeners = vm.$options._parentListeners;\n\n    if (listeners) {\n      updateComponentListeners(vm, listeners);\n    }\n  }\n\n  var target;\n\n  function add(event, fn) {\n    target.$on(event, fn);\n  }\n\n  function remove$1(event, fn) {\n    target.$off(event, fn);\n  }\n\n  function createOnceHandler(event, fn) {\n    var _target = target;\n    return function onceHandler() {\n      var res = fn.apply(null, arguments);\n\n      if (res !== null) {\n        _target.$off(event, onceHandler);\n      }\n    };\n  }\n\n  function updateComponentListeners(vm, listeners, oldListeners) {\n    target = vm;\n    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n    target = undefined;\n  }\n\n  function eventsMixin(Vue) {\n    var hookRE = /^hook:/;\n\n    Vue.prototype.$on = function (event, fn) {\n      var vm = this;\n\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          vm.$on(event[i], fn);\n        }\n      } else {\n        (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration\n        // instead of a hash lookup\n\n        if (hookRE.test(event)) {\n          vm._hasHookEvent = true;\n        }\n      }\n\n      return vm;\n    };\n\n    Vue.prototype.$once = function (event, fn) {\n      var vm = this;\n\n      function on() {\n        vm.$off(event, on);\n        fn.apply(vm, arguments);\n      }\n\n      on.fn = fn;\n      vm.$on(event, on);\n      return vm;\n    };\n\n    Vue.prototype.$off = function (event, fn) {\n      var vm = this; // all\n\n      if (!arguments.length) {\n        vm._events = Object.create(null);\n        return vm;\n      } // array of events\n\n\n      if (Array.isArray(event)) {\n        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n          vm.$off(event[i$1], fn);\n        }\n\n        return vm;\n      } // specific event\n\n\n      var cbs = vm._events[event];\n\n      if (!cbs) {\n        return vm;\n      }\n\n      if (!fn) {\n        vm._events[event] = null;\n        return vm;\n      } // specific handler\n\n\n      var cb;\n      var i = cbs.length;\n\n      while (i--) {\n        cb = cbs[i];\n\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i, 1);\n          break;\n        }\n      }\n\n      return vm;\n    };\n\n    Vue.prototype.$emit = function (event) {\n      var vm = this;\n      {\n        var lowerCaseEvent = event.toLowerCase();\n\n        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n          tip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n        }\n      }\n      var cbs = vm._events[event];\n\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        var args = toArray(arguments, 1);\n        var info = \"event handler for \\\"\" + event + \"\\\"\";\n\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n        }\n      }\n\n      return vm;\n    };\n  }\n  /*  */\n\n\n  var activeInstance = null;\n  var isUpdatingChildComponent = false;\n\n  function setActiveInstance(vm) {\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    return function () {\n      activeInstance = prevActiveInstance;\n    };\n  }\n\n  function initLifecycle(vm) {\n    var options = vm.$options; // locate first non-abstract parent\n\n    var parent = options.parent;\n\n    if (parent && !options.abstract) {\n      while (parent.$options.abstract && parent.$parent) {\n        parent = parent.$parent;\n      }\n\n      parent.$children.push(vm);\n    }\n\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n    vm.$children = [];\n    vm.$refs = {};\n    vm._watcher = null;\n    vm._inactive = null;\n    vm._directInactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n  }\n\n  function lifecycleMixin(Vue) {\n    Vue.prototype._update = function (vnode, hydrating) {\n      var vm = this;\n      var prevEl = vm.$el;\n      var prevVnode = vm._vnode;\n      var restoreActiveInstance = setActiveInstance(vm);\n      vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points\n      // based on the rendering backend used.\n\n      if (!prevVnode) {\n        // initial render\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false\n        /* removeOnly */\n        );\n      } else {\n        // updates\n        vm.$el = vm.__patch__(prevVnode, vnode);\n      }\n\n      restoreActiveInstance(); // update __vue__ reference\n\n      if (prevEl) {\n        prevEl.__vue__ = null;\n      }\n\n      if (vm.$el) {\n        vm.$el.__vue__ = vm;\n      } // if parent is an HOC, update its $el as well\n\n\n      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el;\n      } // updated hook is called by the scheduler to ensure that children are\n      // updated in a parent's updated hook.\n\n    };\n\n    Vue.prototype.$forceUpdate = function () {\n      var vm = this;\n\n      if (vm._watcher) {\n        vm._watcher.update();\n      }\n    };\n\n    Vue.prototype.$destroy = function () {\n      var vm = this;\n\n      if (vm._isBeingDestroyed) {\n        return;\n      }\n\n      callHook(vm, 'beforeDestroy');\n      vm._isBeingDestroyed = true; // remove self from parent\n\n      var parent = vm.$parent;\n\n      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n        remove(parent.$children, vm);\n      } // teardown watchers\n\n\n      if (vm._watcher) {\n        vm._watcher.teardown();\n      }\n\n      var i = vm._watchers.length;\n\n      while (i--) {\n        vm._watchers[i].teardown();\n      } // remove reference from data ob\n      // frozen object may not have observer.\n\n\n      if (vm._data.__ob__) {\n        vm._data.__ob__.vmCount--;\n      } // call the last hook...\n\n\n      vm._isDestroyed = true; // invoke destroy hooks on current rendered tree\n\n      vm.__patch__(vm._vnode, null); // fire destroyed hook\n\n\n      callHook(vm, 'destroyed'); // turn off all instance listeners.\n\n      vm.$off(); // remove __vue__ reference\n\n      if (vm.$el) {\n        vm.$el.__vue__ = null;\n      } // release circular reference (#6759)\n\n\n      if (vm.$vnode) {\n        vm.$vnode.parent = null;\n      }\n    };\n  }\n\n  function mountComponent(vm, el, hydrating) {\n    vm.$el = el;\n\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      {\n        /* istanbul ignore if */\n        if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n          warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n        } else {\n          warn('Failed to mount component: template or render function not defined.', vm);\n        }\n      }\n    }\n\n    callHook(vm, 'beforeMount');\n    var updateComponent;\n    /* istanbul ignore if */\n\n    if (config.performance && mark) {\n      updateComponent = function () {\n        var name = vm._name;\n        var id = vm._uid;\n        var startTag = \"vue-perf-start:\" + id;\n        var endTag = \"vue-perf-end:\" + id;\n        mark(startTag);\n\n        var vnode = vm._render();\n\n        mark(endTag);\n        measure(\"vue \" + name + \" render\", startTag, endTag);\n        mark(startTag);\n\n        vm._update(vnode, hydrating);\n\n        mark(endTag);\n        measure(\"vue \" + name + \" patch\", startTag, endTag);\n      };\n    } else {\n      updateComponent = function () {\n        vm._update(vm._render(), hydrating);\n      };\n    } // we set this to vm._watcher inside the watcher's constructor\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n    // component's mounted hook), which relies on vm._watcher being already defined\n\n\n    new Watcher(vm, updateComponent, noop, {\n      before: function before() {\n        if (vm._isMounted && !vm._isDestroyed) {\n          callHook(vm, 'beforeUpdate');\n        }\n      }\n    }, true\n    /* isRenderWatcher */\n    );\n    hydrating = false; // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n\n    return vm;\n  }\n\n  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n    {\n      isUpdatingChildComponent = true;\n    } // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren.\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\n    // dynamic slot names). Static scoped slots compiled from template has the\n    // \"$stable\" marker.\n\n    var newScopedSlots = parentVnode.data.scopedSlots;\n    var oldScopedSlots = vm.$scopedSlots;\n    var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key || !newScopedSlots && vm.$scopedSlots.$key); // Any static slot children from the parent may have changed during parent's\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\n    // update is necessary to ensure correctness.\n\n    var needsForceUpdate = !!(renderChildren || // has new static slots\n    vm.$options._renderChildren || // has old static slots\n    hasDynamicScopedSlot);\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n    if (vm._vnode) {\n      // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n\n    vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n\n    vm.$attrs = parentVnode.data.attrs || emptyObject;\n    vm.$listeners = listeners || emptyObject; // update props\n\n    if (propsData && vm.$options.props) {\n      toggleObserving(false);\n      var props = vm._props;\n      var propKeys = vm.$options._propKeys || [];\n\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        var propOptions = vm.$options.props; // wtf flow?\n\n        props[key] = validateProp(key, propOptions, propsData, vm);\n      }\n\n      toggleObserving(true); // keep a copy of raw propsData\n\n      vm.$options.propsData = propsData;\n    } // update listeners\n\n\n    listeners = listeners || emptyObject;\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children\n\n    if (needsForceUpdate) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n\n    {\n      isUpdatingChildComponent = false;\n    }\n  }\n\n  function isInInactiveTree(vm) {\n    while (vm && (vm = vm.$parent)) {\n      if (vm._inactive) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function activateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = false;\n\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    } else if (vm._directInactive) {\n      return;\n    }\n\n    if (vm._inactive || vm._inactive === null) {\n      vm._inactive = false;\n\n      for (var i = 0; i < vm.$children.length; i++) {\n        activateChildComponent(vm.$children[i]);\n      }\n\n      callHook(vm, 'activated');\n    }\n  }\n\n  function deactivateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = true;\n\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    }\n\n    if (!vm._inactive) {\n      vm._inactive = true;\n\n      for (var i = 0; i < vm.$children.length; i++) {\n        deactivateChildComponent(vm.$children[i]);\n      }\n\n      callHook(vm, 'deactivated');\n    }\n  }\n\n  function callHook(vm, hook) {\n    // #7573 disable dep collection when invoking lifecycle hooks\n    pushTarget();\n    var handlers = vm.$options[hook];\n    var info = hook + \" hook\";\n\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n      }\n    }\n\n    if (vm._hasHookEvent) {\n      vm.$emit('hook:' + hook);\n    }\n\n    popTarget();\n  }\n  /*  */\n\n\n  var MAX_UPDATE_COUNT = 100;\n  var queue = [];\n  var activatedChildren = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n  var flushing = false;\n  var index = 0;\n  /**\n   * Reset the scheduler's state.\n   */\n\n  function resetSchedulerState() {\n    index = queue.length = activatedChildren.length = 0;\n    has = {};\n    {\n      circular = {};\n    }\n    waiting = flushing = false;\n  } // Async edge case #6566 requires saving the timestamp when event listeners are\n  // attached. However, calling performance.now() has a perf overhead especially\n  // if the page has thousands of event listeners. Instead, we take a timestamp\n  // every time the scheduler flushes and use that for all event listeners\n  // attached during that flush.\n\n\n  var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.\n\n  var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the\n  // timestamp can either be hi-res (relative to page load) or low-res\n  // (relative to UNIX epoch), so in order to compare time we have to use the\n  // same timestamp type when saving the flush timestamp.\n  // All IE versions use low-res event timestamps, and have problematic clock\n  // implementations (#9632)\n\n  if (inBrowser && !isIE) {\n    var performance = window.performance;\n\n    if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {\n      // if the event timestamp, although evaluated AFTER the Date.now(), is\n      // smaller than it, it means the event is using a hi-res timestamp,\n      // and we need to use the hi-res version for event listener timestamps as\n      // well.\n      getNow = function () {\n        return performance.now();\n      };\n    }\n  }\n  /**\n   * Flush both queues and run the watchers.\n   */\n\n\n  function flushSchedulerQueue() {\n    currentFlushTimestamp = getNow();\n    flushing = true;\n    var watcher, id; // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n\n    queue.sort(function (a, b) {\n      return a.id - b.id;\n    }); // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n\n    for (index = 0; index < queue.length; index++) {\n      watcher = queue[index];\n\n      if (watcher.before) {\n        watcher.before();\n      }\n\n      id = watcher.id;\n      has[id] = null;\n      watcher.run(); // in dev build, check and stop circular updates.\n\n      if (has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n\n        if (circular[id] > MAX_UPDATE_COUNT) {\n          warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n          break;\n        }\n      }\n    } // keep copies of post queues before resetting state\n\n\n    var activatedQueue = activatedChildren.slice();\n    var updatedQueue = queue.slice();\n    resetSchedulerState(); // call component updated and activated hooks\n\n    callActivatedHooks(activatedQueue);\n    callUpdatedHooks(updatedQueue); // devtool hook\n\n    /* istanbul ignore if */\n\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n  }\n\n  function callUpdatedHooks(queue) {\n    var i = queue.length;\n\n    while (i--) {\n      var watcher = queue[i];\n      var vm = watcher.vm;\n\n      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'updated');\n      }\n    }\n  }\n  /**\n   * Queue a kept-alive component that was activated during patch.\n   * The queue will be processed after the entire tree has been patched.\n   */\n\n\n  function queueActivatedComponent(vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n    activatedChildren.push(vm);\n  }\n\n  function callActivatedHooks(queue) {\n    for (var i = 0; i < queue.length; i++) {\n      queue[i]._inactive = true;\n      activateChildComponent(queue[i], true\n      /* true */\n      );\n    }\n  }\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   */\n\n\n  function queueWatcher(watcher) {\n    var id = watcher.id;\n\n    if (has[id] == null) {\n      has[id] = true;\n\n      if (!flushing) {\n        queue.push(watcher);\n      } else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        var i = queue.length - 1;\n\n        while (i > index && queue[i].id > watcher.id) {\n          i--;\n        }\n\n        queue.splice(i + 1, 0, watcher);\n      } // queue the flush\n\n\n      if (!waiting) {\n        waiting = true;\n\n        if (!config.async) {\n          flushSchedulerQueue();\n          return;\n        }\n\n        nextTick(flushSchedulerQueue);\n      }\n    }\n  }\n  /*  */\n\n\n  var uid$2 = 0;\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   */\n\n  var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\n    this.vm = vm;\n\n    if (isRenderWatcher) {\n      vm._watcher = this;\n    }\n\n    vm._watchers.push(this); // options\n\n\n    if (options) {\n      this.deep = !!options.deep;\n      this.user = !!options.user;\n      this.lazy = !!options.lazy;\n      this.sync = !!options.sync;\n      this.before = options.before;\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false;\n    }\n\n    this.cb = cb;\n    this.id = ++uid$2; // uid for batching\n\n    this.active = true;\n    this.dirty = this.lazy; // for lazy watchers\n\n    this.deps = [];\n    this.newDeps = [];\n    this.depIds = new _Set();\n    this.newDepIds = new _Set();\n    this.expression = expOrFn.toString(); // parse expression for getter\n\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn;\n    } else {\n      this.getter = parsePath(expOrFn);\n\n      if (!this.getter) {\n        this.getter = noop;\n        warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n      }\n    }\n\n    this.value = this.lazy ? undefined : this.get();\n  };\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n\n\n  Watcher.prototype.get = function get() {\n    pushTarget(this);\n    var value;\n    var vm = this.vm;\n\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n      } else {\n        throw e;\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value);\n      }\n\n      popTarget();\n      this.cleanupDeps();\n    }\n\n    return value;\n  };\n  /**\n   * Add a dependency to this directive.\n   */\n\n\n  Watcher.prototype.addDep = function addDep(dep) {\n    var id = dep.id;\n\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id);\n      this.newDeps.push(dep);\n\n      if (!this.depIds.has(id)) {\n        dep.addSub(this);\n      }\n    }\n  };\n  /**\n   * Clean up for dependency collection.\n   */\n\n\n  Watcher.prototype.cleanupDeps = function cleanupDeps() {\n    var i = this.deps.length;\n\n    while (i--) {\n      var dep = this.deps[i];\n\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this);\n      }\n    }\n\n    var tmp = this.depIds;\n    this.depIds = this.newDepIds;\n    this.newDepIds = tmp;\n    this.newDepIds.clear();\n    tmp = this.deps;\n    this.deps = this.newDeps;\n    this.newDeps = tmp;\n    this.newDeps.length = 0;\n  };\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n\n\n  Watcher.prototype.update = function update() {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync) {\n      this.run();\n    } else {\n      queueWatcher(this);\n    }\n  };\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n\n\n  Watcher.prototype.run = function run() {\n    if (this.active) {\n      var value = this.get();\n\n      if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) || this.deep) {\n        // set new value\n        var oldValue = this.value;\n        this.value = value;\n\n        if (this.user) {\n          var info = \"callback for watcher \\\"\" + this.expression + \"\\\"\";\n          invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n    }\n  };\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n\n\n  Watcher.prototype.evaluate = function evaluate() {\n    this.value = this.get();\n    this.dirty = false;\n  };\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n\n\n  Watcher.prototype.depend = function depend() {\n    var i = this.deps.length;\n\n    while (i--) {\n      this.deps[i].depend();\n    }\n  };\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n\n\n  Watcher.prototype.teardown = function teardown() {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this);\n      }\n\n      var i = this.deps.length;\n\n      while (i--) {\n        this.deps[i].removeSub(this);\n      }\n\n      this.active = false;\n    }\n  };\n  /*  */\n\n\n  var sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n  };\n\n  function proxy(target, sourceKey, key) {\n    sharedPropertyDefinition.get = function proxyGetter() {\n      return this[sourceKey][key];\n    };\n\n    sharedPropertyDefinition.set = function proxySetter(val) {\n      this[sourceKey][key] = val;\n    };\n\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function initState(vm) {\n    vm._watchers = [];\n    var opts = vm.$options;\n\n    if (opts.props) {\n      initProps(vm, opts.props);\n    }\n\n    if (opts.methods) {\n      initMethods(vm, opts.methods);\n    }\n\n    if (opts.data) {\n      initData(vm);\n    } else {\n      observe(vm._data = {}, true\n      /* asRootData */\n      );\n    }\n\n    if (opts.computed) {\n      initComputed(vm, opts.computed);\n    }\n\n    if (opts.watch && opts.watch !== nativeWatch) {\n      initWatch(vm, opts.watch);\n    }\n  }\n\n  function initProps(vm, propsOptions) {\n    var propsData = vm.$options.propsData || {};\n    var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array\n    // instead of dynamic object key enumeration.\n\n    var keys = vm.$options._propKeys = [];\n    var isRoot = !vm.$parent; // root instance props should be converted\n\n    if (!isRoot) {\n      toggleObserving(false);\n    }\n\n    var loop = function (key) {\n      keys.push(key);\n      var value = validateProp(key, propsOptions, propsData, vm);\n      /* istanbul ignore else */\n\n      {\n        var hyphenatedKey = hyphenate(key);\n\n        if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {\n          warn(\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n        }\n\n        defineReactive$$1(props, key, value, function () {\n          if (!isRoot && !isUpdatingChildComponent) {\n            warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n          }\n        });\n      } // static props are already proxied on the component's prototype\n      // during Vue.extend(). We only need to proxy props defined at\n      // instantiation here.\n\n      if (!(key in vm)) {\n        proxy(vm, \"_props\", key);\n      }\n    };\n\n    for (var key in propsOptions) loop(key);\n\n    toggleObserving(true);\n  }\n\n  function initData(vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n\n    if (!isPlainObject(data)) {\n      data = {};\n      warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n    } // proxy data on instance\n\n\n    var keys = Object.keys(data);\n    var props = vm.$options.props;\n    var methods = vm.$options.methods;\n    var i = keys.length;\n\n    while (i--) {\n      var key = keys[i];\n      {\n        if (methods && hasOwn(methods, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\", vm);\n        }\n      }\n\n      if (props && hasOwn(props, key)) {\n        warn(\"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n      } else if (!isReserved(key)) {\n        proxy(vm, \"_data\", key);\n      }\n    } // observe data\n\n\n    observe(data, true\n    /* asRootData */\n    );\n  }\n\n  function getData(data, vm) {\n    // #7573 disable dep collection when invoking data getters\n    pushTarget();\n\n    try {\n      return data.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, \"data()\");\n      return {};\n    } finally {\n      popTarget();\n    }\n  }\n\n  var computedWatcherOptions = {\n    lazy: true\n  };\n\n  function initComputed(vm, computed) {\n    // $flow-disable-line\n    var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR\n\n    var isSSR = isServerRendering();\n\n    for (var key in computed) {\n      var userDef = computed[key];\n      var getter = typeof userDef === 'function' ? userDef : userDef.get;\n\n      if (getter == null) {\n        warn(\"Getter is missing for computed property \\\"\" + key + \"\\\".\", vm);\n      }\n\n      if (!isSSR) {\n        // create internal watcher for the computed property.\n        watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n      } // component-defined computed properties are already defined on the\n      // component prototype. We only need to define computed properties defined\n      // at instantiation here.\n\n\n      if (!(key in vm)) {\n        defineComputed(vm, key, userDef);\n      } else {\n        if (key in vm.$data) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n        } else if (vm.$options.props && key in vm.$options.props) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n        } else if (vm.$options.methods && key in vm.$options.methods) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a method.\", vm);\n        }\n      }\n    }\n  }\n\n  function defineComputed(target, key, userDef) {\n    var shouldCache = !isServerRendering();\n\n    if (typeof userDef === 'function') {\n      sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);\n      sharedPropertyDefinition.set = noop;\n    } else {\n      sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;\n      sharedPropertyDefinition.set = userDef.set || noop;\n    }\n\n    if (sharedPropertyDefinition.set === noop) {\n      sharedPropertyDefinition.set = function () {\n        warn(\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\", this);\n      };\n    }\n\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function createComputedGetter(key) {\n    return function computedGetter() {\n      var watcher = this._computedWatchers && this._computedWatchers[key];\n\n      if (watcher) {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n\n        if (Dep.target) {\n          watcher.depend();\n        }\n\n        return watcher.value;\n      }\n    };\n  }\n\n  function createGetterInvoker(fn) {\n    return function computedGetter() {\n      return fn.call(this, this);\n    };\n  }\n\n  function initMethods(vm, methods) {\n    var props = vm.$options.props;\n\n    for (var key in methods) {\n      {\n        if (typeof methods[key] !== 'function') {\n          warn(\"Method \\\"\" + key + \"\\\" has type \\\"\" + typeof methods[key] + \"\\\" in the component definition. \" + \"Did you reference the function correctly?\", vm);\n        }\n\n        if (props && hasOwn(props, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n        }\n\n        if (key in vm && isReserved(key)) {\n          warn(\"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" + \"Avoid defining component methods that start with _ or $.\");\n        }\n      }\n      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n    }\n  }\n\n  function initWatch(vm, watch) {\n    for (var key in watch) {\n      var handler = watch[key];\n\n      if (Array.isArray(handler)) {\n        for (var i = 0; i < handler.length; i++) {\n          createWatcher(vm, key, handler[i]);\n        }\n      } else {\n        createWatcher(vm, key, handler);\n      }\n    }\n  }\n\n  function createWatcher(vm, expOrFn, handler, options) {\n    if (isPlainObject(handler)) {\n      options = handler;\n      handler = handler.handler;\n    }\n\n    if (typeof handler === 'string') {\n      handler = vm[handler];\n    }\n\n    return vm.$watch(expOrFn, handler, options);\n  }\n\n  function stateMixin(Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    var dataDef = {};\n\n    dataDef.get = function () {\n      return this._data;\n    };\n\n    var propsDef = {};\n\n    propsDef.get = function () {\n      return this._props;\n    };\n\n    {\n      dataDef.set = function () {\n        warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n      };\n\n      propsDef.set = function () {\n        warn(\"$props is readonly.\", this);\n      };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\n    Vue.prototype.$set = set;\n    Vue.prototype.$delete = del;\n\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\n      var vm = this;\n\n      if (isPlainObject(cb)) {\n        return createWatcher(vm, expOrFn, cb, options);\n      }\n\n      options = options || {};\n      options.user = true;\n      var watcher = new Watcher(vm, expOrFn, cb, options);\n\n      if (options.immediate) {\n        var info = \"callback for immediate watcher \\\"\" + watcher.expression + \"\\\"\";\n        pushTarget();\n        invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);\n        popTarget();\n      }\n\n      return function unwatchFn() {\n        watcher.teardown();\n      };\n    };\n  }\n  /*  */\n\n\n  var uid$3 = 0;\n\n  function initMixin(Vue) {\n    Vue.prototype._init = function (options) {\n      var vm = this; // a uid\n\n      vm._uid = uid$3++;\n      var startTag, endTag;\n      /* istanbul ignore if */\n\n      if (config.performance && mark) {\n        startTag = \"vue-perf-start:\" + vm._uid;\n        endTag = \"vue-perf-end:\" + vm._uid;\n        mark(startTag);\n      } // a flag to avoid this being observed\n\n\n      vm._isVue = true; // merge options\n\n      if (options && options._isComponent) {\n        // optimize internal component instantiation\n        // since dynamic options merging is pretty slow, and none of the\n        // internal component options needs special treatment.\n        initInternalComponent(vm, options);\n      } else {\n        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n      }\n      /* istanbul ignore else */\n\n\n      {\n        initProxy(vm);\n      } // expose real self\n\n      vm._self = vm;\n      initLifecycle(vm);\n      initEvents(vm);\n      initRender(vm);\n      callHook(vm, 'beforeCreate');\n      initInjections(vm); // resolve injections before data/props\n\n      initState(vm);\n      initProvide(vm); // resolve provide after data/props\n\n      callHook(vm, 'created');\n      /* istanbul ignore if */\n\n      if (config.performance && mark) {\n        vm._name = formatComponentName(vm, false);\n        mark(endTag);\n        measure(\"vue \" + vm._name + \" init\", startTag, endTag);\n      }\n\n      if (vm.$options.el) {\n        vm.$mount(vm.$options.el);\n      }\n    };\n  }\n\n  function initInternalComponent(vm, options) {\n    var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.\n\n    var parentVnode = options._parentVnode;\n    opts.parent = options.parent;\n    opts._parentVnode = parentVnode;\n    var vnodeComponentOptions = parentVnode.componentOptions;\n    opts.propsData = vnodeComponentOptions.propsData;\n    opts._parentListeners = vnodeComponentOptions.listeners;\n    opts._renderChildren = vnodeComponentOptions.children;\n    opts._componentTag = vnodeComponentOptions.tag;\n\n    if (options.render) {\n      opts.render = options.render;\n      opts.staticRenderFns = options.staticRenderFns;\n    }\n  }\n\n  function resolveConstructorOptions(Ctor) {\n    var options = Ctor.options;\n\n    if (Ctor.super) {\n      var superOptions = resolveConstructorOptions(Ctor.super);\n      var cachedSuperOptions = Ctor.superOptions;\n\n      if (superOptions !== cachedSuperOptions) {\n        // super option changed,\n        // need to resolve new options.\n        Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)\n\n        var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options\n\n        if (modifiedOptions) {\n          extend(Ctor.extendOptions, modifiedOptions);\n        }\n\n        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n\n        if (options.name) {\n          options.components[options.name] = Ctor;\n        }\n      }\n    }\n\n    return options;\n  }\n\n  function resolveModifiedOptions(Ctor) {\n    var modified;\n    var latest = Ctor.options;\n    var sealed = Ctor.sealedOptions;\n\n    for (var key in latest) {\n      if (latest[key] !== sealed[key]) {\n        if (!modified) {\n          modified = {};\n        }\n\n        modified[key] = latest[key];\n      }\n    }\n\n    return modified;\n  }\n\n  function Vue(options) {\n    if (!(this instanceof Vue)) {\n      warn('Vue is a constructor and should be called with the `new` keyword');\n    }\n\n    this._init(options);\n  }\n\n  initMixin(Vue);\n  stateMixin(Vue);\n  eventsMixin(Vue);\n  lifecycleMixin(Vue);\n  renderMixin(Vue);\n  /*  */\n\n  function initUse(Vue) {\n    Vue.use = function (plugin) {\n      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n\n      if (installedPlugins.indexOf(plugin) > -1) {\n        return this;\n      } // additional parameters\n\n\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else if (typeof plugin === 'function') {\n        plugin.apply(null, args);\n      }\n\n      installedPlugins.push(plugin);\n      return this;\n    };\n  }\n  /*  */\n\n\n  function initMixin$1(Vue) {\n    Vue.mixin = function (mixin) {\n      this.options = mergeOptions(this.options, mixin);\n      return this;\n    };\n  }\n  /*  */\n\n\n  function initExtend(Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    var cid = 1;\n    /**\n     * Class inheritance\n     */\n\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var SuperId = Super.cid;\n      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n\n      if (cachedCtors[SuperId]) {\n        return cachedCtors[SuperId];\n      }\n\n      var name = extendOptions.name || Super.options.name;\n\n      if (name) {\n        validateComponentName(name);\n      }\n\n      var Sub = function VueComponent(options) {\n        this._init(options);\n      };\n\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(Super.options, extendOptions);\n      Sub['super'] = Super; // For props and computed properties, we define the proxy getters on\n      // the Vue instances at extension time, on the extended prototype. This\n      // avoids Object.defineProperty calls for each instance created.\n\n      if (Sub.options.props) {\n        initProps$1(Sub);\n      }\n\n      if (Sub.options.computed) {\n        initComputed$1(Sub);\n      } // allow further extension/mixin/plugin usage\n\n\n      Sub.extend = Super.extend;\n      Sub.mixin = Super.mixin;\n      Sub.use = Super.use; // create asset registers, so extended classes\n      // can have their private assets too.\n\n      ASSET_TYPES.forEach(function (type) {\n        Sub[type] = Super[type];\n      }); // enable recursive self-lookup\n\n      if (name) {\n        Sub.options.components[name] = Sub;\n      } // keep a reference to the super options at extension time.\n      // later at instantiation we can check if Super's options have\n      // been updated.\n\n\n      Sub.superOptions = Super.options;\n      Sub.extendOptions = extendOptions;\n      Sub.sealedOptions = extend({}, Sub.options); // cache constructor\n\n      cachedCtors[SuperId] = Sub;\n      return Sub;\n    };\n  }\n\n  function initProps$1(Comp) {\n    var props = Comp.options.props;\n\n    for (var key in props) {\n      proxy(Comp.prototype, \"_props\", key);\n    }\n  }\n\n  function initComputed$1(Comp) {\n    var computed = Comp.options.computed;\n\n    for (var key in computed) {\n      defineComputed(Comp.prototype, key, computed[key]);\n    }\n  }\n  /*  */\n\n\n  function initAssetRegisters(Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    ASSET_TYPES.forEach(function (type) {\n      Vue[type] = function (id, definition) {\n        if (!definition) {\n          return this.options[type + 's'][id];\n        } else {\n          /* istanbul ignore if */\n          if (type === 'component') {\n            validateComponentName(id);\n          }\n\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = definition.name || id;\n            definition = this.options._base.extend(definition);\n          }\n\n          if (type === 'directive' && typeof definition === 'function') {\n            definition = {\n              bind: definition,\n              update: definition\n            };\n          }\n\n          this.options[type + 's'][id] = definition;\n          return definition;\n        }\n      };\n    });\n  }\n  /*  */\n\n\n  function getComponentName(opts) {\n    return opts && (opts.Ctor.options.name || opts.tag);\n  }\n\n  function matches(pattern, name) {\n    if (Array.isArray(pattern)) {\n      return pattern.indexOf(name) > -1;\n    } else if (typeof pattern === 'string') {\n      return pattern.split(',').indexOf(name) > -1;\n    } else if (isRegExp(pattern)) {\n      return pattern.test(name);\n    }\n    /* istanbul ignore next */\n\n\n    return false;\n  }\n\n  function pruneCache(keepAliveInstance, filter) {\n    var cache = keepAliveInstance.cache;\n    var keys = keepAliveInstance.keys;\n    var _vnode = keepAliveInstance._vnode;\n\n    for (var key in cache) {\n      var entry = cache[key];\n\n      if (entry) {\n        var name = entry.name;\n\n        if (name && !filter(name)) {\n          pruneCacheEntry(cache, key, keys, _vnode);\n        }\n      }\n    }\n  }\n\n  function pruneCacheEntry(cache, key, keys, current) {\n    var entry = cache[key];\n\n    if (entry && (!current || entry.tag !== current.tag)) {\n      entry.componentInstance.$destroy();\n    }\n\n    cache[key] = null;\n    remove(keys, key);\n  }\n\n  var patternTypes = [String, RegExp, Array];\n  var KeepAlive = {\n    name: 'keep-alive',\n    abstract: true,\n    props: {\n      include: patternTypes,\n      exclude: patternTypes,\n      max: [String, Number]\n    },\n    methods: {\n      cacheVNode: function cacheVNode() {\n        var ref = this;\n        var cache = ref.cache;\n        var keys = ref.keys;\n        var vnodeToCache = ref.vnodeToCache;\n        var keyToCache = ref.keyToCache;\n\n        if (vnodeToCache) {\n          var tag = vnodeToCache.tag;\n          var componentInstance = vnodeToCache.componentInstance;\n          var componentOptions = vnodeToCache.componentOptions;\n          cache[keyToCache] = {\n            name: getComponentName(componentOptions),\n            tag: tag,\n            componentInstance: componentInstance\n          };\n          keys.push(keyToCache); // prune oldest entry\n\n          if (this.max && keys.length > parseInt(this.max)) {\n            pruneCacheEntry(cache, keys[0], keys, this._vnode);\n          }\n\n          this.vnodeToCache = null;\n        }\n      }\n    },\n    created: function created() {\n      this.cache = Object.create(null);\n      this.keys = [];\n    },\n    destroyed: function destroyed() {\n      for (var key in this.cache) {\n        pruneCacheEntry(this.cache, key, this.keys);\n      }\n    },\n    mounted: function mounted() {\n      var this$1 = this;\n      this.cacheVNode();\n      this.$watch('include', function (val) {\n        pruneCache(this$1, function (name) {\n          return matches(val, name);\n        });\n      });\n      this.$watch('exclude', function (val) {\n        pruneCache(this$1, function (name) {\n          return !matches(val, name);\n        });\n      });\n    },\n    updated: function updated() {\n      this.cacheVNode();\n    },\n    render: function render() {\n      var slot = this.$slots.default;\n      var vnode = getFirstComponentChild(slot);\n      var componentOptions = vnode && vnode.componentOptions;\n\n      if (componentOptions) {\n        // check pattern\n        var name = getComponentName(componentOptions);\n        var ref = this;\n        var include = ref.include;\n        var exclude = ref.exclude;\n\n        if ( // not included\n        include && (!name || !matches(include, name)) || // excluded\n        exclude && name && matches(exclude, name)) {\n          return vnode;\n        }\n\n        var ref$1 = this;\n        var cache = ref$1.cache;\n        var keys = ref$1.keys;\n        var key = vnode.key == null // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n\n        if (cache[key]) {\n          vnode.componentInstance = cache[key].componentInstance; // make current key freshest\n\n          remove(keys, key);\n          keys.push(key);\n        } else {\n          // delay setting the cache until update\n          this.vnodeToCache = vnode;\n          this.keyToCache = key;\n        }\n\n        vnode.data.keepAlive = true;\n      }\n\n      return vnode || slot && slot[0];\n    }\n  };\n  var builtInComponents = {\n    KeepAlive: KeepAlive\n  };\n  /*  */\n\n  function initGlobalAPI(Vue) {\n    // config\n    var configDef = {};\n\n    configDef.get = function () {\n      return config;\n    };\n\n    {\n      configDef.set = function () {\n        warn('Do not replace the Vue.config object, set individual fields instead.');\n      };\n    }\n    Object.defineProperty(Vue, 'config', configDef); // exposed util methods.\n    // NOTE: these are not considered part of the public API - avoid relying on\n    // them unless you are aware of the risk.\n\n    Vue.util = {\n      warn: warn,\n      extend: extend,\n      mergeOptions: mergeOptions,\n      defineReactive: defineReactive$$1\n    };\n    Vue.set = set;\n    Vue.delete = del;\n    Vue.nextTick = nextTick; // 2.6 explicit observable API\n\n    Vue.observable = function (obj) {\n      observe(obj);\n      return obj;\n    };\n\n    Vue.options = Object.create(null);\n    ASSET_TYPES.forEach(function (type) {\n      Vue.options[type + 's'] = Object.create(null);\n    }); // this is used to identify the \"base\" constructor to extend all plain-object\n    // components with in Weex's multi-instance scenarios.\n\n    Vue.options._base = Vue;\n    extend(Vue.options.components, builtInComponents);\n    initUse(Vue);\n    initMixin$1(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n  }\n\n  initGlobalAPI(Vue);\n  Object.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n  });\n  Object.defineProperty(Vue.prototype, '$ssrContext', {\n    get: function get() {\n      /* istanbul ignore next */\n      return this.$vnode && this.$vnode.ssrContext;\n    }\n  }); // expose FunctionalRenderContext for ssr runtime helper installation\n\n  Object.defineProperty(Vue, 'FunctionalRenderContext', {\n    value: FunctionalRenderContext\n  });\n  Vue.version = '2.6.14';\n  /*  */\n  // these are reserved for web because they are directly compiled away\n  // during template compilation\n\n  var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding\n\n  var acceptValue = makeMap('input,textarea,option,select,progress');\n\n  var mustUseProp = function (tag, type, attr) {\n    return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n  };\n\n  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\n  var convertEnumeratedValue = function (key, value) {\n    return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable\n    : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';\n  };\n\n  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,' + 'truespeed,typemustmatch,visible');\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n\n  var isXlink = function (name) {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n  };\n\n  var getXlinkProp = function (name) {\n    return isXlink(name) ? name.slice(6, name.length) : '';\n  };\n\n  var isFalsyAttrValue = function (val) {\n    return val == null || val === false;\n  };\n  /*  */\n\n\n  function genClassForVnode(vnode) {\n    var data = vnode.data;\n    var parentNode = vnode;\n    var childNode = vnode;\n\n    while (isDef(childNode.componentInstance)) {\n      childNode = childNode.componentInstance._vnode;\n\n      if (childNode && childNode.data) {\n        data = mergeClassData(childNode.data, data);\n      }\n    }\n\n    while (isDef(parentNode = parentNode.parent)) {\n      if (parentNode && parentNode.data) {\n        data = mergeClassData(data, parentNode.data);\n      }\n    }\n\n    return renderClass(data.staticClass, data.class);\n  }\n\n  function mergeClassData(child, parent) {\n    return {\n      staticClass: concat(child.staticClass, parent.staticClass),\n      class: isDef(child.class) ? [child.class, parent.class] : parent.class\n    };\n  }\n\n  function renderClass(staticClass, dynamicClass) {\n    if (isDef(staticClass) || isDef(dynamicClass)) {\n      return concat(staticClass, stringifyClass(dynamicClass));\n    }\n    /* istanbul ignore next */\n\n\n    return '';\n  }\n\n  function concat(a, b) {\n    return a ? b ? a + ' ' + b : a : b || '';\n  }\n\n  function stringifyClass(value) {\n    if (Array.isArray(value)) {\n      return stringifyArray(value);\n    }\n\n    if (isObject(value)) {\n      return stringifyObject(value);\n    }\n\n    if (typeof value === 'string') {\n      return value;\n    }\n    /* istanbul ignore next */\n\n\n    return '';\n  }\n\n  function stringifyArray(value) {\n    var res = '';\n    var stringified;\n\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n        if (res) {\n          res += ' ';\n        }\n\n        res += stringified;\n      }\n    }\n\n    return res;\n  }\n\n  function stringifyObject(value) {\n    var res = '';\n\n    for (var key in value) {\n      if (value[key]) {\n        if (res) {\n          res += ' ';\n        }\n\n        res += key;\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  var namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n  };\n  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may\n  // contain child elements.\n\n  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\n  var isPreTag = function (tag) {\n    return tag === 'pre';\n  };\n\n  var isReservedTag = function (tag) {\n    return isHTMLTag(tag) || isSVG(tag);\n  };\n\n  function getTagNamespace(tag) {\n    if (isSVG(tag)) {\n      return 'svg';\n    } // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n\n\n    if (tag === 'math') {\n      return 'math';\n    }\n  }\n\n  var unknownElementCache = Object.create(null);\n\n  function isUnknownElement(tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n      return true;\n    }\n\n    if (isReservedTag(tag)) {\n      return false;\n    }\n\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n\n    if (unknownElementCache[tag] != null) {\n      return unknownElementCache[tag];\n    }\n\n    var el = document.createElement(tag);\n\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n    } else {\n      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n    }\n  }\n\n  var isTextInputType = makeMap('text,number,password,search,email,tel,url');\n  /*  */\n\n  /**\n   * Query an element selector if it's not an element already.\n   */\n\n  function query(el) {\n    if (typeof el === 'string') {\n      var selected = document.querySelector(el);\n\n      if (!selected) {\n        warn('Cannot find element: ' + el);\n        return document.createElement('div');\n      }\n\n      return selected;\n    } else {\n      return el;\n    }\n  }\n  /*  */\n\n\n  function createElement$1(tagName, vnode) {\n    var elm = document.createElement(tagName);\n\n    if (tagName !== 'select') {\n      return elm;\n    } // false or null will remove the attribute but undefined will not\n\n\n    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n      elm.setAttribute('multiple', 'multiple');\n    }\n\n    return elm;\n  }\n\n  function createElementNS(namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName);\n  }\n\n  function createTextNode(text) {\n    return document.createTextNode(text);\n  }\n\n  function createComment(text) {\n    return document.createComment(text);\n  }\n\n  function insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  function removeChild(node, child) {\n    node.removeChild(child);\n  }\n\n  function appendChild(node, child) {\n    node.appendChild(child);\n  }\n\n  function parentNode(node) {\n    return node.parentNode;\n  }\n\n  function nextSibling(node) {\n    return node.nextSibling;\n  }\n\n  function tagName(node) {\n    return node.tagName;\n  }\n\n  function setTextContent(node, text) {\n    node.textContent = text;\n  }\n\n  function setStyleScope(node, scopeId) {\n    node.setAttribute(scopeId, '');\n  }\n\n  var nodeOps = /*#__PURE__*/Object.freeze({\n    createElement: createElement$1,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    setStyleScope: setStyleScope\n  });\n  /*  */\n\n  var ref = {\n    create: function create(_, vnode) {\n      registerRef(vnode);\n    },\n    update: function update(oldVnode, vnode) {\n      if (oldVnode.data.ref !== vnode.data.ref) {\n        registerRef(oldVnode, true);\n        registerRef(vnode);\n      }\n    },\n    destroy: function destroy(vnode) {\n      registerRef(vnode, true);\n    }\n  };\n\n  function registerRef(vnode, isRemoval) {\n    var key = vnode.data.ref;\n\n    if (!isDef(key)) {\n      return;\n    }\n\n    var vm = vnode.context;\n    var ref = vnode.componentInstance || vnode.elm;\n    var refs = vm.$refs;\n\n    if (isRemoval) {\n      if (Array.isArray(refs[key])) {\n        remove(refs[key], ref);\n      } else if (refs[key] === ref) {\n        refs[key] = undefined;\n      }\n    } else {\n      if (vnode.data.refInFor) {\n        if (!Array.isArray(refs[key])) {\n          refs[key] = [ref];\n        } else if (refs[key].indexOf(ref) < 0) {\n          // $flow-disable-line\n          refs[key].push(ref);\n        }\n      } else {\n        refs[key] = ref;\n      }\n    }\n  }\n  /**\n   * Virtual DOM patching algorithm based on Snabbdom by\n   * Simon Friis Vindum (@paldepind)\n   * Licensed under the MIT License\n   * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n   *\n   * modified by Evan You (@yyx990803)\n   *\n   * Not type-checking this because this file is perf-critical and the cost\n   * of making flow understand it is not worth it.\n   */\n\n\n  var emptyNode = new VNode('', {}, []);\n  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n  function sameVnode(a, b) {\n    return a.key === b.key && a.asyncFactory === b.asyncFactory && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error));\n  }\n\n  function sameInputType(a, b) {\n    if (a.tag !== 'input') {\n      return true;\n    }\n\n    var i;\n    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);\n  }\n\n  function createKeyToOldIdx(children, beginIdx, endIdx) {\n    var i, key;\n    var map = {};\n\n    for (i = beginIdx; i <= endIdx; ++i) {\n      key = children[i].key;\n\n      if (isDef(key)) {\n        map[key] = i;\n      }\n    }\n\n    return map;\n  }\n\n  function createPatchFunction(backend) {\n    var i, j;\n    var cbs = {};\n    var modules = backend.modules;\n    var nodeOps = backend.nodeOps;\n\n    for (i = 0; i < hooks.length; ++i) {\n      cbs[hooks[i]] = [];\n\n      for (j = 0; j < modules.length; ++j) {\n        if (isDef(modules[j][hooks[i]])) {\n          cbs[hooks[i]].push(modules[j][hooks[i]]);\n        }\n      }\n    }\n\n    function emptyNodeAt(elm) {\n      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n    }\n\n    function createRmCb(childElm, listeners) {\n      function remove$$1() {\n        if (--remove$$1.listeners === 0) {\n          removeNode(childElm);\n        }\n      }\n\n      remove$$1.listeners = listeners;\n      return remove$$1;\n    }\n\n    function removeNode(el) {\n      var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text\n\n      if (isDef(parent)) {\n        nodeOps.removeChild(parent, el);\n      }\n    }\n\n    function isUnknownElement$$1(vnode, inVPre) {\n      return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {\n        return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;\n      })) && config.isUnknownElement(vnode.tag);\n    }\n\n    var creatingElmInVPre = 0;\n\n    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // This vnode was used in a previous render!\n        // now it's used as a new node, overwriting its elm would cause\n        // potential patch errors down the road when it's used as an insertion\n        // reference node. Instead, we clone the node on-demand before creating\n        // associated DOM element for it.\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      vnode.isRootInsert = !nested; // for transition enter check\n\n      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n        return;\n      }\n\n      var data = vnode.data;\n      var children = vnode.children;\n      var tag = vnode.tag;\n\n      if (isDef(tag)) {\n        {\n          if (data && data.pre) {\n            creatingElmInVPre++;\n          }\n\n          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n          }\n        }\n        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n        setScope(vnode);\n        /* istanbul ignore if */\n\n        {\n          createChildren(vnode, children, insertedVnodeQueue);\n\n          if (isDef(data)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n          }\n\n          insert(parentElm, vnode.elm, refElm);\n        }\n\n        if (data && data.pre) {\n          creatingElmInVPre--;\n        }\n      } else if (isTrue(vnode.isComment)) {\n        vnode.elm = nodeOps.createComment(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      } else {\n        vnode.elm = nodeOps.createTextNode(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      }\n    }\n\n    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i = vnode.data;\n\n      if (isDef(i)) {\n        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n\n        if (isDef(i = i.hook) && isDef(i = i.init)) {\n          i(vnode, false\n          /* hydrating */\n          );\n        } // after calling the init hook, if the vnode is a child component\n        // it should've created a child instance and mounted it. the child\n        // component also has set the placeholder vnode's elm.\n        // in that case we can just return the element and be done.\n\n\n        if (isDef(vnode.componentInstance)) {\n          initComponent(vnode, insertedVnodeQueue);\n          insert(parentElm, vnode.elm, refElm);\n\n          if (isTrue(isReactivated)) {\n            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n          }\n\n          return true;\n        }\n      }\n    }\n\n    function initComponent(vnode, insertedVnodeQueue) {\n      if (isDef(vnode.data.pendingInsert)) {\n        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n        vnode.data.pendingInsert = null;\n      }\n\n      vnode.elm = vnode.componentInstance.$el;\n\n      if (isPatchable(vnode)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n        setScope(vnode);\n      } else {\n        // empty component root.\n        // skip all element-related modules except for ref (#3455)\n        registerRef(vnode); // make sure to invoke the insert hook\n\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n\n    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i; // hack for #4339: a reactivated component with inner transition\n      // does not trigger because the inner node's created hooks are not called\n      // again. It's not ideal to involve module-specific logic in here but\n      // there doesn't seem to be a better way to do it.\n\n      var innerNode = vnode;\n\n      while (innerNode.componentInstance) {\n        innerNode = innerNode.componentInstance._vnode;\n\n        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n          for (i = 0; i < cbs.activate.length; ++i) {\n            cbs.activate[i](emptyNode, innerNode);\n          }\n\n          insertedVnodeQueue.push(innerNode);\n          break;\n        }\n      } // unlike a newly created component,\n      // a reactivated keep-alive component doesn't insert itself\n\n\n      insert(parentElm, vnode.elm, refElm);\n    }\n\n    function insert(parent, elm, ref$$1) {\n      if (isDef(parent)) {\n        if (isDef(ref$$1)) {\n          if (nodeOps.parentNode(ref$$1) === parent) {\n            nodeOps.insertBefore(parent, elm, ref$$1);\n          }\n        } else {\n          nodeOps.appendChild(parent, elm);\n        }\n      }\n    }\n\n    function createChildren(vnode, children, insertedVnodeQueue) {\n      if (Array.isArray(children)) {\n        {\n          checkDuplicateKeys(children);\n        }\n\n        for (var i = 0; i < children.length; ++i) {\n          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n        }\n      } else if (isPrimitive(vnode.text)) {\n        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n      }\n    }\n\n    function isPatchable(vnode) {\n      while (vnode.componentInstance) {\n        vnode = vnode.componentInstance._vnode;\n      }\n\n      return isDef(vnode.tag);\n    }\n\n    function invokeCreateHooks(vnode, insertedVnodeQueue) {\n      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n        cbs.create[i$1](emptyNode, vnode);\n      }\n\n      i = vnode.data.hook; // Reuse variable\n\n      if (isDef(i)) {\n        if (isDef(i.create)) {\n          i.create(emptyNode, vnode);\n        }\n\n        if (isDef(i.insert)) {\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n    } // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n\n\n    function setScope(vnode) {\n      var i;\n\n      if (isDef(i = vnode.fnScopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      } else {\n        var ancestor = vnode;\n\n        while (ancestor) {\n          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n            nodeOps.setStyleScope(vnode.elm, i);\n          }\n\n          ancestor = ancestor.parent;\n        }\n      } // for slot content they should also get the scopeId from the host instance.\n\n\n      if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      }\n    }\n\n    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n      }\n    }\n\n    function invokeDestroyHook(vnode) {\n      var i, j;\n      var data = vnode.data;\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n          i(vnode);\n        }\n\n        for (i = 0; i < cbs.destroy.length; ++i) {\n          cbs.destroy[i](vnode);\n        }\n      }\n\n      if (isDef(i = vnode.children)) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          invokeDestroyHook(vnode.children[j]);\n        }\n      }\n    }\n\n    function removeVnodes(vnodes, startIdx, endIdx) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n\n        if (isDef(ch)) {\n          if (isDef(ch.tag)) {\n            removeAndInvokeRemoveHook(ch);\n            invokeDestroyHook(ch);\n          } else {\n            // Text node\n            removeNode(ch.elm);\n          }\n        }\n      }\n    }\n\n    function removeAndInvokeRemoveHook(vnode, rm) {\n      if (isDef(rm) || isDef(vnode.data)) {\n        var i;\n        var listeners = cbs.remove.length + 1;\n\n        if (isDef(rm)) {\n          // we have a recursively passed down rm callback\n          // increase the listeners count\n          rm.listeners += listeners;\n        } else {\n          // directly removing\n          rm = createRmCb(vnode.elm, listeners);\n        } // recursively invoke hooks on child component root node\n\n\n        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n          removeAndInvokeRemoveHook(i, rm);\n        }\n\n        for (i = 0; i < cbs.remove.length; ++i) {\n          cbs.remove[i](vnode, rm);\n        }\n\n        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n          i(vnode, rm);\n        } else {\n          rm();\n        }\n      } else {\n        removeNode(vnode.elm);\n      }\n    }\n\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n      var oldStartIdx = 0;\n      var newStartIdx = 0;\n      var oldEndIdx = oldCh.length - 1;\n      var oldStartVnode = oldCh[0];\n      var oldEndVnode = oldCh[oldEndIdx];\n      var newEndIdx = newCh.length - 1;\n      var newStartVnode = newCh[0];\n      var newEndVnode = newCh[newEndIdx];\n      var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>\n      // to ensure removed elements stay in correct relative positions\n      // during leaving transitions\n\n      var canMove = !removeOnly;\n      {\n        checkDuplicateKeys(newCh);\n      }\n\n      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n          oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          oldStartVnode = oldCh[++oldStartIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) {\n          // Vnode moved right\n          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n          oldStartVnode = oldCh[++oldStartIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) {\n          // Vnode moved left\n          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          if (isUndef(oldKeyToIdx)) {\n            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n          }\n\n          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n\n          if (isUndef(idxInOld)) {\n            // New element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          } else {\n            vnodeToMove = oldCh[idxInOld];\n\n            if (sameVnode(vnodeToMove, newStartVnode)) {\n              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n              oldCh[idxInOld] = undefined;\n              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n            } else {\n              // same key but different element. treat as new element\n              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n            }\n          }\n\n          newStartVnode = newCh[++newStartIdx];\n        }\n      }\n\n      if (oldStartIdx > oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n      } else if (newStartIdx > newEndIdx) {\n        removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n\n    function checkDuplicateKeys(children) {\n      var seenKeys = {};\n\n      for (var i = 0; i < children.length; i++) {\n        var vnode = children[i];\n        var key = vnode.key;\n\n        if (isDef(key)) {\n          if (seenKeys[key]) {\n            warn(\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\", vnode.context);\n          } else {\n            seenKeys[key] = true;\n          }\n        }\n      }\n    }\n\n    function findIdxInOld(node, oldCh, start, end) {\n      for (var i = start; i < end; i++) {\n        var c = oldCh[i];\n\n        if (isDef(c) && sameVnode(node, c)) {\n          return i;\n        }\n      }\n    }\n\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {\n      if (oldVnode === vnode) {\n        return;\n      }\n\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // clone reused vnode\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      var elm = vnode.elm = oldVnode.elm;\n\n      if (isTrue(oldVnode.isAsyncPlaceholder)) {\n        if (isDef(vnode.asyncFactory.resolved)) {\n          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n        } else {\n          vnode.isAsyncPlaceholder = true;\n        }\n\n        return;\n      } // reuse element for static trees.\n      // note we only do this if the vnode is cloned -\n      // if the new node is not cloned it means the render functions have been\n      // reset by the hot-reload-api and we need to do a proper re-render.\n\n\n      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n        vnode.componentInstance = oldVnode.componentInstance;\n        return;\n      }\n\n      var i;\n      var data = vnode.data;\n\n      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n        i(oldVnode, vnode);\n      }\n\n      var oldCh = oldVnode.children;\n      var ch = vnode.children;\n\n      if (isDef(data) && isPatchable(vnode)) {\n        for (i = 0; i < cbs.update.length; ++i) {\n          cbs.update[i](oldVnode, vnode);\n        }\n\n        if (isDef(i = data.hook) && isDef(i = i.update)) {\n          i(oldVnode, vnode);\n        }\n      }\n\n      if (isUndef(vnode.text)) {\n        if (isDef(oldCh) && isDef(ch)) {\n          if (oldCh !== ch) {\n            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n          }\n        } else if (isDef(ch)) {\n          {\n            checkDuplicateKeys(ch);\n          }\n\n          if (isDef(oldVnode.text)) {\n            nodeOps.setTextContent(elm, '');\n          }\n\n          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n        } else if (isDef(oldCh)) {\n          removeVnodes(oldCh, 0, oldCh.length - 1);\n        } else if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n      } else if (oldVnode.text !== vnode.text) {\n        nodeOps.setTextContent(elm, vnode.text);\n      }\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n          i(oldVnode, vnode);\n        }\n      }\n    }\n\n    function invokeInsertHook(vnode, queue, initial) {\n      // delay insert hooks for component root nodes, invoke them after the\n      // element is really inserted\n      if (isTrue(initial) && isDef(vnode.parent)) {\n        vnode.parent.data.pendingInsert = queue;\n      } else {\n        for (var i = 0; i < queue.length; ++i) {\n          queue[i].data.hook.insert(queue[i]);\n        }\n      }\n    }\n\n    var hydrationBailed = false; // list of modules that can skip create hook during hydration because they\n    // are already rendered on the client or has no need for initialization\n    // Note: style is excluded because it relies on initial clone for future\n    // deep updates (#7063).\n\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.\n\n    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\n      var i;\n      var tag = vnode.tag;\n      var data = vnode.data;\n      var children = vnode.children;\n      inVPre = inVPre || data && data.pre;\n      vnode.elm = elm;\n\n      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n        vnode.isAsyncPlaceholder = true;\n        return true;\n      } // assert node match\n\n\n      {\n        if (!assertNodeMatch(elm, vnode, inVPre)) {\n          return false;\n        }\n      }\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.init)) {\n          i(vnode, true\n          /* hydrating */\n          );\n        }\n\n        if (isDef(i = vnode.componentInstance)) {\n          // child component. it should have hydrated its own tree.\n          initComponent(vnode, insertedVnodeQueue);\n          return true;\n        }\n      }\n\n      if (isDef(tag)) {\n        if (isDef(children)) {\n          // empty element, allow client to pick up and populate children\n          if (!elm.hasChildNodes()) {\n            createChildren(vnode, children, insertedVnodeQueue);\n          } else {\n            // v-html and domProps: innerHTML\n            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n              if (i !== elm.innerHTML) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('server innerHTML: ', i);\n                  console.warn('client innerHTML: ', elm.innerHTML);\n                }\n\n                return false;\n              }\n            } else {\n              // iterate and compare children lists\n              var childrenMatch = true;\n              var childNode = elm.firstChild;\n\n              for (var i$1 = 0; i$1 < children.length; i$1++) {\n                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                  childrenMatch = false;\n                  break;\n                }\n\n                childNode = childNode.nextSibling;\n              } // if childNode is not null, it means the actual childNodes list is\n              // longer than the virtual children list.\n\n\n              if (!childrenMatch || childNode) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n                }\n\n                return false;\n              }\n            }\n          }\n        }\n\n        if (isDef(data)) {\n          var fullInvoke = false;\n\n          for (var key in data) {\n            if (!isRenderedModule(key)) {\n              fullInvoke = true;\n              invokeCreateHooks(vnode, insertedVnodeQueue);\n              break;\n            }\n          }\n\n          if (!fullInvoke && data['class']) {\n            // ensure collecting deps for deep class bindings for future updates\n            traverse(data['class']);\n          }\n        }\n      } else if (elm.data !== vnode.text) {\n        elm.data = vnode.text;\n      }\n\n      return true;\n    }\n\n    function assertNodeMatch(node, vnode, inVPre) {\n      if (isDef(vnode.tag)) {\n        return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n      } else {\n        return node.nodeType === (vnode.isComment ? 8 : 3);\n      }\n    }\n\n    return function patch(oldVnode, vnode, hydrating, removeOnly) {\n      if (isUndef(vnode)) {\n        if (isDef(oldVnode)) {\n          invokeDestroyHook(oldVnode);\n        }\n\n        return;\n      }\n\n      var isInitialPatch = false;\n      var insertedVnodeQueue = [];\n\n      if (isUndef(oldVnode)) {\n        // empty mount (likely as component), create new root element\n        isInitialPatch = true;\n        createElm(vnode, insertedVnodeQueue);\n      } else {\n        var isRealElement = isDef(oldVnode.nodeType);\n\n        if (!isRealElement && sameVnode(oldVnode, vnode)) {\n          // patch existing root node\n          patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n        } else {\n          if (isRealElement) {\n            // mounting to a real element\n            // check if this is server-rendered content and if we can perform\n            // a successful hydration.\n            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n              oldVnode.removeAttribute(SSR_ATTR);\n              hydrating = true;\n            }\n\n            if (isTrue(hydrating)) {\n              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                invokeInsertHook(vnode, insertedVnodeQueue, true);\n                return oldVnode;\n              } else {\n                warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n              }\n            } // either not server-rendered, or hydration failed.\n            // create an empty node and replace it\n\n\n            oldVnode = emptyNodeAt(oldVnode);\n          } // replacing existing element\n\n\n          var oldElm = oldVnode.elm;\n          var parentElm = nodeOps.parentNode(oldElm); // create new node\n\n          createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively\n\n          if (isDef(vnode.parent)) {\n            var ancestor = vnode.parent;\n            var patchable = isPatchable(vnode);\n\n            while (ancestor) {\n              for (var i = 0; i < cbs.destroy.length; ++i) {\n                cbs.destroy[i](ancestor);\n              }\n\n              ancestor.elm = vnode.elm;\n\n              if (patchable) {\n                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                  cbs.create[i$1](emptyNode, ancestor);\n                } // #6513\n                // invoke insert hooks that may have been merged by create hooks.\n                // e.g. for directives that uses the \"inserted\" hook.\n\n\n                var insert = ancestor.data.hook.insert;\n\n                if (insert.merged) {\n                  // start at index 1 to avoid re-invoking component mounted hook\n                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                    insert.fns[i$2]();\n                  }\n                }\n              } else {\n                registerRef(ancestor);\n              }\n\n              ancestor = ancestor.parent;\n            }\n          } // destroy old node\n\n\n          if (isDef(parentElm)) {\n            removeVnodes([oldVnode], 0, 0);\n          } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode);\n          }\n        }\n      }\n\n      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n      return vnode.elm;\n    };\n  }\n  /*  */\n\n\n  var directives = {\n    create: updateDirectives,\n    update: updateDirectives,\n    destroy: function unbindDirectives(vnode) {\n      updateDirectives(vnode, emptyNode);\n    }\n  };\n\n  function updateDirectives(oldVnode, vnode) {\n    if (oldVnode.data.directives || vnode.data.directives) {\n      _update(oldVnode, vnode);\n    }\n  }\n\n  function _update(oldVnode, vnode) {\n    var isCreate = oldVnode === emptyNode;\n    var isDestroy = vnode === emptyNode;\n    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n    var dirsWithInsert = [];\n    var dirsWithPostpatch = [];\n    var key, oldDir, dir;\n\n    for (key in newDirs) {\n      oldDir = oldDirs[key];\n      dir = newDirs[key];\n\n      if (!oldDir) {\n        // new directive, bind\n        callHook$1(dir, 'bind', vnode, oldVnode);\n\n        if (dir.def && dir.def.inserted) {\n          dirsWithInsert.push(dir);\n        }\n      } else {\n        // existing directive, update\n        dir.oldValue = oldDir.value;\n        dir.oldArg = oldDir.arg;\n        callHook$1(dir, 'update', vnode, oldVnode);\n\n        if (dir.def && dir.def.componentUpdated) {\n          dirsWithPostpatch.push(dir);\n        }\n      }\n    }\n\n    if (dirsWithInsert.length) {\n      var callInsert = function () {\n        for (var i = 0; i < dirsWithInsert.length; i++) {\n          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n        }\n      };\n\n      if (isCreate) {\n        mergeVNodeHook(vnode, 'insert', callInsert);\n      } else {\n        callInsert();\n      }\n    }\n\n    if (dirsWithPostpatch.length) {\n      mergeVNodeHook(vnode, 'postpatch', function () {\n        for (var i = 0; i < dirsWithPostpatch.length; i++) {\n          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n        }\n      });\n    }\n\n    if (!isCreate) {\n      for (key in oldDirs) {\n        if (!newDirs[key]) {\n          // no longer present, unbind\n          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n        }\n      }\n    }\n  }\n\n  var emptyModifiers = Object.create(null);\n\n  function normalizeDirectives$1(dirs, vm) {\n    var res = Object.create(null);\n\n    if (!dirs) {\n      // $flow-disable-line\n      return res;\n    }\n\n    var i, dir;\n\n    for (i = 0; i < dirs.length; i++) {\n      dir = dirs[i];\n\n      if (!dir.modifiers) {\n        // $flow-disable-line\n        dir.modifiers = emptyModifiers;\n      }\n\n      res[getRawDirName(dir)] = dir;\n      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n    } // $flow-disable-line\n\n\n    return res;\n  }\n\n  function getRawDirName(dir) {\n    return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n  }\n\n  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n    var fn = dir.def && dir.def[hook];\n\n    if (fn) {\n      try {\n        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n      } catch (e) {\n        handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n      }\n    }\n  }\n\n  var baseModules = [ref, directives];\n  /*  */\n\n  function updateAttrs(oldVnode, vnode) {\n    var opts = vnode.componentOptions;\n\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n      return;\n    }\n\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n      return;\n    }\n\n    var key, cur, old;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode.data.attrs || {};\n    var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it\n\n    if (isDef(attrs.__ob__)) {\n      attrs = vnode.data.attrs = extend({}, attrs);\n    }\n\n    for (key in attrs) {\n      cur = attrs[key];\n      old = oldAttrs[key];\n\n      if (old !== cur) {\n        setAttr(elm, key, cur, vnode.data.pre);\n      }\n    } // #4391: in IE9, setting type can reset value for input[type=radio]\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\n\n    /* istanbul ignore if */\n\n\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n      setAttr(elm, 'value', attrs.value);\n    }\n\n    for (key in oldAttrs) {\n      if (isUndef(attrs[key])) {\n        if (isXlink(key)) {\n          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        } else if (!isEnumeratedAttr(key)) {\n          elm.removeAttribute(key);\n        }\n      }\n    }\n  }\n\n  function setAttr(el, key, value, isInPre) {\n    if (isInPre || el.tagName.indexOf('-') > -1) {\n      baseSetAttr(el, key, value);\n    } else if (isBooleanAttr(key)) {\n      // set attribute for blank value\n      // e.g. <option disabled>Select one</option>\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        // technically allowfullscreen is a boolean attribute for <iframe>,\n        // but Flash expects a value of \"true\" when used on <embed> tag\n        value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\n        el.setAttribute(key, value);\n      }\n    } else if (isEnumeratedAttr(key)) {\n      el.setAttribute(key, convertEnumeratedValue(key, value));\n    } else if (isXlink(key)) {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else {\n        el.setAttributeNS(xlinkNS, key, value);\n      }\n    } else {\n      baseSetAttr(el, key, value);\n    }\n  }\n\n  function baseSetAttr(el, key, value) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // #7138: IE10 & 11 fires input event when setting placeholder on\n      // <textarea>... block the first input event and remove the blocker\n      // immediately.\n\n      /* istanbul ignore if */\n      if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {\n        var blocker = function (e) {\n          e.stopImmediatePropagation();\n          el.removeEventListener('input', blocker);\n        };\n\n        el.addEventListener('input', blocker); // $flow-disable-line\n\n        el.__ieph = true;\n        /* IE placeholder patched */\n      }\n\n      el.setAttribute(key, value);\n    }\n  }\n\n  var attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n  };\n  /*  */\n\n  function updateClass(oldVnode, vnode) {\n    var el = vnode.elm;\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n      return;\n    }\n\n    var cls = genClassForVnode(vnode); // handle transition classes\n\n    var transitionClass = el._transitionClasses;\n\n    if (isDef(transitionClass)) {\n      cls = concat(cls, stringifyClass(transitionClass));\n    } // set the class\n\n\n    if (cls !== el._prevClass) {\n      el.setAttribute('class', cls);\n      el._prevClass = cls;\n    }\n  }\n\n  var klass = {\n    create: updateClass,\n    update: updateClass\n  };\n  /*  */\n\n  var validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n  function parseFilters(exp) {\n    var inSingle = false;\n    var inDouble = false;\n    var inTemplateString = false;\n    var inRegex = false;\n    var curly = 0;\n    var square = 0;\n    var paren = 0;\n    var lastFilterIndex = 0;\n    var c, prev, i, expression, filters;\n\n    for (i = 0; i < exp.length; i++) {\n      prev = c;\n      c = exp.charCodeAt(i);\n\n      if (inSingle) {\n        if (c === 0x27 && prev !== 0x5C) {\n          inSingle = false;\n        }\n      } else if (inDouble) {\n        if (c === 0x22 && prev !== 0x5C) {\n          inDouble = false;\n        }\n      } else if (inTemplateString) {\n        if (c === 0x60 && prev !== 0x5C) {\n          inTemplateString = false;\n        }\n      } else if (inRegex) {\n        if (c === 0x2f && prev !== 0x5C) {\n          inRegex = false;\n        }\n      } else if (c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n        if (expression === undefined) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          expression = exp.slice(0, i).trim();\n        } else {\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22:\n            inDouble = true;\n            break;\n          // \"\n\n          case 0x27:\n            inSingle = true;\n            break;\n          // '\n\n          case 0x60:\n            inTemplateString = true;\n            break;\n          // `\n\n          case 0x28:\n            paren++;\n            break;\n          // (\n\n          case 0x29:\n            paren--;\n            break;\n          // )\n\n          case 0x5B:\n            square++;\n            break;\n          // [\n\n          case 0x5D:\n            square--;\n            break;\n          // ]\n\n          case 0x7B:\n            curly++;\n            break;\n          // {\n\n          case 0x7D:\n            curly--;\n            break;\n          // }\n        }\n\n        if (c === 0x2f) {\n          // /\n          var j = i - 1;\n          var p = void 0; // find first non-whitespace prev char\n\n          for (; j >= 0; j--) {\n            p = exp.charAt(j);\n\n            if (p !== ' ') {\n              break;\n            }\n          }\n\n          if (!p || !validDivisionCharRE.test(p)) {\n            inRegex = true;\n          }\n        }\n      }\n    }\n\n    if (expression === undefined) {\n      expression = exp.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    function pushFilter() {\n      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n      lastFilterIndex = i + 1;\n    }\n\n    if (filters) {\n      for (i = 0; i < filters.length; i++) {\n        expression = wrapFilter(expression, filters[i]);\n      }\n    }\n\n    return expression;\n  }\n\n  function wrapFilter(exp, filter) {\n    var i = filter.indexOf('(');\n\n    if (i < 0) {\n      // _f: resolveFilter\n      return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n    } else {\n      var name = filter.slice(0, i);\n      var args = filter.slice(i + 1);\n      return \"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args);\n    }\n  }\n  /*  */\n\n  /* eslint-disable no-unused-vars */\n\n\n  function baseWarn(msg, range) {\n    console.error(\"[Vue compiler]: \" + msg);\n  }\n  /* eslint-enable no-unused-vars */\n\n\n  function pluckModuleFunction(modules, key) {\n    return modules ? modules.map(function (m) {\n      return m[key];\n    }).filter(function (_) {\n      return _;\n    }) : [];\n  }\n\n  function addProp(el, name, value, range, dynamic) {\n    (el.props || (el.props = [])).push(rangeSetItem({\n      name: name,\n      value: value,\n      dynamic: dynamic\n    }, range));\n    el.plain = false;\n  }\n\n  function addAttr(el, name, value, range, dynamic) {\n    var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);\n    attrs.push(rangeSetItem({\n      name: name,\n      value: value,\n      dynamic: dynamic\n    }, range));\n    el.plain = false;\n  } // add a raw attr (use this in preTransforms)\n\n\n  function addRawAttr(el, name, value, range) {\n    el.attrsMap[name] = value;\n    el.attrsList.push(rangeSetItem({\n      name: name,\n      value: value\n    }, range));\n  }\n\n  function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {\n    (el.directives || (el.directives = [])).push(rangeSetItem({\n      name: name,\n      rawName: rawName,\n      value: value,\n      arg: arg,\n      isDynamicArg: isDynamicArg,\n      modifiers: modifiers\n    }, range));\n    el.plain = false;\n  }\n\n  function prependModifierMarker(symbol, name, dynamic) {\n    return dynamic ? \"_p(\" + name + \",\\\"\" + symbol + \"\\\")\" : symbol + name; // mark the event as captured\n  }\n\n  function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {\n    modifiers = modifiers || emptyObject; // warn prevent and passive modifier\n\n    /* istanbul ignore if */\n\n    if (warn && modifiers.prevent && modifiers.passive) {\n      warn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.', range);\n    } // normalize click.right and click.middle since they don't actually fire\n    // this is technically browser-specific, but at least for now browsers are\n    // the only target envs that have right/middle clicks.\n\n\n    if (modifiers.right) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'contextmenu';\n        delete modifiers.right;\n      }\n    } else if (modifiers.middle) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'mouseup';\n      }\n    } // check capture modifier\n\n\n    if (modifiers.capture) {\n      delete modifiers.capture;\n      name = prependModifierMarker('!', name, dynamic);\n    }\n\n    if (modifiers.once) {\n      delete modifiers.once;\n      name = prependModifierMarker('~', name, dynamic);\n    }\n    /* istanbul ignore if */\n\n\n    if (modifiers.passive) {\n      delete modifiers.passive;\n      name = prependModifierMarker('&', name, dynamic);\n    }\n\n    var events;\n\n    if (modifiers.native) {\n      delete modifiers.native;\n      events = el.nativeEvents || (el.nativeEvents = {});\n    } else {\n      events = el.events || (el.events = {});\n    }\n\n    var newHandler = rangeSetItem({\n      value: value.trim(),\n      dynamic: dynamic\n    }, range);\n\n    if (modifiers !== emptyObject) {\n      newHandler.modifiers = modifiers;\n    }\n\n    var handlers = events[name];\n    /* istanbul ignore if */\n\n    if (Array.isArray(handlers)) {\n      important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n    } else if (handlers) {\n      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n    } else {\n      events[name] = newHandler;\n    }\n\n    el.plain = false;\n  }\n\n  function getRawBindingAttr(el, name) {\n    return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];\n  }\n\n  function getBindingAttr(el, name, getStatic) {\n    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n\n    if (dynamicValue != null) {\n      return parseFilters(dynamicValue);\n    } else if (getStatic !== false) {\n      var staticValue = getAndRemoveAttr(el, name);\n\n      if (staticValue != null) {\n        return JSON.stringify(staticValue);\n      }\n    }\n  } // note: this only removes the attr from the Array (attrsList) so that it\n  // doesn't get processed by processAttrs.\n  // By default it does NOT remove it from the map (attrsMap) because the map is\n  // needed during codegen.\n\n\n  function getAndRemoveAttr(el, name, removeFromMap) {\n    var val;\n\n    if ((val = el.attrsMap[name]) != null) {\n      var list = el.attrsList;\n\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i].name === name) {\n          list.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    if (removeFromMap) {\n      delete el.attrsMap[name];\n    }\n\n    return val;\n  }\n\n  function getAndRemoveAttrByRegex(el, name) {\n    var list = el.attrsList;\n\n    for (var i = 0, l = list.length; i < l; i++) {\n      var attr = list[i];\n\n      if (name.test(attr.name)) {\n        list.splice(i, 1);\n        return attr;\n      }\n    }\n  }\n\n  function rangeSetItem(item, range) {\n    if (range) {\n      if (range.start != null) {\n        item.start = range.start;\n      }\n\n      if (range.end != null) {\n        item.end = range.end;\n      }\n    }\n\n    return item;\n  }\n  /*  */\n\n  /**\n   * Cross-platform code generation for component v-model\n   */\n\n\n  function genComponentModel(el, value, modifiers) {\n    var ref = modifiers || {};\n    var number = ref.number;\n    var trim = ref.trim;\n    var baseValueExpression = '$$v';\n    var valueExpression = baseValueExpression;\n\n    if (trim) {\n      valueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n    }\n\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var assignment = genAssignmentCode(value, valueExpression);\n    el.model = {\n      value: \"(\" + value + \")\",\n      expression: JSON.stringify(value),\n      callback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n    };\n  }\n  /**\n   * Cross-platform codegen helper for generating v-model value assignment code.\n   */\n\n\n  function genAssignmentCode(value, assignment) {\n    var res = parseModel(value);\n\n    if (res.key === null) {\n      return value + \"=\" + assignment;\n    } else {\n      return \"$set(\" + res.exp + \", \" + res.key + \", \" + assignment + \")\";\n    }\n  }\n  /**\n   * Parse a v-model expression into a base path and a final key segment.\n   * Handles both dot-path and possible square brackets.\n   *\n   * Possible cases:\n   *\n   * - test\n   * - test[key]\n   * - test[test1[key]]\n   * - test[\"a\"][key]\n   * - xxx.test[a[a].test1[key]]\n   * - test.xxx.a[\"asa\"][test1[key]]\n   *\n   */\n\n\n  var len, str, chr, index$1, expressionPos, expressionEndPos;\n\n  function parseModel(val) {\n    // Fix https://github.com/vuejs/vue/pull/7730\n    // allow v-model=\"obj.val \" (trailing whitespace)\n    val = val.trim();\n    len = val.length;\n\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n      index$1 = val.lastIndexOf('.');\n\n      if (index$1 > -1) {\n        return {\n          exp: val.slice(0, index$1),\n          key: '\"' + val.slice(index$1 + 1) + '\"'\n        };\n      } else {\n        return {\n          exp: val,\n          key: null\n        };\n      }\n    }\n\n    str = val;\n    index$1 = expressionPos = expressionEndPos = 0;\n\n    while (!eof()) {\n      chr = next();\n      /* istanbul ignore if */\n\n      if (isStringStart(chr)) {\n        parseString(chr);\n      } else if (chr === 0x5B) {\n        parseBracket(chr);\n      }\n    }\n\n    return {\n      exp: val.slice(0, expressionPos),\n      key: val.slice(expressionPos + 1, expressionEndPos)\n    };\n  }\n\n  function next() {\n    return str.charCodeAt(++index$1);\n  }\n\n  function eof() {\n    return index$1 >= len;\n  }\n\n  function isStringStart(chr) {\n    return chr === 0x22 || chr === 0x27;\n  }\n\n  function parseBracket(chr) {\n    var inBracket = 1;\n    expressionPos = index$1;\n\n    while (!eof()) {\n      chr = next();\n\n      if (isStringStart(chr)) {\n        parseString(chr);\n        continue;\n      }\n\n      if (chr === 0x5B) {\n        inBracket++;\n      }\n\n      if (chr === 0x5D) {\n        inBracket--;\n      }\n\n      if (inBracket === 0) {\n        expressionEndPos = index$1;\n        break;\n      }\n    }\n  }\n\n  function parseString(chr) {\n    var stringQuote = chr;\n\n    while (!eof()) {\n      chr = next();\n\n      if (chr === stringQuote) {\n        break;\n      }\n    }\n  }\n  /*  */\n\n\n  var warn$1; // in some cases, the event used has to be determined at runtime\n  // so we used some reserved tokens during compile.\n\n  var RANGE_TOKEN = '__r';\n  var CHECKBOX_RADIO_TOKEN = '__c';\n\n  function model(el, dir, _warn) {\n    warn$1 = _warn;\n    var value = dir.value;\n    var modifiers = dir.modifiers;\n    var tag = el.tag;\n    var type = el.attrsMap.type;\n    {\n      // inputs with type=\"file\" are read only and setting the input's\n      // value will throw an error.\n      if (tag === 'input' && type === 'file') {\n        warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\", el.rawAttrsMap['v-model']);\n      }\n    }\n\n    if (el.component) {\n      genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n      return false;\n    } else if (tag === 'select') {\n      genSelect(el, value, modifiers);\n    } else if (tag === 'input' && type === 'checkbox') {\n      genCheckboxModel(el, value, modifiers);\n    } else if (tag === 'input' && type === 'radio') {\n      genRadioModel(el, value, modifiers);\n    } else if (tag === 'input' || tag === 'textarea') {\n      genDefaultModel(el, value, modifiers);\n    } else if (!config.isReservedTag(tag)) {\n      genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n      return false;\n    } else {\n      warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);\n    } // ensure runtime directive metadata\n\n\n    return true;\n  }\n\n  function genCheckboxModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n    addHandler(el, 'change', \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$el.checked){$$i<0&&(\" + genAssignmentCode(value, '$$a.concat([$$v])') + \")}\" + \"else{$$i>-1&&(\" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + \")}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n  }\n\n  function genRadioModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    valueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n    addProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n  }\n\n  function genSelect(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n    var code = \"var $$selectedVal = \" + selectedVal + \";\";\n    code = code + \" \" + genAssignmentCode(value, assignment);\n    addHandler(el, 'change', code, null, true);\n  }\n\n  function genDefaultModel(el, value, modifiers) {\n    var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model\n    // except for inputs with v-bind:type\n\n    {\n      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n\n      if (value$1 && !typeBinding) {\n        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n        warn$1(binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);\n      }\n    }\n    var ref = modifiers || {};\n    var lazy = ref.lazy;\n    var number = ref.number;\n    var trim = ref.trim;\n    var needCompositionGuard = !lazy && type !== 'range';\n    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n    var valueExpression = '$event.target.value';\n\n    if (trim) {\n      valueExpression = \"$event.target.value.trim()\";\n    }\n\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var code = genAssignmentCode(value, valueExpression);\n\n    if (needCompositionGuard) {\n      code = \"if($event.target.composing)return;\" + code;\n    }\n\n    addProp(el, 'value', \"(\" + value + \")\");\n    addHandler(el, event, code, null, true);\n\n    if (trim || number) {\n      addHandler(el, 'blur', '$forceUpdate()');\n    }\n  }\n  /*  */\n  // normalize v-model event tokens that can only be determined at runtime.\n  // it's important to place the event as the first in the array because\n  // the whole point is ensuring the v-model callback gets called before\n  // user-attached handlers.\n\n\n  function normalizeEvents(on) {\n    /* istanbul ignore if */\n    if (isDef(on[RANGE_TOKEN])) {\n      // IE input[type=range] only supports `change` event\n      var event = isIE ? 'change' : 'input';\n      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n      delete on[RANGE_TOKEN];\n    } // This was originally intended to fix #4521 but no longer necessary\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n\n    /* istanbul ignore if */\n\n\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n      delete on[CHECKBOX_RADIO_TOKEN];\n    }\n  }\n\n  var target$1;\n\n  function createOnceHandler$1(event, handler, capture) {\n    var _target = target$1; // save current target element in closure\n\n    return function onceHandler() {\n      var res = handler.apply(null, arguments);\n\n      if (res !== null) {\n        remove$2(event, onceHandler, capture, _target);\n      }\n    };\n  } // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n  // implementation and does not fire microtasks in between event propagation, so\n  // safe to exclude.\n\n\n  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\n  function add$1(name, handler, capture, passive) {\n    // async edge case #6566: inner click event triggers patch, event handler\n    // attached to outer element during patch, and triggered again. This\n    // happens because browsers fire microtask ticks between event propagation.\n    // the solution is simple: we save the timestamp when a handler is attached,\n    // and the handler would only fire if the event passed to it was fired\n    // AFTER it was attached.\n    if (useMicrotaskFix) {\n      var attachedTimestamp = currentFlushTimestamp;\n      var original = handler;\n\n      handler = original._wrapper = function (e) {\n        if ( // no bubbling, should always fire.\n        // this is just a safety net in case event.timeStamp is unreliable in\n        // certain weird environments...\n        e.target === e.currentTarget || // event is fired after handler attachment\n        e.timeStamp >= attachedTimestamp || // bail for environments that have buggy event.timeStamp implementations\n        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n        // #9681 QtWebEngine event.timeStamp is negative value\n        e.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page\n        // electron/nw.js app, since event.timeStamp will be using a different\n        // starting reference\n        e.target.ownerDocument !== document) {\n          return original.apply(this, arguments);\n        }\n      };\n    }\n\n    target$1.addEventListener(name, handler, supportsPassive ? {\n      capture: capture,\n      passive: passive\n    } : capture);\n  }\n\n  function remove$2(name, handler, capture, _target) {\n    (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);\n  }\n\n  function updateDOMListeners(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n      return;\n    }\n\n    var on = vnode.data.on || {};\n    var oldOn = oldVnode.data.on || {};\n    target$1 = vnode.elm;\n    normalizeEvents(on);\n    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n    target$1 = undefined;\n  }\n\n  var events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners\n  };\n  /*  */\n\n  var svgContainer;\n\n  function updateDOMProps(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n      return;\n    }\n\n    var key, cur;\n    var elm = vnode.elm;\n    var oldProps = oldVnode.data.domProps || {};\n    var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it\n\n    if (isDef(props.__ob__)) {\n      props = vnode.data.domProps = extend({}, props);\n    }\n\n    for (key in oldProps) {\n      if (!(key in props)) {\n        elm[key] = '';\n      }\n    }\n\n    for (key in props) {\n      cur = props[key]; // ignore children if the node has textContent or innerHTML,\n      // as these will throw away existing DOM nodes and cause removal errors\n      // on subsequent patches (#3360)\n\n      if (key === 'textContent' || key === 'innerHTML') {\n        if (vnode.children) {\n          vnode.children.length = 0;\n        }\n\n        if (cur === oldProps[key]) {\n          continue;\n        } // #6601 work around Chrome version <= 55 bug where single textNode\n        // replaced by innerHTML/textContent retains its parentNode property\n\n\n        if (elm.childNodes.length === 1) {\n          elm.removeChild(elm.childNodes[0]);\n        }\n      }\n\n      if (key === 'value' && elm.tagName !== 'PROGRESS') {\n        // store value as _value as well since\n        // non-string values will be stringified\n        elm._value = cur; // avoid resetting cursor position when value is the same\n\n        var strCur = isUndef(cur) ? '' : String(cur);\n\n        if (shouldUpdateValue(elm, strCur)) {\n          elm.value = strCur;\n        }\n      } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n        // IE doesn't support innerHTML for SVG elements\n        svgContainer = svgContainer || document.createElement('div');\n        svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n        var svg = svgContainer.firstChild;\n\n        while (elm.firstChild) {\n          elm.removeChild(elm.firstChild);\n        }\n\n        while (svg.firstChild) {\n          elm.appendChild(svg.firstChild);\n        }\n      } else if ( // skip the update if old and new VDOM state is the same.\n      // `value` is handled separately because the DOM value may be temporarily\n      // out of sync with VDOM state due to focus, composition and modifiers.\n      // This  #4521 by skipping the unnecessary `checked` update.\n      cur !== oldProps[key]) {\n        // some property updates can throw\n        // e.g. `value` on <progress> w/ non-finite value\n        try {\n          elm[key] = cur;\n        } catch (e) {}\n      }\n    }\n  } // check platforms/web/util/attrs.js acceptValue\n\n\n  function shouldUpdateValue(elm, checkVal) {\n    return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));\n  }\n\n  function isNotInFocusAndDirty(elm, checkVal) {\n    // return true when textbox (.number and .trim) loses focus and its value is\n    // not equal to the updated value\n    var notInFocus = true; // #6157\n    // work around IE bug when accessing document.activeElement in an iframe\n\n    try {\n      notInFocus = document.activeElement !== elm;\n    } catch (e) {}\n\n    return notInFocus && elm.value !== checkVal;\n  }\n\n  function isDirtyWithModifiers(elm, newVal) {\n    var value = elm.value;\n    var modifiers = elm._vModifiers; // injected by v-model runtime\n\n    if (isDef(modifiers)) {\n      if (modifiers.number) {\n        return toNumber(value) !== toNumber(newVal);\n      }\n\n      if (modifiers.trim) {\n        return value.trim() !== newVal.trim();\n      }\n    }\n\n    return value !== newVal;\n  }\n\n  var domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n  };\n  /*  */\n\n  var parseStyleText = cached(function (cssText) {\n    var res = {};\n    var listDelimiter = /;(?![^(]*\\))/g;\n    var propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n      if (item) {\n        var tmp = item.split(propertyDelimiter);\n        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return res;\n  }); // merge static and dynamic style data on the same vnode\n\n  function normalizeStyleData(data) {\n    var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation\n    // and is always a fresh object, so it's safe to merge into it\n\n    return data.staticStyle ? extend(data.staticStyle, style) : style;\n  } // normalize possible array / string values into Object\n\n\n  function normalizeStyleBinding(bindingStyle) {\n    if (Array.isArray(bindingStyle)) {\n      return toObject(bindingStyle);\n    }\n\n    if (typeof bindingStyle === 'string') {\n      return parseStyleText(bindingStyle);\n    }\n\n    return bindingStyle;\n  }\n  /**\n   * parent component style should be after child's\n   * so that parent component's style could override it\n   */\n\n\n  function getStyle(vnode, checkChild) {\n    var res = {};\n    var styleData;\n\n    if (checkChild) {\n      var childNode = vnode;\n\n      while (childNode.componentInstance) {\n        childNode = childNode.componentInstance._vnode;\n\n        if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n          extend(res, styleData);\n        }\n      }\n    }\n\n    if (styleData = normalizeStyleData(vnode.data)) {\n      extend(res, styleData);\n    }\n\n    var parentNode = vnode;\n\n    while (parentNode = parentNode.parent) {\n      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n        extend(res, styleData);\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  var cssVarRE = /^--/;\n  var importantRE = /\\s*!important$/;\n\n  var setProp = function (el, name, val) {\n    /* istanbul ignore if */\n    if (cssVarRE.test(name)) {\n      el.style.setProperty(name, val);\n    } else if (importantRE.test(val)) {\n      el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n    } else {\n      var normalizedName = normalize(name);\n\n      if (Array.isArray(val)) {\n        // Support values array created by autoprefixer, e.g.\n        // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n        // Set them one by one, and the browser will only set those it can recognize\n        for (var i = 0, len = val.length; i < len; i++) {\n          el.style[normalizedName] = val[i];\n        }\n      } else {\n        el.style[normalizedName] = val;\n      }\n    }\n  };\n\n  var vendorNames = ['Webkit', 'Moz', 'ms'];\n  var emptyStyle;\n  var normalize = cached(function (prop) {\n    emptyStyle = emptyStyle || document.createElement('div').style;\n    prop = camelize(prop);\n\n    if (prop !== 'filter' && prop in emptyStyle) {\n      return prop;\n    }\n\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n\n    for (var i = 0; i < vendorNames.length; i++) {\n      var name = vendorNames[i] + capName;\n\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  });\n\n  function updateStyle(oldVnode, vnode) {\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n      return;\n    }\n\n    var cur, name;\n    var el = vnode.elm;\n    var oldStaticStyle = oldData.staticStyle;\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n\n    var oldStyle = oldStaticStyle || oldStyleBinding;\n    var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff\n    // make sure to clone it if it's reactive, since the user likely wants\n    // to mutate it.\n\n    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n    var newStyle = getStyle(vnode, true);\n\n    for (name in oldStyle) {\n      if (isUndef(newStyle[name])) {\n        setProp(el, name, '');\n      }\n    }\n\n    for (name in newStyle) {\n      cur = newStyle[name];\n\n      if (cur !== oldStyle[name]) {\n        // ie9 setting to null has no effect, must use empty string\n        setProp(el, name, cur == null ? '' : cur);\n      }\n    }\n  }\n\n  var style = {\n    create: updateStyle,\n    update: updateStyle\n  };\n  /*  */\n\n  var whitespaceRE = /\\s+/;\n  /**\n   * Add class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n\n  function addClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) {\n          return el.classList.add(c);\n        });\n      } else {\n        el.classList.add(cls);\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        el.setAttribute('class', (cur + cls).trim());\n      }\n    }\n  }\n  /**\n   * Remove class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n\n\n  function removeClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) {\n          return el.classList.remove(c);\n        });\n      } else {\n        el.classList.remove(cls);\n      }\n\n      if (!el.classList.length) {\n        el.removeAttribute('class');\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      var tar = ' ' + cls + ' ';\n\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n\n      cur = cur.trim();\n\n      if (cur) {\n        el.setAttribute('class', cur);\n      } else {\n        el.removeAttribute('class');\n      }\n    }\n  }\n  /*  */\n\n\n  function resolveTransition(def$$1) {\n    if (!def$$1) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (typeof def$$1 === 'object') {\n      var res = {};\n\n      if (def$$1.css !== false) {\n        extend(res, autoCssTransition(def$$1.name || 'v'));\n      }\n\n      extend(res, def$$1);\n      return res;\n    } else if (typeof def$$1 === 'string') {\n      return autoCssTransition(def$$1);\n    }\n  }\n\n  var autoCssTransition = cached(function (name) {\n    return {\n      enterClass: name + \"-enter\",\n      enterToClass: name + \"-enter-to\",\n      enterActiveClass: name + \"-enter-active\",\n      leaveClass: name + \"-leave\",\n      leaveToClass: name + \"-leave-to\",\n      leaveActiveClass: name + \"-leave-active\"\n    };\n  });\n  var hasTransition = inBrowser && !isIE9;\n  var TRANSITION = 'transition';\n  var ANIMATION = 'animation'; // Transition property/event sniffing\n\n  var transitionProp = 'transition';\n  var transitionEndEvent = 'transitionend';\n  var animationProp = 'animation';\n  var animationEndEvent = 'animationend';\n\n  if (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n      transitionProp = 'WebkitTransition';\n      transitionEndEvent = 'webkitTransitionEnd';\n    }\n\n    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n      animationProp = 'WebkitAnimation';\n      animationEndEvent = 'webkitAnimationEnd';\n    }\n  } // binding to window is necessary to make hot reload work in IE in strict mode\n\n\n  var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :\n  /* istanbul ignore next */\n  function (fn) {\n    return fn();\n  };\n\n  function nextFrame(fn) {\n    raf(function () {\n      raf(fn);\n    });\n  }\n\n  function addTransitionClass(el, cls) {\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n\n    if (transitionClasses.indexOf(cls) < 0) {\n      transitionClasses.push(cls);\n      addClass(el, cls);\n    }\n  }\n\n  function removeTransitionClass(el, cls) {\n    if (el._transitionClasses) {\n      remove(el._transitionClasses, cls);\n    }\n\n    removeClass(el, cls);\n  }\n\n  function whenTransitionEnds(el, expectedType, cb) {\n    var ref = getTransitionInfo(el, expectedType);\n    var type = ref.type;\n    var timeout = ref.timeout;\n    var propCount = ref.propCount;\n\n    if (!type) {\n      return cb();\n    }\n\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    var ended = 0;\n\n    var end = function () {\n      el.removeEventListener(event, onEnd);\n      cb();\n    };\n\n    var onEnd = function (e) {\n      if (e.target === el) {\n        if (++ended >= propCount) {\n          end();\n        }\n      }\n    };\n\n    setTimeout(function () {\n      if (ended < propCount) {\n        end();\n      }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n  }\n\n  var transformRE = /\\b(transform|all)(,|$)/;\n\n  function getTransitionInfo(el, expectedType) {\n    var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties\n\n    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\n    var type;\n    var timeout = 0;\n    var propCount = 0;\n    /* istanbul ignore if */\n\n    if (expectedType === TRANSITION) {\n      if (transitionTimeout > 0) {\n        type = TRANSITION;\n        timeout = transitionTimeout;\n        propCount = transitionDurations.length;\n      }\n    } else if (expectedType === ANIMATION) {\n      if (animationTimeout > 0) {\n        type = ANIMATION;\n        timeout = animationTimeout;\n        propCount = animationDurations.length;\n      }\n    } else {\n      timeout = Math.max(transitionTimeout, animationTimeout);\n      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n    }\n\n    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n    return {\n      type: type,\n      timeout: timeout,\n      propCount: propCount,\n      hasTransform: hasTransform\n    };\n  }\n\n  function getTimeout(delays, durations) {\n    /* istanbul ignore next */\n    while (delays.length < durations.length) {\n      delays = delays.concat(delays);\n    }\n\n    return Math.max.apply(null, durations.map(function (d, i) {\n      return toMs(d) + toMs(delays[i]);\n    }));\n  } // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n  // in a locale-dependent way, using a comma instead of a dot.\n  // If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n  // as a floor function) causing unexpected behaviors\n\n\n  function toMs(s) {\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000;\n  }\n  /*  */\n\n\n  function enter(vnode, toggleDisplay) {\n    var el = vnode.elm; // call leave callback now\n\n    if (isDef(el._leaveCb)) {\n      el._leaveCb.cancelled = true;\n\n      el._leaveCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n\n    if (isUndef(data)) {\n      return;\n    }\n    /* istanbul ignore if */\n\n\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var enterClass = data.enterClass;\n    var enterToClass = data.enterToClass;\n    var enterActiveClass = data.enterActiveClass;\n    var appearClass = data.appearClass;\n    var appearToClass = data.appearToClass;\n    var appearActiveClass = data.appearActiveClass;\n    var beforeEnter = data.beforeEnter;\n    var enter = data.enter;\n    var afterEnter = data.afterEnter;\n    var enterCancelled = data.enterCancelled;\n    var beforeAppear = data.beforeAppear;\n    var appear = data.appear;\n    var afterAppear = data.afterAppear;\n    var appearCancelled = data.appearCancelled;\n    var duration = data.duration; // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n\n    var context = activeInstance;\n    var transitionNode = activeInstance.$vnode;\n\n    while (transitionNode && transitionNode.parent) {\n      context = transitionNode.context;\n      transitionNode = transitionNode.parent;\n    }\n\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n    if (isAppear && !appear && appear !== '') {\n      return;\n    }\n\n    var startClass = isAppear && appearClass ? appearClass : enterClass;\n    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n    if (explicitEnterDuration != null) {\n      checkDuration(explicitEnterDuration, 'enter', vnode);\n    }\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(enterHook);\n    var cb = el._enterCb = once(function () {\n      if (expectsCSS) {\n        removeTransitionClass(el, toClass);\n        removeTransitionClass(el, activeClass);\n      }\n\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, startClass);\n        }\n\n        enterCancelledHook && enterCancelledHook(el);\n      } else {\n        afterEnterHook && afterEnterHook(el);\n      }\n\n      el._enterCb = null;\n    });\n\n    if (!vnode.data.show) {\n      // remove pending leave element on enter by injecting an insert hook\n      mergeVNodeHook(vnode, 'insert', function () {\n        var parent = el.parentNode;\n        var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\n        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n          pendingNode.elm._leaveCb();\n        }\n\n        enterHook && enterHook(el, cb);\n      });\n    } // start enter transition\n\n\n    beforeEnterHook && beforeEnterHook(el);\n\n    if (expectsCSS) {\n      addTransitionClass(el, startClass);\n      addTransitionClass(el, activeClass);\n      nextFrame(function () {\n        removeTransitionClass(el, startClass);\n\n        if (!cb.cancelled) {\n          addTransitionClass(el, toClass);\n\n          if (!userWantsControl) {\n            if (isValidDuration(explicitEnterDuration)) {\n              setTimeout(cb, explicitEnterDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    if (vnode.data.show) {\n      toggleDisplay && toggleDisplay();\n      enterHook && enterHook(el, cb);\n    }\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n\n  function leave(vnode, rm) {\n    var el = vnode.elm; // call enter callback now\n\n    if (isDef(el._enterCb)) {\n      el._enterCb.cancelled = true;\n\n      el._enterCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n\n    if (isUndef(data) || el.nodeType !== 1) {\n      return rm();\n    }\n    /* istanbul ignore if */\n\n\n    if (isDef(el._leaveCb)) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var leaveClass = data.leaveClass;\n    var leaveToClass = data.leaveToClass;\n    var leaveActiveClass = data.leaveActiveClass;\n    var beforeLeave = data.beforeLeave;\n    var leave = data.leave;\n    var afterLeave = data.afterLeave;\n    var leaveCancelled = data.leaveCancelled;\n    var delayLeave = data.delayLeave;\n    var duration = data.duration;\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(leave);\n    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n    if (isDef(explicitLeaveDuration)) {\n      checkDuration(explicitLeaveDuration, 'leave', vnode);\n    }\n\n    var cb = el._leaveCb = once(function () {\n      if (el.parentNode && el.parentNode._pending) {\n        el.parentNode._pending[vnode.key] = null;\n      }\n\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveActiveClass);\n      }\n\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, leaveClass);\n        }\n\n        leaveCancelled && leaveCancelled(el);\n      } else {\n        rm();\n        afterLeave && afterLeave(el);\n      }\n\n      el._leaveCb = null;\n    });\n\n    if (delayLeave) {\n      delayLeave(performLeave);\n    } else {\n      performLeave();\n    }\n\n    function performLeave() {\n      // the delayed leave may have already been cancelled\n      if (cb.cancelled) {\n        return;\n      } // record leaving element\n\n\n      if (!vnode.data.show && el.parentNode) {\n        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n      }\n\n      beforeLeave && beforeLeave(el);\n\n      if (expectsCSS) {\n        addTransitionClass(el, leaveClass);\n        addTransitionClass(el, leaveActiveClass);\n        nextFrame(function () {\n          removeTransitionClass(el, leaveClass);\n\n          if (!cb.cancelled) {\n            addTransitionClass(el, leaveToClass);\n\n            if (!userWantsControl) {\n              if (isValidDuration(explicitLeaveDuration)) {\n                setTimeout(cb, explicitLeaveDuration);\n              } else {\n                whenTransitionEnds(el, type, cb);\n              }\n            }\n          }\n        });\n      }\n\n      leave && leave(el, cb);\n\n      if (!expectsCSS && !userWantsControl) {\n        cb();\n      }\n    }\n  } // only used in dev mode\n\n\n  function checkDuration(val, name, vnode) {\n    if (typeof val !== 'number') {\n      warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n    } else if (isNaN(val)) {\n      warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n    }\n  }\n\n  function isValidDuration(val) {\n    return typeof val === 'number' && !isNaN(val);\n  }\n  /**\n   * Normalize a transition hook's argument length. The hook may be:\n   * - a merged hook (invoker) with the original in .fns\n   * - a wrapped component method (check ._length)\n   * - a plain function (.length)\n   */\n\n\n  function getHookArgumentsLength(fn) {\n    if (isUndef(fn)) {\n      return false;\n    }\n\n    var invokerFns = fn.fns;\n\n    if (isDef(invokerFns)) {\n      // invoker\n      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n    } else {\n      return (fn._length || fn.length) > 1;\n    }\n  }\n\n  function _enter(_, vnode) {\n    if (vnode.data.show !== true) {\n      enter(vnode);\n    }\n  }\n\n  var transition = inBrowser ? {\n    create: _enter,\n    activate: _enter,\n    remove: function remove$$1(vnode, rm) {\n      /* istanbul ignore else */\n      if (vnode.data.show !== true) {\n        leave(vnode, rm);\n      } else {\n        rm();\n      }\n    }\n  } : {};\n  var platformModules = [attrs, klass, events, domProps, style, transition];\n  /*  */\n  // the directive module should be applied last, after all\n  // built-in modules have been applied.\n\n  var modules = platformModules.concat(baseModules);\n  var patch = createPatchFunction({\n    nodeOps: nodeOps,\n    modules: modules\n  });\n  /**\n   * Not type checking this file because flow doesn't like attaching\n   * properties to Elements.\n   */\n\n  /* istanbul ignore if */\n\n  if (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', function () {\n      var el = document.activeElement;\n\n      if (el && el.vmodel) {\n        trigger(el, 'input');\n      }\n    });\n  }\n\n  var directive = {\n    inserted: function inserted(el, binding, vnode, oldVnode) {\n      if (vnode.tag === 'select') {\n        // #6903\n        if (oldVnode.elm && !oldVnode.elm._vOptions) {\n          mergeVNodeHook(vnode, 'postpatch', function () {\n            directive.componentUpdated(el, binding, vnode);\n          });\n        } else {\n          setSelected(el, binding, vnode.context);\n        }\n\n        el._vOptions = [].map.call(el.options, getValue);\n      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n        el._vModifiers = binding.modifiers;\n\n        if (!binding.modifiers.lazy) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when\n          // switching focus before confirming composition choice\n          // this also fixes the issue where some browsers e.g. iOS Chrome\n          // fires \"change\" instead of \"input\" on autocomplete.\n\n          el.addEventListener('change', onCompositionEnd);\n          /* istanbul ignore if */\n\n          if (isIE9) {\n            el.vmodel = true;\n          }\n        }\n      }\n    },\n    componentUpdated: function componentUpdated(el, binding, vnode) {\n      if (vnode.tag === 'select') {\n        setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,\n        // it's possible that the value is out-of-sync with the rendered options.\n        // detect such cases and filter out values that no longer has a matching\n        // option in the DOM.\n\n        var prevOptions = el._vOptions;\n        var curOptions = el._vOptions = [].map.call(el.options, getValue);\n\n        if (curOptions.some(function (o, i) {\n          return !looseEqual(o, prevOptions[i]);\n        })) {\n          // trigger change event if\n          // no matching option found for at least one value\n          var needReset = el.multiple ? binding.value.some(function (v) {\n            return hasNoMatchingOption(v, curOptions);\n          }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n\n          if (needReset) {\n            trigger(el, 'change');\n          }\n        }\n      }\n    }\n  };\n\n  function setSelected(el, binding, vm) {\n    actuallySetSelected(el, binding, vm);\n    /* istanbul ignore if */\n\n    if (isIE || isEdge) {\n      setTimeout(function () {\n        actuallySetSelected(el, binding, vm);\n      }, 0);\n    }\n  }\n\n  function actuallySetSelected(el, binding, vm) {\n    var value = binding.value;\n    var isMultiple = el.multiple;\n\n    if (isMultiple && !Array.isArray(value)) {\n      warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n      return;\n    }\n\n    var selected, option;\n\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      option = el.options[i];\n\n      if (isMultiple) {\n        selected = looseIndexOf(value, getValue(option)) > -1;\n\n        if (option.selected !== selected) {\n          option.selected = selected;\n        }\n      } else {\n        if (looseEqual(getValue(option), value)) {\n          if (el.selectedIndex !== i) {\n            el.selectedIndex = i;\n          }\n\n          return;\n        }\n      }\n    }\n\n    if (!isMultiple) {\n      el.selectedIndex = -1;\n    }\n  }\n\n  function hasNoMatchingOption(value, options) {\n    return options.every(function (o) {\n      return !looseEqual(o, value);\n    });\n  }\n\n  function getValue(option) {\n    return '_value' in option ? option._value : option.value;\n  }\n\n  function onCompositionStart(e) {\n    e.target.composing = true;\n  }\n\n  function onCompositionEnd(e) {\n    // prevent triggering an input event for no reason\n    if (!e.target.composing) {\n      return;\n    }\n\n    e.target.composing = false;\n    trigger(e.target, 'input');\n  }\n\n  function trigger(el, type) {\n    var e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n  }\n  /*  */\n  // recursively search for possible transition defined inside the component root\n\n\n  function locateNode(vnode) {\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n  }\n\n  var show = {\n    bind: function bind(el, ref, vnode) {\n      var value = ref.value;\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n\n      if (value && transition$$1) {\n        vnode.data.show = true;\n        enter(vnode, function () {\n          el.style.display = originalDisplay;\n        });\n      } else {\n        el.style.display = value ? originalDisplay : 'none';\n      }\n    },\n    update: function update(el, ref, vnode) {\n      var value = ref.value;\n      var oldValue = ref.oldValue;\n      /* istanbul ignore if */\n\n      if (!value === !oldValue) {\n        return;\n      }\n\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n\n      if (transition$$1) {\n        vnode.data.show = true;\n\n        if (value) {\n          enter(vnode, function () {\n            el.style.display = el.__vOriginalDisplay;\n          });\n        } else {\n          leave(vnode, function () {\n            el.style.display = 'none';\n          });\n        }\n      } else {\n        el.style.display = value ? el.__vOriginalDisplay : 'none';\n      }\n    },\n    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n      if (!isDestroy) {\n        el.style.display = el.__vOriginalDisplay;\n      }\n    }\n  };\n  var platformDirectives = {\n    model: directive,\n    show: show\n  };\n  /*  */\n\n  var transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n  }; // in case the child is also an abstract component, e.g. <keep-alive>\n  // we want to recursively retrieve the real component to be rendered\n\n  function getRealChild(vnode) {\n    var compOptions = vnode && vnode.componentOptions;\n\n    if (compOptions && compOptions.Ctor.options.abstract) {\n      return getRealChild(getFirstComponentChild(compOptions.children));\n    } else {\n      return vnode;\n    }\n  }\n\n  function extractTransitionData(comp) {\n    var data = {};\n    var options = comp.$options; // props\n\n    for (var key in options.propsData) {\n      data[key] = comp[key];\n    } // events.\n    // extract listeners and pass them directly to the transition methods\n\n\n    var listeners = options._parentListeners;\n\n    for (var key$1 in listeners) {\n      data[camelize(key$1)] = listeners[key$1];\n    }\n\n    return data;\n  }\n\n  function placeholder(h, rawChild) {\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\n      return h('keep-alive', {\n        props: rawChild.componentOptions.propsData\n      });\n    }\n  }\n\n  function hasParentTransition(vnode) {\n    while (vnode = vnode.parent) {\n      if (vnode.data.transition) {\n        return true;\n      }\n    }\n  }\n\n  function isSameChild(child, oldChild) {\n    return oldChild.key === child.key && oldChild.tag === child.tag;\n  }\n\n  var isNotTextNode = function (c) {\n    return c.tag || isAsyncPlaceholder(c);\n  };\n\n  var isVShowDirective = function (d) {\n    return d.name === 'show';\n  };\n\n  var Transition = {\n    name: 'transition',\n    props: transitionProps,\n    abstract: true,\n    render: function render(h) {\n      var this$1 = this;\n      var children = this.$slots.default;\n\n      if (!children) {\n        return;\n      } // filter out text nodes (possible whitespaces)\n\n\n      children = children.filter(isNotTextNode);\n      /* istanbul ignore if */\n\n      if (!children.length) {\n        return;\n      } // warn multiple elements\n\n\n      if (children.length > 1) {\n        warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n      }\n\n      var mode = this.mode; // warn invalid mode\n\n      if (mode && mode !== 'in-out' && mode !== 'out-in') {\n        warn('invalid <transition> mode: ' + mode, this.$parent);\n      }\n\n      var rawChild = children[0]; // if this is a component root node and the component's\n      // parent container node also has transition, skip.\n\n      if (hasParentTransition(this.$vnode)) {\n        return rawChild;\n      } // apply transition data to child\n      // use getRealChild() to ignore abstract components e.g. keep-alive\n\n\n      var child = getRealChild(rawChild);\n      /* istanbul ignore if */\n\n      if (!child) {\n        return rawChild;\n      }\n\n      if (this._leaving) {\n        return placeholder(h, rawChild);\n      } // ensure a key that is unique to the vnode type and to this transition\n      // component instance. This key will be used to remove pending leaving nodes\n      // during entering.\n\n\n      var id = \"__transition-\" + this._uid + \"-\";\n      child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n      var oldRawChild = this._vnode;\n      var oldChild = getRealChild(oldRawChild); // mark v-show\n      // so that the transition module can hand over the control to the directive\n\n      if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n        child.data.show = true;\n      }\n\n      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {\n        // replace old child transition data with fresh one\n        // important for dynamic transitions!\n        var oldData = oldChild.data.transition = extend({}, data); // handle transition mode\n\n        if (mode === 'out-in') {\n          // return placeholder node and queue update when leave finishes\n          this._leaving = true;\n          mergeVNodeHook(oldData, 'afterLeave', function () {\n            this$1._leaving = false;\n            this$1.$forceUpdate();\n          });\n          return placeholder(h, rawChild);\n        } else if (mode === 'in-out') {\n          if (isAsyncPlaceholder(child)) {\n            return oldRawChild;\n          }\n\n          var delayedLeave;\n\n          var performLeave = function () {\n            delayedLeave();\n          };\n\n          mergeVNodeHook(data, 'afterEnter', performLeave);\n          mergeVNodeHook(data, 'enterCancelled', performLeave);\n          mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n            delayedLeave = leave;\n          });\n        }\n      }\n\n      return rawChild;\n    }\n  };\n  /*  */\n\n  var props = extend({\n    tag: String,\n    moveClass: String\n  }, transitionProps);\n  delete props.mode;\n  var TransitionGroup = {\n    props: props,\n    beforeMount: function beforeMount() {\n      var this$1 = this;\n      var update = this._update;\n\n      this._update = function (vnode, hydrating) {\n        var restoreActiveInstance = setActiveInstance(this$1); // force removing pass\n\n        this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating\n        true // removeOnly (!important, avoids unnecessary moves)\n        );\n\n        this$1._vnode = this$1.kept;\n        restoreActiveInstance();\n        update.call(this$1, vnode, hydrating);\n      };\n    },\n    render: function render(h) {\n      var tag = this.tag || this.$vnode.data.tag || 'span';\n      var map = Object.create(null);\n      var prevChildren = this.prevChildren = this.children;\n      var rawChildren = this.$slots.default || [];\n      var children = this.children = [];\n      var transitionData = extractTransitionData(this);\n\n      for (var i = 0; i < rawChildren.length; i++) {\n        var c = rawChildren[i];\n\n        if (c.tag) {\n          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n            children.push(c);\n            map[c.key] = c;\n            (c.data || (c.data = {})).transition = transitionData;\n          } else {\n            var opts = c.componentOptions;\n            var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n            warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n          }\n        }\n      }\n\n      if (prevChildren) {\n        var kept = [];\n        var removed = [];\n\n        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n          var c$1 = prevChildren[i$1];\n          c$1.data.transition = transitionData;\n          c$1.data.pos = c$1.elm.getBoundingClientRect();\n\n          if (map[c$1.key]) {\n            kept.push(c$1);\n          } else {\n            removed.push(c$1);\n          }\n        }\n\n        this.kept = h(tag, null, kept);\n        this.removed = removed;\n      }\n\n      return h(tag, null, children);\n    },\n    updated: function updated() {\n      var children = this.prevChildren;\n      var moveClass = this.moveClass || (this.name || 'v') + '-move';\n\n      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n        return;\n      } // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n\n\n      children.forEach(callPendingCbs);\n      children.forEach(recordPosition);\n      children.forEach(applyTranslation); // force reflow to put everything in position\n      // assign to this to avoid being removed in tree-shaking\n      // $flow-disable-line\n\n      this._reflow = document.body.offsetHeight;\n      children.forEach(function (c) {\n        if (c.data.moved) {\n          var el = c.elm;\n          var s = el.style;\n          addTransitionClass(el, moveClass);\n          s.transform = s.WebkitTransform = s.transitionDuration = '';\n          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n            if (e && e.target !== el) {\n              return;\n            }\n\n            if (!e || /transform$/.test(e.propertyName)) {\n              el.removeEventListener(transitionEndEvent, cb);\n              el._moveCb = null;\n              removeTransitionClass(el, moveClass);\n            }\n          });\n        }\n      });\n    },\n    methods: {\n      hasMove: function hasMove(el, moveClass) {\n        /* istanbul ignore if */\n        if (!hasTransition) {\n          return false;\n        }\n        /* istanbul ignore if */\n\n\n        if (this._hasMove) {\n          return this._hasMove;\n        } // Detect whether an element with the move class applied has\n        // CSS transitions. Since the element may be inside an entering\n        // transition at this very moment, we make a clone of it and remove\n        // all other transition classes applied to ensure only the move class\n        // is applied.\n\n\n        var clone = el.cloneNode();\n\n        if (el._transitionClasses) {\n          el._transitionClasses.forEach(function (cls) {\n            removeClass(clone, cls);\n          });\n        }\n\n        addClass(clone, moveClass);\n        clone.style.display = 'none';\n        this.$el.appendChild(clone);\n        var info = getTransitionInfo(clone);\n        this.$el.removeChild(clone);\n        return this._hasMove = info.hasTransform;\n      }\n    }\n  };\n\n  function callPendingCbs(c) {\n    /* istanbul ignore if */\n    if (c.elm._moveCb) {\n      c.elm._moveCb();\n    }\n    /* istanbul ignore if */\n\n\n    if (c.elm._enterCb) {\n      c.elm._enterCb();\n    }\n  }\n\n  function recordPosition(c) {\n    c.data.newPos = c.elm.getBoundingClientRect();\n  }\n\n  function applyTranslation(c) {\n    var oldPos = c.data.pos;\n    var newPos = c.data.newPos;\n    var dx = oldPos.left - newPos.left;\n    var dy = oldPos.top - newPos.top;\n\n    if (dx || dy) {\n      c.data.moved = true;\n      var s = c.elm.style;\n      s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n      s.transitionDuration = '0s';\n    }\n  }\n\n  var platformComponents = {\n    Transition: Transition,\n    TransitionGroup: TransitionGroup\n  };\n  /*  */\n  // install platform specific utils\n\n  Vue.config.mustUseProp = mustUseProp;\n  Vue.config.isReservedTag = isReservedTag;\n  Vue.config.isReservedAttr = isReservedAttr;\n  Vue.config.getTagNamespace = getTagNamespace;\n  Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components\n\n  extend(Vue.options.directives, platformDirectives);\n  extend(Vue.options.components, platformComponents); // install platform patch function\n\n  Vue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method\n\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && inBrowser ? query(el) : undefined;\n    return mountComponent(this, el, hydrating);\n  }; // devtools global hook\n\n  /* istanbul ignore next */\n\n\n  if (inBrowser) {\n    setTimeout(function () {\n      if (config.devtools) {\n        if (devtools) {\n          devtools.emit('init', Vue);\n        } else {\n          console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n        }\n      }\n\n      if (config.productionTip !== false && typeof console !== 'undefined') {\n        console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n      }\n    }, 0);\n  }\n  /*  */\n\n\n  var defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n  var buildRegex = cached(function (delimiters) {\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n  });\n\n  function parseText(text, delimiters) {\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n\n    if (!tagRE.test(text)) {\n      return;\n    }\n\n    var tokens = [];\n    var rawTokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match, index, tokenValue;\n\n    while (match = tagRE.exec(text)) {\n      index = match.index; // push text token\n\n      if (index > lastIndex) {\n        rawTokens.push(tokenValue = text.slice(lastIndex, index));\n        tokens.push(JSON.stringify(tokenValue));\n      } // tag token\n\n\n      var exp = parseFilters(match[1].trim());\n      tokens.push(\"_s(\" + exp + \")\");\n      rawTokens.push({\n        '@binding': exp\n      });\n      lastIndex = index + match[0].length;\n    }\n\n    if (lastIndex < text.length) {\n      rawTokens.push(tokenValue = text.slice(lastIndex));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n\n    return {\n      expression: tokens.join('+'),\n      tokens: rawTokens\n    };\n  }\n  /*  */\n\n\n  function transformNode(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticClass = getAndRemoveAttr(el, 'class');\n\n    if (staticClass) {\n      var res = parseText(staticClass, options.delimiters);\n\n      if (res) {\n        warn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.', el.rawAttrsMap['class']);\n      }\n    }\n\n    if (staticClass) {\n      el.staticClass = JSON.stringify(staticClass);\n    }\n\n    var classBinding = getBindingAttr(el, 'class', false\n    /* getStatic */\n    );\n\n    if (classBinding) {\n      el.classBinding = classBinding;\n    }\n  }\n\n  function genData(el) {\n    var data = '';\n\n    if (el.staticClass) {\n      data += \"staticClass:\" + el.staticClass + \",\";\n    }\n\n    if (el.classBinding) {\n      data += \"class:\" + el.classBinding + \",\";\n    }\n\n    return data;\n  }\n\n  var klass$1 = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode,\n    genData: genData\n  };\n  /*  */\n\n  function transformNode$1(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticStyle = getAndRemoveAttr(el, 'style');\n\n    if (staticStyle) {\n      /* istanbul ignore if */\n      {\n        var res = parseText(staticStyle, options.delimiters);\n\n        if (res) {\n          warn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.', el.rawAttrsMap['style']);\n        }\n      }\n      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n    }\n\n    var styleBinding = getBindingAttr(el, 'style', false\n    /* getStatic */\n    );\n\n    if (styleBinding) {\n      el.styleBinding = styleBinding;\n    }\n  }\n\n  function genData$1(el) {\n    var data = '';\n\n    if (el.staticStyle) {\n      data += \"staticStyle:\" + el.staticStyle + \",\";\n    }\n\n    if (el.styleBinding) {\n      data += \"style:(\" + el.styleBinding + \"),\";\n    }\n\n    return data;\n  }\n\n  var style$1 = {\n    staticKeys: ['staticStyle'],\n    transformNode: transformNode$1,\n    genData: genData$1\n  };\n  /*  */\n\n  var decoder;\n  var he = {\n    decode: function decode(html) {\n      decoder = decoder || document.createElement('div');\n      decoder.innerHTML = html;\n      return decoder.textContent;\n    }\n  };\n  /*  */\n\n  var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open\n  // (and which close themselves)\n\n  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n\n  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n  /**\n   * Not type-checking this file because it's mostly vendor code.\n   */\n  // Regular Expressions for parsing tags and attributes\n\n  var attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+?\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + unicodeRegExp.source + \"]*\";\n  var qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\n  var startTagOpen = new RegExp(\"^<\" + qnameCapture);\n  var startTagClose = /^\\s*(\\/?)>/;\n  var endTag = new RegExp(\"^<\\\\/\" + qnameCapture + \"[^>]*>\");\n  var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being passed as HTML comment when inlined in page\n\n  var comment = /^<!\\--/;\n  var conditionalComment = /^<!\\[/; // Special Elements (can contain anything)\n\n  var isPlainTextElement = makeMap('script,style,textarea', true);\n  var reCache = {};\n  var decodingMap = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&amp;': '&',\n    '&#10;': '\\n',\n    '&#9;': '\\t',\n    '&#39;': \"'\"\n  };\n  var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\n  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992\n\n  var isIgnoreNewlineTag = makeMap('pre,textarea', true);\n\n  var shouldIgnoreFirstNewline = function (tag, html) {\n    return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\n  };\n\n  function decodeAttr(value, shouldDecodeNewlines) {\n    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n    return value.replace(re, function (match) {\n      return decodingMap[match];\n    });\n  }\n\n  function parseHTML(html, options) {\n    var stack = [];\n    var expectHTML = options.expectHTML;\n    var isUnaryTag$$1 = options.isUnaryTag || no;\n    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n    var index = 0;\n    var last, lastTag;\n\n    while (html) {\n      last = html; // Make sure we're not in a plaintext content element like script/style\n\n      if (!lastTag || !isPlainTextElement(lastTag)) {\n        var textEnd = html.indexOf('<');\n\n        if (textEnd === 0) {\n          // Comment:\n          if (comment.test(html)) {\n            var commentEnd = html.indexOf('--\x3e');\n\n            if (commentEnd >= 0) {\n              if (options.shouldKeepComment) {\n                options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n              }\n\n              advance(commentEnd + 3);\n              continue;\n            }\n          } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n\n\n          if (conditionalComment.test(html)) {\n            var conditionalEnd = html.indexOf(']>');\n\n            if (conditionalEnd >= 0) {\n              advance(conditionalEnd + 2);\n              continue;\n            }\n          } // Doctype:\n\n\n          var doctypeMatch = html.match(doctype);\n\n          if (doctypeMatch) {\n            advance(doctypeMatch[0].length);\n            continue;\n          } // End tag:\n\n\n          var endTagMatch = html.match(endTag);\n\n          if (endTagMatch) {\n            var curIndex = index;\n            advance(endTagMatch[0].length);\n            parseEndTag(endTagMatch[1], curIndex, index);\n            continue;\n          } // Start tag:\n\n\n          var startTagMatch = parseStartTag();\n\n          if (startTagMatch) {\n            handleStartTag(startTagMatch);\n\n            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n              advance(1);\n            }\n\n            continue;\n          }\n        }\n\n        var text = void 0,\n            rest = void 0,\n            next = void 0;\n\n        if (textEnd >= 0) {\n          rest = html.slice(textEnd);\n\n          while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n            // < in plain text, be forgiving and treat it as text\n            next = rest.indexOf('<', 1);\n\n            if (next < 0) {\n              break;\n            }\n\n            textEnd += next;\n            rest = html.slice(textEnd);\n          }\n\n          text = html.substring(0, textEnd);\n        }\n\n        if (textEnd < 0) {\n          text = html;\n        }\n\n        if (text) {\n          advance(text.length);\n        }\n\n        if (options.chars && text) {\n          options.chars(text, index - text.length, index);\n        }\n      } else {\n        var endTagLength = 0;\n        var stackedTag = lastTag.toLowerCase();\n        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n          endTagLength = endTag.length;\n\n          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n            text = text.replace(/<!\\--([\\s\\S]*?)--\x3e/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n          }\n\n          if (shouldIgnoreFirstNewline(stackedTag, text)) {\n            text = text.slice(1);\n          }\n\n          if (options.chars) {\n            options.chars(text);\n          }\n\n          return '';\n        });\n        index += html.length - rest$1.length;\n        html = rest$1;\n        parseEndTag(stackedTag, index - endTagLength, index);\n      }\n\n      if (html === last) {\n        options.chars && options.chars(html);\n\n        if (!stack.length && options.warn) {\n          options.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\", {\n            start: index + html.length\n          });\n        }\n\n        break;\n      }\n    } // Clean up any remaining tags\n\n\n    parseEndTag();\n\n    function advance(n) {\n      index += n;\n      html = html.substring(n);\n    }\n\n    function parseStartTag() {\n      var start = html.match(startTagOpen);\n\n      if (start) {\n        var match = {\n          tagName: start[1],\n          attrs: [],\n          start: index\n        };\n        advance(start[0].length);\n        var end, attr;\n\n        while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n          attr.start = index;\n          advance(attr[0].length);\n          attr.end = index;\n          match.attrs.push(attr);\n        }\n\n        if (end) {\n          match.unarySlash = end[1];\n          advance(end[0].length);\n          match.end = index;\n          return match;\n        }\n      }\n    }\n\n    function handleStartTag(match) {\n      var tagName = match.tagName;\n      var unarySlash = match.unarySlash;\n\n      if (expectHTML) {\n        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n          parseEndTag(lastTag);\n        }\n\n        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n          parseEndTag(tagName);\n        }\n      }\n\n      var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n      var l = match.attrs.length;\n      var attrs = new Array(l);\n\n      for (var i = 0; i < l; i++) {\n        var args = match.attrs[i];\n        var value = args[3] || args[4] || args[5] || '';\n        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;\n        attrs[i] = {\n          name: args[1],\n          value: decodeAttr(value, shouldDecodeNewlines)\n        };\n\n        if (options.outputSourceRange) {\n          attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n          attrs[i].end = args.end;\n        }\n      }\n\n      if (!unary) {\n        stack.push({\n          tag: tagName,\n          lowerCasedTag: tagName.toLowerCase(),\n          attrs: attrs,\n          start: match.start,\n          end: match.end\n        });\n        lastTag = tagName;\n      }\n\n      if (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n      }\n    }\n\n    function parseEndTag(tagName, start, end) {\n      var pos, lowerCasedTagName;\n\n      if (start == null) {\n        start = index;\n      }\n\n      if (end == null) {\n        end = index;\n      } // Find the closest opened tag of the same type\n\n\n      if (tagName) {\n        lowerCasedTagName = tagName.toLowerCase();\n\n        for (pos = stack.length - 1; pos >= 0; pos--) {\n          if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n            break;\n          }\n        }\n      } else {\n        // If no tag name is provided, clean shop\n        pos = 0;\n      }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (var i = stack.length - 1; i >= pos; i--) {\n          if (i > pos || !tagName && options.warn) {\n            options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\", {\n              start: stack[i].start,\n              end: stack[i].end\n            });\n          }\n\n          if (options.end) {\n            options.end(stack[i].tag, start, end);\n          }\n        } // Remove the open elements from the stack\n\n\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (lowerCasedTagName === 'br') {\n        if (options.start) {\n          options.start(tagName, [], true, start, end);\n        }\n      } else if (lowerCasedTagName === 'p') {\n        if (options.start) {\n          options.start(tagName, [], false, start, end);\n        }\n\n        if (options.end) {\n          options.end(tagName, start, end);\n        }\n      }\n    }\n  }\n  /*  */\n\n\n  var onRE = /^@|^v-on:/;\n  var dirRE = /^v-|^@|^:|^#/;\n  var forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  var forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  var stripParensRE = /^\\(|\\)$/g;\n  var dynamicArgRE = /^\\[.*\\]$/;\n  var argRE = /:(.*)$/;\n  var bindRE = /^:|^\\.|^v-bind:/;\n  var modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n  var slotRE = /^v-slot(:|$)|^#/;\n  var lineBreakRE = /[\\r\\n]/;\n  var whitespaceRE$1 = /[ \\f\\t\\r\\n]+/g;\n  var invalidAttributeRE = /[\\s\"'<>\\/=]/;\n  var decodeHTMLCached = cached(he.decode);\n  var emptySlotScopeToken = \"_empty_\"; // configurable state\n\n  var warn$2;\n  var delimiters;\n  var transforms;\n  var preTransforms;\n  var postTransforms;\n  var platformIsPreTag;\n  var platformMustUseProp;\n  var platformGetTagNamespace;\n  var maybeComponent;\n\n  function createASTElement(tag, attrs, parent) {\n    return {\n      type: 1,\n      tag: tag,\n      attrsList: attrs,\n      attrsMap: makeAttrsMap(attrs),\n      rawAttrsMap: {},\n      parent: parent,\n      children: []\n    };\n  }\n  /**\n   * Convert HTML string to AST.\n   */\n\n\n  function parse(template, options) {\n    warn$2 = options.warn || baseWarn;\n    platformIsPreTag = options.isPreTag || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformGetTagNamespace = options.getTagNamespace || no;\n    var isReservedTag = options.isReservedTag || no;\n\n    maybeComponent = function (el) {\n      return !!(el.component || el.attrsMap[':is'] || el.attrsMap['v-bind:is'] || !(el.attrsMap.is ? isReservedTag(el.attrsMap.is) : isReservedTag(el.tag)));\n    };\n\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n    delimiters = options.delimiters;\n    var stack = [];\n    var preserveWhitespace = options.preserveWhitespace !== false;\n    var whitespaceOption = options.whitespace;\n    var root;\n    var currentParent;\n    var inVPre = false;\n    var inPre = false;\n    var warned = false;\n\n    function warnOnce(msg, range) {\n      if (!warned) {\n        warned = true;\n        warn$2(msg, range);\n      }\n    }\n\n    function closeElement(element) {\n      trimEndingWhitespace(element);\n\n      if (!inVPre && !element.processed) {\n        element = processElement(element, options);\n      } // tree management\n\n\n      if (!stack.length && element !== root) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          {\n            checkRootConstraints(element);\n          }\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else {\n          warnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\", {\n            start: element.start\n          });\n        }\n      }\n\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else {\n          if (element.slotScope) {\n            // scoped slot\n            // keep it in the children list so that v-else(-if) conditions can\n            // find it as the prev node.\n            var name = element.slotTarget || '\"default\"';\n            (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n          }\n\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      } // final children cleanup\n      // filter out scoped slots\n\n\n      element.children = element.children.filter(function (c) {\n        return !c.slotScope;\n      }); // remove trailing whitespace node again\n\n      trimEndingWhitespace(element); // check pre state\n\n      if (element.pre) {\n        inVPre = false;\n      }\n\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      } // apply post-transforms\n\n\n      for (var i = 0; i < postTransforms.length; i++) {\n        postTransforms[i](element, options);\n      }\n    }\n\n    function trimEndingWhitespace(el) {\n      // remove trailing whitespace node\n      if (!inPre) {\n        var lastNode;\n\n        while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {\n          el.children.pop();\n        }\n      }\n    }\n\n    function checkRootConstraints(el) {\n      if (el.tag === 'slot' || el.tag === 'template') {\n        warnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.', {\n          start: el.start\n        });\n      }\n\n      if (el.attrsMap.hasOwnProperty('v-for')) {\n        warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);\n      }\n    }\n\n    parseHTML(template, {\n      warn: warn$2,\n      expectHTML: options.expectHTML,\n      isUnaryTag: options.isUnaryTag,\n      canBeLeftOpenTag: options.canBeLeftOpenTag,\n      shouldDecodeNewlines: options.shouldDecodeNewlines,\n      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n      shouldKeepComment: options.comments,\n      outputSourceRange: options.outputSourceRange,\n      start: function start(tag, attrs, unary, start$1, end) {\n        // check namespace.\n        // inherit parent ns if there is one\n        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug\n\n        /* istanbul ignore if */\n\n        if (isIE && ns === 'svg') {\n          attrs = guardIESVGBug(attrs);\n        }\n\n        var element = createASTElement(tag, attrs, currentParent);\n\n        if (ns) {\n          element.ns = ns;\n        }\n\n        {\n          if (options.outputSourceRange) {\n            element.start = start$1;\n            element.end = end;\n            element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n              cumulated[attr.name] = attr;\n              return cumulated;\n            }, {});\n          }\n\n          attrs.forEach(function (attr) {\n            if (invalidAttributeRE.test(attr.name)) {\n              warn$2(\"Invalid dynamic argument expression: attribute names cannot contain \" + \"spaces, quotes, <, >, / or =.\", {\n                start: attr.start + attr.name.indexOf(\"[\"),\n                end: attr.start + attr.name.length\n              });\n            }\n          });\n        }\n\n        if (isForbiddenTag(element) && !isServerRendering()) {\n          element.forbidden = true;\n          warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.', {\n            start: element.start\n          });\n        } // apply pre-transforms\n\n\n        for (var i = 0; i < preTransforms.length; i++) {\n          element = preTransforms[i](element, options) || element;\n        }\n\n        if (!inVPre) {\n          processPre(element);\n\n          if (element.pre) {\n            inVPre = true;\n          }\n        }\n\n        if (platformIsPreTag(element.tag)) {\n          inPre = true;\n        }\n\n        if (inVPre) {\n          processRawAttrs(element);\n        } else if (!element.processed) {\n          // structural directives\n          processFor(element);\n          processIf(element);\n          processOnce(element);\n        }\n\n        if (!root) {\n          root = element;\n          {\n            checkRootConstraints(root);\n          }\n        }\n\n        if (!unary) {\n          currentParent = element;\n          stack.push(element);\n        } else {\n          closeElement(element);\n        }\n      },\n      end: function end(tag, start, end$1) {\n        var element = stack[stack.length - 1]; // pop stack\n\n        stack.length -= 1;\n        currentParent = stack[stack.length - 1];\n\n        if (options.outputSourceRange) {\n          element.end = end$1;\n        }\n\n        closeElement(element);\n      },\n      chars: function chars(text, start, end) {\n        if (!currentParent) {\n          {\n            if (text === template) {\n              warnOnce('Component template requires a root element, rather than just text.', {\n                start: start\n              });\n            } else if (text = text.trim()) {\n              warnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\", {\n                start: start\n              });\n            }\n          }\n          return;\n        } // IE textarea placeholder bug\n\n        /* istanbul ignore if */\n\n\n        if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n          return;\n        }\n\n        var children = currentParent.children;\n\n        if (inPre || text.trim()) {\n          text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n        } else if (!children.length) {\n          // remove the whitespace-only node right after an opening tag\n          text = '';\n        } else if (whitespaceOption) {\n          if (whitespaceOption === 'condense') {\n            // in condense mode, remove the whitespace node if it contains\n            // line break, otherwise condense to a single space\n            text = lineBreakRE.test(text) ? '' : ' ';\n          } else {\n            text = ' ';\n          }\n        } else {\n          text = preserveWhitespace ? ' ' : '';\n        }\n\n        if (text) {\n          if (!inPre && whitespaceOption === 'condense') {\n            // condense consecutive whitespaces into single space\n            text = text.replace(whitespaceRE$1, ' ');\n          }\n\n          var res;\n          var child;\n\n          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n            child = {\n              type: 2,\n              expression: res.expression,\n              tokens: res.tokens,\n              text: text\n            };\n          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n            child = {\n              type: 3,\n              text: text\n            };\n          }\n\n          if (child) {\n            if (options.outputSourceRange) {\n              child.start = start;\n              child.end = end;\n            }\n\n            children.push(child);\n          }\n        }\n      },\n      comment: function comment(text, start, end) {\n        // adding anything as a sibling to the root node is forbidden\n        // comments should still be allowed, but ignored\n        if (currentParent) {\n          var child = {\n            type: 3,\n            text: text,\n            isComment: true\n          };\n\n          if (options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n\n          currentParent.children.push(child);\n        }\n      }\n    });\n    return root;\n  }\n\n  function processPre(el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n      el.pre = true;\n    }\n  }\n\n  function processRawAttrs(el) {\n    var list = el.attrsList;\n    var len = list.length;\n\n    if (len) {\n      var attrs = el.attrs = new Array(len);\n\n      for (var i = 0; i < len; i++) {\n        attrs[i] = {\n          name: list[i].name,\n          value: JSON.stringify(list[i].value)\n        };\n\n        if (list[i].start != null) {\n          attrs[i].start = list[i].start;\n          attrs[i].end = list[i].end;\n        }\n      }\n    } else if (!el.pre) {\n      // non root node in pre blocks with no attributes\n      el.plain = true;\n    }\n  }\n\n  function processElement(element, options) {\n    processKey(element); // determine whether this is a plain element after\n    // removing structural attributes\n\n    element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;\n    processRef(element);\n    processSlotContent(element);\n    processSlotOutlet(element);\n    processComponent(element);\n\n    for (var i = 0; i < transforms.length; i++) {\n      element = transforms[i](element, options) || element;\n    }\n\n    processAttrs(element);\n    return element;\n  }\n\n  function processKey(el) {\n    var exp = getBindingAttr(el, 'key');\n\n    if (exp) {\n      {\n        if (el.tag === 'template') {\n          warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\", getRawBindingAttr(el, 'key'));\n        }\n\n        if (el.for) {\n          var iterator = el.iterator2 || el.iterator1;\n          var parent = el.parent;\n\n          if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n            warn$2(\"Do not use v-for index as key on <transition-group> children, \" + \"this is the same as not using keys.\", getRawBindingAttr(el, 'key'), true\n            /* tip */\n            );\n          }\n        }\n      }\n      el.key = exp;\n    }\n  }\n\n  function processRef(el) {\n    var ref = getBindingAttr(el, 'ref');\n\n    if (ref) {\n      el.ref = ref;\n      el.refInFor = checkInFor(el);\n    }\n  }\n\n  function processFor(el) {\n    var exp;\n\n    if (exp = getAndRemoveAttr(el, 'v-for')) {\n      var res = parseFor(exp);\n\n      if (res) {\n        extend(el, res);\n      } else {\n        warn$2(\"Invalid v-for expression: \" + exp, el.rawAttrsMap['v-for']);\n      }\n    }\n  }\n\n  function parseFor(exp) {\n    var inMatch = exp.match(forAliasRE);\n\n    if (!inMatch) {\n      return;\n    }\n\n    var res = {};\n    res.for = inMatch[2].trim();\n    var alias = inMatch[1].trim().replace(stripParensRE, '');\n    var iteratorMatch = alias.match(forIteratorRE);\n\n    if (iteratorMatch) {\n      res.alias = alias.replace(forIteratorRE, '').trim();\n      res.iterator1 = iteratorMatch[1].trim();\n\n      if (iteratorMatch[2]) {\n        res.iterator2 = iteratorMatch[2].trim();\n      }\n    } else {\n      res.alias = alias;\n    }\n\n    return res;\n  }\n\n  function processIf(el) {\n    var exp = getAndRemoveAttr(el, 'v-if');\n\n    if (exp) {\n      el.if = exp;\n      addIfCondition(el, {\n        exp: exp,\n        block: el\n      });\n    } else {\n      if (getAndRemoveAttr(el, 'v-else') != null) {\n        el.else = true;\n      }\n\n      var elseif = getAndRemoveAttr(el, 'v-else-if');\n\n      if (elseif) {\n        el.elseif = elseif;\n      }\n    }\n  }\n\n  function processIfConditions(el, parent) {\n    var prev = findPrevElement(parent.children);\n\n    if (prev && prev.if) {\n      addIfCondition(prev, {\n        exp: el.elseif,\n        block: el\n      });\n    } else {\n      warn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);\n    }\n  }\n\n  function findPrevElement(children) {\n    var i = children.length;\n\n    while (i--) {\n      if (children[i].type === 1) {\n        return children[i];\n      } else {\n        if (children[i].text !== ' ') {\n          warn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\", children[i]);\n        }\n\n        children.pop();\n      }\n    }\n  }\n\n  function addIfCondition(el, condition) {\n    if (!el.ifConditions) {\n      el.ifConditions = [];\n    }\n\n    el.ifConditions.push(condition);\n  }\n\n  function processOnce(el) {\n    var once$$1 = getAndRemoveAttr(el, 'v-once');\n\n    if (once$$1 != null) {\n      el.once = true;\n    }\n  } // handle content being passed to a component as slot,\n  // e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\n\n\n  function processSlotContent(el) {\n    var slotScope;\n\n    if (el.tag === 'template') {\n      slotScope = getAndRemoveAttr(el, 'scope');\n      /* istanbul ignore if */\n\n      if (slotScope) {\n        warn$2(\"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" + \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" + \"can also be used on plain elements in addition to <template> to \" + \"denote scoped slots.\", el.rawAttrsMap['scope'], true);\n      }\n\n      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {\n      /* istanbul ignore if */\n      if (el.attrsMap['v-for']) {\n        warn$2(\"Ambiguous combined usage of slot-scope and v-for on <\" + el.tag + \"> \" + \"(v-for takes higher priority). Use a wrapper <template> for the \" + \"scoped slot to make it clearer.\", el.rawAttrsMap['slot-scope'], true);\n      }\n\n      el.slotScope = slotScope;\n    } // slot=\"xxx\"\n\n\n    var slotTarget = getBindingAttr(el, 'slot');\n\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n      el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat\n      // only for non-scoped slots.\n\n      if (el.tag !== 'template' && !el.slotScope) {\n        addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n      }\n    } // 2.6 v-slot syntax\n\n\n    {\n      if (el.tag === 'template') {\n        // v-slot on <template>\n        var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n\n        if (slotBinding) {\n          {\n            if (el.slotTarget || el.slotScope) {\n              warn$2(\"Unexpected mixed usage of different slot syntaxes.\", el);\n            }\n\n            if (el.parent && !maybeComponent(el.parent)) {\n              warn$2(\"<template v-slot> can only appear at the root level inside \" + \"the receiving component\", el);\n            }\n          }\n          var ref = getSlotName(slotBinding);\n          var name = ref.name;\n          var dynamic = ref.dynamic;\n          el.slotTarget = name;\n          el.slotTargetDynamic = dynamic;\n          el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n        }\n      } else {\n        // v-slot on component, denotes default slot\n        var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n\n        if (slotBinding$1) {\n          {\n            if (!maybeComponent(el)) {\n              warn$2(\"v-slot can only be used on components or <template>.\", slotBinding$1);\n            }\n\n            if (el.slotScope || el.slotTarget) {\n              warn$2(\"Unexpected mixed usage of different slot syntaxes.\", el);\n            }\n\n            if (el.scopedSlots) {\n              warn$2(\"To avoid scope ambiguity, the default slot should also use \" + \"<template> syntax when there are other named slots.\", slotBinding$1);\n            }\n          } // add the component's children to its default slot\n\n          var slots = el.scopedSlots || (el.scopedSlots = {});\n          var ref$1 = getSlotName(slotBinding$1);\n          var name$1 = ref$1.name;\n          var dynamic$1 = ref$1.dynamic;\n          var slotContainer = slots[name$1] = createASTElement('template', [], el);\n          slotContainer.slotTarget = name$1;\n          slotContainer.slotTargetDynamic = dynamic$1;\n          slotContainer.children = el.children.filter(function (c) {\n            if (!c.slotScope) {\n              c.parent = slotContainer;\n              return true;\n            }\n          });\n          slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now\n\n          el.children = []; // mark el non-plain so data gets generated\n\n          el.plain = false;\n        }\n      }\n    }\n  }\n\n  function getSlotName(binding) {\n    var name = binding.name.replace(slotRE, '');\n\n    if (!name) {\n      if (binding.name[0] !== '#') {\n        name = 'default';\n      } else {\n        warn$2(\"v-slot shorthand syntax requires a slot name.\", binding);\n      }\n    }\n\n    return dynamicArgRE.test(name) // dynamic [name]\n    ? {\n      name: name.slice(1, -1),\n      dynamic: true\n    } // static name\n    : {\n      name: \"\\\"\" + name + \"\\\"\",\n      dynamic: false\n    };\n  } // handle <slot/> outlets\n\n\n  function processSlotOutlet(el) {\n    if (el.tag === 'slot') {\n      el.slotName = getBindingAttr(el, 'name');\n\n      if (el.key) {\n        warn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\", getRawBindingAttr(el, 'key'));\n      }\n    }\n  }\n\n  function processComponent(el) {\n    var binding;\n\n    if (binding = getBindingAttr(el, 'is')) {\n      el.component = binding;\n    }\n\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n      el.inlineTemplate = true;\n    }\n  }\n\n  function processAttrs(el) {\n    var list = el.attrsList;\n    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n\n    for (i = 0, l = list.length; i < l; i++) {\n      name = rawName = list[i].name;\n      value = list[i].value;\n\n      if (dirRE.test(name)) {\n        // mark element as dynamic\n        el.hasBindings = true; // modifiers\n\n        modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier\n\n        if (modifiers) {\n          name = name.replace(modifierRE, '');\n        }\n\n        if (bindRE.test(name)) {\n          // v-bind\n          name = name.replace(bindRE, '');\n          value = parseFilters(value);\n          isDynamic = dynamicArgRE.test(name);\n\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n\n          if (value.trim().length === 0) {\n            warn$2(\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\");\n          }\n\n          if (modifiers) {\n            if (modifiers.prop && !isDynamic) {\n              name = camelize(name);\n\n              if (name === 'innerHtml') {\n                name = 'innerHTML';\n              }\n            }\n\n            if (modifiers.camel && !isDynamic) {\n              name = camelize(name);\n            }\n\n            if (modifiers.sync) {\n              syncGen = genAssignmentCode(value, \"$event\");\n\n              if (!isDynamic) {\n                addHandler(el, \"update:\" + camelize(name), syncGen, null, false, warn$2, list[i]);\n\n                if (hyphenate(name) !== camelize(name)) {\n                  addHandler(el, \"update:\" + hyphenate(name), syncGen, null, false, warn$2, list[i]);\n                }\n              } else {\n                // handler w/ dynamic event name\n                addHandler(el, \"\\\"update:\\\"+(\" + name + \")\", syncGen, null, false, warn$2, list[i], true // dynamic\n                );\n              }\n            }\n          }\n\n          if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n            addProp(el, name, value, list[i], isDynamic);\n          } else {\n            addAttr(el, name, value, list[i], isDynamic);\n          }\n        } else if (onRE.test(name)) {\n          // v-on\n          name = name.replace(onRE, '');\n          isDynamic = dynamicArgRE.test(name);\n\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n\n          addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n        } else {\n          // normal directives\n          name = name.replace(dirRE, ''); // parse arg\n\n          var argMatch = name.match(argRE);\n          var arg = argMatch && argMatch[1];\n          isDynamic = false;\n\n          if (arg) {\n            name = name.slice(0, -(arg.length + 1));\n\n            if (dynamicArgRE.test(arg)) {\n              arg = arg.slice(1, -1);\n              isDynamic = true;\n            }\n          }\n\n          addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n\n          if (name === 'model') {\n            checkForAliasModel(el, value);\n          }\n        }\n      } else {\n        // literal attribute\n        {\n          var res = parseText(value, delimiters);\n\n          if (res) {\n            warn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.', list[i]);\n          }\n        }\n        addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute\n        // even immediately after element creation\n\n        if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, 'true', list[i]);\n        }\n      }\n    }\n  }\n\n  function checkInFor(el) {\n    var parent = el;\n\n    while (parent) {\n      if (parent.for !== undefined) {\n        return true;\n      }\n\n      parent = parent.parent;\n    }\n\n    return false;\n  }\n\n  function parseModifiers(name) {\n    var match = name.match(modifierRE);\n\n    if (match) {\n      var ret = {};\n      match.forEach(function (m) {\n        ret[m.slice(1)] = true;\n      });\n      return ret;\n    }\n  }\n\n  function makeAttrsMap(attrs) {\n    var map = {};\n\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      if (map[attrs[i].name] && !isIE && !isEdge) {\n        warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n      }\n\n      map[attrs[i].name] = attrs[i].value;\n    }\n\n    return map;\n  } // for script (e.g. type=\"x/template\") or style, do not decode content\n\n\n  function isTextTag(el) {\n    return el.tag === 'script' || el.tag === 'style';\n  }\n\n  function isForbiddenTag(el) {\n    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n  }\n\n  var ieNSBug = /^xmlns:NS\\d+/;\n  var ieNSPrefix = /^NS\\d+:/;\n  /* istanbul ignore next */\n\n  function guardIESVGBug(attrs) {\n    var res = [];\n\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n\n      if (!ieNSBug.test(attr.name)) {\n        attr.name = attr.name.replace(ieNSPrefix, '');\n        res.push(attr);\n      }\n    }\n\n    return res;\n  }\n\n  function checkForAliasModel(el, value) {\n    var _el = el;\n\n    while (_el) {\n      if (_el.for && _el.alias === value) {\n        warn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\", el.rawAttrsMap['v-model']);\n      }\n\n      _el = _el.parent;\n    }\n  }\n  /*  */\n\n\n  function preTransformNode(el, options) {\n    if (el.tag === 'input') {\n      var map = el.attrsMap;\n\n      if (!map['v-model']) {\n        return;\n      }\n\n      var typeBinding;\n\n      if (map[':type'] || map['v-bind:type']) {\n        typeBinding = getBindingAttr(el, 'type');\n      }\n\n      if (!map.type && !typeBinding && map['v-bind']) {\n        typeBinding = \"(\" + map['v-bind'] + \").type\";\n      }\n\n      if (typeBinding) {\n        var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n        var ifConditionExtra = ifCondition ? \"&&(\" + ifCondition + \")\" : \"\";\n        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox\n\n        var branch0 = cloneASTElement(el); // process for on the main node\n\n        processFor(branch0);\n        addRawAttr(branch0, 'type', 'checkbox');\n        processElement(branch0, options);\n        branch0.processed = true; // prevent it from double-processed\n\n        branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n        addIfCondition(branch0, {\n          exp: branch0.if,\n          block: branch0\n        }); // 2. add radio else-if condition\n\n        var branch1 = cloneASTElement(el);\n        getAndRemoveAttr(branch1, 'v-for', true);\n        addRawAttr(branch1, 'type', 'radio');\n        processElement(branch1, options);\n        addIfCondition(branch0, {\n          exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n          block: branch1\n        }); // 3. other\n\n        var branch2 = cloneASTElement(el);\n        getAndRemoveAttr(branch2, 'v-for', true);\n        addRawAttr(branch2, ':type', typeBinding);\n        processElement(branch2, options);\n        addIfCondition(branch0, {\n          exp: ifCondition,\n          block: branch2\n        });\n\n        if (hasElse) {\n          branch0.else = true;\n        } else if (elseIfCondition) {\n          branch0.elseif = elseIfCondition;\n        }\n\n        return branch0;\n      }\n    }\n  }\n\n  function cloneASTElement(el) {\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent);\n  }\n\n  var model$1 = {\n    preTransformNode: preTransformNode\n  };\n  var modules$1 = [klass$1, style$1, model$1];\n  /*  */\n\n  function text(el, dir) {\n    if (dir.value) {\n      addProp(el, 'textContent', \"_s(\" + dir.value + \")\", dir);\n    }\n  }\n  /*  */\n\n\n  function html(el, dir) {\n    if (dir.value) {\n      addProp(el, 'innerHTML', \"_s(\" + dir.value + \")\", dir);\n    }\n  }\n\n  var directives$1 = {\n    model: model,\n    text: text,\n    html: html\n  };\n  /*  */\n\n  var baseOptions = {\n    expectHTML: true,\n    modules: modules$1,\n    directives: directives$1,\n    isPreTag: isPreTag,\n    isUnaryTag: isUnaryTag,\n    mustUseProp: mustUseProp,\n    canBeLeftOpenTag: canBeLeftOpenTag,\n    isReservedTag: isReservedTag,\n    getTagNamespace: getTagNamespace,\n    staticKeys: genStaticKeys(modules$1)\n  };\n  /*  */\n\n  var isStaticKey;\n  var isPlatformReservedTag;\n  var genStaticKeysCached = cached(genStaticKeys$1);\n  /**\n   * Goal of the optimizer: walk the generated template AST tree\n   * and detect sub-trees that are purely static, i.e. parts of\n   * the DOM that never needs to change.\n   *\n   * Once we detect these sub-trees, we can:\n   *\n   * 1. Hoist them into constants, so that we no longer need to\n   *    create fresh nodes for them on each re-render;\n   * 2. Completely skip them in the patching process.\n   */\n\n  function optimize(root, options) {\n    if (!root) {\n      return;\n    }\n\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.\n\n    markStatic$1(root); // second pass: mark static roots.\n\n    markStaticRoots(root, false);\n  }\n\n  function genStaticKeys$1(keys) {\n    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));\n  }\n\n  function markStatic$1(node) {\n    node.static = isStatic(node);\n\n    if (node.type === 1) {\n      // do not make component slot content static. this avoids\n      // 1. components not able to mutate slot nodes\n      // 2. static slot content fails for hot-reloading\n      if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n        return;\n      }\n\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        var child = node.children[i];\n        markStatic$1(child);\n\n        if (!child.static) {\n          node.static = false;\n        }\n      }\n\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          var block = node.ifConditions[i$1].block;\n          markStatic$1(block);\n\n          if (!block.static) {\n            node.static = false;\n          }\n        }\n      }\n    }\n  }\n\n  function markStaticRoots(node, isInFor) {\n    if (node.type === 1) {\n      if (node.static || node.once) {\n        node.staticInFor = isInFor;\n      } // For a node to qualify as a static root, it should have children that\n      // are not just static text. Otherwise the cost of hoisting out will\n      // outweigh the benefits and it's better off to just always render it fresh.\n\n\n      if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n        node.staticRoot = true;\n        return;\n      } else {\n        node.staticRoot = false;\n      }\n\n      if (node.children) {\n        for (var i = 0, l = node.children.length; i < l; i++) {\n          markStaticRoots(node.children[i], isInFor || !!node.for);\n        }\n      }\n\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          markStaticRoots(node.ifConditions[i$1].block, isInFor);\n        }\n      }\n    }\n  }\n\n  function isStatic(node) {\n    if (node.type === 2) {\n      // expression\n      return false;\n    }\n\n    if (node.type === 3) {\n      // text\n      return true;\n    }\n\n    return !!(node.pre || !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n  }\n\n  function isDirectChildOfTemplateFor(node) {\n    while (node.parent) {\n      node = node.parent;\n\n      if (node.tag !== 'template') {\n        return false;\n      }\n\n      if (node.for) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /*  */\n\n\n  var fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function(?:\\s+[\\w$]+)?\\s*\\(/;\n  var fnInvokeRE = /\\([^)]*?\\);*$/;\n  var simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/; // KeyboardEvent.keyCode aliases\n\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    'delete': [8, 46]\n  }; // KeyboardEvent.key aliases\n\n  var keyNames = {\n    // #7880: IE11 and Edge use `Esc` for Escape key name.\n    esc: ['Esc', 'Escape'],\n    tab: 'Tab',\n    enter: 'Enter',\n    // #9112: IE11 uses `Spacebar` for Space key name.\n    space: [' ', 'Spacebar'],\n    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n    up: ['Up', 'ArrowUp'],\n    left: ['Left', 'ArrowLeft'],\n    right: ['Right', 'ArrowRight'],\n    down: ['Down', 'ArrowDown'],\n    // #9112: IE11 uses `Del` for Delete key name.\n    'delete': ['Backspace', 'Delete', 'Del']\n  }; // #4868: modifiers that prevent the execution of the listener\n  // need to explicitly return null so that we can determine whether to remove\n  // the listener for .once\n\n  var genGuard = function (condition) {\n    return \"if(\" + condition + \")return null;\";\n  };\n\n  var modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: genGuard(\"$event.target !== $event.currentTarget\"),\n    ctrl: genGuard(\"!$event.ctrlKey\"),\n    shift: genGuard(\"!$event.shiftKey\"),\n    alt: genGuard(\"!$event.altKey\"),\n    meta: genGuard(\"!$event.metaKey\"),\n    left: genGuard(\"'button' in $event && $event.button !== 0\"),\n    middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n    right: genGuard(\"'button' in $event && $event.button !== 2\")\n  };\n\n  function genHandlers(events, isNative) {\n    var prefix = isNative ? 'nativeOn:' : 'on:';\n    var staticHandlers = \"\";\n    var dynamicHandlers = \"\";\n\n    for (var name in events) {\n      var handlerCode = genHandler(events[name]);\n\n      if (events[name] && events[name].dynamic) {\n        dynamicHandlers += name + \",\" + handlerCode + \",\";\n      } else {\n        staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n      }\n    }\n\n    staticHandlers = \"{\" + staticHandlers.slice(0, -1) + \"}\";\n\n    if (dynamicHandlers) {\n      return prefix + \"_d(\" + staticHandlers + \",[\" + dynamicHandlers.slice(0, -1) + \"])\";\n    } else {\n      return prefix + staticHandlers;\n    }\n  }\n\n  function genHandler(handler) {\n    if (!handler) {\n      return 'function(){}';\n    }\n\n    if (Array.isArray(handler)) {\n      return \"[\" + handler.map(function (handler) {\n        return genHandler(handler);\n      }).join(',') + \"]\";\n    }\n\n    var isMethodPath = simplePathRE.test(handler.value);\n    var isFunctionExpression = fnExpRE.test(handler.value);\n    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n    if (!handler.modifiers) {\n      if (isMethodPath || isFunctionExpression) {\n        return handler.value;\n      }\n\n      return \"function($event){\" + (isFunctionInvocation ? \"return \" + handler.value : handler.value) + \"}\"; // inline statement\n    } else {\n      var code = '';\n      var genModifierCode = '';\n      var keys = [];\n\n      for (var key in handler.modifiers) {\n        if (modifierCode[key]) {\n          genModifierCode += modifierCode[key]; // left/right\n\n          if (keyCodes[key]) {\n            keys.push(key);\n          }\n        } else if (key === 'exact') {\n          var modifiers = handler.modifiers;\n          genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {\n            return !modifiers[keyModifier];\n          }).map(function (keyModifier) {\n            return \"$event.\" + keyModifier + \"Key\";\n          }).join('||'));\n        } else {\n          keys.push(key);\n        }\n      }\n\n      if (keys.length) {\n        code += genKeyFilter(keys);\n      } // Make sure modifiers like prevent and stop get executed after key filtering\n\n\n      if (genModifierCode) {\n        code += genModifierCode;\n      }\n\n      var handlerCode = isMethodPath ? \"return \" + handler.value + \".apply(null, arguments)\" : isFunctionExpression ? \"return (\" + handler.value + \").apply(null, arguments)\" : isFunctionInvocation ? \"return \" + handler.value : handler.value;\n      return \"function($event){\" + code + handlerCode + \"}\";\n    }\n  }\n\n  function genKeyFilter(keys) {\n    return (// make sure the key filters only apply to KeyboardEvents\n      // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n      // key events that do not have keyCode property...\n      \"if(!$event.type.indexOf('key')&&\" + keys.map(genFilterCode).join('&&') + \")return null;\"\n    );\n  }\n\n  function genFilterCode(key) {\n    var keyVal = parseInt(key, 10);\n\n    if (keyVal) {\n      return \"$event.keyCode!==\" + keyVal;\n    }\n\n    var keyCode = keyCodes[key];\n    var keyName = keyNames[key];\n    return \"_k($event.keyCode,\" + JSON.stringify(key) + \",\" + JSON.stringify(keyCode) + \",\" + \"$event.key,\" + \"\" + JSON.stringify(keyName) + \")\";\n  }\n  /*  */\n\n\n  function on(el, dir) {\n    if (dir.modifiers) {\n      warn(\"v-on without argument does not support modifiers.\");\n    }\n\n    el.wrapListeners = function (code) {\n      return \"_g(\" + code + \",\" + dir.value + \")\";\n    };\n  }\n  /*  */\n\n\n  function bind$1(el, dir) {\n    el.wrapData = function (code) {\n      return \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\";\n    };\n  }\n  /*  */\n\n\n  var baseDirectives = {\n    on: on,\n    bind: bind$1,\n    cloak: noop\n  };\n  /*  */\n\n  var CodegenState = function CodegenState(options) {\n    this.options = options;\n    this.warn = options.warn || baseWarn;\n    this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n    this.directives = extend(extend({}, baseDirectives), options.directives);\n    var isReservedTag = options.isReservedTag || no;\n\n    this.maybeComponent = function (el) {\n      return !!el.component || !isReservedTag(el.tag);\n    };\n\n    this.onceId = 0;\n    this.staticRenderFns = [];\n    this.pre = false;\n  };\n\n  function generate(ast, options) {\n    var state = new CodegenState(options); // fix #11483, Root level <script> tags should not be rendered.\n\n    var code = ast ? ast.tag === 'script' ? 'null' : genElement(ast, state) : '_c(\"div\")';\n    return {\n      render: \"with(this){return \" + code + \"}\",\n      staticRenderFns: state.staticRenderFns\n    };\n  }\n\n  function genElement(el, state) {\n    if (el.parent) {\n      el.pre = el.pre || el.parent.pre;\n    }\n\n    if (el.staticRoot && !el.staticProcessed) {\n      return genStatic(el, state);\n    } else if (el.once && !el.onceProcessed) {\n      return genOnce(el, state);\n    } else if (el.for && !el.forProcessed) {\n      return genFor(el, state);\n    } else if (el.if && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n      return genChildren(el, state) || 'void 0';\n    } else if (el.tag === 'slot') {\n      return genSlot(el, state);\n    } else {\n      // component or element\n      var code;\n\n      if (el.component) {\n        code = genComponent(el.component, el, state);\n      } else {\n        var data;\n\n        if (!el.plain || el.pre && state.maybeComponent(el)) {\n          data = genData$2(el, state);\n        }\n\n        var children = el.inlineTemplate ? null : genChildren(el, state, true);\n        code = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n      } // module transforms\n\n\n      for (var i = 0; i < state.transforms.length; i++) {\n        code = state.transforms[i](el, code);\n      }\n\n      return code;\n    }\n  } // hoist static sub-trees out\n\n\n  function genStatic(el, state) {\n    el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre\n    // node.  All pre nodes are static roots, so we can use this as a location to\n    // wrap a state change and reset it upon exiting the pre node.\n\n    var originalPreState = state.pre;\n\n    if (el.pre) {\n      state.pre = el.pre;\n    }\n\n    state.staticRenderFns.push(\"with(this){return \" + genElement(el, state) + \"}\");\n    state.pre = originalPreState;\n    return \"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n  } // v-once\n\n\n  function genOnce(el, state) {\n    el.onceProcessed = true;\n\n    if (el.if && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.staticInFor) {\n      var key = '';\n      var parent = el.parent;\n\n      while (parent) {\n        if (parent.for) {\n          key = parent.key;\n          break;\n        }\n\n        parent = parent.parent;\n      }\n\n      if (!key) {\n        state.warn(\"v-once can only be used inside v-for that is keyed. \", el.rawAttrsMap['v-once']);\n        return genElement(el, state);\n      }\n\n      return \"_o(\" + genElement(el, state) + \",\" + state.onceId++ + \",\" + key + \")\";\n    } else {\n      return genStatic(el, state);\n    }\n  }\n\n  function genIf(el, state, altGen, altEmpty) {\n    el.ifProcessed = true; // avoid recursion\n\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\n  }\n\n  function genIfConditions(conditions, state, altGen, altEmpty) {\n    if (!conditions.length) {\n      return altEmpty || '_e()';\n    }\n\n    var condition = conditions.shift();\n\n    if (condition.exp) {\n      return \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions, state, altGen, altEmpty);\n    } else {\n      return \"\" + genTernaryExp(condition.block);\n    } // v-if with v-once should generate code like (a)?_m(0):_m(1)\n\n\n    function genTernaryExp(el) {\n      return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);\n    }\n  }\n\n  function genFor(el, state, altGen, altHelper) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n    var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n    if (state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n      state.warn(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", el.rawAttrsMap['v-for'], true\n      /* tip */\n      );\n    }\n\n    el.forProcessed = true; // avoid recursion\n\n    return (altHelper || '_l') + \"((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + (altGen || genElement)(el, state) + '})';\n  }\n\n  function genData$2(el, state) {\n    var data = '{'; // directives first.\n    // directives may mutate the el's other properties before they are generated.\n\n    var dirs = genDirectives(el, state);\n\n    if (dirs) {\n      data += dirs + ',';\n    } // key\n\n\n    if (el.key) {\n      data += \"key:\" + el.key + \",\";\n    } // ref\n\n\n    if (el.ref) {\n      data += \"ref:\" + el.ref + \",\";\n    }\n\n    if (el.refInFor) {\n      data += \"refInFor:true,\";\n    } // pre\n\n\n    if (el.pre) {\n      data += \"pre:true,\";\n    } // record original tag name for components using \"is\" attribute\n\n\n    if (el.component) {\n      data += \"tag:\\\"\" + el.tag + \"\\\",\";\n    } // module data generation functions\n\n\n    for (var i = 0; i < state.dataGenFns.length; i++) {\n      data += state.dataGenFns[i](el);\n    } // attributes\n\n\n    if (el.attrs) {\n      data += \"attrs:\" + genProps(el.attrs) + \",\";\n    } // DOM props\n\n\n    if (el.props) {\n      data += \"domProps:\" + genProps(el.props) + \",\";\n    } // event handlers\n\n\n    if (el.events) {\n      data += genHandlers(el.events, false) + \",\";\n    }\n\n    if (el.nativeEvents) {\n      data += genHandlers(el.nativeEvents, true) + \",\";\n    } // slot target\n    // only for non-scoped slots\n\n\n    if (el.slotTarget && !el.slotScope) {\n      data += \"slot:\" + el.slotTarget + \",\";\n    } // scoped slots\n\n\n    if (el.scopedSlots) {\n      data += genScopedSlots(el, el.scopedSlots, state) + \",\";\n    } // component v-model\n\n\n    if (el.model) {\n      data += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n    } // inline-template\n\n\n    if (el.inlineTemplate) {\n      var inlineTemplate = genInlineTemplate(el, state);\n\n      if (inlineTemplate) {\n        data += inlineTemplate + \",\";\n      }\n    }\n\n    data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap\n    // v-bind with dynamic arguments must be applied using the same v-bind object\n    // merge helper so that class/style/mustUseProp attrs are handled correctly.\n\n    if (el.dynamicAttrs) {\n      data = \"_b(\" + data + \",\\\"\" + el.tag + \"\\\",\" + genProps(el.dynamicAttrs) + \")\";\n    } // v-bind data wrap\n\n\n    if (el.wrapData) {\n      data = el.wrapData(data);\n    } // v-on data wrap\n\n\n    if (el.wrapListeners) {\n      data = el.wrapListeners(data);\n    }\n\n    return data;\n  }\n\n  function genDirectives(el, state) {\n    var dirs = el.directives;\n\n    if (!dirs) {\n      return;\n    }\n\n    var res = 'directives:[';\n    var hasRuntime = false;\n    var i, l, dir, needRuntime;\n\n    for (i = 0, l = dirs.length; i < l; i++) {\n      dir = dirs[i];\n      needRuntime = true;\n      var gen = state.directives[dir.name];\n\n      if (gen) {\n        // compile-time directive that manipulates AST.\n        // returns true if it also needs a runtime counterpart.\n        needRuntime = !!gen(el, dir, state.warn);\n      }\n\n      if (needRuntime) {\n        hasRuntime = true;\n        res += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\" + (dir.isDynamicArg ? dir.arg : \"\\\"\" + dir.arg + \"\\\"\") : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n      }\n    }\n\n    if (hasRuntime) {\n      return res.slice(0, -1) + ']';\n    }\n  }\n\n  function genInlineTemplate(el, state) {\n    var ast = el.children[0];\n\n    if (el.children.length !== 1 || ast.type !== 1) {\n      state.warn('Inline-template components must have exactly one child element.', {\n        start: el.start\n      });\n    }\n\n    if (ast && ast.type === 1) {\n      var inlineRenderFns = generate(ast, state.options);\n      return \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n        return \"function(){\" + code + \"}\";\n      }).join(',') + \"]}\";\n    }\n  }\n\n  function genScopedSlots(el, slots, state) {\n    // by default scoped slots are considered \"stable\", this allows child\n    // components with only scoped slots to skip forced updates from parent.\n    // but in some cases we have to bail-out of this optimization\n    // for example if the slot contains dynamic names, has v-if or v-for on them...\n    var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n      var slot = slots[key];\n      return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n      ;\n    }); // #9534: if a component with scoped slots is inside a conditional branch,\n    // it's possible for the same component to be reused but with different\n    // compiled slot content. To avoid that, we generate a unique key based on\n    // the generated code of all the slot contents.\n\n    var needsKey = !!el.if; // OR when it is inside another scoped slot or v-for (the reactivity may be\n    // disconnected due to the intermediate scope variable)\n    // #9438, #9506\n    // TODO: this can be further optimized by properly analyzing in-scope bindings\n    // and skip force updating ones that do not actually use scope variables.\n\n    if (!needsForceUpdate) {\n      var parent = el.parent;\n\n      while (parent) {\n        if (parent.slotScope && parent.slotScope !== emptySlotScopeToken || parent.for) {\n          needsForceUpdate = true;\n          break;\n        }\n\n        if (parent.if) {\n          needsKey = true;\n        }\n\n        parent = parent.parent;\n      }\n    }\n\n    var generatedSlots = Object.keys(slots).map(function (key) {\n      return genScopedSlot(slots[key], state);\n    }).join(',');\n    return \"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? \",null,false,\" + hash(generatedSlots) : \"\") + \")\";\n  }\n\n  function hash(str) {\n    var hash = 5381;\n    var i = str.length;\n\n    while (i) {\n      hash = hash * 33 ^ str.charCodeAt(--i);\n    }\n\n    return hash >>> 0;\n  }\n\n  function containsSlotChild(el) {\n    if (el.type === 1) {\n      if (el.tag === 'slot') {\n        return true;\n      }\n\n      return el.children.some(containsSlotChild);\n    }\n\n    return false;\n  }\n\n  function genScopedSlot(el, state) {\n    var isLegacySyntax = el.attrsMap['slot-scope'];\n\n    if (el.if && !el.ifProcessed && !isLegacySyntax) {\n      return genIf(el, state, genScopedSlot, \"null\");\n    }\n\n    if (el.for && !el.forProcessed) {\n      return genFor(el, state, genScopedSlot);\n    }\n\n    var slotScope = el.slotScope === emptySlotScopeToken ? \"\" : String(el.slotScope);\n    var fn = \"function(\" + slotScope + \"){\" + \"return \" + (el.tag === 'template' ? el.if && isLegacySyntax ? \"(\" + el.if + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\" : genChildren(el, state) || 'undefined' : genElement(el, state)) + \"}\"; // reverse proxy v-slot without scope on this.$slots\n\n    var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n    return \"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\";\n  }\n\n  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {\n    var children = el.children;\n\n    if (children.length) {\n      var el$1 = children[0]; // optimize single v-for\n\n      if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n        var normalizationType = checkSkip ? state.maybeComponent(el$1) ? \",1\" : \",0\" : \"\";\n        return \"\" + (altGenElement || genElement)(el$1, state) + normalizationType;\n      }\n\n      var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;\n      var gen = altGenNode || genNode;\n      return \"[\" + children.map(function (c) {\n        return gen(c, state);\n      }).join(',') + \"]\" + (normalizationType$1 ? \",\" + normalizationType$1 : '');\n    }\n  } // determine the normalization needed for the children array.\n  // 0: no normalization needed\n  // 1: simple normalization needed (possible 1-level deep nested array)\n  // 2: full normalization needed\n\n\n  function getNormalizationType(children, maybeComponent) {\n    var res = 0;\n\n    for (var i = 0; i < children.length; i++) {\n      var el = children[i];\n\n      if (el.type !== 1) {\n        continue;\n      }\n\n      if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return needsNormalization(c.block);\n      })) {\n        res = 2;\n        break;\n      }\n\n      if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return maybeComponent(c.block);\n      })) {\n        res = 1;\n      }\n    }\n\n    return res;\n  }\n\n  function needsNormalization(el) {\n    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n  }\n\n  function genNode(node, state) {\n    if (node.type === 1) {\n      return genElement(node, state);\n    } else if (node.type === 3 && node.isComment) {\n      return genComment(node);\n    } else {\n      return genText(node);\n    }\n  }\n\n  function genText(text) {\n    return \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n  }\n\n  function genComment(comment) {\n    return \"_e(\" + JSON.stringify(comment.text) + \")\";\n  }\n\n  function genSlot(el, state) {\n    var slotName = el.slotName || '\"default\"';\n    var children = genChildren(el, state);\n    var res = \"_t(\" + slotName + (children ? \",function(){return \" + children + \"}\" : '');\n    var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {\n      return {\n        // slot props are camelized\n        name: camelize(attr.name),\n        value: attr.value,\n        dynamic: attr.dynamic\n      };\n    })) : null;\n    var bind$$1 = el.attrsMap['v-bind'];\n\n    if ((attrs || bind$$1) && !children) {\n      res += \",null\";\n    }\n\n    if (attrs) {\n      res += \",\" + attrs;\n    }\n\n    if (bind$$1) {\n      res += (attrs ? '' : ',null') + \",\" + bind$$1;\n    }\n\n    return res + ')';\n  } // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n\n\n  function genComponent(componentName, el, state) {\n    var children = el.inlineTemplate ? null : genChildren(el, state, true);\n    return \"_c(\" + componentName + \",\" + genData$2(el, state) + (children ? \",\" + children : '') + \")\";\n  }\n\n  function genProps(props) {\n    var staticProps = \"\";\n    var dynamicProps = \"\";\n\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      var value = transformSpecialNewlines(prop.value);\n\n      if (prop.dynamic) {\n        dynamicProps += prop.name + \",\" + value + \",\";\n      } else {\n        staticProps += \"\\\"\" + prop.name + \"\\\":\" + value + \",\";\n      }\n    }\n\n    staticProps = \"{\" + staticProps.slice(0, -1) + \"}\";\n\n    if (dynamicProps) {\n      return \"_d(\" + staticProps + \",[\" + dynamicProps.slice(0, -1) + \"])\";\n    } else {\n      return staticProps;\n    }\n  } // #3895, #4268\n\n\n  function transformSpecialNewlines(text) {\n    return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n  }\n  /*  */\n  // these keywords should not appear inside expressions, but operators like\n  // typeof, instanceof and in are allowed\n\n\n  var prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b'); // these unary operators should not be used as property/method names\n\n  var unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)'); // strip strings in expressions\n\n  var stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g; // detect problematic expressions in a template\n\n  function detectErrors(ast, warn) {\n    if (ast) {\n      checkNode(ast, warn);\n    }\n  }\n\n  function checkNode(node, warn) {\n    if (node.type === 1) {\n      for (var name in node.attrsMap) {\n        if (dirRE.test(name)) {\n          var value = node.attrsMap[name];\n\n          if (value) {\n            var range = node.rawAttrsMap[name];\n\n            if (name === 'v-for') {\n              checkFor(node, \"v-for=\\\"\" + value + \"\\\"\", warn, range);\n            } else if (name === 'v-slot' || name[0] === '#') {\n              checkFunctionParameterExpression(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n            } else if (onRE.test(name)) {\n              checkEvent(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n            } else {\n              checkExpression(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n            }\n          }\n        }\n      }\n\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          checkNode(node.children[i], warn);\n        }\n      }\n    } else if (node.type === 2) {\n      checkExpression(node.expression, node.text, warn, node);\n    }\n  }\n\n  function checkEvent(exp, text, warn, range) {\n    var stripped = exp.replace(stripStringRE, '');\n    var keywordMatch = stripped.match(unaryOperatorsRE);\n\n    if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {\n      warn(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim(), range);\n    }\n\n    checkExpression(exp, text, warn, range);\n  }\n\n  function checkFor(node, text, warn, range) {\n    checkExpression(node.for || '', text, warn, range);\n    checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n  }\n\n  function checkIdentifier(ident, type, text, warn, range) {\n    if (typeof ident === 'string') {\n      try {\n        new Function(\"var \" + ident + \"=_\");\n      } catch (e) {\n        warn(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim(), range);\n      }\n    }\n  }\n\n  function checkExpression(exp, text, warn, range) {\n    try {\n      new Function(\"return \" + exp);\n    } catch (e) {\n      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n\n      if (keywordMatch) {\n        warn(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\"\\n  Raw expression: \" + text.trim(), range);\n      } else {\n        warn(\"invalid expression: \" + e.message + \" in\\n\\n\" + \"    \" + exp + \"\\n\\n\" + \"  Raw expression: \" + text.trim() + \"\\n\", range);\n      }\n    }\n  }\n\n  function checkFunctionParameterExpression(exp, text, warn, range) {\n    try {\n      new Function(exp, '');\n    } catch (e) {\n      warn(\"invalid function parameter expression: \" + e.message + \" in\\n\\n\" + \"    \" + exp + \"\\n\\n\" + \"  Raw expression: \" + text.trim() + \"\\n\", range);\n    }\n  }\n  /*  */\n\n\n  var range = 2;\n\n  function generateCodeFrame(source, start, end) {\n    if (start === void 0) start = 0;\n    if (end === void 0) end = source.length;\n    var lines = source.split(/\\r?\\n/);\n    var count = 0;\n    var res = [];\n\n    for (var i = 0; i < lines.length; i++) {\n      count += lines[i].length + 1;\n\n      if (count >= start) {\n        for (var j = i - range; j <= i + range || end > count; j++) {\n          if (j < 0 || j >= lines.length) {\n            continue;\n          }\n\n          res.push(\"\" + (j + 1) + repeat$1(\" \", 3 - String(j + 1).length) + \"|  \" + lines[j]);\n          var lineLength = lines[j].length;\n\n          if (j === i) {\n            // push underline\n            var pad = start - (count - lineLength) + 1;\n            var length = end > count ? lineLength - pad : end - start;\n            res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n          } else if (j > i) {\n            if (end > count) {\n              var length$1 = Math.min(end - count, lineLength);\n              res.push(\"   |  \" + repeat$1(\"^\", length$1));\n            }\n\n            count += lineLength + 1;\n          }\n        }\n\n        break;\n      }\n    }\n\n    return res.join('\\n');\n  }\n\n  function repeat$1(str, n) {\n    var result = '';\n\n    if (n > 0) {\n      while (true) {\n        // eslint-disable-line\n        if (n & 1) {\n          result += str;\n        }\n\n        n >>>= 1;\n\n        if (n <= 0) {\n          break;\n        }\n\n        str += str;\n      }\n    }\n\n    return result;\n  }\n  /*  */\n\n\n  function createFunction(code, errors) {\n    try {\n      return new Function(code);\n    } catch (err) {\n      errors.push({\n        err: err,\n        code: code\n      });\n      return noop;\n    }\n  }\n\n  function createCompileToFunctionFn(compile) {\n    var cache = Object.create(null);\n    return function compileToFunctions(template, options, vm) {\n      options = extend({}, options);\n      var warn$$1 = options.warn || warn;\n      delete options.warn;\n      /* istanbul ignore if */\n\n      {\n        // detect possible CSP restriction\n        try {\n          new Function('return 1');\n        } catch (e) {\n          if (e.toString().match(/unsafe-eval|CSP/)) {\n            warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n          }\n        }\n      } // check cache\n\n      var key = options.delimiters ? String(options.delimiters) + template : template;\n\n      if (cache[key]) {\n        return cache[key];\n      } // compile\n\n\n      var compiled = compile(template, options); // check compilation errors/tips\n\n      {\n        if (compiled.errors && compiled.errors.length) {\n          if (options.outputSourceRange) {\n            compiled.errors.forEach(function (e) {\n              warn$$1(\"Error compiling template:\\n\\n\" + e.msg + \"\\n\\n\" + generateCodeFrame(template, e.start, e.end), vm);\n            });\n          } else {\n            warn$$1(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n              return \"- \" + e;\n            }).join('\\n') + '\\n', vm);\n          }\n        }\n\n        if (compiled.tips && compiled.tips.length) {\n          if (options.outputSourceRange) {\n            compiled.tips.forEach(function (e) {\n              return tip(e.msg, vm);\n            });\n          } else {\n            compiled.tips.forEach(function (msg) {\n              return tip(msg, vm);\n            });\n          }\n        }\n      } // turn code into functions\n\n      var res = {};\n      var fnGenErrors = [];\n      res.render = createFunction(compiled.render, fnGenErrors);\n      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n        return createFunction(code, fnGenErrors);\n      }); // check function generation errors.\n      // this should only happen if there is a bug in the compiler itself.\n      // mostly for codegen development use\n\n      /* istanbul ignore if */\n\n      {\n        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n          warn$$1(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n            return err.toString() + \" in\\n\\n\" + code + \"\\n\";\n          }).join('\\n'), vm);\n        }\n      }\n      return cache[key] = res;\n    };\n  }\n  /*  */\n\n\n  function createCompilerCreator(baseCompile) {\n    return function createCompiler(baseOptions) {\n      function compile(template, options) {\n        var finalOptions = Object.create(baseOptions);\n        var errors = [];\n        var tips = [];\n\n        var warn = function (msg, range, tip) {\n          (tip ? tips : errors).push(msg);\n        };\n\n        if (options) {\n          if (options.outputSourceRange) {\n            // $flow-disable-line\n            var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n            warn = function (msg, range, tip) {\n              var data = {\n                msg: msg\n              };\n\n              if (range) {\n                if (range.start != null) {\n                  data.start = range.start + leadingSpaceLength;\n                }\n\n                if (range.end != null) {\n                  data.end = range.end + leadingSpaceLength;\n                }\n              }\n\n              (tip ? tips : errors).push(data);\n            };\n          } // merge custom modules\n\n\n          if (options.modules) {\n            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n          } // merge custom directives\n\n\n          if (options.directives) {\n            finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);\n          } // copy other options\n\n\n          for (var key in options) {\n            if (key !== 'modules' && key !== 'directives') {\n              finalOptions[key] = options[key];\n            }\n          }\n        }\n\n        finalOptions.warn = warn;\n        var compiled = baseCompile(template.trim(), finalOptions);\n        {\n          detectErrors(compiled.ast, warn);\n        }\n        compiled.errors = errors;\n        compiled.tips = tips;\n        return compiled;\n      }\n\n      return {\n        compile: compile,\n        compileToFunctions: createCompileToFunctionFn(compile)\n      };\n    };\n  }\n  /*  */\n  // `createCompilerCreator` allows creating compilers that use alternative\n  // parser/optimizer/codegen, e.g the SSR optimizing compiler.\n  // Here we just export a default compiler using the default parts.\n\n\n  var createCompiler = createCompilerCreator(function baseCompile(template, options) {\n    var ast = parse(template.trim(), options);\n\n    if (options.optimize !== false) {\n      optimize(ast, options);\n    }\n\n    var code = generate(ast, options);\n    return {\n      ast: ast,\n      render: code.render,\n      staticRenderFns: code.staticRenderFns\n    };\n  });\n  /*  */\n\n  var ref$1 = createCompiler(baseOptions);\n  var compile = ref$1.compile;\n  var compileToFunctions = ref$1.compileToFunctions;\n  /*  */\n  // check whether current browser encodes a char inside attribute values\n\n  var div;\n\n  function getShouldDecode(href) {\n    div = div || document.createElement('div');\n    div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n    return div.innerHTML.indexOf('&#10;') > 0;\n  } // #3663: IE encodes newlines inside attribute values while other browsers don't\n\n\n  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]\n\n  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n  /*  */\n\n  var idToTemplate = cached(function (id) {\n    var el = query(id);\n    return el && el.innerHTML;\n  });\n  var mount = Vue.prototype.$mount;\n\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && query(el);\n    /* istanbul ignore if */\n\n    if (el === document.body || el === document.documentElement) {\n      warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n      return this;\n    }\n\n    var options = this.$options; // resolve template/el and convert to render function\n\n    if (!options.render) {\n      var template = options.template;\n\n      if (template) {\n        if (typeof template === 'string') {\n          if (template.charAt(0) === '#') {\n            template = idToTemplate(template);\n            /* istanbul ignore if */\n\n            if (!template) {\n              warn(\"Template element not found or is empty: \" + options.template, this);\n            }\n          }\n        } else if (template.nodeType) {\n          template = template.innerHTML;\n        } else {\n          {\n            warn('invalid template option:' + template, this);\n          }\n          return this;\n        }\n      } else if (el) {\n        template = getOuterHTML(el);\n      }\n\n      if (template) {\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          mark('compile');\n        }\n\n        var ref = compileToFunctions(template, {\n          outputSourceRange: \"development\" !== 'production',\n          shouldDecodeNewlines: shouldDecodeNewlines,\n          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n          delimiters: options.delimiters,\n          comments: options.comments\n        }, this);\n        var render = ref.render;\n        var staticRenderFns = ref.staticRenderFns;\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n        /* istanbul ignore if */\n\n        if (config.performance && mark) {\n          mark('compile end');\n          measure(\"vue \" + this._name + \" compile\", 'compile', 'compile end');\n        }\n      }\n    }\n\n    return mount.call(this, el, hydrating);\n  };\n  /**\n   * Get outerHTML of elements, taking care\n   * of SVG elements in IE as well.\n   */\n\n\n  function getOuterHTML(el) {\n    if (el.outerHTML) {\n      return el.outerHTML;\n    } else {\n      var container = document.createElement('div');\n      container.appendChild(el.cloneNode(true));\n      return container.innerHTML;\n    }\n  }\n\n  Vue.compile = compileToFunctions;\n  return Vue;\n});\n\n//# sourceURL=webpack://kloster/./node_modules/vue/dist/vue.js?")},"./node_modules/vue/dist/vue.runtime.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * Vue.js v2.6.14\n * (c) 2014-2021 Evan You\n * Released under the MIT License.\n */\n\n/*  */\nvar emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\n\nfunction isUndef(v) {\n  return v === undefined || v === null;\n}\n\nfunction isDef(v) {\n  return v !== undefined && v !== null;\n}\n\nfunction isTrue(v) {\n  return v === true;\n}\n\nfunction isFalse(v) {\n  return v === false;\n}\n/**\n * Check if value is primitive.\n */\n\n\nfunction isPrimitive(value) {\n  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line\n  typeof value === 'symbol' || typeof value === 'boolean';\n}\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\n\n\nfunction isObject(obj) {\n  return obj !== null && typeof obj === 'object';\n}\n/**\n * Get the raw type string of a value, e.g., [object Object].\n */\n\n\nvar _toString = Object.prototype.toString;\n\nfunction toRawType(value) {\n  return _toString.call(value).slice(8, -1);\n}\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\n\n\nfunction isPlainObject(obj) {\n  return _toString.call(obj) === '[object Object]';\n}\n\nfunction isRegExp(v) {\n  return _toString.call(v) === '[object RegExp]';\n}\n/**\n * Check if val is a valid array index.\n */\n\n\nfunction isValidArrayIndex(val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val);\n}\n\nfunction isPromise(val) {\n  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';\n}\n/**\n * Convert a value to a string that is actually rendered.\n */\n\n\nfunction toString(val) {\n  return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);\n}\n/**\n * Convert an input value to a number for persistence.\n * If the conversion fails, return original string.\n */\n\n\nfunction toNumber(val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n;\n}\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\n\n\nfunction makeMap(str, expectsLowerCase) {\n  var map = Object.create(null);\n  var list = str.split(',');\n\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n\n  return expectsLowerCase ? function (val) {\n    return map[val.toLowerCase()];\n  } : function (val) {\n    return map[val];\n  };\n}\n/**\n * Check if a tag is a built-in tag.\n */\n\n\nvar isBuiltInTag = makeMap('slot,component', true);\n/**\n * Check if an attribute is a reserved attribute.\n */\n\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n/**\n * Remove an item from an array.\n */\n\nfunction remove(arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n\n    if (index > -1) {\n      return arr.splice(index, 1);\n    }\n  }\n}\n/**\n * Check whether an object has the property.\n */\n\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n/**\n * Create a cached version of a pure function.\n */\n\n\nfunction cached(fn) {\n  var cache = Object.create(null);\n  return function cachedFn(str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\n/**\n * Camelize a hyphen-delimited string.\n */\n\n\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) {\n    return c ? c.toUpperCase() : '';\n  });\n});\n/**\n * Capitalize a string.\n */\n\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\n/**\n * Hyphenate a camelCase string.\n */\n\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase();\n});\n/**\n * Simple bind polyfill for environments that do not support it,\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n * since native bind is now performant enough in most browsers.\n * But removing it would mean breaking code that was able to run in\n * PhantomJS 1.x, so this must be kept for backward compatibility.\n */\n\n/* istanbul ignore next */\n\nfunction polyfillBind(fn, ctx) {\n  function boundFn(a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  }\n\n  boundFn._length = fn.length;\n  return boundFn;\n}\n\nfunction nativeBind(fn, ctx) {\n  return fn.bind(ctx);\n}\n\nvar bind = Function.prototype.bind ? nativeBind : polyfillBind;\n/**\n * Convert an Array-like object to a real Array.\n */\n\nfunction toArray(list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n\n  return ret;\n}\n/**\n * Mix properties into target object.\n */\n\n\nfunction extend(to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n\n  return to;\n}\n/**\n * Merge an Array of Objects into a single Object.\n */\n\n\nfunction toObject(arr) {\n  var res = {};\n\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n\n  return res;\n}\n/* eslint-disable no-unused-vars */\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n */\n\n\nfunction noop(a, b, c) {}\n/**\n * Always return false.\n */\n\n\nvar no = function (a, b, c) {\n  return false;\n};\n/* eslint-enable no-unused-vars */\n\n/**\n * Return the same value.\n */\n\n\nvar identity = function (_) {\n  return _;\n};\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\n\n\nfunction looseEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i]);\n        });\n      } else if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime();\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key]);\n        });\n      } else {\n        /* istanbul ignore next */\n        return false;\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false;\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b);\n  } else {\n    return false;\n  }\n}\n/**\n * Return the first index at which a loosely equal value can be\n * found in the array (if value is a plain object, the array must\n * contain an object of the same shape), or -1 if it is not present.\n */\n\n\nfunction looseIndexOf(arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n/**\n * Ensure a function is called only once.\n */\n\n\nfunction once(fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  };\n}\n\nvar SSR_ATTR = 'data-server-rendered';\nvar ASSET_TYPES = ['component', 'directive', 'filter'];\nvar LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"development\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"development\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Perform updates asynchronously. Intended to be used by Vue Test Utils\n   * This will significantly reduce performance if set to false.\n   */\n  async: true,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n};\n/*  */\n\n/**\n * unicode letters used for parsing html tags, component names and property paths.\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n */\n\nvar unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n/**\n * Check if a string starts with $ or _\n */\n\nfunction isReserved(str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F;\n}\n/**\n * Define a property.\n */\n\n\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n/**\n * Parse simple path.\n */\n\n\nvar bailRE = new RegExp(\"[^\" + unicodeRegExp.source + \".$_\\\\d]\");\n\nfunction parsePath(path) {\n  if (bailRE.test(path)) {\n    return;\n  }\n\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) {\n        return;\n      }\n\n      obj = obj[segments[i]];\n    }\n\n    return obj;\n  };\n}\n/*  */\n// can we use __proto__?\n\n\nvar hasProto = ('__proto__' in {}); // Browser environment sniffing\n\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\nvar isPhantomJS = UA && /phantomjs/.test(UA);\nvar isFF = UA && UA.match(/firefox\\/(\\d+)/); // Firefox has a \"watch\" function on Object.prototype...\n\nvar nativeWatch = {}.watch;\nvar supportsPassive = false;\n\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', {\n      get: function get() {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    }); // https://github.com/facebook/flow/issues/285\n\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n} // this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\n\n\nvar _isServer;\n\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && !inWeex && typeof __webpack_require__.g !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = __webpack_require__.g['process'] && __webpack_require__.g['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n\n  return _isServer;\n}; // detect devtools\n\n\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n/* istanbul ignore next */\n\nfunction isNative(Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n}\n\nvar hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */\n// $flow-disable-line\n\n\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = /*@__PURE__*/function () {\n    function Set() {\n      this.set = Object.create(null);\n    }\n\n    Set.prototype.has = function has(key) {\n      return this.set[key] === true;\n    };\n\n    Set.prototype.add = function add(key) {\n      this.set[key] = true;\n    };\n\n    Set.prototype.clear = function clear() {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }();\n}\n/*  */\n\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = noop; // work around flow check\n\nvar formatComponentName = noop;\n\nif (true) {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n\n  var classify = function (str) {\n    return str.replace(classifyRE, function (c) {\n      return c.toUpperCase();\n    }).replace(/[-_]/g, '');\n  };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && !config.silent) {\n      console.error(\"[Vue warn]: \" + msg + trace);\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && !config.silent) {\n      console.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>';\n    }\n\n    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;\n    var name = options.name || options._componentTag;\n    var file = options.__file;\n\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n\n    while (n) {\n      if (n % 2 === 1) {\n        res += str;\n      }\n\n      if (n > 1) {\n        str += str;\n      }\n\n      n >>= 1;\n    }\n\n    return res;\n  };\n\n  generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue;\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n\n      return '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n        return \"\" + (i === 0 ? '---\x3e ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n      }).join('\\n');\n    } else {\n      return \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n    }\n  };\n}\n/*  */\n\n\nvar uid = 0;\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\n\nvar Dep = function Dep() {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub(sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub(sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend() {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify() {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n\n  if ( true && !config.async) {\n    // subs aren't sorted in scheduler if not running async\n    // we need to sort them now to make sure they fire in correct\n    // order\n    subs.sort(function (a, b) {\n      return a.id - b.id;\n    });\n  }\n\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n}; // The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\n\n\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget(target) {\n  targetStack.push(target);\n  Dep.target = target;\n}\n\nfunction popTarget() {\n  targetStack.pop();\n  Dep.target = targetStack[targetStack.length - 1];\n}\n/*  */\n\n\nvar VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = {\n  child: {\n    configurable: true\n  }\n}; // DEPRECATED: alias for componentInstance for backwards compat.\n\n/* istanbul ignore next */\n\nprototypeAccessors.child.get = function () {\n  return this.componentInstance;\n};\n\nObject.defineProperties(VNode.prototype, prototypeAccessors);\n\nvar createEmptyVNode = function (text) {\n  if (text === void 0) text = '';\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node;\n};\n\nfunction createTextVNode(val) {\n  return new VNode(undefined, undefined, undefined, String(val));\n} // optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\n\n\nfunction cloneVNode(vnode) {\n  var cloned = new VNode(vnode.tag, vnode.data, // #7975\n  // clone children array to avoid mutating original in case of cloning\n  // a child.\n  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.asyncMeta = vnode.asyncMeta;\n  cloned.isCloned = true;\n  return cloned;\n}\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\nvar methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\n/**\n * Intercept mutating methods and emit events\n */\n\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator() {\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break;\n\n      case 'splice':\n        inserted = args.slice(2);\n        break;\n    }\n\n    if (inserted) {\n      ob.observeArray(inserted);\n    } // notify change\n\n\n    ob.dep.notify();\n    return result;\n  });\n});\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\n\nvar shouldObserve = true;\n\nfunction toggleObserving(value) {\n  shouldObserve = value;\n}\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\n\n\nvar Observer = function Observer(value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n\n  if (Array.isArray(value)) {\n    if (hasProto) {\n      protoAugment(value, arrayMethods);\n    } else {\n      copyAugment(value, arrayMethods, arrayKeys);\n    }\n\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n/**\n * Walk through all properties and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\n\n\nObserver.prototype.walk = function walk(obj) {\n  var keys = Object.keys(obj);\n\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i]);\n  }\n};\n/**\n * Observe a list of Array items.\n */\n\n\nObserver.prototype.observeArray = function observeArray(items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n}; // helpers\n\n/**\n * Augment a target Object or Array by intercepting\n * the prototype chain using __proto__\n */\n\n\nfunction protoAugment(target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n/**\n * Augment a target Object or Array by defining\n * hidden properties.\n */\n\n/* istanbul ignore next */\n\n\nfunction copyAugment(target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\n\n\nfunction observe(value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return;\n  }\n\n  var ob;\n\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n    ob = new Observer(value);\n  }\n\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n\n  return ob;\n}\n/**\n * Define a reactive property on an Object.\n */\n\n\nfunction defineReactive$$1(obj, key, val, customSetter, shallow) {\n  var dep = new Dep();\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n\n  if (property && property.configurable === false) {\n    return;\n  } // cater for pre-defined getter/setters\n\n\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key];\n  }\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      var value = getter ? getter.call(obj) : val;\n\n      if (Dep.target) {\n        dep.depend();\n\n        if (childOb) {\n          childOb.dep.depend();\n\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n\n      return value;\n    },\n    set: function reactiveSetter(newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n\n      if (newVal === value || newVal !== newVal && value !== value) {\n        return;\n      }\n      /* eslint-enable no-self-compare */\n\n\n      if ( true && customSetter) {\n        customSetter();\n      } // #7981: for accessor properties without setter\n\n\n      if (getter && !setter) {\n        return;\n      }\n\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\n\n\nfunction set(target, key, val) {\n  if ( true && (isUndef(target) || isPrimitive(target))) {\n    warn(\"Cannot set reactive property on undefined, null, or primitive value: \" + target);\n  }\n\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val;\n  }\n\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val;\n  }\n\n  var ob = target.__ob__;\n\n  if (target._isVue || ob && ob.vmCount) {\n     true && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n    return val;\n  }\n\n  if (!ob) {\n    target[key] = val;\n    return val;\n  }\n\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val;\n}\n/**\n * Delete a property and trigger change if necessary.\n */\n\n\nfunction del(target, key) {\n  if ( true && (isUndef(target) || isPrimitive(target))) {\n    warn(\"Cannot delete reactive property on undefined, null, or primitive value: \" + target);\n  }\n\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return;\n  }\n\n  var ob = target.__ob__;\n\n  if (target._isVue || ob && ob.vmCount) {\n     true && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n    return;\n  }\n\n  if (!hasOwn(target, key)) {\n    return;\n  }\n\n  delete target[key];\n\n  if (!ob) {\n    return;\n  }\n\n  ob.dep.notify();\n}\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\n\n\nfunction dependArray(value) {\n  for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\n\n\nvar strats = config.optionMergeStrategies;\n/**\n * Options with restrictions\n */\n\nif (true) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n    }\n\n    return defaultStrat(parent, child);\n  };\n}\n/**\n * Helper that recursively merges two data objects together.\n */\n\n\nfunction mergeData(to, from) {\n  if (!from) {\n    return to;\n  }\n\n  var key, toVal, fromVal;\n  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i]; // in case the object is already observed...\n\n    if (key === '__ob__') {\n      continue;\n    }\n\n    toVal = to[key];\n    fromVal = from[key];\n\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n\n  return to;\n}\n/**\n * Data\n */\n\n\nfunction mergeDataOrFn(parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal;\n    }\n\n    if (!parentVal) {\n      return childVal;\n    } // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n\n\n    return function mergedDataFn() {\n      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);\n    };\n  } else {\n    return function mergedInstanceDataFn() {\n      // instance merge\n      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;\n      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;\n\n      if (instanceData) {\n        return mergeData(instanceData, defaultData);\n      } else {\n        return defaultData;\n      }\n    };\n  }\n}\n\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n       true && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n      return parentVal;\n    }\n\n    return mergeDataOrFn(parentVal, childVal);\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm);\n};\n/**\n * Hooks and props are merged as arrays.\n */\n\n\nfunction mergeHook(parentVal, childVal) {\n  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n  return res ? dedupeHooks(res) : res;\n}\n\nfunction dedupeHooks(hooks) {\n  var res = [];\n\n  for (var i = 0; i < hooks.length; i++) {\n    if (res.indexOf(hooks[i]) === -1) {\n      res.push(hooks[i]);\n    }\n  }\n\n  return res;\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\n\nfunction mergeAssets(parentVal, childVal, vm, key) {\n  var res = Object.create(parentVal || null);\n\n  if (childVal) {\n     true && assertObjectType(key, childVal, vm);\n    return extend(res, childVal);\n  } else {\n    return res;\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\n\nstrats.watch = function (parentVal, childVal, vm, key) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) {\n    parentVal = undefined;\n  }\n\n  if (childVal === nativeWatch) {\n    childVal = undefined;\n  }\n  /* istanbul ignore if */\n\n\n  if (!childVal) {\n    return Object.create(parentVal || null);\n  }\n\n  if (true) {\n    assertObjectType(key, childVal, vm);\n  }\n\n  if (!parentVal) {\n    return childVal;\n  }\n\n  var ret = {};\n  extend(ret, parentVal);\n\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n\n    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];\n  }\n\n  return ret;\n};\n/**\n * Other object hashes.\n */\n\n\nstrats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {\n  if (childVal && \"development\" !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n\n  if (!parentVal) {\n    return childVal;\n  }\n\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n\n  if (childVal) {\n    extend(ret, childVal);\n  }\n\n  return ret;\n};\n\nstrats.provide = mergeDataOrFn;\n/**\n * Default strategy.\n */\n\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined ? parentVal : childVal;\n};\n/**\n * Validate component names\n */\n\n\nfunction checkComponents(options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName(name) {\n  if (!new RegExp(\"^[a-zA-Z][\\\\-\\\\.0-9_\" + unicodeRegExp.source + \"]*$\").test(name)) {\n    warn('Invalid component name: \"' + name + '\". Component names ' + 'should conform to valid custom element name in html5 specification.');\n  }\n\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);\n  }\n}\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\n\n\nfunction normalizeProps(options, vm) {\n  var props = options.props;\n\n  if (!props) {\n    return;\n  }\n\n  var res = {};\n  var i, val, name;\n\n  if (Array.isArray(props)) {\n    i = props.length;\n\n    while (i--) {\n      val = props[i];\n\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = {\n          type: null\n        };\n      } else if (true) {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val) ? val : {\n        type: val\n      };\n    }\n  } else if (true) {\n    warn(\"Invalid value for option \\\"props\\\": expected an Array or an Object, \" + \"but got \" + toRawType(props) + \".\", vm);\n  }\n\n  options.props = res;\n}\n/**\n * Normalize all injections into Object-based format\n */\n\n\nfunction normalizeInject(options, vm) {\n  var inject = options.inject;\n\n  if (!inject) {\n    return;\n  }\n\n  var normalized = options.inject = {};\n\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = {\n        from: inject[i]\n      };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val) ? extend({\n        from: key\n      }, val) : {\n        from: val\n      };\n    }\n  } else if (true) {\n    warn(\"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" + \"but got \" + toRawType(inject) + \".\", vm);\n  }\n}\n/**\n * Normalize raw function directives into object format.\n */\n\n\nfunction normalizeDirectives(options) {\n  var dirs = options.directives;\n\n  if (dirs) {\n    for (var key in dirs) {\n      var def$$1 = dirs[key];\n\n      if (typeof def$$1 === 'function') {\n        dirs[key] = {\n          bind: def$$1,\n          update: def$$1\n        };\n      }\n    }\n  }\n}\n\nfunction assertObjectType(name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" + \"but got \" + toRawType(value) + \".\", vm);\n  }\n}\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\n\n\nfunction mergeOptions(parent, child, vm) {\n  if (true) {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child); // Apply extends and mixins on the child options,\n  // but only if it is a raw options object that isn't\n  // the result of another mergeOptions call.\n  // Only merged options has the _base property.\n\n  if (!child._base) {\n    if (child.extends) {\n      parent = mergeOptions(parent, child.extends, vm);\n    }\n\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n  }\n\n  var options = {};\n  var key;\n\n  for (key in parent) {\n    mergeField(key);\n  }\n\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n\n  function mergeField(key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n\n  return options;\n}\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\n\n\nfunction resolveAsset(options, type, id, warnMissing) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return;\n  }\n\n  var assets = options[type]; // check local registration variations first\n\n  if (hasOwn(assets, id)) {\n    return assets[id];\n  }\n\n  var camelizedId = camelize(id);\n\n  if (hasOwn(assets, camelizedId)) {\n    return assets[camelizedId];\n  }\n\n  var PascalCaseId = capitalize(camelizedId);\n\n  if (hasOwn(assets, PascalCaseId)) {\n    return assets[PascalCaseId];\n  } // fallback to prototype chain\n\n\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n\n  if ( true && warnMissing && !res) {\n    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n  }\n\n  return res;\n}\n/*  */\n\n\nfunction validateProp(key, propOptions, propsData, vm) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key]; // boolean casting\n\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\n\n  if (booleanIndex > -1) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      // only cast empty string / same name to boolean if\n      // boolean has higher priority\n      var stringIndex = getTypeIndex(String, prop.type);\n\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\n        value = true;\n      }\n    }\n  } // check default value\n\n\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,\n    // make sure to observe it.\n\n    var prevShouldObserve = shouldObserve;\n    toggleObserving(true);\n    observe(value);\n    toggleObserving(prevShouldObserve);\n  }\n\n  if (true) {\n    assertProp(prop, key, value, vm, absent);\n  }\n\n  return value;\n}\n/**\n * Get the default value of a prop.\n */\n\n\nfunction getPropDefaultValue(vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined;\n  }\n\n  var def = prop.default; // warn against non-factory defaults for Object & Array\n\n  if ( true && isObject(def)) {\n    warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n  } // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n\n\n  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n    return vm._props[key];\n  } // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n\n\n  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n}\n/**\n * Assert whether a prop is valid.\n */\n\n\nfunction assertProp(prop, name, value, vm, absent) {\n  if (prop.required && absent) {\n    warn('Missing required prop: \"' + name + '\"', vm);\n    return;\n  }\n\n  if (value == null && !prop.required) {\n    return;\n  }\n\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i], vm);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n\n  var haveExpectedTypes = expectedTypes.some(function (t) {\n    return t;\n  });\n\n  if (!valid && haveExpectedTypes) {\n    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);\n    return;\n  }\n\n  var validator = prop.validator;\n\n  if (validator) {\n    if (!validator(value)) {\n      warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;\n\nfunction assertType(value, type, vm) {\n  var valid;\n  var expectedType = getType(type);\n\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects\n\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    try {\n      valid = value instanceof type;\n    } catch (e) {\n      warn('Invalid prop type: \"' + String(type) + '\" is not a constructor', vm);\n      valid = false;\n    }\n  }\n\n  return {\n    valid: valid,\n    expectedType: expectedType\n  };\n}\n\nvar functionTypeCheckRE = /^\\s*function (\\w+)/;\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\n\nfunction getType(fn) {\n  var match = fn && fn.toString().match(functionTypeCheckRE);\n  return match ? match[1] : '';\n}\n\nfunction isSameType(a, b) {\n  return getType(a) === getType(b);\n}\n\nfunction getTypeIndex(type, expectedTypes) {\n  if (!Array.isArray(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1;\n  }\n\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\n    if (isSameType(expectedTypes[i], type)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\n  var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" + \" Expected \" + expectedTypes.map(capitalize).join(', ');\n  var expectedType = expectedTypes[0];\n  var receivedType = toRawType(value); // check if we need to specify expected value\n\n  if (expectedTypes.length === 1 && isExplicable(expectedType) && isExplicable(typeof value) && !isBoolean(expectedType, receivedType)) {\n    message += \" with value \" + styleValue(value, expectedType);\n  }\n\n  message += \", got \" + receivedType + \" \"; // check if we need to specify received value\n\n  if (isExplicable(receivedType)) {\n    message += \"with value \" + styleValue(value, receivedType) + \".\";\n  }\n\n  return message;\n}\n\nfunction styleValue(value, type) {\n  if (type === 'String') {\n    return \"\\\"\" + value + \"\\\"\";\n  } else if (type === 'Number') {\n    return \"\" + Number(value);\n  } else {\n    return \"\" + value;\n  }\n}\n\nvar EXPLICABLE_TYPES = ['string', 'number', 'boolean'];\n\nfunction isExplicable(value) {\n  return EXPLICABLE_TYPES.some(function (elem) {\n    return value.toLowerCase() === elem;\n  });\n}\n\nfunction isBoolean() {\n  var args = [],\n      len = arguments.length;\n\n  while (len--) args[len] = arguments[len];\n\n  return args.some(function (elem) {\n    return elem.toLowerCase() === 'boolean';\n  });\n}\n/*  */\n\n\nfunction handleError(err, vm, info) {\n  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n  // See: https://github.com/vuejs/vuex/issues/1505\n  pushTarget();\n\n  try {\n    if (vm) {\n      var cur = vm;\n\n      while (cur = cur.$parent) {\n        var hooks = cur.$options.errorCaptured;\n\n        if (hooks) {\n          for (var i = 0; i < hooks.length; i++) {\n            try {\n              var capture = hooks[i].call(cur, err, vm, info) === false;\n\n              if (capture) {\n                return;\n              }\n            } catch (e) {\n              globalHandleError(e, cur, 'errorCaptured hook');\n            }\n          }\n        }\n      }\n    }\n\n    globalHandleError(err, vm, info);\n  } finally {\n    popTarget();\n  }\n}\n\nfunction invokeWithErrorHandling(handler, context, args, vm, info) {\n  var res;\n\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context);\n\n    if (res && !res._isVue && isPromise(res) && !res._handled) {\n      res.catch(function (e) {\n        return handleError(e, vm, info + \" (Promise/async)\");\n      }); // issue #9511\n      // avoid catch triggering multiple times when nested calls\n\n      res._handled = true;\n    }\n  } catch (e) {\n    handleError(e, vm, info);\n  }\n\n  return res;\n}\n\nfunction globalHandleError(err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info);\n    } catch (e) {\n      // if the user intentionally throws the original error in the handler,\n      // do not log it twice\n      if (e !== err) {\n        logError(e, null, 'config.errorHandler');\n      }\n    }\n  }\n\n  logError(err, vm, info);\n}\n\nfunction logError(err, vm, info) {\n  if (true) {\n    warn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n  }\n  /* istanbul ignore else */\n\n\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err;\n  }\n}\n/*  */\n\n\nvar isUsingMicroTask = false;\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks() {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n} // Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\n\n\nvar timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n\n/* istanbul ignore next, $flow-disable-line */\n\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n\n  timerFunc = function () {\n    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n\n    if (isIOS) {\n      setTimeout(noop);\n    }\n  };\n\n  isUsingMicroTask = true;\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x\nMutationObserver.toString() === '[object MutationObserverConstructor]')) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  var counter = 1;\n  var observer = new MutationObserver(flushCallbacks);\n  var textNode = document.createTextNode(String(counter));\n  observer.observe(textNode, {\n    characterData: true\n  });\n\n  timerFunc = function () {\n    counter = (counter + 1) % 2;\n    textNode.data = String(counter);\n  };\n\n  isUsingMicroTask = true;\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Technically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  // Fallback to setTimeout.\n  timerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\nfunction nextTick(cb, ctx) {\n  var _resolve;\n\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n\n  if (!pending) {\n    pending = true;\n    timerFunc();\n  } // $flow-disable-line\n\n\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    });\n  }\n}\n/*  */\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\n\nvar initProxy;\n\nif (true) {\n  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' + 'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\n  };\n\n  var warnReservedPrefix = function (target, key) {\n    warn(\"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" + 'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals. ' + 'See: https://vuejs.org/v2/api/#data', target);\n  };\n\n  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set(target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n          return false;\n        } else {\n          target[key] = value;\n          return true;\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has(target, key) {\n      var has = (key in target);\n      var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);\n\n      if (!has && !isAllowed) {\n        if (key in target.$data) {\n          warnReservedPrefix(target, key);\n        } else {\n          warnNonPresent(target, key);\n        }\n      }\n\n      return has || !isAllowed;\n    }\n  };\n  var getHandler = {\n    get: function get(target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        if (key in target.$data) {\n          warnReservedPrefix(target, key);\n        } else {\n          warnNonPresent(target, key);\n        }\n      }\n\n      return target[key];\n    }\n  };\n\n  initProxy = function initProxy(vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n/*  */\n\n\nvar seenObjects = new _Set();\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\n\nfunction traverse(val) {\n  _traverse(val, seenObjects);\n\n  seenObjects.clear();\n}\n\nfunction _traverse(val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n\n  if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {\n    return;\n  }\n\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n\n    if (seen.has(depId)) {\n      return;\n    }\n\n    seen.add(depId);\n  }\n\n  if (isA) {\n    i = val.length;\n\n    while (i--) {\n      _traverse(val[i], seen);\n    }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n\n    while (i--) {\n      _traverse(val[keys[i]], seen);\n    }\n  }\n}\n\nvar mark;\nvar measure;\n\nif (true) {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n\n  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n    mark = function (tag) {\n      return perf.mark(tag);\n    };\n\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag); // perf.clearMeasures(name)\n    };\n  }\n}\n/*  */\n\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  };\n});\n\nfunction createFnInvoker(fns, vm) {\n  function invoker() {\n    var arguments$1 = arguments;\n    var fns = invoker.fns;\n\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n\n      for (var i = 0; i < cloned.length; i++) {\n        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n      }\n    } else {\n      // return handler return value for single handlers\n      return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\");\n    }\n  }\n\n  invoker.fns = fns;\n  return invoker;\n}\n\nfunction updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {\n  var name, def$$1, cur, old, event;\n\n  for (name in on) {\n    def$$1 = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n\n    if (isUndef(cur)) {\n       true && warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur, vm);\n      }\n\n      if (isTrue(event.once)) {\n        cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n      }\n\n      add(event.name, cur, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n/*  */\n\n\nfunction mergeVNodeHook(def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook() {\n    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n/*  */\n\n\nfunction extractPropsFromVNodeData(data, Ctor, tag) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n\n  if (isUndef(propOptions)) {\n    return;\n  }\n\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n\n      if (true) {\n        var keyInLowerCase = key.toLowerCase();\n\n        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n          tip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n        }\n      }\n\n      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n    }\n  }\n\n  return res;\n}\n\nfunction checkProp(res, hash, key, altKey, preserve) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n\n      if (!preserve) {\n        delete hash[key];\n      }\n\n      return true;\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n\n      if (!preserve) {\n        delete hash[altKey];\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n/*  */\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\n\n\nfunction simpleNormalizeChildren(children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children);\n    }\n  }\n\n  return children;\n} // 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\n\n\nfunction normalizeChildren(children) {\n  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n}\n\nfunction isTextNode(node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n}\n\nfunction normalizeArrayChildren(children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n\n    if (isUndef(c) || typeof c === 'boolean') {\n      continue;\n    }\n\n    lastIndex = res.length - 1;\n    last = res[lastIndex]; //  nested\n\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i); // merge adjacent text nodes\n\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + c[0].text);\n          c.shift();\n        }\n\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n\n        res.push(c);\n      }\n    }\n  }\n\n  return res;\n}\n/*  */\n\n\nfunction initProvide(vm) {\n  var provide = vm.$options.provide;\n\n  if (provide) {\n    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n  }\n}\n\nfunction initInjections(vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n\n  if (result) {\n    toggleObserving(false);\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (true) {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n        });\n      } else {}\n    });\n    toggleObserving(true);\n  }\n}\n\nfunction resolveInject(inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]; // #6574 in case the inject object is observed...\n\n      if (key === '__ob__') {\n        continue;\n      }\n\n      var provideKey = inject[key].from;\n      var source = vm;\n\n      while (source) {\n        if (source._provided && hasOwn(source._provided, provideKey)) {\n          result[key] = source._provided[provideKey];\n          break;\n        }\n\n        source = source.$parent;\n      }\n\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;\n        } else if (true) {\n          warn(\"Injection \\\"\" + key + \"\\\" not found\", vm);\n        }\n      }\n    }\n\n    return result;\n  }\n}\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\n\n\nfunction resolveSlots(children, context) {\n  if (!children || !children.length) {\n    return {};\n  }\n\n  var slots = {};\n\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node\n\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    } // named slots should only be respected if the vnode was rendered in the\n    // same context.\n\n\n    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {\n      var name = data.slot;\n      var slot = slots[name] || (slots[name] = []);\n\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  } // ignore slots that contains only whitespace\n\n\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n\n  return slots;\n}\n\nfunction isWhitespace(node) {\n  return node.isComment && !node.asyncFactory || node.text === ' ';\n}\n/*  */\n\n\nfunction isAsyncPlaceholder(node) {\n  return node.isComment && node.asyncFactory;\n}\n/*  */\n\n\nfunction normalizeScopedSlots(slots, normalSlots, prevSlots) {\n  var res;\n  var hasNormalSlots = Object.keys(normalSlots).length > 0;\n  var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n  var key = slots && slots.$key;\n\n  if (!slots) {\n    res = {};\n  } else if (slots._normalized) {\n    // fast path 1: child component re-render only, parent did not change\n    return slots._normalized;\n  } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {\n    // fast path 2: stable scoped slots w/ no normal slots to proxy,\n    // only need to normalize once\n    return prevSlots;\n  } else {\n    res = {};\n\n    for (var key$1 in slots) {\n      if (slots[key$1] && key$1[0] !== '$') {\n        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n      }\n    }\n  } // expose normal slots on scopedSlots\n\n\n  for (var key$2 in normalSlots) {\n    if (!(key$2 in res)) {\n      res[key$2] = proxyNormalSlot(normalSlots, key$2);\n    }\n  } // avoriaz seems to mock a non-extensible $scopedSlots object\n  // and when that is passed down this would cause an error\n\n\n  if (slots && Object.isExtensible(slots)) {\n    slots._normalized = res;\n  }\n\n  def(res, '$stable', isStable);\n  def(res, '$key', key);\n  def(res, '$hasNormal', hasNormalSlots);\n  return res;\n}\n\nfunction normalizeScopedSlot(normalSlots, key, fn) {\n  var normalized = function () {\n    var res = arguments.length ? fn.apply(null, arguments) : fn({});\n    res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode\n    : normalizeChildren(res);\n    var vnode = res && res[0];\n    return res && (!vnode || res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode) // #9658, #10391\n    ) ? undefined : res;\n  }; // this is a slot using the new v-slot syntax without scope. although it is\n  // compiled as a scoped slot, render fn users would expect it to be present\n  // on this.$slots because the usage is semantically a normal slot.\n\n\n  if (fn.proxy) {\n    Object.defineProperty(normalSlots, key, {\n      get: normalized,\n      enumerable: true,\n      configurable: true\n    });\n  }\n\n  return normalized;\n}\n\nfunction proxyNormalSlot(slots, key) {\n  return function () {\n    return slots[key];\n  };\n}\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\n\n\nfunction renderList(val, render) {\n  var ret, i, l, keys, key;\n\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    if (hasSymbol && val[Symbol.iterator]) {\n      ret = [];\n      var iterator = val[Symbol.iterator]();\n      var result = iterator.next();\n\n      while (!result.done) {\n        ret.push(render(result.value, ret.length));\n        result = iterator.next();\n      }\n    } else {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n  }\n\n  if (!isDef(ret)) {\n    ret = [];\n  }\n\n  ret._isVList = true;\n  return ret;\n}\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\n\n\nfunction renderSlot(name, fallbackRender, props, bindObject) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n\n  if (scopedSlotFn) {\n    // scoped slot\n    props = props || {};\n\n    if (bindObject) {\n      if ( true && !isObject(bindObject)) {\n        warn('slot v-bind without argument expects an Object', this);\n      }\n\n      props = extend(extend({}, bindObject), props);\n    }\n\n    nodes = scopedSlotFn(props) || (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);\n  } else {\n    nodes = this.$slots[name] || (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);\n  }\n\n  var target = props && props.slot;\n\n  if (target) {\n    return this.$createElement('template', {\n      slot: target\n    }, nodes);\n  } else {\n    return nodes;\n  }\n}\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\n\n\nfunction resolveFilter(id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity;\n}\n/*  */\n\n\nfunction isKeyNotMatch(expect, actual) {\n  if (Array.isArray(expect)) {\n    return expect.indexOf(actual) === -1;\n  } else {\n    return expect !== actual;\n  }\n}\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\n\n\nfunction checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n    return isKeyNotMatch(builtInKeyName, eventKeyName);\n  } else if (mappedKeyCode) {\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode);\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key;\n  }\n\n  return eventKeyCode === undefined;\n}\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\n\n\nfunction bindObjectProps(data, tag, value, asProp, isSync) {\n  if (value) {\n    if (!isObject(value)) {\n       true && warn('v-bind without argument expects an Object or Array value', this);\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n\n      var hash;\n\n      var loop = function (key) {\n        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n        }\n\n        var camelizedKey = camelize(key);\n        var hyphenatedKey = hyphenate(key);\n\n        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n\n            on[\"update:\" + key] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop(key);\n    }\n  }\n\n  return data;\n}\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\n\n\nfunction renderStatic(index, isInFor) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree.\n\n  if (tree && !isInFor) {\n    return tree;\n  } // otherwise, render a fresh tree.\n\n\n  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates\n  );\n  markStatic(tree, \"__static__\" + index, false);\n  return tree;\n}\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\n\n\nfunction markOnce(tree, index, key) {\n  markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n  return tree;\n}\n\nfunction markStatic(tree, key, isOnce) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], key + \"_\" + i, isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode(node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n/*  */\n\n\nfunction bindObjectListeners(data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n       true && warn('v-on without argument expects an Object value', this);\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n\n  return data;\n}\n/*  */\n\n\nfunction resolveScopedSlots(fns, // see flow/vnode\nres, // the following are added in 2.6\nhasDynamicKeys, contentHashKey) {\n  res = res || {\n    $stable: !hasDynamicKeys\n  };\n\n  for (var i = 0; i < fns.length; i++) {\n    var slot = fns[i];\n\n    if (Array.isArray(slot)) {\n      resolveScopedSlots(slot, res, hasDynamicKeys);\n    } else if (slot) {\n      // marker for reverse proxying v-slot without scope on this.$slots\n      if (slot.proxy) {\n        slot.fn.proxy = true;\n      }\n\n      res[slot.key] = slot.fn;\n    }\n  }\n\n  if (contentHashKey) {\n    res.$key = contentHashKey;\n  }\n\n  return res;\n}\n/*  */\n\n\nfunction bindDynamicKeys(baseObj, values) {\n  for (var i = 0; i < values.length; i += 2) {\n    var key = values[i];\n\n    if (typeof key === 'string' && key) {\n      baseObj[values[i]] = values[i + 1];\n    } else if ( true && key !== '' && key !== null) {\n      // null is a special value for explicitly removing a binding\n      warn(\"Invalid value for dynamic directive argument (expected string or null): \" + key, this);\n    }\n  }\n\n  return baseObj;\n} // helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\n\n\nfunction prependModifier(value, symbol) {\n  return typeof value === 'string' ? symbol + value : value;\n}\n/*  */\n\n\nfunction installRenderHelpers(target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n  target._d = bindDynamicKeys;\n  target._p = prependModifier;\n}\n/*  */\n\n\nfunction FunctionalRenderContext(data, props, children, parent, Ctor) {\n  var this$1 = this;\n  var options = Ctor.options; // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n\n  var contextVm;\n\n  if (hasOwn(parent, '_uid')) {\n    contextVm = Object.create(parent); // $flow-disable-line\n\n    contextVm._original = parent;\n  } else {\n    // the context vm passed in is a functional context as well.\n    // in this case we want to make sure we are able to get a hold to the\n    // real context instance.\n    contextVm = parent; // $flow-disable-line\n\n    parent = parent._original;\n  }\n\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n\n  this.slots = function () {\n    if (!this$1.$slots) {\n      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));\n    }\n\n    return this$1.$slots;\n  };\n\n  Object.defineProperty(this, 'scopedSlots', {\n    enumerable: true,\n    get: function get() {\n      return normalizeScopedSlots(data.scopedSlots, this.slots());\n    }\n  }); // support for compiled functional template\n\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options; // pre-resolve slots for renderSlot()\n\n    this.$slots = this.slots();\n    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n\n      if (vnode && !Array.isArray(vnode)) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n\n      return vnode;\n    };\n  } else {\n    this._c = function (a, b, c, d) {\n      return createElement(contextVm, a, b, c, d, needNormalization);\n    };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) {\n      mergeProps(props, data.attrs);\n    }\n\n    if (isDef(data.props)) {\n      mergeProps(props, data.props);\n    }\n  }\n\n  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\n  } else if (Array.isArray(vnode)) {\n    var vnodes = normalizeChildren(vnode) || [];\n    var res = new Array(vnodes.length);\n\n    for (var i = 0; i < vnodes.length; i++) {\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n    }\n\n    return res;\n  }\n}\n\nfunction cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\n  // that should not be matched to match.\n  var clone = cloneVNode(vnode);\n  clone.fnContext = contextVm;\n  clone.fnOptions = options;\n\n  if (true) {\n    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n  }\n\n  if (data.slot) {\n    (clone.data || (clone.data = {})).slot = data.slot;\n  }\n\n  return clone;\n}\n\nfunction mergeProps(to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n/*  */\n\n/*  */\n\n/*  */\n\n/*  */\n// inline hooks to be invoked on component VNodes during patch\n\n\nvar componentVNodeHooks = {\n  init: function init(vnode, hydrating) {\n    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    } else {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  },\n  prepatch: function prepatch(oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(child, options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n    );\n  },\n  insert: function insert(vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true\n        /* direct */\n        );\n      }\n    }\n  },\n  destroy: function destroy(vnode) {\n    var componentInstance = vnode.componentInstance;\n\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true\n        /* direct */\n        );\n      }\n    }\n  }\n};\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent(Ctor, data, context, children, tag) {\n  if (isUndef(Ctor)) {\n    return;\n  }\n\n  var baseCtor = context.$options._base; // plain options object: turn it into a constructor\n\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  } // if at this stage it's not a constructor or an async component factory,\n  // reject.\n\n\n  if (typeof Ctor !== 'function') {\n    if (true) {\n      warn(\"Invalid Component definition: \" + String(Ctor), context);\n    }\n\n    return;\n  } // async component\n\n\n  var asyncFactory;\n\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n    }\n  }\n\n  data = data || {}; // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n\n  resolveConstructorOptions(Ctor); // transform component v-model data into props & events\n\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  } // extract props\n\n\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component\n\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children);\n  } // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n\n\n  var listeners = data.on; // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n    // work around flow\n    var slot = data.slot;\n    data = {};\n\n    if (slot) {\n      data.slot = slot;\n    }\n  } // install component management hooks onto the placeholder node\n\n\n  installComponentHooks(data); // return a placeholder vnode\n\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, {\n    Ctor: Ctor,\n    propsData: propsData,\n    listeners: listeners,\n    tag: tag,\n    children: children\n  }, asyncFactory);\n  return vnode;\n}\n\nfunction createComponentInstanceForVnode( // we know it's MountedComponentVNode but flow doesn't\nvnode, // activeInstance in lifecycle state\nparent) {\n  var options = {\n    _isComponent: true,\n    _parentVnode: vnode,\n    parent: parent\n  }; // check inline-template render functions\n\n  var inlineTemplate = vnode.data.inlineTemplate;\n\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n\n  return new vnode.componentOptions.Ctor(options);\n}\n\nfunction installComponentHooks(data) {\n  var hooks = data.hook || (data.hook = {});\n\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var existing = hooks[key];\n    var toMerge = componentVNodeHooks[key];\n\n    if (existing !== toMerge && !(existing && existing._merged)) {\n      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n    }\n  }\n}\n\nfunction mergeHook$1(f1, f2) {\n  var merged = function (a, b) {\n    // flow complains about extra args which is why we use any\n    f1(a, b);\n    f2(a, b);\n  };\n\n  merged._merged = true;\n  return merged;\n} // transform component v-model info (value and callback) into\n// prop and event handler respectively.\n\n\nfunction transformModel(options, data) {\n  var prop = options.model && options.model.prop || 'value';\n  var event = options.model && options.model.event || 'input';\n  (data.attrs || (data.attrs = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  var existing = on[event];\n  var callback = data.model.callback;\n\n  if (isDef(existing)) {\n    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {\n      on[event] = [callback].concat(existing);\n    }\n  } else {\n    on[event] = callback;\n  }\n}\n/*  */\n\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface\n// without getting yelled at by flow\n\nfunction createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n\n  return _createElement(context, tag, data, children, normalizationType);\n}\n\nfunction _createElement(context, tag, data, children, normalizationType) {\n  if (isDef(data) && isDef(data.__ob__)) {\n     true && warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n    return createEmptyVNode();\n  } // object syntax in v-bind\n\n\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode();\n  } // warn against non-primitive key\n\n\n  if ( true && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n    {\n      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);\n    }\n  } // support single function children as default scoped slot\n\n\n  if (Array.isArray(children) && typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = {\n      default: children[0]\n    };\n    children.length = 0;\n  }\n\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n\n  var vnode, ns;\n\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);\n\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      if ( true && isDef(data) && isDef(data.nativeOn) && data.tag !== 'component') {\n        warn(\"The .native modifier for v-on is only valid on components but it was used on <\" + tag + \">.\", context);\n      }\n\n      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(tag, data, children, undefined, undefined, context);\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n\n  if (Array.isArray(vnode)) {\n    return vnode;\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) {\n      applyNS(vnode, ns);\n    }\n\n    if (isDef(data)) {\n      registerDeepBindings(data);\n    }\n\n    return vnode;\n  } else {\n    return createEmptyVNode();\n  }\n}\n\nfunction applyNS(vnode, ns, force) {\n  vnode.ns = ns;\n\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n\n      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n} // ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\n\n\nfunction registerDeepBindings(data) {\n  if (isObject(data.style)) {\n    traverse(data.style);\n  }\n\n  if (isObject(data.class)) {\n    traverse(data.class);\n  }\n}\n/*  */\n\n\nfunction initRender(vm) {\n  vm._vnode = null; // the root of the child tree\n\n  vm._staticTrees = null; // v-once cached trees\n\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n\n  vm._c = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, false);\n  }; // normalization is always applied for the public version, used in\n  // user-written render functions.\n\n\n  vm.$createElement = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, true);\n  }; // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n\n\n  var parentData = parentVnode && parentVnode.data;\n  /* istanbul ignore else */\n\n  if (true) {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {}\n}\n\nvar currentRenderingInstance = null;\n\nfunction renderMixin(Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this);\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    if (_parentVnode) {\n      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);\n    } // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n\n\n    vm.$vnode = _parentVnode; // render self\n\n    var vnode;\n\n    try {\n      // There's no need to maintain a stack because all render fns are called\n      // separately from one another. Nested component's render fns are called\n      // when parent component is patched.\n      currentRenderingInstance = vm;\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\"); // return error render result,\n      // or previous vnode to prevent render error causing blank component\n\n      /* istanbul ignore else */\n\n      if ( true && vm.$options.renderError) {\n        try {\n          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n        } catch (e) {\n          handleError(e, vm, \"renderError\");\n          vnode = vm._vnode;\n        }\n      } else {\n        vnode = vm._vnode;\n      }\n    } finally {\n      currentRenderingInstance = null;\n    } // if the returned array contains only a single node, allow it\n\n\n    if (Array.isArray(vnode) && vnode.length === 1) {\n      vnode = vnode[0];\n    } // return empty vnode in case the render function errored out\n\n\n    if (!(vnode instanceof VNode)) {\n      if ( true && Array.isArray(vnode)) {\n        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n      }\n\n      vnode = createEmptyVNode();\n    } // set parent\n\n\n    vnode.parent = _parentVnode;\n    return vnode;\n  };\n}\n/*  */\n\n\nfunction ensureCtor(comp, base) {\n  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {\n    comp = comp.default;\n  }\n\n  return isObject(comp) ? base.extend(comp) : comp;\n}\n\nfunction createAsyncPlaceholder(factory, data, context, children, tag) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = {\n    data: data,\n    context: context,\n    children: children,\n    tag: tag\n  };\n  return node;\n}\n\nfunction resolveAsyncComponent(factory, baseCtor) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp;\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved;\n  }\n\n  var owner = currentRenderingInstance;\n\n  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n    // already pending\n    factory.owners.push(owner);\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp;\n  }\n\n  if (owner && !isDef(factory.owners)) {\n    var owners = factory.owners = [owner];\n    var sync = true;\n    var timerLoading = null;\n    var timerTimeout = null;\n    owner.$on('hook:destroyed', function () {\n      return remove(owners, owner);\n    });\n\n    var forceRender = function (renderCompleted) {\n      for (var i = 0, l = owners.length; i < l; i++) {\n        owners[i].$forceUpdate();\n      }\n\n      if (renderCompleted) {\n        owners.length = 0;\n\n        if (timerLoading !== null) {\n          clearTimeout(timerLoading);\n          timerLoading = null;\n        }\n\n        if (timerTimeout !== null) {\n          clearTimeout(timerTimeout);\n          timerTimeout = null;\n        }\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n\n      if (!sync) {\n        forceRender(true);\n      } else {\n        owners.length = 0;\n      }\n    });\n    var reject = once(function (reason) {\n       true && warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender(true);\n      }\n    });\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (isPromise(res)) {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isPromise(res.component)) {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            timerLoading = setTimeout(function () {\n              timerLoading = null;\n\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender(false);\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          timerTimeout = setTimeout(function () {\n            timerTimeout = null;\n\n            if (isUndef(factory.resolved)) {\n              reject( true ? \"timeout (\" + res.timeout + \"ms)\" : 0);\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false; // return in case resolved synchronously\n\n    return factory.loading ? factory.loadingComp : factory.resolved;\n  }\n}\n/*  */\n\n\nfunction getFirstComponentChild(children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c;\n      }\n    }\n  }\n}\n/*  */\n\n/*  */\n\n\nfunction initEvents(vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false; // init parent attached events\n\n  var listeners = vm.$options._parentListeners;\n\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add(event, fn) {\n  target.$on(event, fn);\n}\n\nfunction remove$1(event, fn) {\n  target.$off(event, fn);\n}\n\nfunction createOnceHandler(event, fn) {\n  var _target = target;\n  return function onceHandler() {\n    var res = fn.apply(null, arguments);\n\n    if (res !== null) {\n      _target.$off(event, onceHandler);\n    }\n  };\n}\n\nfunction updateComponentListeners(vm, listeners, oldListeners) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n  target = undefined;\n}\n\nfunction eventsMixin(Vue) {\n  var hookRE = /^hook:/;\n\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;\n\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        vm.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n\n    return vm;\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n\n    function on() {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm;\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this; // all\n\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm;\n    } // array of events\n\n\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        vm.$off(event[i$1], fn);\n      }\n\n      return vm;\n    } // specific event\n\n\n    var cbs = vm._events[event];\n\n    if (!cbs) {\n      return vm;\n    }\n\n    if (!fn) {\n      vm._events[event] = null;\n      return vm;\n    } // specific handler\n\n\n    var cb;\n    var i = cbs.length;\n\n    while (i--) {\n      cb = cbs[i];\n\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break;\n      }\n    }\n\n    return vm;\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n\n    if (true) {\n      var lowerCaseEvent = event.toLowerCase();\n\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n      }\n    }\n\n    var cbs = vm._events[event];\n\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      var info = \"event handler for \\\"\" + event + \"\\\"\";\n\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n      }\n    }\n\n    return vm;\n  };\n}\n/*  */\n\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction setActiveInstance(vm) {\n  var prevActiveInstance = activeInstance;\n  activeInstance = vm;\n  return function () {\n    activeInstance = prevActiveInstance;\n  };\n}\n\nfunction initLifecycle(vm) {\n  var options = vm.$options; // locate first non-abstract parent\n\n  var parent = options.parent;\n\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n  vm.$children = [];\n  vm.$refs = {};\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin(Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var restoreActiveInstance = setActiveInstance(vm);\n    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false\n      /* removeOnly */\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n\n    restoreActiveInstance(); // update __vue__ reference\n\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    } // if parent is an HOC, update its $el as well\n\n\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    } // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n\n    if (vm._isBeingDestroyed) {\n      return;\n    }\n\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true; // remove self from parent\n\n    var parent = vm.$parent;\n\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    } // teardown watchers\n\n\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n\n    var i = vm._watchers.length;\n\n    while (i--) {\n      vm._watchers[i].teardown();\n    } // remove reference from data ob\n    // frozen object may not have observer.\n\n\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    } // call the last hook...\n\n\n    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree\n\n    vm.__patch__(vm._vnode, null); // fire destroyed hook\n\n\n    callHook(vm, 'destroyed'); // turn off all instance listeners.\n\n    vm.$off(); // remove __vue__ reference\n\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    } // release circular reference (#6759)\n\n\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent(vm, el, hydrating) {\n  vm.$el = el;\n\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n\n    if (true) {\n      /* istanbul ignore if */\n      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n      } else {\n        warn('Failed to mount component: template or render function not defined.', vm);\n      }\n    }\n  }\n\n  callHook(vm, 'beforeMount');\n  var updateComponent;\n  /* istanbul ignore if */\n\n  if ( true && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n      mark(startTag);\n\n      var vnode = vm._render();\n\n      mark(endTag);\n      measure(\"vue \" + name + \" render\", startTag, endTag);\n      mark(startTag);\n\n      vm._update(vnode, hydrating);\n\n      mark(endTag);\n      measure(\"vue \" + name + \" patch\", startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  } // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n\n\n  new Watcher(vm, updateComponent, noop, {\n    before: function before() {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate');\n      }\n    }\n  }, true\n  /* isRenderWatcher */\n  );\n  hydrating = false; // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n\n  return vm;\n}\n\nfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n  if (true) {\n    isUpdatingChildComponent = true;\n  } // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren.\n  // check if there are dynamic scopedSlots (hand-written or compiled but with\n  // dynamic slot names). Static scoped slots compiled from template has the\n  // \"$stable\" marker.\n\n\n  var newScopedSlots = parentVnode.data.scopedSlots;\n  var oldScopedSlots = vm.$scopedSlots;\n  var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key || !newScopedSlots && vm.$scopedSlots.$key); // Any static slot children from the parent may have changed during parent's\n  // update. Dynamic scoped slots may also have changed. In such cases, a forced\n  // update is necessary to ensure correctness.\n\n  var needsForceUpdate = !!(renderChildren || // has new static slots\n  vm.$options._renderChildren || // has old static slots\n  hasDynamicScopedSlot);\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) {\n    // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n\n  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\n  vm.$listeners = listeners || emptyObject; // update props\n\n  if (propsData && vm.$options.props) {\n    toggleObserving(false);\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      var propOptions = vm.$options.props; // wtf flow?\n\n      props[key] = validateProp(key, propOptions, propsData, vm);\n    }\n\n    toggleObserving(true); // keep a copy of raw propsData\n\n    vm.$options.propsData = propsData;\n  } // update listeners\n\n\n  listeners = listeners || emptyObject;\n  var oldListeners = vm.$options._parentListeners;\n  vm.$options._parentListeners = listeners;\n  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children\n\n  if (needsForceUpdate) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (true) {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree(vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction activateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  } else if (vm._directInactive) {\n    return;\n  }\n\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  }\n\n  if (!vm._inactive) {\n    vm._inactive = true;\n\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook(vm, hook) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget();\n  var handlers = vm.$options[hook];\n  var info = hook + \" hook\";\n\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n    }\n  }\n\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n\n  popTarget();\n}\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n/**\n * Reset the scheduler's state.\n */\n\nfunction resetSchedulerState() {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n\n  if (true) {\n    circular = {};\n  }\n\n  waiting = flushing = false;\n} // Async edge case #6566 requires saving the timestamp when event listeners are\n// attached. However, calling performance.now() has a perf overhead especially\n// if the page has thousands of event listeners. Instead, we take a timestamp\n// every time the scheduler flushes and use that for all event listeners\n// attached during that flush.\n\n\nvar currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.\n\nvar getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res (relative to page load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n// All IE versions use low-res event timestamps, and have problematic clock\n// implementations (#9632)\n\nif (inBrowser && !isIE) {\n  var performance = window.performance;\n\n  if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {\n    // if the event timestamp, although evaluated AFTER the Date.now(), is\n    // smaller than it, it means the event is using a hi-res timestamp,\n    // and we need to use the hi-res version for event listener timestamps as\n    // well.\n    getNow = function () {\n      return performance.now();\n    };\n  }\n}\n/**\n * Flush both queues and run the watchers.\n */\n\n\nfunction flushSchedulerQueue() {\n  currentFlushTimestamp = getNow();\n  flushing = true;\n  var watcher, id; // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n\n  queue.sort(function (a, b) {\n    return a.id - b.id;\n  }); // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n\n    if (watcher.before) {\n      watcher.before();\n    }\n\n    id = watcher.id;\n    has[id] = null;\n    watcher.run(); // in dev build, check and stop circular updates.\n\n    if ( true && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n        break;\n      }\n    }\n  } // keep copies of post queues before resetting state\n\n\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n  resetSchedulerState(); // call component updated and activated hooks\n\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue); // devtool hook\n\n  /* istanbul ignore if */\n\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks(queue) {\n  var i = queue.length;\n\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n\n    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\n\n\nfunction queueActivatedComponent(vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks(queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true\n    /* true */\n    );\n  }\n}\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\n\n\nfunction queueWatcher(watcher) {\n  var id = watcher.id;\n\n  if (has[id] == null) {\n    has[id] = true;\n\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n\n      queue.splice(i + 1, 0, watcher);\n    } // queue the flush\n\n\n    if (!waiting) {\n      waiting = true;\n\n      if ( true && !config.async) {\n        flushSchedulerQueue();\n        return;\n      }\n\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n/*  */\n\n\nvar uid$2 = 0;\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\n\nvar Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\n  this.vm = vm;\n\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n\n  vm._watchers.push(this); // options\n\n\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n    this.before = options.before;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  true ? expOrFn.toString() : 0; // parse expression for getter\n\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n\n    if (!this.getter) {\n      this.getter = noop;\n       true && warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n    }\n  }\n\n  this.value = this.lazy ? undefined : this.get();\n};\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\n\n\nWatcher.prototype.get = function get() {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n    } else {\n      throw e;\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n\n    popTarget();\n    this.cleanupDeps();\n  }\n\n  return value;\n};\n/**\n * Add a dependency to this directive.\n */\n\n\nWatcher.prototype.addDep = function addDep(dep) {\n  var id = dep.id;\n\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n/**\n * Clean up for dependency collection.\n */\n\n\nWatcher.prototype.cleanupDeps = function cleanupDeps() {\n  var i = this.deps.length;\n\n  while (i--) {\n    var dep = this.deps[i];\n\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\n\n\nWatcher.prototype.update = function update() {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\n\n\nWatcher.prototype.run = function run() {\n  if (this.active) {\n    var value = this.get();\n\n    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even\n    // when the value is the same, because the value may\n    // have mutated.\n    isObject(value) || this.deep) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n\n      if (this.user) {\n        var info = \"callback for watcher \\\"\" + this.expression + \"\\\"\";\n        invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\n\n\nWatcher.prototype.evaluate = function evaluate() {\n  this.value = this.get();\n  this.dirty = false;\n};\n/**\n * Depend on all deps collected by this watcher.\n */\n\n\nWatcher.prototype.depend = function depend() {\n  var i = this.deps.length;\n\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n/**\n * Remove self from all dependencies' subscriber list.\n */\n\n\nWatcher.prototype.teardown = function teardown() {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n\n    var i = this.deps.length;\n\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n\n    this.active = false;\n  }\n};\n/*  */\n\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy(target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter() {\n    return this[sourceKey][key];\n  };\n\n  sharedPropertyDefinition.set = function proxySetter(val) {\n    this[sourceKey][key] = val;\n  };\n\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState(vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n\n  if (opts.props) {\n    initProps(vm, opts.props);\n  }\n\n  if (opts.methods) {\n    initMethods(vm, opts.methods);\n  }\n\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true\n    /* asRootData */\n    );\n  }\n\n  if (opts.computed) {\n    initComputed(vm, opts.computed);\n  }\n\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps(vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent; // root instance props should be converted\n\n  if (!isRoot) {\n    toggleObserving(false);\n  }\n\n  var loop = function (key) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n\n    if (true) {\n      var hyphenatedKey = hyphenate(key);\n\n      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {\n        warn(\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n      }\n\n      defineReactive$$1(props, key, value, function () {\n        if (!isRoot && !isUpdatingChildComponent) {\n          warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n        }\n      });\n    } else {} // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n\n\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop(key);\n\n  toggleObserving(true);\n}\n\nfunction initData(vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n\n  if (!isPlainObject(data)) {\n    data = {};\n     true && warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n  } // proxy data on instance\n\n\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n\n  while (i--) {\n    var key = keys[i];\n\n    if (true) {\n      if (methods && hasOwn(methods, key)) {\n        warn(\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\", vm);\n      }\n    }\n\n    if (props && hasOwn(props, key)) {\n       true && warn(\"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  } // observe data\n\n\n  observe(data, true\n  /* asRootData */\n  );\n}\n\nfunction getData(data, vm) {\n  // #7573 disable dep collection when invoking data getters\n  pushTarget();\n\n  try {\n    return data.call(vm, vm);\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {};\n  } finally {\n    popTarget();\n  }\n}\n\nvar computedWatcherOptions = {\n  lazy: true\n};\n\nfunction initComputed(vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR\n\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n\n    if ( true && getter == null) {\n      warn(\"Getter is missing for computed property \\\"\" + key + \"\\\".\", vm);\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n    } // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n\n\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (true) {\n      if (key in vm.$data) {\n        warn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n      } else if (vm.$options.methods && key in vm.$options.methods) {\n        warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a method.\", vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed(target, key, userDef) {\n  var shouldCache = !isServerRendering();\n\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;\n    sharedPropertyDefinition.set = userDef.set || noop;\n  }\n\n  if ( true && sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\", this);\n    };\n  }\n\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter(key) {\n  return function computedGetter() {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n\n      if (Dep.target) {\n        watcher.depend();\n      }\n\n      return watcher.value;\n    }\n  };\n}\n\nfunction createGetterInvoker(fn) {\n  return function computedGetter() {\n    return fn.call(this, this);\n  };\n}\n\nfunction initMethods(vm, methods) {\n  var props = vm.$options.props;\n\n  for (var key in methods) {\n    if (true) {\n      if (typeof methods[key] !== 'function') {\n        warn(\"Method \\\"\" + key + \"\\\" has type \\\"\" + typeof methods[key] + \"\\\" in the component definition. \" + \"Did you reference the function correctly?\", vm);\n      }\n\n      if (props && hasOwn(props, key)) {\n        warn(\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n      }\n\n      if (key in vm && isReserved(key)) {\n        warn(\"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" + \"Avoid defining component methods that start with _ or $.\");\n      }\n    }\n\n    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch(vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher(vm, expOrFn, handler, options) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n\n  return vm.$watch(expOrFn, handler, options);\n}\n\nfunction stateMixin(Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n\n  dataDef.get = function () {\n    return this._data;\n  };\n\n  var propsDef = {};\n\n  propsDef.get = function () {\n    return this._props;\n  };\n\n  if (true) {\n    dataDef.set = function () {\n      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n    };\n\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (expOrFn, cb, options) {\n    var vm = this;\n\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options);\n    }\n\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n\n    if (options.immediate) {\n      var info = \"callback for immediate watcher \\\"\" + watcher.expression + \"\\\"\";\n      pushTarget();\n      invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);\n      popTarget();\n    }\n\n    return function unwatchFn() {\n      watcher.teardown();\n    };\n  };\n}\n/*  */\n\n\nvar uid$3 = 0;\n\nfunction initMixin(Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this; // a uid\n\n    vm._uid = uid$3++;\n    var startTag, endTag;\n    /* istanbul ignore if */\n\n    if ( true && config.performance && mark) {\n      startTag = \"vue-perf-start:\" + vm._uid;\n      endTag = \"vue-perf-end:\" + vm._uid;\n      mark(startTag);\n    } // a flag to avoid this being observed\n\n\n    vm._isVue = true; // merge options\n\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n    }\n    /* istanbul ignore else */\n\n\n    if (true) {\n      initProxy(vm);\n    } else {} // expose real self\n\n\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n\n    callHook(vm, 'created');\n    /* istanbul ignore if */\n\n    if ( true && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(\"vue \" + vm._name + \" init\", startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent(vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.\n\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions(Ctor) {\n  var options = Ctor.options;\n\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)\n\n      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options\n\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n\n  return options;\n}\n\nfunction resolveModifiedOptions(Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) {\n        modified = {};\n      }\n\n      modified[key] = latest[key];\n    }\n  }\n\n  return modified;\n}\n\nfunction Vue(options) {\n  if ( true && !(this instanceof Vue)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n\n  this._init(options);\n}\n\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nrenderMixin(Vue);\n/*  */\n\nfunction initUse(Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this;\n    } // additional parameters\n\n\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n\n    installedPlugins.push(plugin);\n    return this;\n  };\n}\n/*  */\n\n\nfunction initMixin$1(Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this;\n  };\n}\n/*  */\n\n\nfunction initExtend(Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n  /**\n   * Class inheritance\n   */\n\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId];\n    }\n\n    var name = extendOptions.name || Super.options.name;\n\n    if ( true && name) {\n      validateComponentName(name);\n    }\n\n    var Sub = function VueComponent(options) {\n      this._init(options);\n    };\n\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(Super.options, extendOptions);\n    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    } // allow further extension/mixin/plugin usage\n\n\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use; // create asset registers, so extended classes\n    // can have their private assets too.\n\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    }); // enable recursive self-lookup\n\n    if (name) {\n      Sub.options.components[name] = Sub;\n    } // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n\n\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options); // cache constructor\n\n    cachedCtors[SuperId] = Sub;\n    return Sub;\n  };\n}\n\nfunction initProps$1(Comp) {\n  var props = Comp.options.props;\n\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1(Comp) {\n  var computed = Comp.options.computed;\n\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n/*  */\n\n\nfunction initAssetRegisters(Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (id, definition) {\n      if (!definition) {\n        return this.options[type + 's'][id];\n      } else {\n        /* istanbul ignore if */\n        if ( true && type === 'component') {\n          validateComponentName(id);\n        }\n\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = {\n            bind: definition,\n            update: definition\n          };\n        }\n\n        this.options[type + 's'][id] = definition;\n        return definition;\n      }\n    };\n  });\n}\n/*  */\n\n\nfunction getComponentName(opts) {\n  return opts && (opts.Ctor.options.name || opts.tag);\n}\n\nfunction matches(pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1;\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1;\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name);\n  }\n  /* istanbul ignore next */\n\n\n  return false;\n}\n\nfunction pruneCache(keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n\n  for (var key in cache) {\n    var entry = cache[key];\n\n    if (entry) {\n      var name = entry.name;\n\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry(cache, key, keys, current) {\n  var entry = cache[key];\n\n  if (entry && (!current || entry.tag !== current.tag)) {\n    entry.componentInstance.$destroy();\n  }\n\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n  methods: {\n    cacheVNode: function cacheVNode() {\n      var ref = this;\n      var cache = ref.cache;\n      var keys = ref.keys;\n      var vnodeToCache = ref.vnodeToCache;\n      var keyToCache = ref.keyToCache;\n\n      if (vnodeToCache) {\n        var tag = vnodeToCache.tag;\n        var componentInstance = vnodeToCache.componentInstance;\n        var componentOptions = vnodeToCache.componentOptions;\n        cache[keyToCache] = {\n          name: getComponentName(componentOptions),\n          tag: tag,\n          componentInstance: componentInstance\n        };\n        keys.push(keyToCache); // prune oldest entry\n\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n\n        this.vnodeToCache = null;\n      }\n    }\n  },\n  created: function created() {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n  destroyed: function destroyed() {\n    for (var key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys);\n    }\n  },\n  mounted: function mounted() {\n    var this$1 = this;\n    this.cacheVNode();\n    this.$watch('include', function (val) {\n      pruneCache(this$1, function (name) {\n        return matches(val, name);\n      });\n    });\n    this.$watch('exclude', function (val) {\n      pruneCache(this$1, function (name) {\n        return !matches(val, name);\n      });\n    });\n  },\n  updated: function updated() {\n    this.cacheVNode();\n  },\n  render: function render() {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n\n      if ( // not included\n      include && (!name || !matches(include, name)) || // excluded\n      exclude && name && matches(exclude, name)) {\n        return vnode;\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null // same constructor may get registered as different local components\n      // so cid alone is not enough (#3269)\n      ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance; // make current key freshest\n\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        // delay setting the cache until update\n        this.vnodeToCache = vnode;\n        this.keyToCache = key;\n      }\n\n      vnode.data.keepAlive = true;\n    }\n\n    return vnode || slot && slot[0];\n  }\n};\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n/*  */\n\nfunction initGlobalAPI(Vue) {\n  // config\n  var configDef = {};\n\n  configDef.get = function () {\n    return config;\n  };\n\n  if (true) {\n    configDef.set = function () {\n      warn('Do not replace the Vue.config object, set individual fields instead.');\n    };\n  }\n\n  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick; // 2.6 explicit observable API\n\n  Vue.observable = function (obj) {\n    observe(obj);\n    return obj;\n  };\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  }); // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n\n  Vue.options._base = Vue;\n  extend(Vue.options.components, builtInComponents);\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n});\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get: function get() {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext;\n  }\n}); // expose FunctionalRenderContext for ssr runtime helper installation\n\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n});\nVue.version = '2.6.14';\n/*  */\n// these are reserved for web because they are directly compiled away\n// during template compilation\n\nvar isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding\n\nvar acceptValue = makeMap('input,textarea,option,select,progress');\n\nvar mustUseProp = function (tag, type, attr) {\n  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\nvar convertEnumeratedValue = function (key, value) {\n  return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable\n  : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';\n};\n\nvar isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,' + 'truespeed,typemustmatch,visible');\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : '';\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false;\n};\n/*  */\n\n\nfunction genClassForVnode(vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n\n  return renderClass(data.staticClass, data.class);\n}\n\nfunction mergeClassData(child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class) ? [child.class, parent.class] : parent.class\n  };\n}\n\nfunction renderClass(staticClass, dynamicClass) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass));\n  }\n  /* istanbul ignore next */\n\n\n  return '';\n}\n\nfunction concat(a, b) {\n  return a ? b ? a + ' ' + b : a : b || '';\n}\n\nfunction stringifyClass(value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value);\n  }\n\n  if (isObject(value)) {\n    return stringifyObject(value);\n  }\n\n  if (typeof value === 'string') {\n    return value;\n  }\n  /* istanbul ignore next */\n\n\n  return '';\n}\n\nfunction stringifyArray(value) {\n  var res = '';\n  var stringified;\n\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) {\n        res += ' ';\n      }\n\n      res += stringified;\n    }\n  }\n\n  return res;\n}\n\nfunction stringifyObject(value) {\n  var res = '';\n\n  for (var key in value) {\n    if (value[key]) {\n      if (res) {\n        res += ' ';\n      }\n\n      res += key;\n    }\n  }\n\n  return res;\n}\n/*  */\n\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\nvar isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\n\nvar isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag);\n};\n\nfunction getTagNamespace(tag) {\n  if (isSVG(tag)) {\n    return 'svg';\n  } // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n\n\n  if (tag === 'math') {\n    return 'math';\n  }\n}\n\nvar unknownElementCache = Object.create(null);\n\nfunction isUnknownElement(tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true;\n  }\n\n  if (isReservedTag(tag)) {\n    return false;\n  }\n\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag];\n  }\n\n  var el = document.createElement(tag);\n\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n  } else {\n    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\n\nfunction query(el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n\n    if (!selected) {\n       true && warn('Cannot find element: ' + el);\n      return document.createElement('div');\n    }\n\n    return selected;\n  } else {\n    return el;\n  }\n}\n/*  */\n\n\nfunction createElement$1(tagName, vnode) {\n  var elm = document.createElement(tagName);\n\n  if (tagName !== 'select') {\n    return elm;\n  } // false or null will remove the attribute but undefined will not\n\n\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n\n  return elm;\n}\n\nfunction createElementNS(namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName);\n}\n\nfunction createTextNode(text) {\n  return document.createTextNode(text);\n}\n\nfunction createComment(text) {\n  return document.createComment(text);\n}\n\nfunction insertBefore(parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild(node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild(node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode(node) {\n  return node.parentNode;\n}\n\nfunction nextSibling(node) {\n  return node.nextSibling;\n}\n\nfunction tagName(node) {\n  return node.tagName;\n}\n\nfunction setTextContent(node, text) {\n  node.textContent = text;\n}\n\nfunction setStyleScope(node, scopeId) {\n  node.setAttribute(scopeId, '');\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n/*  */\n\nvar ref = {\n  create: function create(_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update(oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy(vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef(vnode, isRemoval) {\n  var key = vnode.data.ref;\n\n  if (!isDef(key)) {\n    return;\n  }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\n\nvar emptyNode = new VNode('', {}, []);\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode(a, b) {\n  return a.key === b.key && a.asyncFactory === b.asyncFactory && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error));\n}\n\nfunction sameInputType(a, b) {\n  if (a.tag !== 'input') {\n    return true;\n  }\n\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);\n}\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n\n    if (isDef(key)) {\n      map[key] = i;\n    }\n  }\n\n  return map;\n}\n\nfunction createPatchFunction(backend) {\n  var i, j;\n  var cbs = {};\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt(elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n  }\n\n  function createRmCb(childElm, listeners) {\n    function remove$$1() {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n\n    remove$$1.listeners = listeners;\n    return remove$$1;\n  }\n\n  function removeNode(el) {\n    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text\n\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1(vnode, inVPre) {\n    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {\n      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;\n    })) && config.isUnknownElement(vnode.tag);\n  }\n\n  var creatingElmInVPre = 0;\n\n  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // This vnode was used in a previous render!\n      // now it's used as a new node, overwriting its elm would cause\n      // potential patch errors down the road when it's used as an insertion\n      // reference node. Instead, we clone the node on-demand before creating\n      // associated DOM element for it.\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    vnode.isRootInsert = !nested; // for transition enter check\n\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return;\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n\n    if (isDef(tag)) {\n      if (true) {\n        if (data && data.pre) {\n          creatingElmInVPre++;\n        }\n\n        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n        }\n      }\n\n      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n      /* istanbul ignore if */\n\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if ( true && data && data.pre) {\n        creatingElmInVPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false\n        /* hydrating */\n        );\n      } // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n\n\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        insert(parentElm, vnode.elm, refElm);\n\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n\n        return true;\n      }\n    }\n  }\n\n  function initComponent(vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n\n    vnode.elm = vnode.componentInstance.$el;\n\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode); // make sure to invoke the insert hook\n\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i; // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n\n    var innerNode = vnode;\n\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n\n        insertedVnodeQueue.push(innerNode);\n        break;\n      }\n    } // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n\n\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert(parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (nodeOps.parentNode(ref$$1) === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren(vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (true) {\n        checkDuplicateKeys(children);\n      }\n\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable(vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n\n    return isDef(vnode.tag);\n  }\n\n  function invokeCreateHooks(vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n\n    i = vnode.data.hook; // Reuse variable\n\n    if (isDef(i)) {\n      if (isDef(i.create)) {\n        i.create(emptyNode, vnode);\n      }\n\n      if (isDef(i.insert)) {\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n  } // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n\n\n  function setScope(vnode) {\n    var i;\n\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    } else {\n      var ancestor = vnode;\n\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n\n        ancestor = ancestor.parent;\n      }\n    } // for slot content they should also get the scopeId from the host instance.\n\n\n    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    }\n  }\n\n  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n    }\n  }\n\n  function invokeDestroyHook(vnode) {\n    var i, j;\n    var data = vnode.data;\n\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n        i(vnode);\n      }\n\n      for (i = 0; i < cbs.destroy.length; ++i) {\n        cbs.destroy[i](vnode);\n      }\n    }\n\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes(vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else {\n          // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook(vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      } // recursively invoke hooks on child component root node\n\n\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n\n    var canMove = !removeOnly;\n\n    if (true) {\n      checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\n        // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\n        // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) {\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        }\n\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n\n        if (isUndef(idxInOld)) {\n          // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          }\n        }\n\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys(children) {\n    var seenKeys = {};\n\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\", vnode.context);\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld(node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n\n      if (isDef(c) && sameVnode(node, c)) {\n        return i;\n      }\n    }\n  }\n\n  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {\n    if (oldVnode === vnode) {\n      return;\n    }\n\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // clone reused vnode\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n\n      return;\n    } // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n\n\n    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return;\n    }\n\n    var i;\n    var data = vnode.data;\n\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) {\n        cbs.update[i](oldVnode, vnode);\n      }\n\n      if (isDef(i = data.hook) && isDef(i = i.update)) {\n        i(oldVnode, vnode);\n      }\n    }\n\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) {\n          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n        }\n      } else if (isDef(ch)) {\n        if (true) {\n          checkDuplicateKeys(ch);\n        }\n\n        if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n        i(oldVnode, vnode);\n      }\n    }\n  }\n\n  function invokeInsertHook(vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.\n\n  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || data && data.pre;\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true;\n    } // assert node match\n\n\n    if (true) {\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\n        return false;\n      }\n    }\n\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) {\n        i(vnode, true\n        /* hydrating */\n        );\n      }\n\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true;\n      }\n    }\n\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if ( true && typeof console !== 'undefined' && !hydrationBailed) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n\n              return false;\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break;\n              }\n\n              childNode = childNode.nextSibling;\n            } // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n\n\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if ( true && typeof console !== 'undefined' && !hydrationBailed) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n\n              return false;\n            }\n          }\n        }\n      }\n\n      if (isDef(data)) {\n        var fullInvoke = false;\n\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break;\n          }\n        }\n\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n\n    return true;\n  }\n\n  function assertNodeMatch(node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3);\n    }\n  }\n\n  return function patch(oldVnode, vnode, hydrating, removeOnly) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) {\n        invokeDestroyHook(oldVnode);\n      }\n\n      return;\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode;\n            } else if (true) {\n              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n            }\n          } // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n\n\n          oldVnode = emptyNodeAt(oldVnode);\n        } // replacing existing element\n\n\n        var oldElm = oldVnode.elm;\n        var parentElm = nodeOps.parentNode(oldElm); // create new node\n\n        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a\n        // leaving transition. Only happens when combining transition +\n        // keep-alive + HOCs. (#4590)\n        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively\n\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n\n            ancestor.elm = vnode.elm;\n\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              } // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n\n\n              var insert = ancestor.data.hook.insert;\n\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n\n            ancestor = ancestor.parent;\n          }\n        } // destroy old node\n\n\n        if (isDef(parentElm)) {\n          removeVnodes([oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm;\n  };\n}\n/*  */\n\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives(vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives(oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update(oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n  var key, oldDir, dir;\n\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      dir.oldArg = oldDir.arg;\n      callHook$1(dir, 'update', vnode, oldVnode);\n\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1(dirs, vm) {\n  var res = Object.create(null);\n\n  if (!dirs) {\n    // $flow-disable-line\n    return res;\n  }\n\n  var i, dir;\n\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  } // $flow-disable-line\n\n\n  return res;\n}\n\nfunction getRawDirName(dir) {\n  return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n}\n\nfunction callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n    }\n  }\n}\n\nvar baseModules = [ref, directives];\n/*  */\n\nfunction updateAttrs(oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return;\n  }\n\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return;\n  }\n\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it\n\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n\n    if (old !== cur) {\n      setAttr(elm, key, cur, vnode.data.pre);\n    }\n  } // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n\n  /* istanbul ignore if */\n\n\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr(el, key, value, isInPre) {\n  if (isInPre || el.tagName.indexOf('-') > -1) {\n    baseSetAttr(el, key, value);\n  } else if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, convertEnumeratedValue(key, value));\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    baseSetAttr(el, key, value);\n  }\n}\n\nfunction baseSetAttr(el, key, value) {\n  if (isFalsyAttrValue(value)) {\n    el.removeAttribute(key);\n  } else {\n    // #7138: IE10 & 11 fires input event when setting placeholder on\n    // <textarea>... block the first input event and remove the blocker\n    // immediately.\n\n    /* istanbul ignore if */\n    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {\n      var blocker = function (e) {\n        e.stopImmediatePropagation();\n        el.removeEventListener('input', blocker);\n      };\n\n      el.addEventListener('input', blocker); // $flow-disable-line\n\n      el.__ieph = true;\n      /* IE placeholder patched */\n    }\n\n    el.setAttribute(key, value);\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n/*  */\n\nfunction updateClass(oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n    return;\n  }\n\n  var cls = genClassForVnode(vnode); // handle transition classes\n\n  var transitionClass = el._transitionClasses;\n\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  } // set the class\n\n\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n/*  */\n\n/*  */\n\n/*  */\n\n/*  */\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\n\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n/*  */\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\n\nfunction normalizeEvents(on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  } // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n\n  /* istanbul ignore if */\n\n\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler$1(event, handler, capture) {\n  var _target = target$1; // save current target element in closure\n\n  return function onceHandler() {\n    var res = handler.apply(null, arguments);\n\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  };\n} // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n// implementation and does not fire microtasks in between event propagation, so\n// safe to exclude.\n\n\nvar useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\nfunction add$1(name, handler, capture, passive) {\n  // async edge case #6566: inner click event triggers patch, event handler\n  // attached to outer element during patch, and triggered again. This\n  // happens because browsers fire microtask ticks between event propagation.\n  // the solution is simple: we save the timestamp when a handler is attached,\n  // and the handler would only fire if the event passed to it was fired\n  // AFTER it was attached.\n  if (useMicrotaskFix) {\n    var attachedTimestamp = currentFlushTimestamp;\n    var original = handler;\n\n    handler = original._wrapper = function (e) {\n      if ( // no bubbling, should always fire.\n      // this is just a safety net in case event.timeStamp is unreliable in\n      // certain weird environments...\n      e.target === e.currentTarget || // event is fired after handler attachment\n      e.timeStamp >= attachedTimestamp || // bail for environments that have buggy event.timeStamp implementations\n      // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n      // #9681 QtWebEngine event.timeStamp is negative value\n      e.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page\n      // electron/nw.js app, since event.timeStamp will be using a different\n      // starting reference\n      e.target.ownerDocument !== document) {\n        return original.apply(this, arguments);\n      }\n    };\n  }\n\n  target$1.addEventListener(name, handler, supportsPassive ? {\n    capture: capture,\n    passive: passive\n  } : capture);\n}\n\nfunction remove$2(name, handler, capture, _target) {\n  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);\n}\n\nfunction updateDOMListeners(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return;\n  }\n\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n/*  */\n\nvar svgContainer;\n\nfunction updateDOMProps(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return;\n  }\n\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it\n\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (!(key in props)) {\n      elm[key] = '';\n    }\n  }\n\n  for (key in props) {\n    cur = props[key]; // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) {\n        vnode.children.length = 0;\n      }\n\n      if (cur === oldProps[key]) {\n        continue;\n      } // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n\n\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value' && elm.tagName !== 'PROGRESS') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur; // avoid resetting cursor position when value is the same\n\n      var strCur = isUndef(cur) ? '' : String(cur);\n\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n      // IE doesn't support innerHTML for SVG elements\n      svgContainer = svgContainer || document.createElement('div');\n      svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n      var svg = svgContainer.firstChild;\n\n      while (elm.firstChild) {\n        elm.removeChild(elm.firstChild);\n      }\n\n      while (svg.firstChild) {\n        elm.appendChild(svg.firstChild);\n      }\n    } else if ( // skip the update if old and new VDOM state is the same.\n    // `value` is handled separately because the DOM value may be temporarily\n    // out of sync with VDOM state due to focus, composition and modifiers.\n    // This  #4521 by skipping the unnecessary `checked` update.\n    cur !== oldProps[key]) {\n      // some property updates can throw\n      // e.g. `value` on <progress> w/ non-finite value\n      try {\n        elm[key] = cur;\n      } catch (e) {}\n    }\n  }\n} // check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue(elm, checkVal) {\n  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));\n}\n\nfunction isNotInFocusAndDirty(elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true; // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n\n  try {\n    notInFocus = document.activeElement !== elm;\n  } catch (e) {}\n\n  return notInFocus && elm.value !== checkVal;\n}\n\nfunction isDirtyWithModifiers(elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n\n  if (isDef(modifiers)) {\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal);\n    }\n\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim();\n    }\n  }\n\n  return value !== newVal;\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res;\n}); // merge static and dynamic style data on the same vnode\n\nfunction normalizeStyleData(data) {\n  var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n\n  return data.staticStyle ? extend(data.staticStyle, style) : style;\n} // normalize possible array / string values into Object\n\n\nfunction normalizeStyleBinding(bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle);\n  }\n\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle);\n  }\n\n  return bindingStyle;\n}\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\n\n\nfunction getStyle(vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n\n      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if (styleData = normalizeStyleData(vnode.data)) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n\n  while (parentNode = parentNode.parent) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n\n  return res;\n}\n/*  */\n\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\n\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n\n  if (prop !== 'filter' && prop in emptyStyle) {\n    return prop;\n  }\n\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n\n    if (name in emptyStyle) {\n      return name;\n    }\n  }\n});\n\nfunction updateStyle(oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n    return;\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n  var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n\n  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n\n  for (name in newStyle) {\n    cur = newStyle[name];\n\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n/*  */\n\nvar whitespaceRE = /\\s+/;\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\n\nfunction addClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n  /* istanbul ignore else */\n\n\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) {\n        return el.classList.add(c);\n      });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\n\n\nfunction removeClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n  /* istanbul ignore else */\n\n\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) {\n        return el.classList.remove(c);\n      });\n    } else {\n      el.classList.remove(cls);\n    }\n\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n\n    cur = cur.trim();\n\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n/*  */\n\n\nfunction resolveTransition(def$$1) {\n  if (!def$$1) {\n    return;\n  }\n  /* istanbul ignore else */\n\n\n  if (typeof def$$1 === 'object') {\n    var res = {};\n\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n\n    extend(res, def$$1);\n    return res;\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1);\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: name + \"-enter\",\n    enterToClass: name + \"-enter-to\",\n    enterActiveClass: name + \"-enter-active\",\n    leaveClass: name + \"-leave\",\n    leaveToClass: name + \"-leave-to\",\n    leaveActiveClass: name + \"-leave-active\"\n  };\n});\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation'; // Transition property/event sniffing\n\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\n\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n\n  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n} // binding to window is necessary to make hot reload work in IE in strict mode\n\n\nvar raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :\n/* istanbul ignore next */\nfunction (fn) {\n  return fn();\n};\n\nfunction nextFrame(fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass(el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass(el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds(el, expectedType, cb) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n\n  if (!type) {\n    return cb();\n  }\n\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo(el, expectedType) {\n  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties\n\n  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n\n  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  };\n}\n\nfunction getTimeout(delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i]);\n  }));\n} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n// in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n// as a floor function) causing unexpected behaviors\n\n\nfunction toMs(s) {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000;\n}\n/*  */\n\n\nfunction enter(vnode, toggleDisplay) {\n  var el = vnode.elm; // call leave callback now\n\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n\n  if (isUndef(data)) {\n    return;\n  }\n  /* istanbul ignore if */\n\n\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration; // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n\n  while (transitionNode && transitionNode.parent) {\n    context = transitionNode.context;\n    transitionNode = transitionNode.parent;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return;\n  }\n\n  var startClass = isAppear && appearClass ? appearClass : enterClass;\n  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n  if ( true && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\n      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n\n      enterHook && enterHook(el, cb);\n    });\n  } // start enter transition\n\n\n  beforeEnterHook && beforeEnterHook(el);\n\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n\n      if (!cb.cancelled) {\n        addTransitionClass(el, toClass);\n\n        if (!userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave(vnode, rm) {\n  var el = vnode.elm; // call enter callback now\n\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm();\n  }\n  /* istanbul ignore if */\n\n\n  if (isDef(el._leaveCb)) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n  if ( true && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave() {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return;\n    } // record leaving element\n\n\n    if (!vnode.data.show && el.parentNode) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n\n    beforeLeave && beforeLeave(el);\n\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n\n        if (!cb.cancelled) {\n          addTransitionClass(el, leaveToClass);\n\n          if (!userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    leave && leave(el, cb);\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n} // only used in dev mode\n\n\nfunction checkDuration(val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n  } else if (isNaN(val)) {\n    warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n  }\n}\n\nfunction isValidDuration(val) {\n  return typeof val === 'number' && !isNaN(val);\n}\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\n\n\nfunction getHookArgumentsLength(fn) {\n  if (isUndef(fn)) {\n    return false;\n  }\n\n  var invokerFns = fn.fns;\n\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n  } else {\n    return (fn._length || fn.length) > 1;\n  }\n}\n\nfunction _enter(_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1(vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\nvar platformModules = [attrs, klass, events, domProps, style, transition];\n/*  */\n// the directive module should be applied last, after all\n// built-in modules have been applied.\n\nvar modules = platformModules.concat(baseModules);\nvar patch = createPatchFunction({\n  nodeOps: nodeOps,\n  modules: modules\n});\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\n\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted(el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n\n      if (!binding.modifiers.lazy) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n\n        el.addEventListener('change', onCompositionEnd);\n        /* istanbul ignore if */\n\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated(el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n\n      if (curOptions.some(function (o, i) {\n        return !looseEqual(o, prevOptions[i]);\n      })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple ? binding.value.some(function (v) {\n          return hasNoMatchingOption(v, curOptions);\n        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected(el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected(el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n\n  if (isMultiple && !Array.isArray(value)) {\n     true && warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n    return;\n  }\n\n  var selected, option;\n\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n\n        return;\n      }\n    }\n  }\n\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption(value, options) {\n  return options.every(function (o) {\n    return !looseEqual(o, value);\n  });\n}\n\nfunction getValue(option) {\n  return '_value' in option ? option._value : option.value;\n}\n\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd(e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) {\n    return;\n  }\n\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger(el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n/*  */\n// recursively search for possible transition defined inside the component root\n\n\nfunction locateNode(vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n}\n\nvar show = {\n  bind: function bind(el, ref, vnode) {\n    var value = ref.value;\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n  update: function update(el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n    /* istanbul ignore if */\n\n    if (!value === !oldValue) {\n      return;\n    }\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n\n    if (transition$$1) {\n      vnode.data.show = true;\n\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\nvar platformDirectives = {\n  model: directive,\n  show: show\n};\n/*  */\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n}; // in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\n\nfunction getRealChild(vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children));\n  } else {\n    return vnode;\n  }\n}\n\nfunction extractTransitionData(comp) {\n  var data = {};\n  var options = comp.$options; // props\n\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  } // events.\n  // extract listeners and pass them directly to the transition methods\n\n\n  var listeners = options._parentListeners;\n\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n\n  return data;\n}\n\nfunction placeholder(h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    });\n  }\n}\n\nfunction hasParentTransition(vnode) {\n  while (vnode = vnode.parent) {\n    if (vnode.data.transition) {\n      return true;\n    }\n  }\n}\n\nfunction isSameChild(child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag;\n}\n\nvar isNotTextNode = function (c) {\n  return c.tag || isAsyncPlaceholder(c);\n};\n\nvar isVShowDirective = function (d) {\n  return d.name === 'show';\n};\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n  render: function render(h) {\n    var this$1 = this;\n    var children = this.$slots.default;\n\n    if (!children) {\n      return;\n    } // filter out text nodes (possible whitespaces)\n\n\n    children = children.filter(isNotTextNode);\n    /* istanbul ignore if */\n\n    if (!children.length) {\n      return;\n    } // warn multiple elements\n\n\n    if ( true && children.length > 1) {\n      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n    }\n\n    var mode = this.mode; // warn invalid mode\n\n    if ( true && mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn('invalid <transition> mode: ' + mode, this.$parent);\n    }\n\n    var rawChild = children[0]; // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild;\n    } // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n\n\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n\n    if (!child) {\n      return rawChild;\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild);\n    } // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n\n\n    var id = \"__transition-\" + this._uid + \"-\";\n    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild); // mark v-show\n    // so that the transition module can hand over the control to the directive\n\n    if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node\n    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode\n\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild);\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild;\n        }\n\n        var delayedLeave;\n\n        var performLeave = function () {\n          delayedLeave();\n        };\n\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n          delayedLeave = leave;\n        });\n      }\n    }\n\n    return rawChild;\n  }\n};\n/*  */\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\ndelete props.mode;\nvar TransitionGroup = {\n  props: props,\n  beforeMount: function beforeMount() {\n    var this$1 = this;\n    var update = this._update;\n\n    this._update = function (vnode, hydrating) {\n      var restoreActiveInstance = setActiveInstance(this$1); // force removing pass\n\n      this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n      );\n\n      this$1._vnode = this$1.kept;\n      restoreActiveInstance();\n      update.call(this$1, vnode, hydrating);\n    };\n  },\n  render: function render(h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c;\n          (c.data || (c.data = {})).transition = transitionData;\n        } else if (true) {\n          var opts = c.componentOptions;\n          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n          warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children);\n  },\n  updated: function updated() {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || (this.name || 'v') + '-move';\n\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return;\n    } // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n\n\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation); // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n\n    this._reflow = document.body.offsetHeight;\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n          if (e && e.target !== el) {\n            return;\n          }\n\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n  methods: {\n    hasMove: function hasMove(el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false;\n      }\n      /* istanbul ignore if */\n\n\n      if (this._hasMove) {\n        return this._hasMove;\n      } // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n\n\n      var clone = el.cloneNode();\n\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) {\n          removeClass(clone, cls);\n        });\n      }\n\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return this._hasMove = info.hasTransform;\n    }\n  }\n};\n\nfunction callPendingCbs(c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n\n\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition(c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation(c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n/*  */\n// install platform specific utils\n\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components\n\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents); // install platform patch function\n\nVue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method\n\nVue.prototype.$mount = function (el, hydrating) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating);\n}; // devtools global hook\n\n/* istanbul ignore next */\n\n\nif (inBrowser) {\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else if (true) {\n        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n      }\n    }\n\n    if ( true && config.productionTip !== false && typeof console !== 'undefined') {\n      console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n    }\n  }, 0);\n}\n/*  */\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Vue);\n\n//# sourceURL=webpack://kloster/./node_modules/vue/dist/vue.runtime.esm.js?")},"./src/js/app.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue_gallery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue-gallery */ \"./node_modules/vue-gallery/dist/js/vue-gallery.js\");\n/* harmony import */ var vue_gallery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue_gallery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var vue_owl_carousel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue-owl-carousel */ \"./node_modules/vue-owl-carousel/dist/vue-owl-carousel.js\");\n/* harmony import */ var vue_owl_carousel__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(vue_owl_carousel__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_ContactForm_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/ContactForm.vue */ \"./src/js/components/ContactForm.vue\");\n/* harmony import */ var _components_Socials_vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/Socials.vue */ \"./src/js/components/Socials.vue\");\nwindow.Vue =  false ? 0 : __webpack_require__(/*! vue/dist/vue.js */ \"./node_modules/vue/dist/vue.js\");\nwindow.BootstrapVue = __webpack_require__(/*! bootstrap-vue/dist/bootstrap-vue */ \"./node_modules/bootstrap-vue/dist/bootstrap-vue.js\");\nwindow.axios = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\nwindow.appVersion = (__webpack_require__(/*! ../../package.json */ \"./package.json\").version);\n\n\n\n\nVue.use(BootstrapVue);\n\n(function (ELEMENT) {\n  ELEMENT.matches = ELEMENT.matches || ELEMENT.mozMatchesSelector || ELEMENT.msMatchesSelector || ELEMENT.oMatchesSelector || ELEMENT.webkitMatchesSelector;\n\n  ELEMENT.closest = ELEMENT.closest || function closest(selector) {\n    if (!this) return null;\n    if (this.matches(selector)) return this;\n\n    if (!this.parentElement) {\n      return null;\n    } else return this.parentElement.closest(selector);\n  };\n})(Element.prototype);\n\nwindow.hasElemClass = function (elem, className) {\n  return elem.className.indexOf(className) > -1;\n};\n\nwindow.deleteClassName = function (elem, className) {\n  const regExp = new RegExp('\\\\s*' + className + '\\\\s*');\n  elem.className = elem.className.replace(regExp, '');\n};\n\nvar app = new Vue({\n  el: '#app',\n\n  data() {\n    return {\n      year: '',\n      bodyPaddingTop: 0,\n      mainImageList: ['images/main.jpg'],\n      photoGallery: [],\n      photoGalleryIndex: null,\n      workGalleryAllImages: [],\n      workGallery: [],\n      workGalleryIndex: null,\n      scrollTop: 0,\n      scrollTopMax: 100\n    };\n  },\n\n  mounted() {\n    this.year = new Date().getFullYear();\n    const $vm = this;\n    window.$vm = $vm;\n    $vm.bodyPaddingTop = document.querySelector('.header').offsetHeight;\n\n    window.onscroll = function () {\n      $vm.checkWindowScrollTop();\n      $vm.checkInWhatSection();\n    };\n\n    document.addEventListener(\"DOMContentLoaded\", function () {\n      setTimeout($vm.loadImages, 500);\n    });\n    this.photoGallery = (__webpack_require__(/*! ./src/photos */ \"./src/js/src/photos.json\").images);\n    this.workGalleryAllImages = (__webpack_require__(/*! ./src/works */ \"./src/js/src/works.json\").images);\n  },\n\n  updated() {\n    this.checkWindowScrollTop();\n  },\n\n  methods: {\n    loadImages(container) {\n      container = container || document;\n      const imageContainers = container.querySelectorAll('[data-image-src]');\n\n      for (var i = 0; i < imageContainers.length; i++) {\n        var el = imageContainers[i];\n\n        if (el.dataset.notImageLoading) {\n          return;\n        }\n\n        var image = document.createElement('img'),\n            srcSet = '',\n            imageSizes = '';\n        const dimensions = el.dataset.dimensions ? JSON.parse(this.htmlDecode(el.dataset.dimensions)) : {};\n        image.src = el.dataset.imageSrc;\n        image.alt = el.dataset.imageAlt;\n\n        for (var width in dimensions) {\n          srcSet += (srcSet.length ? ', ' : '') + el.dataset.imageSrc + ' ' + width + 'w';\n          imageSizes += (imageSizes.length ? ', ' : '') + '(max-width: ' + width + 'px)' + ' ' + dimensions[width] + 'px';\n        }\n\n        image.srcset = srcSet;\n        image.sizes = imageSizes;\n        image.className = el.dataset.class && el.dataset.class.length ? el.dataset.class : '';\n        el.appendChild(image);\n      }\n    },\n\n    htmlDecode(str) {\n      return str.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '\"');\n    },\n\n    showWorkGallery(event) {\n      const carouselItem = event.target.closest('.carousel__item');\n      const index = Array.prototype.indexOf.call(carouselItem.closest('.carousel').querySelectorAll('.carousel__item'), carouselItem);\n      this.workGallery = JSON.parse(this.htmlDecode(this.workGalleryAllImages[index]));\n\n      function showGallery() {\n        const gallery = document.querySelector('.gallery_hidden');\n\n        if (gallery) {\n          gallery.querySelectorAll('.gallery__image')[0].click();\n        } else {\n          setTimeout(showGallery, 100);\n        }\n      }\n\n      setTimeout(showGallery, 100);\n    },\n\n    checkWindowScrollTop() {\n      const header = document.querySelector('.header');\n\n      if (document.documentElement.scrollTop >= this.scrollTopMax && !hasElemClass(header, 'header_sticky')) {\n        header.className += ' header_sticky';\n      } else if (document.documentElement.scrollTop < this.scrollTopMax) {\n        header.className = header.className.replace(/\\s*header_sticky/g, '');\n      }\n    },\n\n    scrollWindow(event, index) {\n      event.preventDefault();\n      const $vm = this;\n      const id = event.target.hash;\n      this.scrollTop = document.querySelector(id).offsetTop + (window.width >= 768 ? -$vm.$root.bodyPaddingTop : 0);\n      window.scrollTo({\n        top: index > 0 ? this.scrollTop : index,\n        behavior: 'smooth'\n      });\n    },\n\n    setNavItemActive(navItem) {\n      const activeItems = document.querySelectorAll('.nav-link_active');\n\n      for (var i = 0; i < activeItems.length; i++) {\n        deleteClassName(activeItems[i], 'nav-link_active');\n      }\n\n      navItem.className += ' nav-link_active';\n    },\n\n    checkInWhatSection() {\n      const sections = document.querySelectorAll('.section');\n\n      for (var i = 0; i < sections.length; i++) {\n        var section = sections[i];\n        const scrollTop = document.documentElement.scrollTop;\n        const minScrollTop = i > 0 ? section.offsetTop : 0;\n\n        if (scrollTop >= minScrollTop && scrollTop < section.offsetTop + section.offsetHeight) {\n          this.setNavItemActive(document.querySelector('.header__nav').querySelector('[href=\"#' + section.id + '\"]'));\n        }\n      }\n    }\n\n  },\n  components: {\n    VueGallery: (vue_gallery__WEBPACK_IMPORTED_MODULE_0___default()),\n    carousel: (vue_owl_carousel__WEBPACK_IMPORTED_MODULE_1___default()),\n    ContactForm: _components_ContactForm_vue__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n    Socials: _components_Socials_vue__WEBPACK_IMPORTED_MODULE_3__[\"default\"]\n  }\n});\n\n//# sourceURL=webpack://kloster/./src/js/app.js?")},"./node_modules/blueimp-gallery/css/blueimp-gallery.min.css":()=>{eval("throw new Error(\"Module build failed (from ./node_modules/mini-css-extract-plugin/dist/loader.js):\\nTypeError: Cannot read properties of undefined (reading 'get')\\n    at /home/wanderer/PhpstormProjects/kloster2/node_modules/webpack/lib/asset/AssetModulesPlugin.js:212:52\\n    at Hook.eval [as callAsync] (eval at create (/home/wanderer/PhpstormProjects/kloster2/node_modules/webpack/node_modules/tapable/lib/HookCodeFactory.js:33:10), <anonymous>:9:1)\\n    at /home/wanderer/PhpstormProjects/kloster2/node_modules/webpack/lib/Compilation.js:4986:43\\n    at symbolIterator (/home/wanderer/PhpstormProjects/kloster2/node_modules/neo-async/async.js:3482:9)\\n    at done (/home/wanderer/PhpstormProjects/kloster2/node_modules/neo-async/async.js:3527:9)\\n    at Hook.eval [as callAsync] (eval at create (/home/wanderer/PhpstormProjects/kloster2/node_modules/webpack/node_modules/tapable/lib/HookCodeFactory.js:33:10), <anonymous>:15:1)\\n    at /home/wanderer/PhpstormProjects/kloster2/node_modules/webpack/lib/Compilation.js:4986:43\\n    at symbolIterator (/home/wanderer/PhpstormProjects/kloster2/node_modules/neo-async/async.js:3482:9)\\n    at timesSync (/home/wanderer/PhpstormProjects/kloster2/node_modules/neo-async/async.js:2297:7)\\n    at Object.eachLimit (/home/wanderer/PhpstormProjects/kloster2/node_modules/neo-async/async.js:3463:5)\\n    at /home/wanderer/PhpstormProjects/kloster2/node_modules/webpack/lib/Compilation.js:4951:16\\n    at symbolIterator (/home/wanderer/PhpstormProjects/kloster2/node_modules/neo-async/async.js:3485:9)\\n    at timesSync (/home/wanderer/PhpstormProjects/kloster2/node_modules/neo-async/async.js:2297:7)\\n    at Object.eachLimit (/home/wanderer/PhpstormProjects/kloster2/node_modules/neo-async/async.js:3463:5)\\n    at /home/wanderer/PhpstormProjects/kloster2/node_modules/webpack/lib/Compilation.js:4919:15\\n    at symbolIterator (/home/wanderer/PhpstormProjects/kloster2/node_modules/neo-async/async.js:3485:9)\");\n\n//# sourceURL=webpack://kloster/./node_modules/blueimp-gallery/css/blueimp-gallery.min.css?")},"./src/sass/app.scss":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://kloster/./src/sass/app.scss?")},"./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/js/components/ContactForm.vue?vue&type=style&index=0&id=c03d5630&scoped=true&lang=css&":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://kloster/./src/js/components/ContactForm.vue?./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options")},"./src/js/components/ContactForm.vue":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ContactForm_vue_vue_type_template_id_c03d5630_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContactForm.vue?vue&type=template&id=c03d5630&scoped=true& */ "./src/js/components/ContactForm.vue?vue&type=template&id=c03d5630&scoped=true&");\n/* harmony import */ var _ContactForm_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ContactForm.vue?vue&type=script&lang=js& */ "./src/js/components/ContactForm.vue?vue&type=script&lang=js&");\n/* harmony import */ var _ContactForm_vue_vue_type_style_index_0_id_c03d5630_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ContactForm.vue?vue&type=style&index=0&id=c03d5630&scoped=true&lang=css& */ "./src/js/components/ContactForm.vue?vue&type=style&index=0&id=c03d5630&scoped=true&lang=css&");\n/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");\n\n\n\n;\n\n\n/* normalize component */\n\nvar component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(\n  _ContactForm_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],\n  _ContactForm_vue_vue_type_template_id_c03d5630_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,\n  _ContactForm_vue_vue_type_template_id_c03d5630_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,\n  false,\n  null,\n  "c03d5630",\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = "src/js/components/ContactForm.vue"\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);\n\n//# sourceURL=webpack://kloster/./src/js/components/ContactForm.vue?')},"./src/js/components/Socials.vue":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Socials_vue_vue_type_template_id_1c887b8a_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Socials.vue?vue&type=template&id=1c887b8a&scoped=true& */ "./src/js/components/Socials.vue?vue&type=template&id=1c887b8a&scoped=true&");\n/* harmony import */ var _Socials_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Socials.vue?vue&type=script&lang=js& */ "./src/js/components/Socials.vue?vue&type=script&lang=js&");\n/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(\n  _Socials_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],\n  _Socials_vue_vue_type_template_id_1c887b8a_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,\n  _Socials_vue_vue_type_template_id_1c887b8a_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,\n  false,\n  null,\n  "1c887b8a",\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = "src/js/components/Socials.vue"\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);\n\n//# sourceURL=webpack://kloster/./src/js/components/Socials.vue?')},"./src/js/components/ContactForm.vue?vue&type=script&lang=js&":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_ContactForm_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ContactForm.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/js/components/ContactForm.vue?vue&type=script&lang=js&");\n /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_ContactForm_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); \n\n//# sourceURL=webpack://kloster/./src/js/components/ContactForm.vue?')},"./src/js/components/Socials.vue?vue&type=script&lang=js&":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_Socials_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Socials.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/js/components/Socials.vue?vue&type=script&lang=js&");\n /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_node_modules_vue_loader_lib_index_js_vue_loader_options_Socials_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); \n\n//# sourceURL=webpack://kloster/./src/js/components/Socials.vue?')},"./src/js/components/ContactForm.vue?vue&type=style&index=0&id=c03d5630&scoped=true&lang=css&":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_vue_loader_lib_index_js_vue_loader_options_ContactForm_vue_vue_type_style_index_0_id_c03d5630_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/mini-css-extract-plugin/dist/loader.js!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ContactForm.vue?vue&type=style&index=0&id=c03d5630&scoped=true&lang=css& */ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/js/components/ContactForm.vue?vue&type=style&index=0&id=c03d5630&scoped=true&lang=css&");\n\n\n//# sourceURL=webpack://kloster/./src/js/components/ContactForm.vue?')},"./src/js/components/ContactForm.vue?vue&type=template&id=c03d5630&scoped=true&":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_ContactForm_vue_vue_type_template_id_c03d5630_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),\n/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_ContactForm_vue_vue_type_template_id_c03d5630_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)\n/* harmony export */ });\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_ContactForm_vue_vue_type_template_id_c03d5630_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ContactForm.vue?vue&type=template&id=c03d5630&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/js/components/ContactForm.vue?vue&type=template&id=c03d5630&scoped=true&");\n\n\n//# sourceURL=webpack://kloster/./src/js/components/ContactForm.vue?')},"./src/js/components/Socials.vue?vue&type=template&id=1c887b8a&scoped=true&":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Socials_vue_vue_type_template_id_1c887b8a_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),\n/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Socials_vue_vue_type_template_id_1c887b8a_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)\n/* harmony export */ });\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Socials_vue_vue_type_template_id_1c887b8a_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Socials.vue?vue&type=template&id=1c887b8a&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/js/components/Socials.vue?vue&type=template&id=1c887b8a&scoped=true&");\n\n\n//# sourceURL=webpack://kloster/./src/js/components/Socials.vue?')},"./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/js/components/ContactForm.vue?vue&type=template&id=c03d5630&scoped=true&":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "render": () => (/* binding */ render),\n/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)\n/* harmony export */ });\nvar render = function () {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    "b-form",\n    {\n      staticClass: "contact-form",\n      on: {\n        submit: function ($event) {\n          $event.preventDefault()\n          return _vm.submit.apply(null, arguments)\n        },\n      },\n    },\n    [\n      _vm.message.length && _vm.messageProgress > 0\n        ? _c(\n            "div",\n            {\n              staticClass: "message",\n              class: {\n                message_error: !_vm.success,\n                message_success: _vm.success,\n              },\n            },\n            [\n              _c("p", [\n                _vm._v("\\n            " + _vm._s(_vm.message) + "\\n        "),\n              ]),\n              _vm._v(" "),\n              _c("b-progress", {\n                staticClass: "mb-3",\n                attrs: {\n                  value: _vm.messageProgress,\n                  max: _vm.maxProgress,\n                  variant: _vm.success ? "success" : "danger",\n                  height: "3px",\n                },\n              }),\n            ],\n            1\n          )\n        : _vm._e(),\n      _vm._v(" "),\n      _c(\n        "b-form-group",\n        { staticClass: "contact-form__field" },\n        [\n          _c("b-form-input", {\n            staticClass: "contact-form__input",\n            attrs: {\n              placeholder: _vm.nameText,\n              autocomplete: "off",\n              title: _vm.fillText,\n            },\n            model: {\n              value: _vm.form.name,\n              callback: function ($$v) {\n                _vm.$set(_vm.form, "name", $$v)\n              },\n              expression: "form.name",\n            },\n          }),\n        ],\n        1\n      ),\n      _vm._v(" "),\n      _c(\n        "b-form-group",\n        { staticClass: "contact-form__field" },\n        [\n          _c("b-form-input", {\n            staticClass: "contact-form__input",\n            attrs: {\n              placeholder: "E-mail",\n              type: "email",\n              autocomplete: "off",\n              title: _vm.fillText,\n            },\n            model: {\n              value: _vm.form.email,\n              callback: function ($$v) {\n                _vm.$set(_vm.form, "email", $$v)\n              },\n              expression: "form.email",\n            },\n          }),\n        ],\n        1\n      ),\n      _vm._v(" "),\n      _c(\n        "b-form-group",\n        { staticClass: "contact-form__field" },\n        [\n          _c("b-form-textarea", {\n            staticClass: "contact-form__input",\n            attrs: {\n              placeholder: _vm.messageText,\n              rows: 3,\n              "max-rows": 6,\n              autocomplete: "off",\n              title: _vm.fillText,\n            },\n            model: {\n              value: _vm.form.text,\n              callback: function ($$v) {\n                _vm.$set(_vm.form, "text", $$v)\n              },\n              expression: "form.text",\n            },\n          }),\n        ],\n        1\n      ),\n      _vm._v(" "),\n      _c(\n        "b-form-group",\n        { staticClass: "contact-form__field contact-form__field_left" },\n        [\n          _c(\n            "vue-recaptcha",\n            {\n              attrs: {\n                sitekey: "6LdVSq4ZAAAAABiCNnPDs5ZsSz_F68BpDfilV8Rt",\n                size: "compact",\n              },\n              on: { expired: _vm.resetCaptcha },\n            },\n            [\n              _c(\n                "button",\n                {\n                  staticClass: "btn btn-secondary contact-form__submit",\n                  attrs: { type: "submit" },\n                },\n                [\n                  _c(\n                    "span",\n                    {\n                      class: {\n                        "contact-form__submit-text": true,\n                        "contact-form__submit-text_pale": _vm.submitted,\n                      },\n                    },\n                    [_vm._v(_vm._s(_vm.sendText))]\n                  ),\n                  _vm._v(" "),\n                  _c("vue-loading", {\n                    attrs: {\n                      active: _vm.submitted,\n                      color: "#fff",\n                      spinner: "ring",\n                    },\n                  }),\n                ],\n                1\n              ),\n            ]\n          ),\n        ],\n        1\n      ),\n    ],\n    1\n  )\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack://kloster/./src/js/components/ContactForm.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options')},"./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/js/components/Socials.vue?vue&type=template&id=1c887b8a&scoped=true&":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "render": () => (/* binding */ render),\n/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)\n/* harmony export */ });\nvar render = function () {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _vm._m(0)\n}\nvar staticRenderFns = [\n  function () {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c("div", { staticClass: "socials" }, [\n      _c("a", {\n        staticClass: "socials__link fa fa-facebook-f",\n        attrs: {\n          href: "https://www.facebook.com/groups/2005509819692070/",\n          target: "_blank",\n        },\n      }),\n      _vm._v(" "),\n      _c("a", {\n        staticClass: "socials__link fa fa-vk",\n        attrs: { href: "https://vk.com/mbd_monastyr", target: "_blank" },\n      }),\n    ])\n  },\n]\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack://kloster/./src/js/components/Socials.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options')},"./node_modules/vue-loader/lib/runtime/componentNormalizer.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ normalizeComponent)\n/* harmony export */ });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () {\n        injectStyles.call(\n          this,\n          (options.functional ? this.parent : this).$root.$options.shadowRoot\n        )\n      }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functional component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n//# sourceURL=webpack://kloster/./node_modules/vue-loader/lib/runtime/componentNormalizer.js?")},"./node_modules/vue-demi/lib/index.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* empty/unused harmony star reexport */\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Vue": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_1__["default"]),\n/* harmony export */   "Vue2": () => (/* binding */ Vue2),\n/* harmony export */   "install": () => (/* binding */ install),\n/* harmony export */   "isVue2": () => (/* binding */ isVue2),\n/* harmony export */   "isVue3": () => (/* binding */ isVue3),\n/* harmony export */   "version": () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");\nObject(function webpackMissingModule() { var e = new Error("Cannot find module \'@vue/composition-api/dist/vue-composition-api.mjs\'"); e.code = \'MODULE_NOT_FOUND\'; throw e; }());\n\n\n\nfunction install(_vue) {\n  _vue = _vue || vue__WEBPACK_IMPORTED_MODULE_1__["default"]\n  if (_vue && !_vue[\'__composition_api_installed__\'])\n    vue__WEBPACK_IMPORTED_MODULE_1__["default"].use(Object(function webpackMissingModule() { var e = new Error("Cannot find module \'@vue/composition-api/dist/vue-composition-api.mjs\'"); e.code = \'MODULE_NOT_FOUND\'; throw e; }()))\n}\n\ninstall(vue__WEBPACK_IMPORTED_MODULE_1__["default"])\n\nvar isVue2 = true\nvar isVue3 = false\nvar Vue2 = vue__WEBPACK_IMPORTED_MODULE_1__["default"]\nvar version = vue__WEBPACK_IMPORTED_MODULE_1__["default"].version\n\n/**VCA-EXPORTS**/\n\n/**VCA-EXPORTS**/\n\n\n\n\n//# sourceURL=webpack://kloster/./node_modules/vue-demi/lib/index.mjs?')},"./package.json":module=>{"use strict";eval('module.exports = JSON.parse(\'{"name":"kloster","version":"1.0.2","scripts":{"dev":"NODE_ENV=development webpack -w","prod":"NODE_ENV=production webpack -p"},"devDependencies":{"@vue/compiler-sfc":"^3.2.33","axios":"^0.27.2","babel-loader":"^8.2.5","bootstrap-vue":"^2.22.0","css-loader":"^6.7.1","file-loader":"^6.2.0","flag-icon-css":"^3.5.0","font-awesome":"^4.7.0","html-loader":"^0.5.5","html-webpack-plugin":"^5.5.0","image-webpack-loader":"^8.1.0","mini-css-extract-plugin":"^2.6.0","node-sass":"^7.0.1","sass":"^1.52.1","sass-loader":"^13.0.0","style-loader":"^3.3.1","terser-webpack-plugin":"^5.3.1","vue":"^2.6.14","vue-cli":"^2.9.6","vue-element-loading":"^2.0.2","vue-gallery":"^2.0.1","vue-loader":"^15.9.3","vue-owl-carousel":"^2.0.3","vue-recaptcha":"^2.0.2","vue-template-compiler":"^2.6.14","webpack":"^5.72.1","webpack-cli":"^4.9.2"},"dependencies":{"body-parser":"^1.19.0","compress-images":"^1.7.8","express":"^4.17.1","shelljs":"^0.8.4"}}\');\n\n//# sourceURL=webpack://kloster/./package.json?')},"./src/js/src/photos.json":module=>{"use strict";eval('module.exports = JSON.parse(\'{"images":["/images/photo/1-1280.jpg","/images/photo/11-1280.jpg","/images/photo/2-1280.jpg","/images/photo/3-1280.jpg","/images/photo/4-1280.jpg","/images/photo/5-1280.jpg","/images/photo/6-1280.jpg","/images/photo/7-1280.jpg","/images/photo/8-1280.jpg","/images/photo/9-1280.jpg","/images/photo/10-1280.jpg"]}\');\n\n//# sourceURL=webpack://kloster/./src/js/src/photos.json?')},"./src/js/src/works.json":module=>{"use strict";eval('module.exports = JSON.parse(\'{"images":["[&quot;/images/portfolio/1-768.jpg&quot;,&quot;/images/portfolio/12-768.jpg&quot;]","[&quot;/images/portfolio/3-768.jpg&quot;,&quot;/images/portfolio/4-768.jpg&quot;,&quot;/images/portfolio/6-768.jpg&quot;]","[&quot;/images/portfolio/2-768.jpg&quot;]","[&quot;/images/portfolio/7-768.jpg&quot;]","[&quot;/images/portfolio/8-768.jpg&quot;]","[&quot;/images/portfolio/9-768.jpg&quot;]","[&quot;/images/portfolio/10-768.jpg&quot;,&quot;/images/portfolio/11-768.jpg&quot;]"]}\');\n\n//# sourceURL=webpack://kloster/./src/js/src/works.json?')}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(t.exports,t,t.exports,__webpack_require__),t.exports}__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},__webpack_require__("./src/js/app.js");var __webpack_exports__=__webpack_require__("./src/sass/app.scss")})();